<?php

// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

namespace Algolia\AlgoliaSearch\Api;

use Algolia\AlgoliaSearch\Algolia;
use Algolia\AlgoliaSearch\Configuration\IngestionConfig;
use Algolia\AlgoliaSearch\ObjectSerializer;
use Algolia\AlgoliaSearch\RetryStrategy\ApiWrapper;
use Algolia\AlgoliaSearch\RetryStrategy\ApiWrapperInterface;
use Algolia\AlgoliaSearch\RetryStrategy\ClusterHosts;

/**
 * IngestionClient Class Doc Comment.
 *
 * @category Class
 */
class IngestionClient
{
    public const VERSION = '4.0.0-alpha.103';

    /**
     * @var ApiWrapperInterface
     */
    protected $api;

    /**
     * @var IngestionConfig
     */
    protected $config;

    public function __construct(ApiWrapperInterface $apiWrapper, IngestionConfig $config)
    {
        $this->config = $config;
        $this->api = $apiWrapper;
    }

    /**
     * Instantiate the client with basic credentials and region.
     *
     * @param string $appId  Application ID
     * @param string $apiKey Algolia API Key
     * @param string $region Region
     */
    public static function create($appId = null, $apiKey = null, $region = null)
    {
        $config = IngestionConfig::create($appId, $apiKey, $region);

        return static::createWithConfig($config);
    }

    /**
     * Instantiate the client with configuration.
     *
     * @param IngestionConfig $config Configuration
     */
    public static function createWithConfig(IngestionConfig $config)
    {
        $config = clone $config;

        $apiWrapper = new ApiWrapper(
            Algolia::getHttpClient(),
            $config,
            self::getClusterHosts($config)
        );

        return new static($apiWrapper, $config);
    }

    /**
     * Gets the cluster hosts depending on the config.
     *
     * @return ClusterHosts
     */
    public static function getClusterHosts(IngestionConfig $config)
    {
        if ($hosts = $config->getHosts()) {
            // If a list of hosts was passed, we ignore the cache
            $clusterHosts = ClusterHosts::create($hosts);
        } else {
            $url = null !== $config->getRegion() && '' !== $config->getRegion() ?
                str_replace('{region}', $config->getRegion(), 'data.{region}.algolia.com') :
                '';
            $clusterHosts = ClusterHosts::create($url);
        }

        return $clusterHosts;
    }

    /**
     * @return IngestionConfig
     */
    public function getClientConfig()
    {
        return $this->config;
    }

    /**
     * Creates a new authentication resource.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param array $authenticationCreate (required)
     *                                    - $authenticationCreate['type'] => (array)  (required)
     *                                    - $authenticationCreate['name'] => (string) Descriptive name for the resource. (required)
     *                                    - $authenticationCreate['platform'] => (array)
     *                                    - $authenticationCreate['input'] => (array)  (required)
     *
     * @see \Algolia\AlgoliaSearch\Model\Ingestion\AuthenticationCreate
     *
     * @param array $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\AuthenticationCreateResponse|array<string, mixed>
     */
    public function createAuthentication($authenticationCreate, $requestOptions = [])
    {
        // verify the required parameter 'authenticationCreate' is set
        if (!isset($authenticationCreate)) {
            throw new \InvalidArgumentException(
                'Parameter `authenticationCreate` is required when calling `createAuthentication`.'
            );
        }

        $resourcePath = '/1/authentications';
        $queryParameters = [];
        $headers = [];
        $httpBody = $authenticationCreate;

        return $this->sendRequest('POST', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Creates a new destination.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param array $destinationCreate (required)
     *                                 - $destinationCreate['type'] => (array)  (required)
     *                                 - $destinationCreate['name'] => (string) Descriptive name for the resource. (required)
     *                                 - $destinationCreate['input'] => (array)  (required)
     *                                 - $destinationCreate['authenticationID'] => (string) Universally unique identifier (UUID) of an authentication resource.
     *
     * @see \Algolia\AlgoliaSearch\Model\Ingestion\DestinationCreate
     *
     * @param array $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\DestinationCreateResponse|array<string, mixed>
     */
    public function createDestination($destinationCreate, $requestOptions = [])
    {
        // verify the required parameter 'destinationCreate' is set
        if (!isset($destinationCreate)) {
            throw new \InvalidArgumentException(
                'Parameter `destinationCreate` is required when calling `createDestination`.'
            );
        }

        $resourcePath = '/1/destinations';
        $queryParameters = [];
        $headers = [];
        $httpBody = $destinationCreate;

        return $this->sendRequest('POST', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Creates a new source.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param array $sourceCreate (required)
     *                            - $sourceCreate['type'] => (array)  (required)
     *                            - $sourceCreate['name'] => (string) Descriptive name of the source. (required)
     *                            - $sourceCreate['input'] => (array)  (required)
     *                            - $sourceCreate['authenticationID'] => (string) Universally unique identifier (UUID) of an authentication resource.
     *
     * @see \Algolia\AlgoliaSearch\Model\Ingestion\SourceCreate
     *
     * @param array $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\SourceCreateResponse|array<string, mixed>
     */
    public function createSource($sourceCreate, $requestOptions = [])
    {
        // verify the required parameter 'sourceCreate' is set
        if (!isset($sourceCreate)) {
            throw new \InvalidArgumentException(
                'Parameter `sourceCreate` is required when calling `createSource`.'
            );
        }

        $resourcePath = '/1/sources';
        $queryParameters = [];
        $headers = [];
        $httpBody = $sourceCreate;

        return $this->sendRequest('POST', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Creates a new task.
     *
     * @param array $taskCreate Request body for creating a task. (required)
     *                          - $taskCreate['sourceID'] => (string) Universally uniqud identifier (UUID) of a source. (required)
     *                          - $taskCreate['destinationID'] => (string) Universally unique identifier (UUID) of a destination resource. (required)
     *                          - $taskCreate['trigger'] => (array)  (required)
     *                          - $taskCreate['action'] => (array)  (required)
     *                          - $taskCreate['enabled'] => (bool) Whether the task is enabled.
     *                          - $taskCreate['failureThreshold'] => (int) Maximum accepted percentage of failures for a task run to finish successfully.
     *                          - $taskCreate['input'] => (array)
     *
     * @see \Algolia\AlgoliaSearch\Model\Ingestion\TaskCreate
     *
     * @param array $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\TaskCreateResponse|array<string, mixed>
     */
    public function createTask($taskCreate, $requestOptions = [])
    {
        // verify the required parameter 'taskCreate' is set
        if (!isset($taskCreate)) {
            throw new \InvalidArgumentException(
                'Parameter `taskCreate` is required when calling `createTask`.'
            );
        }

        $resourcePath = '/1/tasks';
        $queryParameters = [];
        $headers = [];
        $httpBody = $taskCreate;

        return $this->sendRequest('POST', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * This method allow you to send requests to the Algolia REST API.
     *
     * @param string $path           Path of the endpoint, anything after \&quot;/1\&quot; must be specified. (required)
     * @param array  $parameters     Query parameters to apply to the current query. (optional)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return array<string, mixed>|object
     */
    public function customDelete($path, $parameters = null, $requestOptions = [])
    {
        // verify the required parameter 'path' is set
        if (!isset($path)) {
            throw new \InvalidArgumentException(
                'Parameter `path` is required when calling `customDelete`.'
            );
        }

        $resourcePath = '/{path}';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        if (null !== $parameters) {
            $queryParameters = $parameters;
        }

        // path params
        if (null !== $path) {
            $resourcePath = str_replace(
                '{path}',
                $path,
                $resourcePath
            );
        }

        return $this->sendRequest('DELETE', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * This method allow you to send requests to the Algolia REST API.
     *
     * @param string $path           Path of the endpoint, anything after \&quot;/1\&quot; must be specified. (required)
     * @param array  $parameters     Query parameters to apply to the current query. (optional)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return array<string, mixed>|object
     */
    public function customGet($path, $parameters = null, $requestOptions = [])
    {
        // verify the required parameter 'path' is set
        if (!isset($path)) {
            throw new \InvalidArgumentException(
                'Parameter `path` is required when calling `customGet`.'
            );
        }

        $resourcePath = '/{path}';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        if (null !== $parameters) {
            $queryParameters = $parameters;
        }

        // path params
        if (null !== $path) {
            $resourcePath = str_replace(
                '{path}',
                $path,
                $resourcePath
            );
        }

        return $this->sendRequest('GET', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * This method allow you to send requests to the Algolia REST API.
     *
     * @param string $path           Path of the endpoint, anything after \&quot;/1\&quot; must be specified. (required)
     * @param array  $parameters     Query parameters to apply to the current query. (optional)
     * @param array  $body           Parameters to send with the custom request. (optional)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return array<string, mixed>|object
     */
    public function customPost($path, $parameters = null, $body = null, $requestOptions = [])
    {
        // verify the required parameter 'path' is set
        if (!isset($path)) {
            throw new \InvalidArgumentException(
                'Parameter `path` is required when calling `customPost`.'
            );
        }

        $resourcePath = '/{path}';
        $queryParameters = [];
        $headers = [];
        $httpBody = isset($body) ? $body : [];

        if (null !== $parameters) {
            $queryParameters = $parameters;
        }

        // path params
        if (null !== $path) {
            $resourcePath = str_replace(
                '{path}',
                $path,
                $resourcePath
            );
        }

        return $this->sendRequest('POST', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * This method allow you to send requests to the Algolia REST API.
     *
     * @param string $path           Path of the endpoint, anything after \&quot;/1\&quot; must be specified. (required)
     * @param array  $parameters     Query parameters to apply to the current query. (optional)
     * @param array  $body           Parameters to send with the custom request. (optional)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return array<string, mixed>|object
     */
    public function customPut($path, $parameters = null, $body = null, $requestOptions = [])
    {
        // verify the required parameter 'path' is set
        if (!isset($path)) {
            throw new \InvalidArgumentException(
                'Parameter `path` is required when calling `customPut`.'
            );
        }

        $resourcePath = '/{path}';
        $queryParameters = [];
        $headers = [];
        $httpBody = isset($body) ? $body : [];

        if (null !== $parameters) {
            $queryParameters = $parameters;
        }

        // path params
        if (null !== $path) {
            $resourcePath = str_replace(
                '{path}',
                $path,
                $resourcePath
            );
        }

        return $this->sendRequest('PUT', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Deletes an authentication resource. You can't delete authentication resources that are used by a source or a destination.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $authenticationID Unique identifier of an authentication resource. (required)
     * @param array  $requestOptions   the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\DeleteResponse|array<string, mixed>
     */
    public function deleteAuthentication($authenticationID, $requestOptions = [])
    {
        // verify the required parameter 'authenticationID' is set
        if (!isset($authenticationID)) {
            throw new \InvalidArgumentException(
                'Parameter `authenticationID` is required when calling `deleteAuthentication`.'
            );
        }

        $resourcePath = '/1/authentications/{authenticationID}';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        // path params
        if (null !== $authenticationID) {
            $resourcePath = str_replace(
                '{authenticationID}',
                ObjectSerializer::toPathValue($authenticationID),
                $resourcePath
            );
        }

        return $this->sendRequest('DELETE', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $destinationID  Unique identifier of a destination. (required)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\DeleteResponse|array<string, mixed>
     */
    public function deleteDestination($destinationID, $requestOptions = [])
    {
        // verify the required parameter 'destinationID' is set
        if (!isset($destinationID)) {
            throw new \InvalidArgumentException(
                'Parameter `destinationID` is required when calling `deleteDestination`.'
            );
        }

        $resourcePath = '/1/destinations/{destinationID}';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        // path params
        if (null !== $destinationID) {
            $resourcePath = str_replace(
                '{destinationID}',
                ObjectSerializer::toPathValue($destinationID),
                $resourcePath
            );
        }

        return $this->sendRequest('DELETE', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Deletes a source by its ID. You can't delete sources that are referenced in tasks.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $sourceID       Unique identifier of a source. (required)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\DeleteResponse|array<string, mixed>
     */
    public function deleteSource($sourceID, $requestOptions = [])
    {
        // verify the required parameter 'sourceID' is set
        if (!isset($sourceID)) {
            throw new \InvalidArgumentException(
                'Parameter `sourceID` is required when calling `deleteSource`.'
            );
        }

        $resourcePath = '/1/sources/{sourceID}';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        // path params
        if (null !== $sourceID) {
            $resourcePath = str_replace(
                '{sourceID}',
                ObjectSerializer::toPathValue($sourceID),
                $resourcePath
            );
        }

        return $this->sendRequest('DELETE', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Deletes a task by its ID.
     *
     * @param string $taskID         Unique identifier of a task. (required)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\DeleteResponse|array<string, mixed>
     */
    public function deleteTask($taskID, $requestOptions = [])
    {
        // verify the required parameter 'taskID' is set
        if (!isset($taskID)) {
            throw new \InvalidArgumentException(
                'Parameter `taskID` is required when calling `deleteTask`.'
            );
        }

        $resourcePath = '/1/tasks/{taskID}';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        // path params
        if (null !== $taskID) {
            $resourcePath = str_replace(
                '{taskID}',
                ObjectSerializer::toPathValue($taskID),
                $resourcePath
            );
        }

        return $this->sendRequest('DELETE', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Disables a task.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $taskID         Unique identifier of a task. (required)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\TaskUpdateResponse|array<string, mixed>
     */
    public function disableTask($taskID, $requestOptions = [])
    {
        // verify the required parameter 'taskID' is set
        if (!isset($taskID)) {
            throw new \InvalidArgumentException(
                'Parameter `taskID` is required when calling `disableTask`.'
            );
        }

        $resourcePath = '/1/tasks/{taskID}/disable';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        // path params
        if (null !== $taskID) {
            $resourcePath = str_replace(
                '{taskID}',
                ObjectSerializer::toPathValue($taskID),
                $resourcePath
            );
        }

        return $this->sendRequest('PUT', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Enables a task.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $taskID         Unique identifier of a task. (required)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\TaskUpdateResponse|array<string, mixed>
     */
    public function enableTask($taskID, $requestOptions = [])
    {
        // verify the required parameter 'taskID' is set
        if (!isset($taskID)) {
            throw new \InvalidArgumentException(
                'Parameter `taskID` is required when calling `enableTask`.'
            );
        }

        $resourcePath = '/1/tasks/{taskID}/enable';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        // path params
        if (null !== $taskID) {
            $resourcePath = str_replace(
                '{taskID}',
                ObjectSerializer::toPathValue($taskID),
                $resourcePath
            );
        }

        return $this->sendRequest('PUT', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Retrieves an authentication resource by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $authenticationID Unique identifier of an authentication resource. (required)
     * @param array  $requestOptions   the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\Authentication|array<string, mixed>
     */
    public function getAuthentication($authenticationID, $requestOptions = [])
    {
        // verify the required parameter 'authenticationID' is set
        if (!isset($authenticationID)) {
            throw new \InvalidArgumentException(
                'Parameter `authenticationID` is required when calling `getAuthentication`.'
            );
        }

        $resourcePath = '/1/authentications/{authenticationID}';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        // path params
        if (null !== $authenticationID) {
            $resourcePath = str_replace(
                '{authenticationID}',
                ObjectSerializer::toPathValue($authenticationID),
                $resourcePath
            );
        }

        return $this->sendRequest('GET', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Retrieves a list of all authentication resources.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param int   $itemsPerPage   Number of items per page. (optional, default to 10)
     * @param int   $page           Page number of the paginated API response. (optional)
     * @param array $type           Type of authentication resource to retrieve. (optional)
     * @param array $platform       Ecommerce platform for which to retrieve authentication resources. (optional)
     * @param array $sort           Property by which to sort the list of authentication resources. (optional)
     * @param array $order          Sort order of the response, ascending or descending. (optional)
     * @param array $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\ListAuthenticationsResponse|array<string, mixed>
     */
    public function getAuthentications($itemsPerPage = null, $page = null, $type = null, $platform = null, $sort = null, $order = null, $requestOptions = [])
    {
        if (null !== $itemsPerPage && $itemsPerPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$itemsPerPage" when calling IngestionClient.getAuthentications, must be smaller than or equal to 100.');
        }
        if (null !== $itemsPerPage && $itemsPerPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$itemsPerPage" when calling IngestionClient.getAuthentications, must be bigger than or equal to 1.');
        }

        if (null !== $page && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling IngestionClient.getAuthentications, must be bigger than or equal to 1.');
        }

        $resourcePath = '/1/authentications';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        if (null !== $itemsPerPage) {
            $queryParameters['itemsPerPage'] = $itemsPerPage;
        }

        if (null !== $page) {
            $queryParameters['page'] = $page;
        }

        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, 'form', true);
        }
        if (null !== $type) {
            $queryParameters['type'] = $type;
        }

        if (is_array($platform)) {
            $platform = ObjectSerializer::serializeCollection($platform, 'form', true);
        }
        if (null !== $platform) {
            $queryParameters['platform'] = $platform;
        }

        if (null !== $sort) {
            $queryParameters['sort'] = $sort;
        }

        if (null !== $order) {
            $queryParameters['order'] = $order;
        }

        return $this->sendRequest('GET', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Retrieves a destination by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $destinationID  Unique identifier of a destination. (required)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\Destination|array<string, mixed>
     */
    public function getDestination($destinationID, $requestOptions = [])
    {
        // verify the required parameter 'destinationID' is set
        if (!isset($destinationID)) {
            throw new \InvalidArgumentException(
                'Parameter `destinationID` is required when calling `getDestination`.'
            );
        }

        $resourcePath = '/1/destinations/{destinationID}';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        // path params
        if (null !== $destinationID) {
            $resourcePath = str_replace(
                '{destinationID}',
                ObjectSerializer::toPathValue($destinationID),
                $resourcePath
            );
        }

        return $this->sendRequest('GET', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Retrieves a list of destinations.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param int   $itemsPerPage     Number of items per page. (optional, default to 10)
     * @param int   $page             Page number of the paginated API response. (optional)
     * @param array $type             Destination type. (optional)
     * @param array $authenticationID Authentication ID used by destinations. (optional)
     * @param array $sort             Property by which to sort the destinations. (optional)
     * @param array $order            Sort order of the response, ascending or descending. (optional)
     * @param array $requestOptions   the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\ListDestinationsResponse|array<string, mixed>
     */
    public function getDestinations($itemsPerPage = null, $page = null, $type = null, $authenticationID = null, $sort = null, $order = null, $requestOptions = [])
    {
        if (null !== $itemsPerPage && $itemsPerPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$itemsPerPage" when calling IngestionClient.getDestinations, must be smaller than or equal to 100.');
        }
        if (null !== $itemsPerPage && $itemsPerPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$itemsPerPage" when calling IngestionClient.getDestinations, must be bigger than or equal to 1.');
        }

        if (null !== $page && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling IngestionClient.getDestinations, must be bigger than or equal to 1.');
        }

        $resourcePath = '/1/destinations';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        if (null !== $itemsPerPage) {
            $queryParameters['itemsPerPage'] = $itemsPerPage;
        }

        if (null !== $page) {
            $queryParameters['page'] = $page;
        }

        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, 'form', true);
        }
        if (null !== $type) {
            $queryParameters['type'] = $type;
        }

        if (is_array($authenticationID)) {
            $authenticationID = ObjectSerializer::serializeCollection($authenticationID, 'form', true);
        }
        if (null !== $authenticationID) {
            $queryParameters['authenticationID'] = $authenticationID;
        }

        if (null !== $sort) {
            $queryParameters['sort'] = $sort;
        }

        if (null !== $order) {
            $queryParameters['order'] = $order;
        }

        return $this->sendRequest('GET', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Retrieves a stream listing for a source.  Listing streams only works with sources with `type: docker` and `imageType: singer`.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $sourceID       Unique identifier of a source. (required)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\DockerSourceStreams|array<string, mixed>
     */
    public function getDockerSourceStreams($sourceID, $requestOptions = [])
    {
        // verify the required parameter 'sourceID' is set
        if (!isset($sourceID)) {
            throw new \InvalidArgumentException(
                'Parameter `sourceID` is required when calling `getDockerSourceStreams`.'
            );
        }

        $resourcePath = '/1/sources/{sourceID}/discover';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        // path params
        if (null !== $sourceID) {
            $resourcePath = str_replace(
                '{sourceID}',
                ObjectSerializer::toPathValue($sourceID),
                $resourcePath
            );
        }

        return $this->sendRequest('GET', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Retrieves a single task run event by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $runID          Unique identifier of a task run. (required)
     * @param string $eventID        Unique identifier of an event. (required)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\Event|array<string, mixed>
     */
    public function getEvent($runID, $eventID, $requestOptions = [])
    {
        // verify the required parameter 'runID' is set
        if (!isset($runID)) {
            throw new \InvalidArgumentException(
                'Parameter `runID` is required when calling `getEvent`.'
            );
        }
        // verify the required parameter 'eventID' is set
        if (!isset($eventID)) {
            throw new \InvalidArgumentException(
                'Parameter `eventID` is required when calling `getEvent`.'
            );
        }

        $resourcePath = '/1/runs/{runID}/events/{eventID}';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        // path params
        if (null !== $runID) {
            $resourcePath = str_replace(
                '{runID}',
                ObjectSerializer::toPathValue($runID),
                $resourcePath
            );
        }

        // path params
        if (null !== $eventID) {
            $resourcePath = str_replace(
                '{eventID}',
                ObjectSerializer::toPathValue($eventID),
                $resourcePath
            );
        }

        return $this->sendRequest('GET', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Retrieves a list of events for a task run, identified by it's ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $runID          Unique identifier of a task run. (required)
     * @param int    $itemsPerPage   Number of items per page. (optional, default to 10)
     * @param int    $page           Page number of the paginated API response. (optional)
     * @param array  $status         Event status for filtering the list of task runs. (optional)
     * @param array  $type           Event type for filtering the list of task runs. (optional)
     * @param array  $sort           Property by which to sort the list of task run events. (optional)
     * @param array  $order          Sort order of the response, ascending or descending. (optional)
     * @param string $startDate      Date and time in RFC3339 format for the earliest events to retrieve. By default, the current time minus three hours is used. (optional)
     * @param string $endDate        Date and time in RFC3339 format for the latest events to retrieve. By default, the current time is used. (optional)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\ListEventsResponse|array<string, mixed>
     */
    public function getEvents($runID, $itemsPerPage = null, $page = null, $status = null, $type = null, $sort = null, $order = null, $startDate = null, $endDate = null, $requestOptions = [])
    {
        // verify the required parameter 'runID' is set
        if (!isset($runID)) {
            throw new \InvalidArgumentException(
                'Parameter `runID` is required when calling `getEvents`.'
            );
        }
        if (null !== $itemsPerPage && $itemsPerPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$itemsPerPage" when calling IngestionClient.getEvents, must be smaller than or equal to 100.');
        }
        if (null !== $itemsPerPage && $itemsPerPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$itemsPerPage" when calling IngestionClient.getEvents, must be bigger than or equal to 1.');
        }

        if (null !== $page && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling IngestionClient.getEvents, must be bigger than or equal to 1.');
        }

        $resourcePath = '/1/runs/{runID}/events';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        if (null !== $itemsPerPage) {
            $queryParameters['itemsPerPage'] = $itemsPerPage;
        }

        if (null !== $page) {
            $queryParameters['page'] = $page;
        }

        if (null !== $status) {
            $queryParameters['status'] = $status;
        }

        if (null !== $type) {
            $queryParameters['type'] = $type;
        }

        if (null !== $sort) {
            $queryParameters['sort'] = $sort;
        }

        if (null !== $order) {
            $queryParameters['order'] = $order;
        }

        if (null !== $startDate) {
            $queryParameters['startDate'] = $startDate;
        }

        if (null !== $endDate) {
            $queryParameters['endDate'] = $endDate;
        }

        // path params
        if (null !== $runID) {
            $resourcePath = str_replace(
                '{runID}',
                ObjectSerializer::toPathValue($runID),
                $resourcePath
            );
        }

        return $this->sendRequest('GET', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Retrieve a single task run by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $runID          Unique identifier of a task run. (required)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\Run|array<string, mixed>
     */
    public function getRun($runID, $requestOptions = [])
    {
        // verify the required parameter 'runID' is set
        if (!isset($runID)) {
            throw new \InvalidArgumentException(
                'Parameter `runID` is required when calling `getRun`.'
            );
        }

        $resourcePath = '/1/runs/{runID}';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        // path params
        if (null !== $runID) {
            $resourcePath = str_replace(
                '{runID}',
                ObjectSerializer::toPathValue($runID),
                $resourcePath
            );
        }

        return $this->sendRequest('GET', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Retrieve a list of task runs.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param int    $itemsPerPage   Number of items per page. (optional, default to 10)
     * @param int    $page           Page number of the paginated API response. (optional)
     * @param array  $status         Run status for filtering the list of task runs. (optional)
     * @param string $taskID         Task ID for filtering the list of task runs. (optional)
     * @param array  $sort           Property by which to sort the list of task runs. (optional)
     * @param array  $order          Sort order of the response, ascending or descending. (optional)
     * @param string $startDate      Date in RFC3339 format for the earliest run to retrieve. By default, the current day minus seven days is used. (optional)
     * @param string $endDate        Date in RFC3339 format for the latest run to retrieve. By default, the current day is used. (optional)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\RunListResponse|array<string, mixed>
     */
    public function getRuns($itemsPerPage = null, $page = null, $status = null, $taskID = null, $sort = null, $order = null, $startDate = null, $endDate = null, $requestOptions = [])
    {
        if (null !== $itemsPerPage && $itemsPerPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$itemsPerPage" when calling IngestionClient.getRuns, must be smaller than or equal to 100.');
        }
        if (null !== $itemsPerPage && $itemsPerPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$itemsPerPage" when calling IngestionClient.getRuns, must be bigger than or equal to 1.');
        }

        if (null !== $page && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling IngestionClient.getRuns, must be bigger than or equal to 1.');
        }

        $resourcePath = '/1/runs';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        if (null !== $itemsPerPage) {
            $queryParameters['itemsPerPage'] = $itemsPerPage;
        }

        if (null !== $page) {
            $queryParameters['page'] = $page;
        }

        if (null !== $status) {
            $queryParameters['status'] = $status;
        }

        if (null !== $taskID) {
            $queryParameters['taskID'] = $taskID;
        }

        if (null !== $sort) {
            $queryParameters['sort'] = $sort;
        }

        if (null !== $order) {
            $queryParameters['order'] = $order;
        }

        if (null !== $startDate) {
            $queryParameters['startDate'] = $startDate;
        }

        if (null !== $endDate) {
            $queryParameters['endDate'] = $endDate;
        }

        return $this->sendRequest('GET', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Retrieve a source by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $sourceID       Unique identifier of a source. (required)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\Source|array<string, mixed>
     */
    public function getSource($sourceID, $requestOptions = [])
    {
        // verify the required parameter 'sourceID' is set
        if (!isset($sourceID)) {
            throw new \InvalidArgumentException(
                'Parameter `sourceID` is required when calling `getSource`.'
            );
        }

        $resourcePath = '/1/sources/{sourceID}';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        // path params
        if (null !== $sourceID) {
            $resourcePath = str_replace(
                '{sourceID}',
                ObjectSerializer::toPathValue($sourceID),
                $resourcePath
            );
        }

        return $this->sendRequest('GET', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Retrieves a list of sources.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param int   $itemsPerPage     Number of items per page. (optional, default to 10)
     * @param int   $page             Page number of the paginated API response. (optional)
     * @param array $type             Source type. Some sources require authentication. (optional)
     * @param array $authenticationID Authentication IDs of the sources to retrieve. &#39;none&#39; returns sources that doesn&#39;t have an authentication resource. (optional)
     * @param array $sort             Property by which to sort the list of sources. (optional)
     * @param array $order            Sort order of the response, ascending or descending. (optional)
     * @param array $requestOptions   the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\ListSourcesResponse|array<string, mixed>
     */
    public function getSources($itemsPerPage = null, $page = null, $type = null, $authenticationID = null, $sort = null, $order = null, $requestOptions = [])
    {
        if (null !== $itemsPerPage && $itemsPerPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$itemsPerPage" when calling IngestionClient.getSources, must be smaller than or equal to 100.');
        }
        if (null !== $itemsPerPage && $itemsPerPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$itemsPerPage" when calling IngestionClient.getSources, must be bigger than or equal to 1.');
        }

        if (null !== $page && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling IngestionClient.getSources, must be bigger than or equal to 1.');
        }

        $resourcePath = '/1/sources';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        if (null !== $itemsPerPage) {
            $queryParameters['itemsPerPage'] = $itemsPerPage;
        }

        if (null !== $page) {
            $queryParameters['page'] = $page;
        }

        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, 'form', true);
        }
        if (null !== $type) {
            $queryParameters['type'] = $type;
        }

        if (is_array($authenticationID)) {
            $authenticationID = ObjectSerializer::serializeCollection($authenticationID, 'form', true);
        }
        if (null !== $authenticationID) {
            $queryParameters['authenticationID'] = $authenticationID;
        }

        if (null !== $sort) {
            $queryParameters['sort'] = $sort;
        }

        if (null !== $order) {
            $queryParameters['order'] = $order;
        }

        return $this->sendRequest('GET', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Retrieves a task by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $taskID         Unique identifier of a task. (required)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\Task|array<string, mixed>
     */
    public function getTask($taskID, $requestOptions = [])
    {
        // verify the required parameter 'taskID' is set
        if (!isset($taskID)) {
            throw new \InvalidArgumentException(
                'Parameter `taskID` is required when calling `getTask`.'
            );
        }

        $resourcePath = '/1/tasks/{taskID}';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        // path params
        if (null !== $taskID) {
            $resourcePath = str_replace(
                '{taskID}',
                ObjectSerializer::toPathValue($taskID),
                $resourcePath
            );
        }

        return $this->sendRequest('GET', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Retrieves a list of tasks.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param int   $itemsPerPage   Number of items per page. (optional, default to 10)
     * @param int   $page           Page number of the paginated API response. (optional)
     * @param array $action         Actions for filtering the list of tasks. (optional)
     * @param bool  $enabled        Whether to filter the list of tasks by the &#x60;enabled&#x60; status. (optional)
     * @param array $sourceID       Source IDs for filtering the list of tasks. (optional)
     * @param array $destinationID  Destination IDs for filtering the list of tasks. (optional)
     * @param array $triggerType    Type of task trigger for filtering the list of tasks. (optional)
     * @param array $sort           Property by which to sort the list of tasks. (optional)
     * @param array $order          Sort order of the response, ascending or descending. (optional)
     * @param array $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\ListTasksResponse|array<string, mixed>
     */
    public function getTasks($itemsPerPage = null, $page = null, $action = null, $enabled = null, $sourceID = null, $destinationID = null, $triggerType = null, $sort = null, $order = null, $requestOptions = [])
    {
        if (null !== $itemsPerPage && $itemsPerPage > 100) {
            throw new \InvalidArgumentException('invalid value for "$itemsPerPage" when calling IngestionClient.getTasks, must be smaller than or equal to 100.');
        }
        if (null !== $itemsPerPage && $itemsPerPage < 1) {
            throw new \InvalidArgumentException('invalid value for "$itemsPerPage" when calling IngestionClient.getTasks, must be bigger than or equal to 1.');
        }

        if (null !== $page && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling IngestionClient.getTasks, must be bigger than or equal to 1.');
        }

        $resourcePath = '/1/tasks';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        if (null !== $itemsPerPage) {
            $queryParameters['itemsPerPage'] = $itemsPerPage;
        }

        if (null !== $page) {
            $queryParameters['page'] = $page;
        }

        if (is_array($action)) {
            $action = ObjectSerializer::serializeCollection($action, 'form', true);
        }
        if (null !== $action) {
            $queryParameters['action'] = $action;
        }

        if (null !== $enabled) {
            $queryParameters['enabled'] = $enabled;
        }

        if (is_array($sourceID)) {
            $sourceID = ObjectSerializer::serializeCollection($sourceID, 'form', true);
        }
        if (null !== $sourceID) {
            $queryParameters['sourceID'] = $sourceID;
        }

        if (is_array($destinationID)) {
            $destinationID = ObjectSerializer::serializeCollection($destinationID, 'form', true);
        }
        if (null !== $destinationID) {
            $queryParameters['destinationID'] = $destinationID;
        }

        if (is_array($triggerType)) {
            $triggerType = ObjectSerializer::serializeCollection($triggerType, 'form', true);
        }
        if (null !== $triggerType) {
            $queryParameters['triggerType'] = $triggerType;
        }

        if (null !== $sort) {
            $queryParameters['sort'] = $sort;
        }

        if (null !== $order) {
            $queryParameters['order'] = $order;
        }

        return $this->sendRequest('GET', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Runs a task. You can check the status of task runs with the observability endpoints.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $taskID         Unique identifier of a task. (required)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\RunResponse|array<string, mixed>
     */
    public function runTask($taskID, $requestOptions = [])
    {
        // verify the required parameter 'taskID' is set
        if (!isset($taskID)) {
            throw new \InvalidArgumentException(
                'Parameter `taskID` is required when calling `runTask`.'
            );
        }

        $resourcePath = '/1/tasks/{taskID}/run';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        // path params
        if (null !== $taskID) {
            $resourcePath = str_replace(
                '{taskID}',
                ObjectSerializer::toPathValue($taskID),
                $resourcePath
            );
        }

        return $this->sendRequest('POST', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Searches for authentication resources.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param array $authenticationSearch authenticationSearch (required)
     *                                    - $authenticationSearch['authenticationIDs'] => (array)  (required)
     *
     * @see \Algolia\AlgoliaSearch\Model\Ingestion\AuthenticationSearch
     *
     * @param array $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\Authentication[]|array<string, mixed>
     */
    public function searchAuthentications($authenticationSearch, $requestOptions = [])
    {
        // verify the required parameter 'authenticationSearch' is set
        if (!isset($authenticationSearch)) {
            throw new \InvalidArgumentException(
                'Parameter `authenticationSearch` is required when calling `searchAuthentications`.'
            );
        }

        $resourcePath = '/1/authentications/search';
        $queryParameters = [];
        $headers = [];
        $httpBody = $authenticationSearch;

        return $this->sendRequest('POST', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Searches for destinations.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param array $destinationSearch destinationSearch (required)
     *                                 - $destinationSearch['destinationIDs'] => (array)  (required)
     *
     * @see \Algolia\AlgoliaSearch\Model\Ingestion\DestinationSearch
     *
     * @param array $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\Destination[]|array<string, mixed>
     */
    public function searchDestinations($destinationSearch, $requestOptions = [])
    {
        // verify the required parameter 'destinationSearch' is set
        if (!isset($destinationSearch)) {
            throw new \InvalidArgumentException(
                'Parameter `destinationSearch` is required when calling `searchDestinations`.'
            );
        }

        $resourcePath = '/1/destinations/search';
        $queryParameters = [];
        $headers = [];
        $httpBody = $destinationSearch;

        return $this->sendRequest('POST', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Searches for sources.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param array $sourceSearch sourceSearch (required)
     *                            - $sourceSearch['sourceIDs'] => (array)  (required)
     *
     * @see \Algolia\AlgoliaSearch\Model\Ingestion\SourceSearch
     *
     * @param array $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\Source[]|array<string, mixed>
     */
    public function searchSources($sourceSearch, $requestOptions = [])
    {
        // verify the required parameter 'sourceSearch' is set
        if (!isset($sourceSearch)) {
            throw new \InvalidArgumentException(
                'Parameter `sourceSearch` is required when calling `searchSources`.'
            );
        }

        $resourcePath = '/1/sources/search';
        $queryParameters = [];
        $headers = [];
        $httpBody = $sourceSearch;

        return $this->sendRequest('POST', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Searches for tasks.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param array $taskSearch taskSearch (required)
     *                          - $taskSearch['taskIDs'] => (array)  (required)
     *
     * @see \Algolia\AlgoliaSearch\Model\Ingestion\TaskSearch
     *
     * @param array $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\Task[]|array<string, mixed>
     */
    public function searchTasks($taskSearch, $requestOptions = [])
    {
        // verify the required parameter 'taskSearch' is set
        if (!isset($taskSearch)) {
            throw new \InvalidArgumentException(
                'Parameter `taskSearch` is required when calling `searchTasks`.'
            );
        }

        $resourcePath = '/1/tasks/search';
        $queryParameters = [];
        $headers = [];
        $httpBody = $taskSearch;

        return $this->sendRequest('POST', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Triggers a stream-listing request for a source. Triggering stream-listing requests only works with sources with `type: docker` and `imageType: singer`.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $sourceID       Unique identifier of a source. (required)
     * @param array  $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\DockerSourceDiscover|array<string, mixed>
     */
    public function triggerDockerSourceDiscover($sourceID, $requestOptions = [])
    {
        // verify the required parameter 'sourceID' is set
        if (!isset($sourceID)) {
            throw new \InvalidArgumentException(
                'Parameter `sourceID` is required when calling `triggerDockerSourceDiscover`.'
            );
        }

        $resourcePath = '/1/sources/{sourceID}/discover';
        $queryParameters = [];
        $headers = [];
        $httpBody = null;

        // path params
        if (null !== $sourceID) {
            $resourcePath = str_replace(
                '{sourceID}',
                ObjectSerializer::toPathValue($sourceID),
                $resourcePath
            );
        }

        return $this->sendRequest('POST', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Updates an authentication resource.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $authenticationID     Unique identifier of an authentication resource. (required)
     * @param array  $authenticationUpdate authenticationUpdate (required)
     *                                     - $authenticationUpdate['type'] => (array)
     *                                     - $authenticationUpdate['name'] => (string) Descriptive name for the resource.
     *                                     - $authenticationUpdate['platform'] => (array)
     *                                     - $authenticationUpdate['input'] => (array)
     *
     * @see \Algolia\AlgoliaSearch\Model\Ingestion\AuthenticationUpdate
     *
     * @param array $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\AuthenticationUpdateResponse|array<string, mixed>
     */
    public function updateAuthentication($authenticationID, $authenticationUpdate, $requestOptions = [])
    {
        // verify the required parameter 'authenticationID' is set
        if (!isset($authenticationID)) {
            throw new \InvalidArgumentException(
                'Parameter `authenticationID` is required when calling `updateAuthentication`.'
            );
        }
        // verify the required parameter 'authenticationUpdate' is set
        if (!isset($authenticationUpdate)) {
            throw new \InvalidArgumentException(
                'Parameter `authenticationUpdate` is required when calling `updateAuthentication`.'
            );
        }

        $resourcePath = '/1/authentications/{authenticationID}';
        $queryParameters = [];
        $headers = [];
        $httpBody = $authenticationUpdate;

        // path params
        if (null !== $authenticationID) {
            $resourcePath = str_replace(
                '{authenticationID}',
                ObjectSerializer::toPathValue($authenticationID),
                $resourcePath
            );
        }

        return $this->sendRequest('PATCH', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Updates the destination by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $destinationID     Unique identifier of a destination. (required)
     * @param array  $destinationUpdate destinationUpdate (required)
     *                                  - $destinationUpdate['type'] => (array)
     *                                  - $destinationUpdate['name'] => (string) Descriptive name for the resource.
     *                                  - $destinationUpdate['input'] => (array)
     *                                  - $destinationUpdate['authenticationID'] => (string) Universally unique identifier (UUID) of an authentication resource.
     *
     * @see \Algolia\AlgoliaSearch\Model\Ingestion\DestinationUpdate
     *
     * @param array $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\DestinationUpdateResponse|array<string, mixed>
     */
    public function updateDestination($destinationID, $destinationUpdate, $requestOptions = [])
    {
        // verify the required parameter 'destinationID' is set
        if (!isset($destinationID)) {
            throw new \InvalidArgumentException(
                'Parameter `destinationID` is required when calling `updateDestination`.'
            );
        }
        // verify the required parameter 'destinationUpdate' is set
        if (!isset($destinationUpdate)) {
            throw new \InvalidArgumentException(
                'Parameter `destinationUpdate` is required when calling `updateDestination`.'
            );
        }

        $resourcePath = '/1/destinations/{destinationID}';
        $queryParameters = [];
        $headers = [];
        $httpBody = $destinationUpdate;

        // path params
        if (null !== $destinationID) {
            $resourcePath = str_replace(
                '{destinationID}',
                ObjectSerializer::toPathValue($destinationID),
                $resourcePath
            );
        }

        return $this->sendRequest('PATCH', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Updates a source by its ID.
     *
     * Required API Key ACLs:
     *  - addObject
     *  - deleteIndex
     *  - editSettings
     *
     * @param string $sourceID     Unique identifier of a source. (required)
     * @param array  $sourceUpdate sourceUpdate (required)
     *                             - $sourceUpdate['name'] => (string) Descriptive name of the source.
     *                             - $sourceUpdate['input'] => (array)
     *                             - $sourceUpdate['authenticationID'] => (string) Universally unique identifier (UUID) of an authentication resource.
     *
     * @see \Algolia\AlgoliaSearch\Model\Ingestion\SourceUpdate
     *
     * @param array $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\SourceUpdateResponse|array<string, mixed>
     */
    public function updateSource($sourceID, $sourceUpdate, $requestOptions = [])
    {
        // verify the required parameter 'sourceID' is set
        if (!isset($sourceID)) {
            throw new \InvalidArgumentException(
                'Parameter `sourceID` is required when calling `updateSource`.'
            );
        }
        // verify the required parameter 'sourceUpdate' is set
        if (!isset($sourceUpdate)) {
            throw new \InvalidArgumentException(
                'Parameter `sourceUpdate` is required when calling `updateSource`.'
            );
        }

        $resourcePath = '/1/sources/{sourceID}';
        $queryParameters = [];
        $headers = [];
        $httpBody = $sourceUpdate;

        // path params
        if (null !== $sourceID) {
            $resourcePath = str_replace(
                '{sourceID}',
                ObjectSerializer::toPathValue($sourceID),
                $resourcePath
            );
        }

        return $this->sendRequest('PATCH', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    /**
     * Updates a task by its ID.
     *
     * @param string $taskID     Unique identifier of a task. (required)
     * @param array  $taskUpdate taskUpdate (required)
     *                           - $taskUpdate['destinationID'] => (string) Universally unique identifier (UUID) of a destination resource.
     *                           - $taskUpdate['trigger'] => (array)
     *                           - $taskUpdate['input'] => (array)
     *                           - $taskUpdate['enabled'] => (bool) Whether the task is enabled.
     *                           - $taskUpdate['failureThreshold'] => (int) Maximum accepted percentage of failures for a task run to finish successfully.
     *
     * @see \Algolia\AlgoliaSearch\Model\Ingestion\TaskUpdate
     *
     * @param array $requestOptions the requestOptions to send along with the query, they will be merged with the transporter requestOptions
     *
     * @return \Algolia\AlgoliaSearch\Model\Ingestion\TaskUpdateResponse|array<string, mixed>
     */
    public function updateTask($taskID, $taskUpdate, $requestOptions = [])
    {
        // verify the required parameter 'taskID' is set
        if (!isset($taskID)) {
            throw new \InvalidArgumentException(
                'Parameter `taskID` is required when calling `updateTask`.'
            );
        }
        // verify the required parameter 'taskUpdate' is set
        if (!isset($taskUpdate)) {
            throw new \InvalidArgumentException(
                'Parameter `taskUpdate` is required when calling `updateTask`.'
            );
        }

        $resourcePath = '/1/tasks/{taskID}';
        $queryParameters = [];
        $headers = [];
        $httpBody = $taskUpdate;

        // path params
        if (null !== $taskID) {
            $resourcePath = str_replace(
                '{taskID}',
                ObjectSerializer::toPathValue($taskID),
                $resourcePath
            );
        }

        return $this->sendRequest('PATCH', $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions);
    }

    private function sendRequest($method, $resourcePath, $headers, $queryParameters, $httpBody, $requestOptions, $useReadTransporter = false)
    {
        if (!isset($requestOptions['headers'])) {
            $requestOptions['headers'] = [];
        }
        if (!isset($requestOptions['queryParameters'])) {
            $requestOptions['queryParameters'] = [];
        }

        $requestOptions['headers'] = array_merge($headers, $requestOptions['headers']);
        $requestOptions['queryParameters'] = array_merge($queryParameters, $requestOptions['queryParameters']);
        $query = \GuzzleHttp\Psr7\Query::build($requestOptions['queryParameters']);

        return $this->api->sendRequest(
            $method,
            $resourcePath.($query ? "?{$query}" : ''),
            $httpBody,
            $requestOptions,
            $useReadTransporter
        );
    }
}
