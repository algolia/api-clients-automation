<?php

// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

namespace Algolia\AlgoliaSearch\Model\Ingestion;

use Algolia\AlgoliaSearch\Model\AbstractModel;

/**
 * SourceUpdateShopify Class Doc Comment.
 *
 * @category Class
 */
class SourceUpdateShopify extends AbstractModel implements ModelInterface, \ArrayAccess, \JsonSerializable
{
    /**
     * Array of property to type mappings. Used for (de)serialization.
     *
     * @var string[]
     */
    protected static $modelTypes = [
        'collectionIDIndexing' => 'bool',
        'increaseProductCollectionLimit' => 'bool',
        'defaultPriceRatioAsOne' => 'bool',
        'excludeOOSVariantsForPriceAtTRS' => 'bool',
        'includeVariantsInventory' => 'bool',
        'hasCollectionSearchPage' => 'bool',
        'productNamedTags' => 'bool',
    ];

    /**
     * Array of property to format mappings. Used for (de)serialization.
     *
     * @var string[]
     */
    protected static $modelFormats = [
        'collectionIDIndexing' => null,
        'increaseProductCollectionLimit' => null,
        'defaultPriceRatioAsOne' => null,
        'excludeOOSVariantsForPriceAtTRS' => null,
        'includeVariantsInventory' => null,
        'hasCollectionSearchPage' => null,
        'productNamedTags' => null,
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name.
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'collectionIDIndexing' => 'collectionIDIndexing',
        'increaseProductCollectionLimit' => 'increaseProductCollectionLimit',
        'defaultPriceRatioAsOne' => 'defaultPriceRatioAsOne',
        'excludeOOSVariantsForPriceAtTRS' => 'excludeOOSVariantsForPriceAtTRS',
        'includeVariantsInventory' => 'includeVariantsInventory',
        'hasCollectionSearchPage' => 'hasCollectionSearchPage',
        'productNamedTags' => 'productNamedTags',
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses).
     *
     * @var string[]
     */
    protected static $setters = [
        'collectionIDIndexing' => 'setCollectionIDIndexing',
        'increaseProductCollectionLimit' => 'setIncreaseProductCollectionLimit',
        'defaultPriceRatioAsOne' => 'setDefaultPriceRatioAsOne',
        'excludeOOSVariantsForPriceAtTRS' => 'setExcludeOOSVariantsForPriceAtTRS',
        'includeVariantsInventory' => 'setIncludeVariantsInventory',
        'hasCollectionSearchPage' => 'setHasCollectionSearchPage',
        'productNamedTags' => 'setProductNamedTags',
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests).
     *
     * @var string[]
     */
    protected static $getters = [
        'collectionIDIndexing' => 'getCollectionIDIndexing',
        'increaseProductCollectionLimit' => 'getIncreaseProductCollectionLimit',
        'defaultPriceRatioAsOne' => 'getDefaultPriceRatioAsOne',
        'excludeOOSVariantsForPriceAtTRS' => 'getExcludeOOSVariantsForPriceAtTRS',
        'includeVariantsInventory' => 'getIncludeVariantsInventory',
        'hasCollectionSearchPage' => 'getHasCollectionSearchPage',
        'productNamedTags' => 'getProductNamedTags',
    ];

    /**
     * Associative array for storing property values.
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor.
     *
     * @param mixed[] $data Associated array of property values
     */
    public function __construct(?array $data = null)
    {
        if (isset($data['collectionIDIndexing'])) {
            $this->container['collectionIDIndexing'] = $data['collectionIDIndexing'];
        }
        if (isset($data['increaseProductCollectionLimit'])) {
            $this->container['increaseProductCollectionLimit'] = $data['increaseProductCollectionLimit'];
        }
        if (isset($data['defaultPriceRatioAsOne'])) {
            $this->container['defaultPriceRatioAsOne'] = $data['defaultPriceRatioAsOne'];
        }
        if (isset($data['excludeOOSVariantsForPriceAtTRS'])) {
            $this->container['excludeOOSVariantsForPriceAtTRS'] = $data['excludeOOSVariantsForPriceAtTRS'];
        }
        if (isset($data['includeVariantsInventory'])) {
            $this->container['includeVariantsInventory'] = $data['includeVariantsInventory'];
        }
        if (isset($data['hasCollectionSearchPage'])) {
            $this->container['hasCollectionSearchPage'] = $data['hasCollectionSearchPage'];
        }
        if (isset($data['productNamedTags'])) {
            $this->container['productNamedTags'] = $data['productNamedTags'];
        }
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name.
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of property to type mappings. Used for (de)serialization.
     *
     * @return array
     */
    public static function modelTypes()
    {
        return self::$modelTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization.
     *
     * @return array
     */
    public static function modelFormats()
    {
        return self::$modelFormats;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses).
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests).
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        return [];
    }

    /**
     * Validate all the properties in the model
     * return true if all passed.
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return 0 === count($this->listInvalidProperties());
    }

    /**
     * Gets collectionIDIndexing.
     *
     * @return null|bool
     */
    public function getCollectionIDIndexing()
    {
        return $this->container['collectionIDIndexing'] ?? null;
    }

    /**
     * Sets collectionIDIndexing.
     *
     * @param null|bool $collectionIDIndexing Whether to index collection IDs.   If your store has `has_collection_search_page` set to true, collection IDs will be indexed even if `collectionIDIndexing` is false.
     *
     * @return self
     */
    public function setCollectionIDIndexing($collectionIDIndexing)
    {
        $this->container['collectionIDIndexing'] = $collectionIDIndexing;

        return $this;
    }

    /**
     * Gets increaseProductCollectionLimit.
     *
     * @return null|bool
     */
    public function getIncreaseProductCollectionLimit()
    {
        return $this->container['increaseProductCollectionLimit'] ?? null;
    }

    /**
     * Sets increaseProductCollectionLimit.
     *
     * @param null|bool $increaseProductCollectionLimit Whether to increase the number of indexed collections per product. If true, Algolia indexes 200 collections per product. If false, 100 collections per product are indexed.
     *
     * @return self
     */
    public function setIncreaseProductCollectionLimit($increaseProductCollectionLimit)
    {
        $this->container['increaseProductCollectionLimit'] = $increaseProductCollectionLimit;

        return $this;
    }

    /**
     * Gets defaultPriceRatioAsOne.
     *
     * @return null|bool
     */
    public function getDefaultPriceRatioAsOne()
    {
        return $this->container['defaultPriceRatioAsOne'] ?? null;
    }

    /**
     * Sets defaultPriceRatioAsOne.
     *
     * @param null|bool $defaultPriceRatioAsOne Whether to set the default price ratio to 1 if no sale price is present.  The price ratio is determined by the ratio: `sale_price` / `regular_price`. If no sale price is present, the price ratio would be 0. If `defaultPriceRatioAsOne` is true, the price ratio is indexed as 1 instead.
     *
     * @return self
     */
    public function setDefaultPriceRatioAsOne($defaultPriceRatioAsOne)
    {
        $this->container['defaultPriceRatioAsOne'] = $defaultPriceRatioAsOne;

        return $this;
    }

    /**
     * Gets excludeOOSVariantsForPriceAtTRS.
     *
     * @return null|bool
     */
    public function getExcludeOOSVariantsForPriceAtTRS()
    {
        return $this->container['excludeOOSVariantsForPriceAtTRS'] ?? null;
    }

    /**
     * Sets excludeOOSVariantsForPriceAtTRS.
     *
     * @param null|bool $excludeOOSVariantsForPriceAtTRS whether to exclude out-of-stock variants when determining the `max_variant_price` and `min_variant_price` attributes
     *
     * @return self
     */
    public function setExcludeOOSVariantsForPriceAtTRS($excludeOOSVariantsForPriceAtTRS)
    {
        $this->container['excludeOOSVariantsForPriceAtTRS'] = $excludeOOSVariantsForPriceAtTRS;

        return $this;
    }

    /**
     * Gets includeVariantsInventory.
     *
     * @return null|bool
     */
    public function getIncludeVariantsInventory()
    {
        return $this->container['includeVariantsInventory'] ?? null;
    }

    /**
     * Sets includeVariantsInventory.
     *
     * @param null|bool $includeVariantsInventory whether to include an inventory with every variant for every product record
     *
     * @return self
     */
    public function setIncludeVariantsInventory($includeVariantsInventory)
    {
        $this->container['includeVariantsInventory'] = $includeVariantsInventory;

        return $this;
    }

    /**
     * Gets hasCollectionSearchPage.
     *
     * @return null|bool
     */
    public function getHasCollectionSearchPage()
    {
        return $this->container['hasCollectionSearchPage'] ?? null;
    }

    /**
     * Sets hasCollectionSearchPage.
     *
     * @param null|bool $hasCollectionSearchPage whether to include collection IDs and handles in the product records
     *
     * @return self
     */
    public function setHasCollectionSearchPage($hasCollectionSearchPage)
    {
        $this->container['hasCollectionSearchPage'] = $hasCollectionSearchPage;

        return $this;
    }

    /**
     * Gets productNamedTags.
     *
     * @return null|bool
     */
    public function getProductNamedTags()
    {
        return $this->container['productNamedTags'] ?? null;
    }

    /**
     * Sets productNamedTags.
     *
     * @param null|bool $productNamedTags Whether to convert tags on products to named tags.  To learn more, see [Named tags](https://www.algolia.com/doc/integration/shopify/sending-and-managing-data/named-tags).
     *
     * @return self
     */
    public function setProductNamedTags($productNamedTags)
    {
        $this->container['productNamedTags'] = $productNamedTags;

        return $this;
    }

    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param int $offset Offset
     *
     * @return bool
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param int $offset Offset
     *
     * @return null|mixed
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param null|int $offset Offset
     * @param mixed    $value  Value to be set
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param int $offset Offset
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }
}
