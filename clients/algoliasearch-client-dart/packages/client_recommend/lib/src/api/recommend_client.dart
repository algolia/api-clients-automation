// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import 'package:algolia_client_core/algolia_client_core.dart';
import 'package:algolia_client_recommend/src/deserialize.dart';
import 'package:algolia_client_recommend/src/version.dart';

import 'package:algolia_client_recommend/src/model/deleted_at_response.dart';
import 'package:algolia_client_recommend/src/model/get_recommend_task_response.dart';
import 'package:algolia_client_recommend/src/model/get_recommendations_params.dart';
import 'package:algolia_client_recommend/src/model/get_recommendations_response.dart';
import 'package:algolia_client_recommend/src/model/recommend_models.dart';
import 'package:algolia_client_recommend/src/model/recommend_rule.dart';
import 'package:algolia_client_recommend/src/model/recommend_updated_at_response.dart';
import 'package:algolia_client_recommend/src/model/search_recommend_rules_params.dart';
import 'package:algolia_client_recommend/src/model/search_recommend_rules_response.dart';

final class RecommendClient implements ApiClient {
  @override
  final ClientOptions options;

  final RetryStrategy _retryStrategy;

  RecommendClient({
    required String appId,
    required String apiKey,
    this.options = const ClientOptions(),
  }) : _retryStrategy = RetryStrategy.create(
          segment: AgentSegment(value: "Recommend", version: packageVersion),
          appId: appId,
          apiKey: apiKey,
          options: options,
          defaultHosts: () =>
              [
                Host(url: '$appId-dsn.algolia.net', callType: CallType.read),
                Host(url: '$appId.algolia.net', callType: CallType.write),
              ] +
              ([
                Host(url: '$appId-1.algolianet.com'),
                Host(url: '$appId-2.algolianet.com'),
                Host(url: '$appId-3.algolianet.com'),
              ]..shuffle()),
        ) {
    assert(appId.isNotEmpty, '`appId` is missing.');
    assert(apiKey.isNotEmpty, '`apiKey` is missing.');
  }

  /// Allows to switch the API key used to authenticate requests.
  @override
  void setClientApiKey({required String apiKey}) {
    _retryStrategy.requester.setClientApiKey(apiKey);
  }

  /// Create or update a batch of Recommend Rules  Each Recommend Rule is created or updated, depending on whether a Recommend Rule with the same `objectID` already exists. You may also specify `true` for `clearExistingRules`, in which case the batch will atomically replace all the existing Recommend Rules.  Recommend Rules are similar to Search Rules, except that the conditions and consequences apply to a [source item](/doc/guides/algolia-recommend/overview/#recommend-models) instead of a query. The main differences are the following: - Conditions `pattern` and `anchoring` are unavailable. - Condition `filters` triggers if the source item matches the specified filters. - Condition `filters` accepts numeric filters. - Consequence `params` only covers filtering parameters. - Consequence `automaticFacetFilters` doesn't require a facet value placeholder (it tries to match the data source item's attributes instead).
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [model] [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
  /// * [recommendRule]
  /// * [requestOptions] additional request configuration.
  Future<RecommendUpdatedAtResponse> batchRecommendRules({
    required String indexName,
    required RecommendModels model,
    List<RecommendRule>? recommendRule,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `batchRecommendRules`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/{model}/recommend/rules/batch'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll('{' r'model' '}', Uri.encodeComponent(model.toString())),
      body: recommendRule,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<RecommendUpdatedAtResponse, RecommendUpdatedAtResponse>(
      response,
      'RecommendUpdatedAtResponse',
      growable: true,
    );
  }

  /// This method lets you send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [requestOptions] additional request configuration.
  Future<Object> customDelete({
    required String path,
    Map<String, Object>? parameters,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `customDelete`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// This method lets you send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [requestOptions] additional request configuration.
  Future<Object> customGet({
    required String path,
    Map<String, Object>? parameters,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `customGet`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// This method lets you send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [body] Parameters to send with the custom request.
  /// * [requestOptions] additional request configuration.
  Future<Object> customPost({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `customPost`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// This method lets you send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, anything after \"/1\" must be specified.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [body] Parameters to send with the custom request.
  /// * [requestOptions] additional request configuration.
  Future<Object> customPut({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `customPut`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Deletes a Recommend rule from a recommendation scenario.
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [model] [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
  /// * [objectID] Unique record identifier.
  /// * [requestOptions] additional request configuration.
  Future<DeletedAtResponse> deleteRecommendRule({
    required String indexName,
    required RecommendModels model,
    required String objectID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteRecommendRule`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `deleteRecommendRule`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/indexes/{indexName}/{model}/recommend/rules/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll('{' r'model' '}', Uri.encodeComponent(model.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeletedAtResponse, DeletedAtResponse>(
      response,
      'DeletedAtResponse',
      growable: true,
    );
  }

  /// Retrieves a Recommend rule that you previously created in the Algolia dashboard.
  ///
  /// Required API Key ACLs:
  ///   - settings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [model] [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
  /// * [objectID] Unique record identifier.
  /// * [requestOptions] additional request configuration.
  Future<RecommendRule> getRecommendRule({
    required String indexName,
    required RecommendModels model,
    required String objectID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getRecommendRule`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `getRecommendRule`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/{model}/recommend/rules/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll('{' r'model' '}', Uri.encodeComponent(model.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<RecommendRule, RecommendRule>(
      response,
      'RecommendRule',
      growable: true,
    );
  }

  /// Checks the status of a given task.  Deleting a Recommend rule is asynchronous. When you delete a rule, a task is created on a queue and completed depending on the load on the server. The API response includes a task ID that you can use to check the status.
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [model] [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
  /// * [taskID] Unique task identifier.
  /// * [requestOptions] additional request configuration.
  Future<GetRecommendTaskResponse> getRecommendStatus({
    required String indexName,
    required RecommendModels model,
    required int taskID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getRecommendStatus`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/{model}/task/{taskID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll('{' r'model' '}', Uri.encodeComponent(model.toString()))
          .replaceAll(
              '{' r'taskID' '}', Uri.encodeComponent(taskID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetRecommendTaskResponse, GetRecommendTaskResponse>(
      response,
      'GetRecommendTaskResponse',
      growable: true,
    );
  }

  /// Retrieves recommendations from selected AI models.
  ///
  /// Required API Key ACLs:
  ///   - search
  ///
  /// Parameters:
  /// * [getRecommendationsParams]
  /// * [requestOptions] additional request configuration.
  Future<GetRecommendationsResponse> getRecommendations({
    required GetRecommendationsParams getRecommendationsParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/*/recommendations',
      isRead: true,
      body: getRecommendationsParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetRecommendationsResponse, GetRecommendationsResponse>(
      response,
      'GetRecommendationsResponse',
      growable: true,
    );
  }

  /// Searches for Recommend rules.  Use an empty query to list all rules for this recommendation scenario.
  ///
  /// Required API Key ACLs:
  ///   - settings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [model] [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
  /// * [searchRecommendRulesParams]
  /// * [requestOptions] additional request configuration.
  Future<SearchRecommendRulesResponse> searchRecommendRules({
    required String indexName,
    required RecommendModels model,
    SearchRecommendRulesParams? searchRecommendRulesParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `searchRecommendRules`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/{model}/recommend/rules/search'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll('{' r'model' '}', Uri.encodeComponent(model.toString())),
      isRead: true,
      body: searchRecommendRulesParams?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchRecommendRulesResponse,
        SearchRecommendRulesResponse>(
      response,
      'SearchRecommendRulesResponse',
      growable: true,
    );
  }

  @Deprecated('This operation has been deprecated, use `customPost` instead')
  Future<Object> post({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    return customPost(
        path: path, parameters: parameters, requestOptions: requestOptions);
  }

  @Deprecated('This operation has been deprecated, use `customPut` instead')
  Future<Object> put({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    return customPut(
        path: path, parameters: parameters, requestOptions: requestOptions);
  }

  @Deprecated('This operation has been deprecated, use `customGet` instead')
  Future<Object> get({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    return customGet(
        path: path, parameters: parameters, requestOptions: requestOptions);
  }

  @Deprecated('This operation has been deprecated, use `customDelete` instead')
  Future<Object> del({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    return customDelete(
        path: path, parameters: parameters, requestOptions: requestOptions);
  }

  @override
  void dispose() => _retryStrategy.dispose();
}
