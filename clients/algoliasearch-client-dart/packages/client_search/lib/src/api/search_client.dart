// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import 'package:algolia_client_core/algolia_client_core.dart';
import 'package:algolia_client_search/src/deserialize.dart';
import 'package:algolia_client_search/src/version.dart';

import 'package:algolia_client_search/src/model/add_api_key_response.dart';
import 'package:algolia_client_search/src/model/api_key.dart';
import 'package:algolia_client_search/src/model/assign_user_id_params.dart';
import 'package:algolia_client_search/src/model/batch_assign_user_ids_params.dart';
import 'package:algolia_client_search/src/model/batch_dictionary_entries_params.dart';
import 'package:algolia_client_search/src/model/batch_params.dart';
import 'package:algolia_client_search/src/model/batch_response.dart';
import 'package:algolia_client_search/src/model/batch_write_params.dart';
import 'package:algolia_client_search/src/model/browse_params_object.dart';
import 'package:algolia_client_search/src/model/browse_response.dart';
import 'package:algolia_client_search/src/model/created_at_response.dart';
import 'package:algolia_client_search/src/model/delete_api_key_response.dart';
import 'package:algolia_client_search/src/model/delete_by_params.dart';
import 'package:algolia_client_search/src/model/delete_source_response.dart';
import 'package:algolia_client_search/src/model/deleted_at_response.dart';
import 'package:algolia_client_search/src/model/dictionary_settings_params.dart';
import 'package:algolia_client_search/src/model/dictionary_type.dart';
import 'package:algolia_client_search/src/model/get_api_key_response.dart';
import 'package:algolia_client_search/src/model/get_dictionary_settings_response.dart';
import 'package:algolia_client_search/src/model/get_logs_response.dart';
import 'package:algolia_client_search/src/model/get_objects_params.dart';
import 'package:algolia_client_search/src/model/get_objects_response.dart';
import 'package:algolia_client_search/src/model/get_task_response.dart';
import 'package:algolia_client_search/src/model/get_top_user_ids_response.dart';
import 'package:algolia_client_search/src/model/has_pending_mappings_response.dart';
import 'package:algolia_client_search/src/model/index_settings.dart';
import 'package:algolia_client_search/src/model/languages.dart';
import 'package:algolia_client_search/src/model/list_api_keys_response.dart';
import 'package:algolia_client_search/src/model/list_clusters_response.dart';
import 'package:algolia_client_search/src/model/list_indices_response.dart';
import 'package:algolia_client_search/src/model/list_user_ids_response.dart';
import 'package:algolia_client_search/src/model/log_type.dart';
import 'package:algolia_client_search/src/model/multiple_batch_response.dart';
import 'package:algolia_client_search/src/model/operation_index_params.dart';
import 'package:algolia_client_search/src/model/remove_user_id_response.dart';
import 'package:algolia_client_search/src/model/replace_source_response.dart';
import 'package:algolia_client_search/src/model/rule.dart';
import 'package:algolia_client_search/src/model/save_object_response.dart';
import 'package:algolia_client_search/src/model/save_synonym_response.dart';
import 'package:algolia_client_search/src/model/search_dictionary_entries_params.dart';
import 'package:algolia_client_search/src/model/search_dictionary_entries_response.dart';
import 'package:algolia_client_search/src/model/search_for_facet_values_request.dart';
import 'package:algolia_client_search/src/model/search_for_facet_values_response.dart';
import 'package:algolia_client_search/src/model/search_method_params.dart';
import 'package:algolia_client_search/src/model/search_response.dart';
import 'package:algolia_client_search/src/model/search_responses.dart';
import 'package:algolia_client_search/src/model/search_rules_params.dart';
import 'package:algolia_client_search/src/model/search_rules_response.dart';
import 'package:algolia_client_search/src/model/search_synonyms_params.dart';
import 'package:algolia_client_search/src/model/search_synonyms_response.dart';
import 'package:algolia_client_search/src/model/search_user_ids_params.dart';
import 'package:algolia_client_search/src/model/search_user_ids_response.dart';
import 'package:algolia_client_search/src/model/settings_response.dart';
import 'package:algolia_client_search/src/model/source.dart';
import 'package:algolia_client_search/src/model/synonym_hit.dart';
import 'package:algolia_client_search/src/model/update_api_key_response.dart';
import 'package:algolia_client_search/src/model/updated_at_response.dart';
import 'package:algolia_client_search/src/model/updated_at_with_object_id_response.dart';
import 'package:algolia_client_search/src/model/user_id.dart';

final class SearchClient implements ApiClient {
  @override
  final ClientOptions options;

  final RetryStrategy _retryStrategy;

  SearchClient({
    required String appId,
    required String apiKey,
    this.options = const ClientOptions(),
  }) : _retryStrategy = RetryStrategy.create(
          segment: AgentSegment(value: "Search", version: packageVersion),
          appId: appId,
          apiKey: apiKey,
          options: options,
          defaultHosts: () =>
              [
                Host(url: '$appId-dsn.algolia.net', callType: CallType.read),
                Host(url: '$appId.algolia.net', callType: CallType.write),
              ] +
              ([
                Host(url: '$appId-1.algolianet.com'),
                Host(url: '$appId-2.algolianet.com'),
                Host(url: '$appId-3.algolianet.com'),
              ]..shuffle()),
        ) {
    assert(appId.isNotEmpty, '`appId` is missing.');
    assert(apiKey.isNotEmpty, '`apiKey` is missing.');
  }

  /// Allows to switch the API key used to authenticate requests.
  @override
  void setClientApiKey({required String apiKey}) {
    _retryStrategy.requester.setClientApiKey(apiKey);
  }

  /// Creates a new API key with specific permissions and restrictions.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [apiKey]
  /// * [requestOptions] additional request configuration.
  Future<AddApiKeyResponse> addApiKey({
    required ApiKey apiKey,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/keys',
      body: apiKey.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<AddApiKeyResponse, AddApiKeyResponse>(
      response,
      'AddApiKeyResponse',
      growable: true,
    );
  }

  /// If a record with the specified object ID exists, the existing record is replaced. Otherwise, a new record is added to the index.  If you want to use auto-generated object IDs, use the [`saveObject` operation](https://www.algolia.com/doc/rest-api/search/save-object). To update _some_ attributes of an existing record, use the [`partial` operation](https://www.algolia.com/doc/rest-api/search/partial-update-object) instead. To add, update, or replace multiple records, use the [`batch` operation](https://www.algolia.com/doc/rest-api/search/batch).
  ///
  /// Required API Key ACLs:
  ///   - addObject
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [objectID] Unique record identifier.
  /// * [body] The record. A schemaless object with attributes that are useful in the context of search and discovery.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtWithObjectIdResponse> addOrUpdateObject({
    required String indexName,
    required String objectID,
    required Object body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `addOrUpdateObject`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `addOrUpdateObject`.',
    );
    if (body is Map) {
      assert(
        body.isNotEmpty,
        'Parameter `body` is required when calling `addOrUpdateObject`.',
      );
    }
    if (body is Map) {
      assert(
        body.isNotEmpty,
        'Parameter `body ` is required when calling `addOrUpdateObject`.',
      );
    }
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/indexes/{indexName}/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtWithObjectIdResponse,
        UpdatedAtWithObjectIdResponse>(
      response,
      'UpdatedAtWithObjectIdResponse',
      growable: true,
    );
  }

  /// Adds a source to the list of allowed sources.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [source] Source to add.
  /// * [requestOptions] additional request configuration.
  Future<CreatedAtResponse> appendSource({
    required Source source,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/security/sources/append',
      body: source.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<CreatedAtResponse, CreatedAtResponse>(
      response,
      'CreatedAtResponse',
      growable: true,
    );
  }

  /// Assigns or moves a user ID to a cluster.  The time it takes to move a user is proportional to the amount of data linked to the user ID.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [xAlgoliaUserID] Unique identifier of the user who makes the search request.
  /// * [assignUserIdParams]
  /// * [requestOptions] additional request configuration.
  @Deprecated('This operation has been deprecated')
  Future<CreatedAtResponse> assignUserId({
    required String xAlgoliaUserID,
    required AssignUserIdParams assignUserIdParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      xAlgoliaUserID.isNotEmpty,
      'Parameter `xAlgoliaUserID` is required when calling `assignUserId`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/clusters/mapping',
      headers: {
        'X-Algolia-User-ID': xAlgoliaUserID,
      },
      body: assignUserIdParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<CreatedAtResponse, CreatedAtResponse>(
      response,
      'CreatedAtResponse',
      growable: true,
    );
  }

  /// Adds, updates, or deletes records in one index with a single API request.  Batching index updates reduces latency and increases data integrity.  - Actions are applied in the order they're specified. - Actions are equivalent to the individual API requests of the same name.  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
  ///
  /// Required API Key ACLs:
  ///   - addObject
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [batchWriteParams]
  /// * [requestOptions] additional request configuration.
  Future<BatchResponse> batch({
    required String indexName,
    required BatchWriteParams batchWriteParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `batch`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/batch'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      body: batchWriteParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<BatchResponse, BatchResponse>(
      response,
      'BatchResponse',
      growable: true,
    );
  }

  /// Assigns multiple user IDs to a cluster.  **You can't move users with this operation**.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [xAlgoliaUserID] Unique identifier of the user who makes the search request.
  /// * [batchAssignUserIdsParams]
  /// * [requestOptions] additional request configuration.
  @Deprecated('This operation has been deprecated')
  Future<CreatedAtResponse> batchAssignUserIds({
    required String xAlgoliaUserID,
    required BatchAssignUserIdsParams batchAssignUserIdsParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      xAlgoliaUserID.isNotEmpty,
      'Parameter `xAlgoliaUserID` is required when calling `batchAssignUserIds`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/clusters/mapping/batch',
      headers: {
        'X-Algolia-User-ID': xAlgoliaUserID,
      },
      body: batchAssignUserIdsParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<CreatedAtResponse, CreatedAtResponse>(
      response,
      'CreatedAtResponse',
      growable: true,
    );
  }

  /// Adds or deletes multiple entries from your plurals, segmentation, or stop word dictionaries.
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [dictionaryName] Dictionary type in which to search.
  /// * [batchDictionaryEntriesParams]
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> batchDictionaryEntries({
    required DictionaryType dictionaryName,
    required BatchDictionaryEntriesParams batchDictionaryEntriesParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/dictionaries/{dictionaryName}/batch'.replaceAll(
          '{' r'dictionaryName' '}',
          Uri.encodeComponent(dictionaryName.toString())),
      body: batchDictionaryEntriesParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Retrieves records from an index, up to 1,000 per request.  While searching retrieves _hits_ (records augmented with attributes for highlighting and ranking details), browsing _just_ returns matching records. This can be useful if you want to export your indices.  - The Analytics API doesn't collect data when using `browse`. - Records are ranked by attributes and custom ranking. - There's no ranking for: typo-tolerance, number of matched words, proximity, geo distance.  Browse requests automatically apply these settings:  - `advancedSyntax`: `false` - `attributesToHighlight`: `[]` - `attributesToSnippet`: `[]` - `distinct`: `false` - `enablePersonalization`: `false` - `enableRules`: `false` - `facets`: `[]` - `getRankingInfo`: `false` - `ignorePlurals`: `false` - `optionalFilters`: `[]` - `typoTolerance`: `true` or `false` (`min` and `strict` evaluate to `true`)  If you send these parameters with your browse requests, they'll be ignored.
  ///
  /// Required API Key ACLs:
  ///   - browse
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [browseParams]  - one of types: [SearchParamsString], [BrowseParamsObject],
  /// * [requestOptions] additional request configuration.
  Future<BrowseResponse> browse({
    required String indexName,
    dynamic browseParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `browse`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/browse'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      isRead: true,
      body: browseParams?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<BrowseResponse, BrowseResponse>(
      response,
      'BrowseResponse',
      growable: true,
    );
  }

  /// Deletes only the records from an index while keeping settings, synonyms, and rules. This operation is resource-intensive and subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
  ///
  /// Required API Key ACLs:
  ///   - deleteIndex
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> clearObjects({
    required String indexName,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `clearObjects`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/clear'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Deletes all rules from the index.
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [forwardToReplicas] Whether changes are applied to replica indices.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> clearRules({
    required String indexName,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `clearRules`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/rules/clear'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Deletes all synonyms from the index.
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [forwardToReplicas] Whether changes are applied to replica indices.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> clearSynonyms({
    required String indexName,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `clearSynonyms`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/synonyms/clear'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// This method lets you send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, for example `1/newFeature`.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [requestOptions] additional request configuration.
  Future<Object> customDelete({
    required String path,
    Map<String, Object>? parameters,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `customDelete`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// This method lets you send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, for example `1/newFeature`.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [requestOptions] additional request configuration.
  Future<Object> customGet({
    required String path,
    Map<String, Object>? parameters,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `customGet`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// This method lets you send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, for example `1/newFeature`.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [body] Parameters to send with the custom request.
  /// * [requestOptions] additional request configuration.
  Future<Object> customPost({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `customPost`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// This method lets you send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, for example `1/newFeature`.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [body] Parameters to send with the custom request.
  /// * [requestOptions] additional request configuration.
  Future<Object> customPut({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `customPut`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Deletes the API key.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [key] API key.
  /// * [requestOptions] additional request configuration.
  Future<DeleteApiKeyResponse> deleteApiKey({
    required String key,
    RequestOptions? requestOptions,
  }) async {
    assert(
      key.isNotEmpty,
      'Parameter `key` is required when calling `deleteApiKey`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/keys/{key}'
          .replaceAll('{' r'key' '}', Uri.encodeComponent(key.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeleteApiKeyResponse, DeleteApiKeyResponse>(
      response,
      'DeleteApiKeyResponse',
      growable: true,
    );
  }

  /// This operation doesn't accept empty filters.  This operation is resource-intensive. You should only use it if you can't get the object IDs of the records you want to delete. It's more efficient to get a list of object IDs with the [`browse` operation](https://www.algolia.com/doc/rest-api/search/browse), and then delete the records using the [`batch` operation](https://www.algolia.com/doc/rest-api/search/batch).  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
  ///
  /// Required API Key ACLs:
  ///   - deleteIndex
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [deleteByParams]
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> deleteBy({
    required String indexName,
    required DeleteByParams deleteByParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteBy`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/deleteByQuery'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      body: deleteByParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Deletes an index and all its settings.  - Deleting an index doesn't delete its analytics data. - If you try to delete a non-existing index, the operation is ignored without warning. - If the index you want to delete has replica indices, the replicas become independent indices. - If the index you want to delete is a replica index, you must first unlink it from its primary index before you can delete it.   For more information, see [Delete replica indices](https://www.algolia.com/doc/guides/managing-results/refine-results/sorting/how-to/deleting-replicas).
  ///
  /// Required API Key ACLs:
  ///   - deleteIndex
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [requestOptions] additional request configuration.
  Future<DeletedAtResponse> deleteIndex({
    required String indexName,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteIndex`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/indexes/{indexName}'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeletedAtResponse, DeletedAtResponse>(
      response,
      'DeletedAtResponse',
      growable: true,
    );
  }

  /// Deletes a record by its object ID.  To delete more than one record, use the [`batch` operation](https://www.algolia.com/doc/rest-api/search/batch). To delete records matching a query, use the [`deleteBy` operation](https://www.algolia.com/doc/rest-api/search/delete-by).
  ///
  /// Required API Key ACLs:
  ///   - deleteObject
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [objectID] Unique record identifier.
  /// * [requestOptions] additional request configuration.
  Future<DeletedAtResponse> deleteObject({
    required String indexName,
    required String objectID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteObject`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `deleteObject`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/indexes/{indexName}/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeletedAtResponse, DeletedAtResponse>(
      response,
      'DeletedAtResponse',
      growable: true,
    );
  }

  /// Deletes a rule by its ID. To find the object ID for rules, use the [`search` operation](https://www.algolia.com/doc/rest-api/search/search-rules).
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [objectID] Unique identifier of a rule object.
  /// * [forwardToReplicas] Whether changes are applied to replica indices.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> deleteRule({
    required String indexName,
    required String objectID,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteRule`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `deleteRule`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/indexes/{indexName}/rules/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Deletes a source from the list of allowed sources.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [source] IP address range of the source.
  /// * [requestOptions] additional request configuration.
  Future<DeleteSourceResponse> deleteSource({
    required String source,
    RequestOptions? requestOptions,
  }) async {
    assert(
      source.isNotEmpty,
      'Parameter `source` is required when calling `deleteSource`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/security/sources/{source}'.replaceAll(
          '{' r'source' '}', Uri.encodeComponent(source.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeleteSourceResponse, DeleteSourceResponse>(
      response,
      'DeleteSourceResponse',
      growable: true,
    );
  }

  /// Deletes a synonym by its ID. To find the object IDs of your synonyms, use the [`search` operation](https://www.algolia.com/doc/rest-api/search/search-synonyms).
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [objectID] Unique identifier of a synonym object.
  /// * [forwardToReplicas] Whether changes are applied to replica indices.
  /// * [requestOptions] additional request configuration.
  Future<DeletedAtResponse> deleteSynonym({
    required String indexName,
    required String objectID,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `deleteSynonym`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `deleteSynonym`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/indexes/{indexName}/synonyms/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<DeletedAtResponse, DeletedAtResponse>(
      response,
      'DeletedAtResponse',
      growable: true,
    );
  }

  /// Gets the permissions and restrictions of an API key.  When authenticating with the admin API key, you can request information for any of your application's keys. When authenticating with other API keys, you can only retrieve information for that key, with the description replaced by `<redacted>`.
  ///
  /// Required API Key ACLs:
  ///   - search
  ///
  /// Parameters:
  /// * [key] API key.
  /// * [requestOptions] additional request configuration.
  Future<GetApiKeyResponse> getApiKey({
    required String key,
    RequestOptions? requestOptions,
  }) async {
    assert(
      key.isNotEmpty,
      'Parameter `key` is required when calling `getApiKey`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/keys/{key}'
          .replaceAll('{' r'key' '}', Uri.encodeComponent(key.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetApiKeyResponse, GetApiKeyResponse>(
      response,
      'GetApiKeyResponse',
      growable: true,
    );
  }

  /// Checks the status of a given application task.
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [taskID] Unique task identifier.
  /// * [requestOptions] additional request configuration.
  Future<GetTaskResponse> getAppTask({
    required int taskID,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/task/{taskID}'.replaceAll(
          '{' r'taskID' '}', Uri.encodeComponent(taskID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetTaskResponse, GetTaskResponse>(
      response,
      'GetTaskResponse',
      growable: true,
    );
  }

  /// Lists supported languages with their supported dictionary types and number of custom entries.
  ///
  /// Required API Key ACLs:
  ///   - settings
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<Map<String, Languages>> getDictionaryLanguages({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/dictionaries/*/languages',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Map<String, Languages>, Languages>(
      response,
      'Map<String, Languages>',
      growable: true,
    );
  }

  /// Retrieves the languages for which standard dictionary entries are turned off.
  ///
  /// Required API Key ACLs:
  ///   - settings
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<GetDictionarySettingsResponse> getDictionarySettings({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/dictionaries/*/settings',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetDictionarySettingsResponse,
        GetDictionarySettingsResponse>(
      response,
      'GetDictionarySettingsResponse',
      growable: true,
    );
  }

  /// The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl).  - Logs are held for the last seven days. - Up to 1,000 API requests per server are logged. - This request counts towards your [operations quota](https://support.algolia.com/hc/articles/17245378392977-How-does-Algolia-count-records-and-operations) but doesn't appear in the logs itself.
  ///
  /// Required API Key ACLs:
  ///   - logs
  ///
  /// Parameters:
  /// * [offset] First log entry to retrieve. The most recent entries are listed first.
  /// * [length] Maximum number of entries to retrieve.
  /// * [indexName] Index for which to retrieve log entries. By default, log entries are retrieved for all indices.
  /// * [type] Type of log entries to retrieve. By default, all log entries are retrieved.
  /// * [requestOptions] additional request configuration.
  Future<GetLogsResponse> getLogs({
    int? offset,
    int? length,
    String? indexName,
    LogType? type,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/logs',
      queryParams: {
        if (offset != null) 'offset': offset,
        if (length != null) 'length': length,
        if (indexName != null) 'indexName': indexName,
        if (type != null) 'type': type,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetLogsResponse, GetLogsResponse>(
      response,
      'GetLogsResponse',
      growable: true,
    );
  }

  /// Retrieves one record by its object ID.  To retrieve more than one record, use the [`objects` operation](https://www.algolia.com/doc/rest-api/search/get-objects).
  ///
  /// Required API Key ACLs:
  ///   - search
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [objectID] Unique record identifier.
  /// * [attributesToRetrieve] Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned.  `objectID` is always retrieved.  Attributes included in `unretrievableAttributes` won't be retrieved unless the request is authenticated with the admin API key.
  /// * [requestOptions] additional request configuration.
  Future<Object> getObject({
    required String indexName,
    required String objectID,
    List<String>? attributesToRetrieve,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getObject`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `getObject`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (attributesToRetrieve != null)
          'attributesToRetrieve': attributesToRetrieve,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Retrieves one or more records, potentially from different indices.  Records are returned in the same order as the requests.
  ///
  /// Required API Key ACLs:
  ///   - search
  ///
  /// Parameters:
  /// * [getObjectsParams] Request object.
  /// * [requestOptions] additional request configuration.
  Future<GetObjectsResponse> getObjects({
    required GetObjectsParams getObjectsParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/*/objects',
      isRead: true,
      body: getObjectsParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetObjectsResponse, GetObjectsResponse>(
      response,
      'GetObjectsResponse',
      growable: true,
    );
  }

  /// Retrieves a rule by its ID. To find the object ID of rules, use the [`search` operation](https://www.algolia.com/doc/rest-api/search/search-rules).
  ///
  /// Required API Key ACLs:
  ///   - settings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [objectID] Unique identifier of a rule object.
  /// * [requestOptions] additional request configuration.
  Future<Rule> getRule({
    required String indexName,
    required String objectID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getRule`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `getRule`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/rules/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Rule, Rule>(
      response,
      'Rule',
      growable: true,
    );
  }

  /// Retrieves an object with non-null index settings.
  ///
  /// Required API Key ACLs:
  ///   - settings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [getVersion] When set to 2, the endpoint will not include `synonyms` in the response. This parameter is here for backward compatibility.
  /// * [requestOptions] additional request configuration.
  Future<SettingsResponse> getSettings({
    required String indexName,
    int? getVersion,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getSettings`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/settings'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      queryParams: {
        if (getVersion != null) 'getVersion': getVersion,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SettingsResponse, SettingsResponse>(
      response,
      'SettingsResponse',
      growable: true,
    );
  }

  /// Retrieves all allowed IP addresses with access to your application.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<List<Source>> getSources({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/security/sources',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<List<Source>, Source>(
      response,
      'List<Source>',
      growable: true,
    );
  }

  /// Retrieves a synonym by its ID. To find the object IDs for your synonyms, use the [`search` operation](https://www.algolia.com/doc/rest-api/search/search-synonyms).
  ///
  /// Required API Key ACLs:
  ///   - settings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [objectID] Unique identifier of a synonym object.
  /// * [requestOptions] additional request configuration.
  Future<SynonymHit> getSynonym({
    required String indexName,
    required String objectID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getSynonym`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `getSynonym`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/synonyms/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SynonymHit, SynonymHit>(
      response,
      'SynonymHit',
      growable: true,
    );
  }

  /// Checks the status of a given task.  Indexing tasks are asynchronous. When you add, update, or delete records or indices, a task is created on a queue and completed depending on the load on the server.  The indexing tasks' responses include a task ID that you can use to check the status.
  ///
  /// Required API Key ACLs:
  ///   - addObject
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [taskID] Unique task identifier.
  /// * [requestOptions] additional request configuration.
  Future<GetTaskResponse> getTask({
    required String indexName,
    required int taskID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `getTask`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes/{indexName}/task/{taskID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'taskID' '}', Uri.encodeComponent(taskID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetTaskResponse, GetTaskResponse>(
      response,
      'GetTaskResponse',
      growable: true,
    );
  }

  /// Get the IDs of the 10 users with the highest number of records per cluster.  Since it can take a few seconds to get the data from the different clusters, the response isn't real-time.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  @Deprecated('This operation has been deprecated')
  Future<GetTopUserIdsResponse> getTopUserIds({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/clusters/mapping/top',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<GetTopUserIdsResponse, GetTopUserIdsResponse>(
      response,
      'GetTopUserIdsResponse',
      growable: true,
    );
  }

  /// Returns the user ID data stored in the mapping.  Since it can take a few seconds to get the data from the different clusters, the response isn't real-time.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [userID] Unique identifier of the user who makes the search request.
  /// * [requestOptions] additional request configuration.
  @Deprecated('This operation has been deprecated')
  Future<UserId> getUserId({
    required String userID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      userID.isNotEmpty,
      'Parameter `userID` is required when calling `getUserId`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/clusters/mapping/{userID}'.replaceAll(
          '{' r'userID' '}', Uri.encodeComponent(userID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UserId, UserId>(
      response,
      'UserId',
      growable: true,
    );
  }

  /// To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [getClusters] Whether to include the cluster's pending mapping state in the response.
  /// * [requestOptions] additional request configuration.
  @Deprecated('This operation has been deprecated')
  Future<HasPendingMappingsResponse> hasPendingMappings({
    bool? getClusters,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/clusters/mapping/pending',
      queryParams: {
        if (getClusters != null) 'getClusters': getClusters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<HasPendingMappingsResponse, HasPendingMappingsResponse>(
      response,
      'HasPendingMappingsResponse',
      growable: true,
    );
  }

  /// Lists all API keys associated with your Algolia application, including their permissions and restrictions.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  Future<ListApiKeysResponse> listApiKeys({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/keys',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListApiKeysResponse, ListApiKeysResponse>(
      response,
      'ListApiKeysResponse',
      growable: true,
    );
  }

  /// Lists the available clusters in a multi-cluster setup.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [requestOptions] additional request configuration.
  @Deprecated('This operation has been deprecated')
  Future<ListClustersResponse> listClusters({
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/clusters',
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListClustersResponse, ListClustersResponse>(
      response,
      'ListClustersResponse',
      growable: true,
    );
  }

  /// Lists all indices in the current Algolia application.  The request follows any index restrictions of the API key you use to make the request.
  ///
  /// Required API Key ACLs:
  ///   - listIndexes
  ///
  /// Parameters:
  /// * [page] Requested page of the API response. If `null`, the API response is not paginated.
  /// * [hitsPerPage] Number of hits per page.
  /// * [requestOptions] additional request configuration.
  Future<ListIndicesResponse> listIndices({
    int? page,
    int? hitsPerPage,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/indexes',
      queryParams: {
        if (page != null) 'page': page,
        if (hitsPerPage != null) 'hitsPerPage': hitsPerPage,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListIndicesResponse, ListIndicesResponse>(
      response,
      'ListIndicesResponse',
      growable: true,
    );
  }

  /// Lists the userIDs assigned to a multi-cluster application.  Since it can take a few seconds to get the data from the different clusters, the response isn't real-time.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [page] Requested page of the API response. If `null`, the API response is not paginated.
  /// * [hitsPerPage] Number of hits per page.
  /// * [requestOptions] additional request configuration.
  @Deprecated('This operation has been deprecated')
  Future<ListUserIdsResponse> listUserIds({
    int? page,
    int? hitsPerPage,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/1/clusters/mapping',
      queryParams: {
        if (page != null) 'page': page,
        if (hitsPerPage != null) 'hitsPerPage': hitsPerPage,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListUserIdsResponse, ListUserIdsResponse>(
      response,
      'ListUserIdsResponse',
      growable: true,
    );
  }

  /// Adds, updates, or deletes records in multiple indices with a single API request.  - Actions are applied in the order they are specified. - Actions are equivalent to the individual API requests of the same name.  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
  ///
  /// Required API Key ACLs:
  ///   - addObject
  ///
  /// Parameters:
  /// * [batchParams]
  /// * [requestOptions] additional request configuration.
  Future<MultipleBatchResponse> multipleBatch({
    required BatchParams batchParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/*/batch',
      body: batchParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<MultipleBatchResponse, MultipleBatchResponse>(
      response,
      'MultipleBatchResponse',
      growable: true,
    );
  }

  /// Copies or moves (renames) an index within the same Algolia application.  - Existing destination indices are overwritten, except for their analytics data. - If the destination index doesn't exist yet, it'll be created. - This operation is resource-intensive.  **Copy**  - Copying a source index that doesn't exist creates a new index with 0 records and default settings. - The API keys of the source index are merged with the existing keys in the destination index. - You can't copy the `enableReRanking`, `mode`, and `replicas` settings. - You can't copy to a destination index that already has replicas. - Be aware of the [size limits](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits). - Related guide: [Copy indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/copy-indices)  **Move**  - Moving a source index that doesn't exist is ignored without returning an error. - When moving an index, the analytics data keeps its original name, and a new set of analytics data is started for the new name.   To access the original analytics in the dashboard, create an index with the original name. - If the destination index has replicas, moving will overwrite the existing index and copy the data to the replica indices. - Related guide: [Move indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/move-indices).  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
  ///
  /// Required API Key ACLs:
  ///   - addObject
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [operationIndexParams]
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> operationIndex({
    required String indexName,
    required OperationIndexParams operationIndexParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `operationIndex`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/operation'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      body: operationIndexParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Adds new attributes to a record, or updates existing ones.  - If a record with the specified object ID doesn't exist,   a new record is added to the index **if** `createIfNotExists` is true. - If the index doesn't exist yet, this method creates a new index. - You can use any first-level attribute but not nested attributes.   If you specify a nested attribute, this operation replaces its first-level ancestor.  To update an attribute without pushing the entire record, you can use these built-in operations. These operations can be helpful if you don't have access to your initial data.  - Increment: increment a numeric attribute - Decrement: decrement a numeric attribute - Add: append a number or string element to an array attribute - Remove: remove all matching number or string elements from an array attribute made of numbers or strings - AddUnique: add a number or string element to an array attribute made of numbers or strings only if it's not already present - IncrementFrom: increment a numeric integer attribute only if the provided value matches the current value, and otherwise ignore the whole object update. For example, if you pass an IncrementFrom value of 2 for the version attribute, but the current value of the attribute is 1, the engine ignores the update. If the object doesn't exist, the engine only creates it if you pass an IncrementFrom value of 0. - IncrementSet: increment a numeric integer attribute only if the provided value is greater than the current value, and otherwise ignore the whole object update. For example, if you pass an IncrementSet value of 2 for the version attribute, and the current value of the attribute is 1, the engine updates the object. If the object doesn't exist yet, the engine only creates it if you pass an IncrementSet value greater than 0.  You can specify an operation by providing an object with the attribute to update as the key and its value being an object with the following properties:  - _operation: the operation to apply on the attribute - value: the right-hand side argument to the operation, for example, increment or decrement step, value to add or remove.  When updating multiple attributes or using multiple operations targeting the same record, you should use a single partial update for faster processing.  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
  ///
  /// Required API Key ACLs:
  ///   - addObject
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [objectID] Unique record identifier.
  /// * [attributesToUpdate] Attributes with their values.
  /// * [createIfNotExists] Whether to create a new record if it doesn't exist.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtWithObjectIdResponse> partialUpdateObject({
    required String indexName,
    required String objectID,
    required Object attributesToUpdate,
    bool? createIfNotExists,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `partialUpdateObject`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `partialUpdateObject`.',
    );
    if (attributesToUpdate is Map) {
      assert(
        attributesToUpdate.isNotEmpty,
        'Parameter `attributesToUpdate` is required when calling `partialUpdateObject`.',
      );
    }
    if (attributesToUpdate is Map) {
      assert(
        attributesToUpdate.isNotEmpty,
        'Parameter `attributesToUpdate ` is required when calling `partialUpdateObject`.',
      );
    }
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/{objectID}/partial'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (createIfNotExists != null) 'createIfNotExists': createIfNotExists,
      },
      body: attributesToUpdate,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtWithObjectIdResponse,
        UpdatedAtWithObjectIdResponse>(
      response,
      'UpdatedAtWithObjectIdResponse',
      growable: true,
    );
  }

  /// Deletes a user ID and its associated data from the clusters.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [userID] Unique identifier of the user who makes the search request.
  /// * [requestOptions] additional request configuration.
  @Deprecated('This operation has been deprecated')
  Future<RemoveUserIdResponse> removeUserId({
    required String userID,
    RequestOptions? requestOptions,
  }) async {
    assert(
      userID.isNotEmpty,
      'Parameter `userID` is required when calling `removeUserId`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/1/clusters/mapping/{userID}'.replaceAll(
          '{' r'userID' '}', Uri.encodeComponent(userID.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<RemoveUserIdResponse, RemoveUserIdResponse>(
      response,
      'RemoveUserIdResponse',
      growable: true,
    );
  }

  /// Replaces the list of allowed sources.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [source] Allowed sources.
  /// * [requestOptions] additional request configuration.
  Future<ReplaceSourceResponse> replaceSources({
    required List<Source> source,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/security/sources',
      body: source,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ReplaceSourceResponse, ReplaceSourceResponse>(
      response,
      'ReplaceSourceResponse',
      growable: true,
    );
  }

  /// Restores a deleted API key.  Restoring resets the `validity` attribute to `0`.  Algolia stores up to 1,000 API keys per application. If you create more, the oldest API keys are deleted and can't be restored.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [key] API key.
  /// * [requestOptions] additional request configuration.
  Future<AddApiKeyResponse> restoreApiKey({
    required String key,
    RequestOptions? requestOptions,
  }) async {
    assert(
      key.isNotEmpty,
      'Parameter `key` is required when calling `restoreApiKey`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/keys/{key}/restore'
          .replaceAll('{' r'key' '}', Uri.encodeComponent(key.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<AddApiKeyResponse, AddApiKeyResponse>(
      response,
      'AddApiKeyResponse',
      growable: true,
    );
  }

  /// Adds a record to an index or replaces it.  - If the record doesn't have an object ID, a new record with an auto-generated object ID is added to your index. - If a record with the specified object ID exists, the existing record is replaced. - If a record with the specified object ID doesn't exist, a new record is added to your index. - If you add a record to an index that doesn't exist yet, a new index is created.  To update _some_ attributes of a record, use the [`partial` operation](https://www.algolia.com/doc/rest-api/search/partial-update-object). To add, update, or replace multiple records, use the [`batch` operation](https://www.algolia.com/doc/rest-api/search/batch).  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
  ///
  /// Required API Key ACLs:
  ///   - addObject
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [body] The record. A schemaless object with attributes that are useful in the context of search and discovery.
  /// * [requestOptions] additional request configuration.
  Future<SaveObjectResponse> saveObject({
    required String indexName,
    required Object body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `saveObject`.',
    );
    if (body is Map) {
      assert(
        body.isNotEmpty,
        'Parameter `body` is required when calling `saveObject`.',
      );
    }
    if (body is Map) {
      assert(
        body.isNotEmpty,
        'Parameter `body ` is required when calling `saveObject`.',
      );
    }
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SaveObjectResponse, SaveObjectResponse>(
      response,
      'SaveObjectResponse',
      growable: true,
    );
  }

  /// If a rule with the specified object ID doesn't exist, it's created. Otherwise, the existing rule is replaced.  To create or update more than one rule, use the [`batch` operation](https://www.algolia.com/doc/rest-api/search/save-rules).
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [objectID] Unique identifier of a rule object.
  /// * [rule]
  /// * [forwardToReplicas] Whether changes are applied to replica indices.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> saveRule({
    required String indexName,
    required String objectID,
    required Rule rule,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `saveRule`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `saveRule`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/indexes/{indexName}/rules/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
      body: rule.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Create or update multiple rules.  If a rule with the specified object ID doesn't exist, Algolia creates a new one. Otherwise, existing rules are replaced.  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [rules]
  /// * [forwardToReplicas] Whether changes are applied to replica indices.
  /// * [clearExistingRules] Whether existing rules should be deleted before adding this batch.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> saveRules({
    required String indexName,
    required List<Rule> rules,
    bool? forwardToReplicas,
    bool? clearExistingRules,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `saveRules`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/rules/batch'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
        if (clearExistingRules != null)
          'clearExistingRules': clearExistingRules,
      },
      body: rules,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// If a synonym with the specified object ID doesn't exist, Algolia adds a new one. Otherwise, the existing synonym is replaced. To add multiple synonyms in a single API request, use the [`batch` operation](https://www.algolia.com/doc/rest-api/search/save-synonyms).
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [objectID] Unique identifier of a synonym object.
  /// * [synonymHit]
  /// * [forwardToReplicas] Whether changes are applied to replica indices.
  /// * [requestOptions] additional request configuration.
  Future<SaveSynonymResponse> saveSynonym({
    required String indexName,
    required String objectID,
    required SynonymHit synonymHit,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `saveSynonym`.',
    );
    assert(
      objectID.isNotEmpty,
      'Parameter `objectID` is required when calling `saveSynonym`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/indexes/{indexName}/synonyms/{objectID}'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'objectID' '}', Uri.encodeComponent(objectID.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
      body: synonymHit.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SaveSynonymResponse, SaveSynonymResponse>(
      response,
      'SaveSynonymResponse',
      growable: true,
    );
  }

  /// If a synonym with the `objectID` doesn't exist, Algolia adds a new one. Otherwise, existing synonyms are replaced.  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [synonymHit]
  /// * [forwardToReplicas] Whether changes are applied to replica indices.
  /// * [replaceExistingSynonyms] Whether to replace all synonyms in the index with the ones sent with this request.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> saveSynonyms({
    required String indexName,
    required List<SynonymHit> synonymHit,
    bool? forwardToReplicas,
    bool? replaceExistingSynonyms,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `saveSynonyms`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/synonyms/batch'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
        if (replaceExistingSynonyms != null)
          'replaceExistingSynonyms': replaceExistingSynonyms,
      },
      body: synonymHit,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Sends multiple search requests to one or more indices.  This can be useful in these cases:  - Different indices for different purposes, such as, one index for products, another one for marketing content. - Multiple searches to the same indexfor example, with different filters.  Use the helper `searchForHits` or `searchForFacets` to get the results in a more convenient format, if you already know the return type you want.
  ///
  /// Required API Key ACLs:
  ///   - search
  ///
  /// Parameters:
  /// * [searchMethodParams] Muli-search request body. Results are returned in the same order as the requests.
  /// * [requestOptions] additional request configuration.
  Future<SearchResponses> search({
    required SearchMethodParams searchMethodParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/*/queries',
      isRead: true,
      body: searchMethodParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchResponses, SearchResponses>(
      response,
      'SearchResponses',
      growable: true,
    );
  }

  /// Searches for standard and custom dictionary entries.
  ///
  /// Required API Key ACLs:
  ///   - settings
  ///
  /// Parameters:
  /// * [dictionaryName] Dictionary type in which to search.
  /// * [searchDictionaryEntriesParams]
  /// * [requestOptions] additional request configuration.
  Future<SearchDictionaryEntriesResponse> searchDictionaryEntries({
    required DictionaryType dictionaryName,
    required SearchDictionaryEntriesParams searchDictionaryEntriesParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/dictionaries/{dictionaryName}/search'.replaceAll(
          '{' r'dictionaryName' '}',
          Uri.encodeComponent(dictionaryName.toString())),
      isRead: true,
      body: searchDictionaryEntriesParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchDictionaryEntriesResponse,
        SearchDictionaryEntriesResponse>(
      response,
      'SearchDictionaryEntriesResponse',
      growable: true,
    );
  }

  /// Searches for values of a specified facet attribute.  - By default, facet values are sorted by decreasing count.   You can adjust this with the `sortFacetValueBy` parameter. - Searching for facet values doesn't work if you have **more than 65 searchable facets and searchable attributes combined**.
  ///
  /// Required API Key ACLs:
  ///   - search
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [facetName] Facet attribute in which to search for values.  This attribute must be included in the `attributesForFaceting` index setting with the `searchable()` modifier.
  /// * [searchForFacetValuesRequest]
  /// * [requestOptions] additional request configuration.
  Future<SearchForFacetValuesResponse> searchForFacetValues({
    required String indexName,
    required String facetName,
    SearchForFacetValuesRequest? searchForFacetValuesRequest,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `searchForFacetValues`.',
    );
    assert(
      facetName.isNotEmpty,
      'Parameter `facetName` is required when calling `searchForFacetValues`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/facets/{facetName}/query'
          .replaceAll(
              '{' r'indexName' '}', Uri.encodeComponent(indexName.toString()))
          .replaceAll(
              '{' r'facetName' '}', Uri.encodeComponent(facetName.toString())),
      isRead: true,
      body: searchForFacetValuesRequest?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchForFacetValuesResponse,
        SearchForFacetValuesResponse>(
      response,
      'SearchForFacetValuesResponse',
      growable: true,
    );
  }

  /// Searches for rules in your index.
  ///
  /// Required API Key ACLs:
  ///   - settings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [searchRulesParams]
  /// * [requestOptions] additional request configuration.
  Future<SearchRulesResponse> searchRules({
    required String indexName,
    SearchRulesParams? searchRulesParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `searchRules`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/rules/search'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      isRead: true,
      body: searchRulesParams?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchRulesResponse, SearchRulesResponse>(
      response,
      'SearchRulesResponse',
      growable: true,
    );
  }

  /// Searches a single index and returns matching search results as hits.  This method lets you retrieve up to 1,000 hits. If you need more, use the [`browse` operation](https://www.algolia.com/doc/rest-api/search/browse) or increase the `paginatedLimitedTo` index setting.
  ///
  /// Required API Key ACLs:
  ///   - search
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [searchParams]  - one of types: [SearchParamsString], [SearchParamsObject],
  /// * [requestOptions] additional request configuration.
  Future<SearchResponse> searchSingleIndex({
    required String indexName,
    dynamic searchParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `searchSingleIndex`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/query'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      isRead: true,
      body: searchParams?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchResponse, SearchResponse>(
      response,
      'SearchResponse',
      growable: true,
    );
  }

  /// Searches for synonyms in your index.
  ///
  /// Required API Key ACLs:
  ///   - settings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [searchSynonymsParams] Body of the `searchSynonyms` operation.
  /// * [requestOptions] additional request configuration.
  Future<SearchSynonymsResponse> searchSynonyms({
    required String indexName,
    SearchSynonymsParams? searchSynonymsParams,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `searchSynonyms`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/indexes/{indexName}/synonyms/search'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      isRead: true,
      body: searchSynonymsParams?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchSynonymsResponse, SearchSynonymsResponse>(
      response,
      'SearchSynonymsResponse',
      growable: true,
    );
  }

  /// Since it can take a few seconds to get the data from the different clusters, the response isn't real-time.  To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [searchUserIdsParams]
  /// * [requestOptions] additional request configuration.
  @Deprecated('This operation has been deprecated')
  Future<SearchUserIdsResponse> searchUserIds({
    required SearchUserIdsParams searchUserIdsParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/clusters/mapping/search',
      isRead: true,
      body: searchUserIdsParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchUserIdsResponse, SearchUserIdsResponse>(
      response,
      'SearchUserIdsResponse',
      growable: true,
    );
  }

  /// Turns standard stop word dictionary entries on or off for a given language.
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [dictionarySettingsParams]
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> setDictionarySettings({
    required DictionarySettingsParams dictionarySettingsParams,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/dictionaries/*/settings',
      body: dictionarySettingsParams.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Update the specified index settings.  Index settings that you don't specify are left unchanged. Specify `null` to reset a setting to its default value.  For best performance, update the index settings before you add new records to your index.
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [indexName] Name of the index on which to perform the operation.
  /// * [indexSettings]
  /// * [forwardToReplicas] Whether changes are applied to replica indices.
  /// * [requestOptions] additional request configuration.
  Future<UpdatedAtResponse> setSettings({
    required String indexName,
    required IndexSettings indexSettings,
    bool? forwardToReplicas,
    RequestOptions? requestOptions,
  }) async {
    assert(
      indexName.isNotEmpty,
      'Parameter `indexName` is required when calling `setSettings`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/indexes/{indexName}/settings'.replaceAll(
          '{' r'indexName' '}', Uri.encodeComponent(indexName.toString())),
      queryParams: {
        if (forwardToReplicas != null) 'forwardToReplicas': forwardToReplicas,
      },
      body: indexSettings.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdatedAtResponse, UpdatedAtResponse>(
      response,
      'UpdatedAtResponse',
      growable: true,
    );
  }

  /// Replaces the permissions of an existing API key.  Any unspecified attribute resets that attribute to its default value.
  ///
  /// Required API Key ACLs:
  ///   - admin
  ///
  /// Parameters:
  /// * [key] API key.
  /// * [apiKey]
  /// * [requestOptions] additional request configuration.
  Future<UpdateApiKeyResponse> updateApiKey({
    required String key,
    required ApiKey apiKey,
    RequestOptions? requestOptions,
  }) async {
    assert(
      key.isNotEmpty,
      'Parameter `key` is required when calling `updateApiKey`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/1/keys/{key}'
          .replaceAll('{' r'key' '}', Uri.encodeComponent(key.toString())),
      body: apiKey.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<UpdateApiKeyResponse, UpdateApiKeyResponse>(
      response,
      'UpdateApiKeyResponse',
      growable: true,
    );
  }

  @Deprecated('This operation has been deprecated, use `customPost` instead')
  Future<Object> post({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    return customPost(
        path: path, parameters: parameters, requestOptions: requestOptions);
  }

  @Deprecated('This operation has been deprecated, use `customPut` instead')
  Future<Object> put({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    return customPut(
        path: path, parameters: parameters, requestOptions: requestOptions);
  }

  @Deprecated('This operation has been deprecated, use `customGet` instead')
  Future<Object> get({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    return customGet(
        path: path, parameters: parameters, requestOptions: requestOptions);
  }

  @Deprecated('This operation has been deprecated, use `customDelete` instead')
  Future<Object> del({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    return customDelete(
        path: path, parameters: parameters, requestOptions: requestOptions);
  }

  @override
  void dispose() => _retryStrategy.dispose();
}
