// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import 'package:algolia_client_core/algolia_client_core.dart';
import 'package:algolia_client_abtesting_v3/src/deserialize.dart';
import 'package:algolia_client_abtesting_v3/src/version.dart';

import 'package:algolia_client_abtesting_v3/src/model/ab_test.dart';
import 'package:algolia_client_abtesting_v3/src/model/ab_test_response.dart';
import 'package:algolia_client_abtesting_v3/src/model/add_ab_tests_request.dart';
import 'package:algolia_client_abtesting_v3/src/model/direction.dart';
import 'package:algolia_client_abtesting_v3/src/model/estimate_ab_test_request.dart';
import 'package:algolia_client_abtesting_v3/src/model/estimate_ab_test_response.dart';
import 'package:algolia_client_abtesting_v3/src/model/list_ab_tests_response.dart';
import 'package:algolia_client_abtesting_v3/src/model/metric_name.dart';
import 'package:algolia_client_abtesting_v3/src/model/timeseries.dart';

final class AbtestingV3Client implements ApiClient {
  @override
  final ClientOptions options;

  final String? region;

  final RetryStrategy _retryStrategy;

  AbtestingV3Client({
    required String appId,
    required String apiKey,
    this.options = const ClientOptions(),
    this.region,
  }) : _retryStrategy = RetryStrategy.create(
            segment:
                AgentSegment(value: "AbtestingV3", version: packageVersion),
            appId: appId,
            apiKey: apiKey,
            options: options,
            defaultHosts: () {
              final allowedRegions = ['de', 'us'];
              assert(
                region == null || allowedRegions.contains(region),
                '`region` must be one of the following: ${allowedRegions.join(', ')}',
              );
              final url = region == null
                  ? 'analytics.algolia.com'
                  : 'analytics.{region}.algolia.com'
                      .replaceAll('{region}', region);
              return [Host(url: url)];
            }) {
    assert(appId.isNotEmpty, '`appId` is missing.');
    assert(apiKey.isNotEmpty, '`apiKey` is missing.');
  }

  /// Allows to switch the API key used to authenticate requests.
  @override
  void setClientApiKey({required String apiKey}) {
    _retryStrategy.requester.setClientApiKey(apiKey);
  }

  /// Creates a new A/B test.
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [addABTestsRequest]
  /// * [requestOptions] additional request configuration.
  Future<ABTestResponse> addABTests({
    required AddABTestsRequest addABTestsRequest,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/3/abtests',
      body: addABTestsRequest.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ABTestResponse, ABTestResponse>(
      response,
      'ABTestResponse',
      growable: true,
    );
  }

  /// This method lets you send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, for example `1/newFeature`.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [requestOptions] additional request configuration.
  Future<Object> customDelete({
    required String path,
    Map<String, Object>? parameters,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `customDelete`.',
    );
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// This method lets you send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, for example `1/newFeature`.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [requestOptions] additional request configuration.
  Future<Object> customGet({
    required String path,
    Map<String, Object>? parameters,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `customGet`.',
    );
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// This method lets you send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, for example `1/newFeature`.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [body] Parameters to send with the custom request.
  /// * [requestOptions] additional request configuration.
  Future<Object> customPost({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `customPost`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// This method lets you send requests to the Algolia REST API.
  ///
  /// Parameters:
  /// * [path] Path of the endpoint, for example `1/newFeature`.
  /// * [parameters] Query parameters to apply to the current query.
  /// * [body] Parameters to send with the custom request.
  /// * [requestOptions] additional request configuration.
  Future<Object> customPut({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    assert(
      path.isNotEmpty,
      'Parameter `path` is required when calling `customPut`.',
    );
    final request = ApiRequest(
      method: RequestMethod.put,
      path: r'/{path}'.replaceAll('{' r'path' '}', path),
      queryParams: {
        ...?parameters,
      },
      body: body,
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Object, Object>(
      response,
      'Object',
      growable: true,
    );
  }

  /// Deletes an A/B test by its ID.
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [id] Unique A/B test identifier.
  /// * [requestOptions] additional request configuration.
  Future<ABTestResponse> deleteABTest({
    required int id,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.delete,
      path: r'/3/abtests/{id}'
          .replaceAll('{' r'id' '}', Uri.encodeComponent(id.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ABTestResponse, ABTestResponse>(
      response,
      'ABTestResponse',
      growable: true,
    );
  }

  /// Given the traffic percentage and the expected effect size, this endpoint estimates the sample size and duration of an A/B test based on historical traffic.
  ///
  /// Required API Key ACLs:
  ///   - analytics
  ///
  /// Parameters:
  /// * [estimateABTestRequest]
  /// * [requestOptions] additional request configuration.
  Future<EstimateABTestResponse> estimateABTest({
    required EstimateABTestRequest estimateABTestRequest,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/3/abtests/estimate',
      body: estimateABTestRequest.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<EstimateABTestResponse, EstimateABTestResponse>(
      response,
      'EstimateABTestResponse',
      growable: true,
    );
  }

  /// Retrieves the details for an A/B test by its ID.
  ///
  /// Required API Key ACLs:
  ///   - analytics
  ///
  /// Parameters:
  /// * [id] Unique A/B test identifier.
  /// * [requestOptions] additional request configuration.
  Future<ABTest> getABTest({
    required int id,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/3/abtests/{id}'
          .replaceAll('{' r'id' '}', Uri.encodeComponent(id.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ABTest, ABTest>(
      response,
      'ABTest',
      growable: true,
    );
  }

  /// Retrieves timeseries for an A/B test by its ID.
  ///
  /// Required API Key ACLs:
  ///   - analytics
  ///
  /// Parameters:
  /// * [id] Unique A/B test identifier.
  /// * [startDate] Start date of the period to analyze, in `YYYY-MM-DD` format.
  /// * [endDate] End date of the period to analyze, in `YYYY-MM-DD` format.
  /// * [metric] List of metrics to retrieve. If not specified, all metrics are returned.
  /// * [requestOptions] additional request configuration.
  Future<Timeseries> getTimeseries({
    required int id,
    String? startDate,
    String? endDate,
    List<MetricName>? metric,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/3/abtests/{id}/timeseries'
          .replaceAll('{' r'id' '}', Uri.encodeComponent(id.toString())),
      queryParams: {
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        if (metric != null) 'metric': metric,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<Timeseries, Timeseries>(
      response,
      'Timeseries',
      growable: true,
    );
  }

  /// Lists all A/B tests you configured for this application.
  ///
  /// Required API Key ACLs:
  ///   - analytics
  ///
  /// Parameters:
  /// * [offset] Position of the first item to return.
  /// * [limit] Number of items to return.
  /// * [indexPrefix] Index name prefix. Only A/B tests for indices starting with this string are included in the response.
  /// * [indexSuffix] Index name suffix. Only A/B tests for indices ending with this string are included in the response.
  /// * [direction] Sort order for A/B tests by start date. Use 'asc' for ascending or 'desc' for descending. Active A/B tests are always listed first.
  /// * [requestOptions] additional request configuration.
  Future<ListABTestsResponse> listABTests({
    int? offset,
    int? limit,
    String? indexPrefix,
    String? indexSuffix,
    Direction? direction,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.get,
      path: r'/3/abtests',
      queryParams: {
        if (offset != null) 'offset': offset,
        if (limit != null) 'limit': limit,
        if (indexPrefix != null) 'indexPrefix': indexPrefix,
        if (indexSuffix != null) 'indexSuffix': indexSuffix,
        if (direction != null) 'direction': direction,
      },
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ListABTestsResponse, ListABTestsResponse>(
      response,
      'ListABTestsResponse',
      growable: true,
    );
  }

  /// Stops an A/B test by its ID.  You can't restart stopped A/B tests.
  ///
  /// Required API Key ACLs:
  ///   - editSettings
  ///
  /// Parameters:
  /// * [id] Unique A/B test identifier.
  /// * [requestOptions] additional request configuration.
  Future<ABTestResponse> stopABTest({
    required int id,
    RequestOptions? requestOptions,
  }) async {
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/3/abtests/{id}/stop'
          .replaceAll('{' r'id' '}', Uri.encodeComponent(id.toString())),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<ABTestResponse, ABTestResponse>(
      response,
      'ABTestResponse',
      growable: true,
    );
  }

  @Deprecated('This operation has been deprecated, use `customPost` instead')
  Future<Object> post({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    return customPost(
        path: path, parameters: parameters, requestOptions: requestOptions);
  }

  @Deprecated('This operation has been deprecated, use `customPut` instead')
  Future<Object> put({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    return customPut(
        path: path, parameters: parameters, requestOptions: requestOptions);
  }

  @Deprecated('This operation has been deprecated, use `customGet` instead')
  Future<Object> get({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    return customGet(
        path: path, parameters: parameters, requestOptions: requestOptions);
  }

  @Deprecated('This operation has been deprecated, use `customDelete` instead')
  Future<Object> del({
    required String path,
    Map<String, Object>? parameters,
    Object? body,
    RequestOptions? requestOptions,
  }) async {
    return customDelete(
        path: path, parameters: parameters, requestOptions: requestOptions);
  }

  @override
  void dispose() => _retryStrategy.dispose();
}
