// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import 'package:algolia_client_core/algolia_client_core.dart';
import 'package:algolia_client_composition/src/deserialize.dart';
import 'package:algolia_client_composition/src/version.dart';

import 'package:algolia_client_composition/src/model/request_body.dart';
import 'package:algolia_client_composition/src/model/search_for_facet_values_request.dart';
import 'package:algolia_client_composition/src/model/search_for_facet_values_response.dart';
import 'package:algolia_client_composition/src/model/search_response.dart';

final class CompositionClient implements ApiClient {
  @override
  final ClientOptions options;

  final RetryStrategy _retryStrategy;

  CompositionClient({
    required String appId,
    required String apiKey,
    this.options = const ClientOptions(),
  }) : _retryStrategy = RetryStrategy.create(
          segment: AgentSegment(value: "Composition", version: packageVersion),
          appId: appId,
          apiKey: apiKey,
          options: options,
          defaultHosts: () =>
              [
                Host(url: '$appId-dsn.algolia.net', callType: CallType.read),
                Host(url: '$appId.algolia.net', callType: CallType.write),
              ] +
              ([
                Host(url: '$appId-1.algolianet.com'),
                Host(url: '$appId-2.algolianet.com'),
                Host(url: '$appId-3.algolianet.com'),
              ]..shuffle()),
        ) {
    assert(appId.isNotEmpty, '`appId` is missing.');
    assert(apiKey.isNotEmpty, '`apiKey` is missing.');
  }

  /// Allows to switch the API key used to authenticate requests.
  @override
  void setClientApiKey({required String apiKey}) {
    _retryStrategy.requester.setClientApiKey(apiKey);
  }

  /// Runs a query on a single composition and returns matching results.
  ///
  /// Required API Key ACLs:
  ///   - search
  ///
  /// Parameters:
  /// * [compositionID] Unique Composition ObjectID.
  /// * [requestBody]
  /// * [requestOptions] additional request configuration.
  Future<SearchResponse> search({
    required String compositionID,
    required RequestBody requestBody,
    RequestOptions? requestOptions,
  }) async {
    assert(
      compositionID.isNotEmpty,
      'Parameter `compositionID` is required when calling `search`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/compositions/{compositionID}/run'.replaceAll(
          '{' r'compositionID' '}',
          Uri.encodeComponent(compositionID.toString())),
      isRead: true,
      body: requestBody.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchResponse, SearchResponse>(
      response,
      'SearchResponse',
      growable: true,
    );
  }

  /// Searches for values of a specified facet attribute on the composition's main source's index.  - By default, facet values are sorted by decreasing count.   You can adjust this with the `sortFacetValueBy` parameter. - Searching for facet values doesn't work if you have **more than 65 searchable facets and searchable attributes combined**.
  ///
  /// Required API Key ACLs:
  ///   - search
  ///
  /// Parameters:
  /// * [compositionID] Unique Composition ObjectID.
  /// * [facetName] Facet attribute in which to search for values.  This attribute must be included in the `attributesForFaceting` index setting with the `searchable()` modifier.
  /// * [searchForFacetValuesRequest]
  /// * [requestOptions] additional request configuration.
  Future<SearchForFacetValuesResponse> searchForFacetValues({
    required String compositionID,
    required String facetName,
    SearchForFacetValuesRequest? searchForFacetValuesRequest,
    RequestOptions? requestOptions,
  }) async {
    assert(
      compositionID.isNotEmpty,
      'Parameter `compositionID` is required when calling `searchForFacetValues`.',
    );
    assert(
      facetName.isNotEmpty,
      'Parameter `facetName` is required when calling `searchForFacetValues`.',
    );
    final request = ApiRequest(
      method: RequestMethod.post,
      path: r'/1/compositions/{compositionID}/facets/{facetName}/query'
          .replaceAll('{' r'compositionID' '}',
              Uri.encodeComponent(compositionID.toString()))
          .replaceAll(
              '{' r'facetName' '}', Uri.encodeComponent(facetName.toString())),
      isRead: true,
      body: searchForFacetValuesRequest?.toJson(),
    );
    final response = await _retryStrategy.execute(
      request: request,
      options: requestOptions,
    );
    return deserialize<SearchForFacetValuesResponse,
        SearchForFacetValuesResponse>(
      response,
      'SearchForFacetValuesResponse',
      growable: true,
    );
  }

  @override
  void dispose() => _retryStrategy.dispose();
}
