// The Recommend API lets you retrieve recommendations from one of Algolia's AI recommendation models that you previously trained on your data.
//
// ## Client libraries
//
// Use Algolia's API clients and libraries to reliably integrate Algolia's APIs with your apps.
// The official API clients are covered by Algolia's [Service Level Agreement](https://www.algolia.com/policies/sla).
//
// See: [Algolia's ecosystem](https://www.algolia.com/doc/guides/getting-started/how-algolia-works/in-depth/ecosystem)
//
// ## Base URLs
//
// The base URLs for requests to the Recommend API are:
//
//   - `https://{APPLICATION_ID}.algolia.net`
//   - `https://{APPLICATION_ID}-dsn.algolia.net`.
//     If your subscription includes a [Distributed Search Network](https://dashboard.algolia.com/infra),
//     this ensures that requests are sent to servers closest to users.
//
// Both URLs provide high availability by distributing requests with load balancing.
//
// **All requests must use HTTPS.**
//
// ## Retry strategy
//
// To guarantee a high availability, implement a retry strategy for all API requests using the URLs of your servers as fallbacks:
//
// - `https://{APPLICATION_ID}-1.algolianet.com`
// - `https://{APPLICATION_ID}-2.algolianet.com`
// - `https://{APPLICATION_ID}-3.algolianet.com`
//
// These URLs use a different DNS provider than the primary URLs.
// You should randomize this list to ensure an even load across the three servers.
//
// All Algolia API clients implement this retry strategy.
//
// ## Authentication
//
// To authenticate your API requests, add these headers:
//
//   - `x-algolia-application-id`. Your Algolia application ID.
//   - `x-algolia-api-key`. An API key with the necessary permissions to make the request.
//     The required access control list (ACL) to make a request is listed in each endpoint's reference.
//
// You can find your application ID and API key in the [Algolia dashboard](https://dashboard.algolia.com/account/api-keys).
//
// ## Request format
//
// Request bodies must be JSON objects.
//
// ## Response status and errors
//
// The Recommend API returns JSON responses.
// Since JSON doesn't guarantee any specific ordering, don't rely on the order of attributes in the API response.
//
// Successful responses return a `2xx` status. Client errors return a `4xx` status. Server errors are indicated by a `5xx` status.
// Error responses have a `message` property with more information.
//
// ## Version
//
// The current version of the Recommend API is version 1, as indicated by the `/1/` in each endpoint's URL.
package recommend

// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import (
	"context"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/transport"
	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type config struct {
	// -- Request options for API calls
	queryParams  url.Values
	headerParams map[string]string
	timeouts     transport.RequestConfiguration
}

type RequestOption interface {
	apply(*config)
}

type requestOption func(*config)

func (r requestOption) apply(c *config) {
	r(c)
}

func WithHeaderParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.headerParams[key] = utils.ParameterToString(value)
	})
}

func WithQueryParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.queryParams.Set(utils.QueryParameterToString(key), utils.QueryParameterToString(value))
	})
}

func WithReadTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ReadTimeout = &timeout
	})
}

func WithWriteTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.WriteTimeout = &timeout
	})
}

func WithConnectTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ConnectTimeout = &timeout
	})
}

// BatchRecommendRules Create or update a batch of Recommend Rules
//
// Each Recommend Rule is created or updated, depending on whether a Recommend Rule with the same `objectID` already exists.
// You may also specify `true` for `clearExistingRules`, in which case the batch will atomically replace all the existing Recommend Rules.
//
// Recommend Rules are similar to Search Rules, except that the conditions and consequences apply to a [source item](/doc/guides/algolia-recommend/overview/#recommend-models) instead of a query. The main differences are the following:
// - Conditions `pattern` and `anchoring` are unavailable.
// - Condition `filters` triggers if the source item matches the specified filters.
// - Condition `filters` accepts numeric filters.
// - Consequence `params` only covers filtering parameters.
// - Consequence `automaticFacetFilters` doesn't require a facet value placeholder (it tries to match the data source item's attributes instead).
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - model - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
//   - recommendRule
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) BatchRecommendRules(
	ctx context.Context,
	indexName string,
	model RecommendModels,
	recommendRule *[]RecommendRule,
	opts ...RequestOption,
) (*RecommendUpdatedAtResponse, error) {
	var returnValue *RecommendUpdatedAtResponse

	res, resBody, err := c.BatchRecommendRulesWithHTTPInfo(ctx, indexName, model, recommendRule, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// BatchRecommendRulesWithHTTPInfo calls the API and returns the raw response from it.
// Create or update a batch of Recommend Rules
//
// Each Recommend Rule is created or updated, depending on whether a Recommend Rule with the same `objectID` already exists.
// You may also specify `true` for `clearExistingRules`, in which case the batch will atomically replace all the existing Recommend Rules.
//
// Recommend Rules are similar to Search Rules, except that the conditions and consequences apply to a [source item](/doc/guides/algolia-recommend/overview/#recommend-models) instead of a query. The main differences are the following:
// - Conditions `pattern` and `anchoring` are unavailable.
// - Condition `filters` triggers if the source item matches the specified filters.
// - Condition `filters` accepts numeric filters.
// - Consequence `params` only covers filtering parameters.
// - Consequence `automaticFacetFilters` doesn't require a facet value placeholder (it tries to match the data source item's attributes instead).
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - model - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
//   - recommendRule
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) BatchRecommendRulesWithHTTPInfo(
	ctx context.Context,
	indexName string,
	model RecommendModels,
	recommendRule *[]RecommendRule,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/{model}/recommend/rules/batch"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{model}", url.PathEscape(utils.ParameterToString(model)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `BatchRecommendRules`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	var postBody any = "{}"
	if !utils.IsNilOrEmpty(recommendRule) {
		postBody = recommendRule
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomDelete This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomDelete(ctx context.Context, path string, parameters map[string]any, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomDeleteWithHTTPInfo(ctx, path, parameters, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomDeleteWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomDeleteWithHTTPInfo(
	ctx context.Context,
	path string,
	parameters map[string]any,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(parameters) {
		for k, v := range parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomGet This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomGet(ctx context.Context, path string, parameters map[string]any, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomGetWithHTTPInfo(ctx, path, parameters, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomGetWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomGetWithHTTPInfo(
	ctx context.Context,
	path string,
	parameters map[string]any,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(parameters) {
		for k, v := range parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomPostOptions represents the optional params for the API call.
type CustomPostOptions struct {
	Parameters map[string]any
	Body       map[string]any
}

// NewCustomPostOptions creates an instance of the CustomPostOptions used to add optional parameters to CustomPostWithOptions.
func NewCustomPostOptions() *CustomPostOptions {
	return &CustomPostOptions{}
}

// WithParameters Query parameters to apply to the current query.
func (o *CustomPostOptions) WithParameters(parameters map[string]any) *CustomPostOptions {
	o.Parameters = parameters

	return o
}

// WithBody Parameters to send with the custom request.
func (o *CustomPostOptions) WithBody(body map[string]any) *CustomPostOptions {
	o.Body = body

	return o
}

// CustomPost This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPost(ctx context.Context, path string, optionalParams *CustomPostOptions, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPostWithHTTPInfo(ctx, path, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomPostWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPostWithHTTPInfo(
	ctx context.Context,
	path string,
	optionalParams *CustomPostOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Parameters) {
		for k, v := range optionalParams.Parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	var postBody any = "{}"
	if optionalParams != nil {
		postBody = optionalParams.Body
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomPutOptions represents the optional params for the API call.
type CustomPutOptions struct {
	Parameters map[string]any
	Body       map[string]any
}

// NewCustomPutOptions creates an instance of the CustomPutOptions used to add optional parameters to CustomPutWithOptions.
func NewCustomPutOptions() *CustomPutOptions {
	return &CustomPutOptions{}
}

// WithParameters Query parameters to apply to the current query.
func (o *CustomPutOptions) WithParameters(parameters map[string]any) *CustomPutOptions {
	o.Parameters = parameters

	return o
}

// WithBody Parameters to send with the custom request.
func (o *CustomPutOptions) WithBody(body map[string]any) *CustomPutOptions {
	o.Body = body

	return o
}

// CustomPut This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPut(ctx context.Context, path string, optionalParams *CustomPutOptions, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPutWithHTTPInfo(ctx, path, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomPutWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPutWithHTTPInfo(
	ctx context.Context,
	path string,
	optionalParams *CustomPutOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Parameters) {
		for k, v := range optionalParams.Parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	var postBody any = "{}"
	if optionalParams != nil {
		postBody = optionalParams.Body
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteRecommendRule Deletes a Recommend rule from a recommendation scenario.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - model - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
//   - objectID - Unique record identifier.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteRecommendRule(
	ctx context.Context,
	indexName string,
	model RecommendModels,
	objectID string,
	opts ...RequestOption,
) (*DeletedAtResponse, error) {
	var returnValue *DeletedAtResponse

	res, resBody, err := c.DeleteRecommendRuleWithHTTPInfo(ctx, indexName, model, objectID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteRecommendRuleWithHTTPInfo calls the API and returns the raw response from it.
// Deletes a Recommend rule from a recommendation scenario.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - model - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
//   - objectID - Unique record identifier.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteRecommendRuleWithHTTPInfo(
	ctx context.Context,
	indexName string,
	model RecommendModels,
	objectID string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/{model}/recommend/rules/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{model}", url.PathEscape(utils.ParameterToString(model)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(objectID)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `DeleteRecommendRule`.")
	}

	if objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `DeleteRecommendRule`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetRecommendRule Retrieves a Recommend rule that you previously created in the Algolia dashboard.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - model - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
//   - objectID - Unique record identifier.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetRecommendRule(
	ctx context.Context,
	indexName string,
	model RecommendModels,
	objectID string,
	opts ...RequestOption,
) (*RecommendRule, error) {
	var returnValue *RecommendRule

	res, resBody, err := c.GetRecommendRuleWithHTTPInfo(ctx, indexName, model, objectID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetRecommendRuleWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a Recommend rule that you previously created in the Algolia dashboard.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - model - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
//   - objectID - Unique record identifier.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetRecommendRuleWithHTTPInfo(
	ctx context.Context,
	indexName string,
	model RecommendModels,
	objectID string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/{model}/recommend/rules/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{model}", url.PathEscape(utils.ParameterToString(model)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(objectID)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetRecommendRule`.")
	}

	if objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `GetRecommendRule`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetRecommendStatus Checks the status of a given task.
//
// Deleting a Recommend rule is asynchronous.
// When you delete a rule, a task is created on a queue and completed depending on the load on the server.
// The API response includes a task ID that you can use to check the status.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - model - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
//   - taskID - Unique task identifier.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetRecommendStatus(
	ctx context.Context,
	indexName string,
	model RecommendModels,
	taskID int64,
	opts ...RequestOption,
) (*GetRecommendTaskResponse, error) {
	var returnValue *GetRecommendTaskResponse

	res, resBody, err := c.GetRecommendStatusWithHTTPInfo(ctx, indexName, model, taskID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetRecommendStatusWithHTTPInfo calls the API and returns the raw response from it.
// Checks the status of a given task.
//
// Deleting a Recommend rule is asynchronous.
// When you delete a rule, a task is created on a queue and completed depending on the load on the server.
// The API response includes a task ID that you can use to check the status.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - model - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
//   - taskID - Unique task identifier.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetRecommendStatusWithHTTPInfo(
	ctx context.Context,
	indexName string,
	model RecommendModels,
	taskID int64,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/{model}/task/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{model}", url.PathEscape(utils.ParameterToString(model)))
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetRecommendStatus`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetRecommendations Retrieves recommendations from selected AI models.
//
// Required API Key ACLs:
//   - search
//
// Parameters:
//   - requests - Recommendation request with parameters depending on the requested model.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetRecommendations(
	ctx context.Context,
	requests []RecommendationsRequest,
	opts ...RequestOption,
) (*GetRecommendationsResponse, error) {
	var returnValue *GetRecommendationsResponse

	res, resBody, err := c.GetRecommendationsWithHTTPInfo(ctx, requests, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetRecommendationsWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves recommendations from selected AI models.
//
// Required API Key ACLs:
//   - search
//
// Parameters:
//   - requests - Recommendation request with parameters depending on the requested model.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetRecommendationsWithHTTPInfo(
	ctx context.Context,
	requests []RecommendationsRequest,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/*/recommendations"

	if len(requests) == 0 {
		return nil, nil, reportError("Parameter `requests` is required when calling `GetRecommendations`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Requests []RecommendationsRequest `json:"requests"`
	}{
		Requests: requests,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}

// SearchRecommendRulesOptions represents the optional params for the API call.
type SearchRecommendRulesOptions struct {
	Query             *string
	Context           *string
	Page              *int
	HitsPerPage       *int
	Enabled           *bool
	Filters           *string
	Facets            *[]string
	MaxValuesPerFacet *int
}

// NewSearchRecommendRulesOptions creates an instance of the SearchRecommendRulesOptions used to add optional parameters to SearchRecommendRulesWithOptions.
func NewSearchRecommendRulesOptions() *SearchRecommendRulesOptions {
	return &SearchRecommendRulesOptions{}
}

// WithQuery Search query.
func (o *SearchRecommendRulesOptions) WithQuery(query string) *SearchRecommendRulesOptions {
	o.Query = &query

	return o
}

// WithContext Only search for rules with matching context.
func (o *SearchRecommendRulesOptions) WithContext(context string) *SearchRecommendRulesOptions {
	o.Context = &context

	return o
}

// WithPage Requested page of the API response.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.
func (o *SearchRecommendRulesOptions) WithPage(page int) *SearchRecommendRulesOptions {
	o.Page = &page

	return o
}

// WithHitsPerPage Maximum number of hits per page.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.
func (o *SearchRecommendRulesOptions) WithHitsPerPage(hitsPerPage int) *SearchRecommendRulesOptions {
	o.HitsPerPage = &hitsPerPage

	return o
}

// WithEnabled Whether to only show rules where the value of their `enabled` property matches this parameter. If absent, show all rules, regardless of their `enabled` property.
func (o *SearchRecommendRulesOptions) WithEnabled(enabled bool) *SearchRecommendRulesOptions {
	o.Enabled = &enabled

	return o
}

// WithFilters Filter expression. This only searches for rules matching the filter expression.
func (o *SearchRecommendRulesOptions) WithFilters(filters string) *SearchRecommendRulesOptions {
	o.Filters = &filters

	return o
}

// WithFacets Include facets and facet values in the response. Use `['*']` to include all facets.
func (o *SearchRecommendRulesOptions) WithFacets(facets []string) *SearchRecommendRulesOptions {
	o.Facets = &facets

	return o
}

// WithMaxValuesPerFacet Maximum number of values to return for each facet.
func (o *SearchRecommendRulesOptions) WithMaxValuesPerFacet(maxValuesPerFacet int) *SearchRecommendRulesOptions {
	o.MaxValuesPerFacet = &maxValuesPerFacet

	return o
}

// SearchRecommendRules Searches for Recommend rules.
//
// Use an empty query to list all rules for this recommendation scenario.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - model - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
//   - query - Search query. (in optionalParams)
//   - context - Only search for rules with matching context. (in optionalParams)
//   - page - Requested page of the API response.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.  (in optionalParams)
//   - hitsPerPage - Maximum number of hits per page.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.  (in optionalParams)
//   - enabled - Whether to only show rules where the value of their `enabled` property matches this parameter. If absent, show all rules, regardless of their `enabled` property.  (in optionalParams)
//   - filters - Filter expression. This only searches for rules matching the filter expression. (in optionalParams)
//   - facets - Include facets and facet values in the response. Use `['*']` to include all facets. (in optionalParams)
//   - maxValuesPerFacet - Maximum number of values to return for each facet. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchRecommendRules(
	ctx context.Context,
	indexName string,
	model RecommendModels,
	optionalParams *SearchRecommendRulesOptions,
	opts ...RequestOption,
) (*SearchRecommendRulesResponse, error) {
	var returnValue *SearchRecommendRulesResponse

	res, resBody, err := c.SearchRecommendRulesWithHTTPInfo(ctx, indexName, model, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchRecommendRulesWithHTTPInfo calls the API and returns the raw response from it.
// Searches for Recommend rules.
//
// Use an empty query to list all rules for this recommendation scenario.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - model - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
//   - query - Search query. (in optionalParams)
//   - context - Only search for rules with matching context. (in optionalParams)
//   - page - Requested page of the API response.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.  (in optionalParams)
//   - hitsPerPage - Maximum number of hits per page.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.  (in optionalParams)
//   - enabled - Whether to only show rules where the value of their `enabled` property matches this parameter. If absent, show all rules, regardless of their `enabled` property.  (in optionalParams)
//   - filters - Filter expression. This only searches for rules matching the filter expression. (in optionalParams)
//   - facets - Include facets and facet values in the response. Use `['*']` to include all facets. (in optionalParams)
//   - maxValuesPerFacet - Maximum number of values to return for each facet. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchRecommendRulesWithHTTPInfo(
	ctx context.Context,
	indexName string,
	model RecommendModels,
	optionalParams *SearchRecommendRulesOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/{model}/recommend/rules/search"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{model}", url.PathEscape(utils.ParameterToString(model)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SearchRecommendRules`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Query             *string   `json:"query,omitempty"`
		Context           *string   `json:"context,omitempty"`
		Page              *int      `json:"page,omitempty"`
		HitsPerPage       *int      `json:"hitsPerPage,omitempty"`
		Enabled           *bool     `json:"enabled,omitempty"`
		Filters           *string   `json:"filters,omitempty"`
		Facets            *[]string `json:"facets,omitempty"`
		MaxValuesPerFacet *int      `json:"maxValuesPerFacet,omitempty"`
	}{}
	if optionalParams != nil {
		postBody.Query = optionalParams.Query
		postBody.Context = optionalParams.Context
		postBody.Page = optionalParams.Page
		postBody.HitsPerPage = optionalParams.HitsPerPage
		postBody.Enabled = optionalParams.Enabled
		postBody.Filters = optionalParams.Filters
		postBody.Facets = optionalParams.Facets
		postBody.MaxValuesPerFacet = optionalParams.MaxValuesPerFacet
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}
