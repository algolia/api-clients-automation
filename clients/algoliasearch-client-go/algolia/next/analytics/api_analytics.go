// The Analytics API gives you access to metrics related to your Algolia search experience.
//
// ## Base URLs
//
// The base URLs for requests to the Analytics API are:
//
// - `https://analytics.us.algolia.com`
// - `https://analytics.de.algolia.com`
// - `https://analytics.algolia.com` (alias of `analytics.us.algolia.com`)
//
// Use the URL that matches your [analytics region](https://dashboard.algolia.com/account/infrastructure/analytics).
//
// **All requests must use HTTPS.**
//
// ## Availability and authentication
//
// Access to the Analytics API is available as part of the [Premium or Elevate plans](https://www.algolia.com/pricing).
//
// To authenticate your API requests, add these headers:
//
//   - `x-algolia-application-id`. Your Algolia application ID.
//   - `x-algolia-api-key`. An API key with the necessary permissions to make the request.
//     The required access control list (ACL) to make a request is listed in each endpoint's reference.
//
// You can find your application ID and API key in the [Algolia dashboard](https://dashboard.algolia.com/account/api-keys).
//
// ## Rate limits
//
// You can make up to **100 requests per minute per app** to the Analytics API.
// The response includes headers with information about the limits.
//
// ## Parameters
//
// Query parameters must be [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding).
// Non-ASCII characters must be UTF-8 encoded.
// Plus characters (`+`) are interpreted as spaces.
//
// ## Response status and errors
//
// The Analytics API returns JSON responses.
// Since JSON doesn't guarantee any specific ordering, don't rely on the order of attributes in the API response.
//
// - Successful responses return a `2xx` status
// - Client errors return a `4xx` status
// - Server errors are indicated by a `5xx` status.
//
// Error responses have a `message` property with more information.
//
// ## Version
//
// The current version of the Analytics API is version 2, as indicated by the `/2/` in each endpoint's URL.
//
// ## Query aggregation
//
// Algolia accepts queries on each keystroke.
// To ensure you have relevant analytics data, however, the series of keystrokes is aggregated to keep only the latest (final) user query.
// This is called "prefix" aggregation.
//
// For more information, see [Query agggregation and processing](https://www.algolia.com/doc/guides/search-analytics/concepts/query-aggregation).
//
// See the analytics implementation overview for more information about query aggregation.
package analytics

// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import (
	"context"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/transport"
	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type config struct {
	// -- Request options for API calls
	queryParams  url.Values
	headerParams map[string]string
	timeouts     transport.RequestConfiguration
}

type RequestOption interface {
	apply(*config)
}

type requestOption func(*config)

func (r requestOption) apply(c *config) {
	r(c)
}

func WithHeaderParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.headerParams[key] = utils.ParameterToString(value)
	})
}

func WithQueryParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.queryParams.Set(utils.QueryParameterToString(key), utils.QueryParameterToString(value))
	})
}

func WithReadTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ReadTimeout = &timeout
	})
}

func WithWriteTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.WriteTimeout = &timeout
	})
}

func WithConnectTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ConnectTimeout = &timeout
	})
}

// CustomDelete This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomDelete(ctx context.Context, path string, parameters map[string]any, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomDeleteWithHTTPInfo(ctx, path, parameters, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomDeleteWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomDeleteWithHTTPInfo(
	ctx context.Context,
	path string,
	parameters map[string]any,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(parameters) {
		for k, v := range parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomGet This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomGet(ctx context.Context, path string, parameters map[string]any, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomGetWithHTTPInfo(ctx, path, parameters, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomGetWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomGetWithHTTPInfo(
	ctx context.Context,
	path string,
	parameters map[string]any,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(parameters) {
		for k, v := range parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomPostOptions represents the optional params for the API call.
type CustomPostOptions struct {
	Parameters map[string]any
	Body       map[string]any
}

// NewCustomPostOptions creates an instance of the CustomPostOptions used to add optional parameters to CustomPostWithOptions.
func NewCustomPostOptions() *CustomPostOptions {
	return &CustomPostOptions{}
}

// WithParameters Query parameters to apply to the current query.
func (o *CustomPostOptions) WithParameters(parameters map[string]any) *CustomPostOptions {
	o.Parameters = parameters

	return o
}

// WithBody Parameters to send with the custom request.
func (o *CustomPostOptions) WithBody(body map[string]any) *CustomPostOptions {
	o.Body = body

	return o
}

// CustomPost This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPost(ctx context.Context, path string, optionalParams *CustomPostOptions, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPostWithHTTPInfo(ctx, path, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomPostWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPostWithHTTPInfo(
	ctx context.Context,
	path string,
	optionalParams *CustomPostOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Parameters) {
		for k, v := range optionalParams.Parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	var postBody any = "{}"
	if optionalParams != nil {
		postBody = optionalParams.Body
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomPutOptions represents the optional params for the API call.
type CustomPutOptions struct {
	Parameters map[string]any
	Body       map[string]any
}

// NewCustomPutOptions creates an instance of the CustomPutOptions used to add optional parameters to CustomPutWithOptions.
func NewCustomPutOptions() *CustomPutOptions {
	return &CustomPutOptions{}
}

// WithParameters Query parameters to apply to the current query.
func (o *CustomPutOptions) WithParameters(parameters map[string]any) *CustomPutOptions {
	o.Parameters = parameters

	return o
}

// WithBody Parameters to send with the custom request.
func (o *CustomPutOptions) WithBody(body map[string]any) *CustomPutOptions {
	o.Body = body

	return o
}

// CustomPut This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPut(ctx context.Context, path string, optionalParams *CustomPutOptions, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPutWithHTTPInfo(ctx, path, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomPutWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPutWithHTTPInfo(
	ctx context.Context,
	path string,
	optionalParams *CustomPutOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Parameters) {
		for k, v := range optionalParams.Parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	var postBody any = "{}"
	if optionalParams != nil {
		postBody = optionalParams.Body
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetAddToCartRateOptions represents the optional params for the API call.
type GetAddToCartRateOptions struct {
	StartDate *string
	EndDate   *string
	Tags      *string
}

// NewGetAddToCartRateOptions creates an instance of the GetAddToCartRateOptions used to add optional parameters to GetAddToCartRateWithOptions.
func NewGetAddToCartRateOptions() *GetAddToCartRateOptions {
	return &GetAddToCartRateOptions{}
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetAddToCartRateOptions) WithStartDate(startDate string) *GetAddToCartRateOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetAddToCartRateOptions) WithEndDate(endDate string) *GetAddToCartRateOptions {
	o.EndDate = &endDate

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetAddToCartRateOptions) WithTags(tags string) *GetAddToCartRateOptions {
	o.Tags = &tags

	return o
}

// GetAddToCartRate Retrieves the add-to-cart rate for all your searches with at least one add-to-cart event, including a daily breakdown.
//
// By default, the analyzed period includes the last eight days including the current day.
//
// The rate is the number of add-to-cart conversion events divided by the number of tracked searches.
// A search is tracked if it returns a queryID (`clickAnalytics` is `true`).
// This differs from the response's `count`, which shows the overall number of searches, including those where `clickAnalytics` is `false`.
//
// **There's a difference between a 0 and null add-to-cart rate when `clickAnalytics` is enabled:**
//
// - **Null** means there were no queries: since Algolia didn't receive any events, the add-to-cart rate is null.
// - **0** mean there _were_ queries but no [add-to-cart events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetAddToCartRate(
	ctx context.Context,
	index string,
	optionalParams *GetAddToCartRateOptions,
	opts ...RequestOption,
) (*GetAddToCartRateResponse, error) {
	var returnValue *GetAddToCartRateResponse

	res, resBody, err := c.GetAddToCartRateWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetAddToCartRateWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the add-to-cart rate for all your searches with at least one add-to-cart event, including a daily breakdown.
//
// By default, the analyzed period includes the last eight days including the current day.
//
// The rate is the number of add-to-cart conversion events divided by the number of tracked searches.
// A search is tracked if it returns a queryID (`clickAnalytics` is `true`).
// This differs from the response's `count`, which shows the overall number of searches, including those where `clickAnalytics` is `false`.
//
// **There's a difference between a 0 and null add-to-cart rate when `clickAnalytics` is enabled:**
//
// - **Null** means there were no queries: since Algolia didn't receive any events, the add-to-cart rate is null.
// - **0** mean there _were_ queries but no [add-to-cart events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetAddToCartRateWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetAddToCartRateOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/conversions/addToCartRate"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetAddToCartRate`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetAverageClickPositionOptions represents the optional params for the API call.
type GetAverageClickPositionOptions struct {
	StartDate *string
	EndDate   *string
	Tags      *string
}

// NewGetAverageClickPositionOptions creates an instance of the GetAverageClickPositionOptions used to add optional parameters to GetAverageClickPositionWithOptions.
func NewGetAverageClickPositionOptions() *GetAverageClickPositionOptions {
	return &GetAverageClickPositionOptions{}
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetAverageClickPositionOptions) WithStartDate(startDate string) *GetAverageClickPositionOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetAverageClickPositionOptions) WithEndDate(endDate string) *GetAverageClickPositionOptions {
	o.EndDate = &endDate

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetAverageClickPositionOptions) WithTags(tags string) *GetAverageClickPositionOptions {
	o.Tags = &tags

	return o
}

// GetAverageClickPosition Retrieves the average click position of your search results, including a daily breakdown.
//
// The average click position is the average of all clicked search result positions.
// For example, if users only ever click on the first result for any search, the average click position is 1.
// By default, the analyzed period includes the last eight days including the current day.
//
// An average of `null` when `clickAnalytics` is enabled means Algolia didn't receive any [click events](https://www.algolia.com/doc/guides/sending-events/getting-started) for the queries.
// The average is `null` until Algolia receives at least one click event.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetAverageClickPosition(
	ctx context.Context,
	index string,
	optionalParams *GetAverageClickPositionOptions,
	opts ...RequestOption,
) (*GetAverageClickPositionResponse, error) {
	var returnValue *GetAverageClickPositionResponse

	res, resBody, err := c.GetAverageClickPositionWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetAverageClickPositionWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the average click position of your search results, including a daily breakdown.
//
// The average click position is the average of all clicked search result positions.
// For example, if users only ever click on the first result for any search, the average click position is 1.
// By default, the analyzed period includes the last eight days including the current day.
//
// An average of `null` when `clickAnalytics` is enabled means Algolia didn't receive any [click events](https://www.algolia.com/doc/guides/sending-events/getting-started) for the queries.
// The average is `null` until Algolia receives at least one click event.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetAverageClickPositionWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetAverageClickPositionOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/clicks/averageClickPosition"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetAverageClickPosition`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetClickPositionsOptions represents the optional params for the API call.
type GetClickPositionsOptions struct {
	StartDate *string
	EndDate   *string
	Tags      *string
}

// NewGetClickPositionsOptions creates an instance of the GetClickPositionsOptions used to add optional parameters to GetClickPositionsWithOptions.
func NewGetClickPositionsOptions() *GetClickPositionsOptions {
	return &GetClickPositionsOptions{}
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetClickPositionsOptions) WithStartDate(startDate string) *GetClickPositionsOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetClickPositionsOptions) WithEndDate(endDate string) *GetClickPositionsOptions {
	o.EndDate = &endDate

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetClickPositionsOptions) WithTags(tags string) *GetClickPositionsOptions {
	o.Tags = &tags

	return o
}

// GetClickPositions Retrieves the positions in the search results and their associated number of clicks.
//
// This lets you check how many clicks the first, second, or tenth search results receive.
//
// An average of `0` when `clickAnalytics` is enabled means Algolia didn't receive any [click events](https://www.algolia.com/doc/guides/sending-events/getting-started) for the queries.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetClickPositions(
	ctx context.Context,
	index string,
	optionalParams *GetClickPositionsOptions,
	opts ...RequestOption,
) (*GetClickPositionsResponse, error) {
	var returnValue *GetClickPositionsResponse

	res, resBody, err := c.GetClickPositionsWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetClickPositionsWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the positions in the search results and their associated number of clicks.
//
// This lets you check how many clicks the first, second, or tenth search results receive.
//
// An average of `0` when `clickAnalytics` is enabled means Algolia didn't receive any [click events](https://www.algolia.com/doc/guides/sending-events/getting-started) for the queries.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetClickPositionsWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetClickPositionsOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/clicks/positions"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetClickPositions`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetClickThroughRateOptions represents the optional params for the API call.
type GetClickThroughRateOptions struct {
	StartDate *string
	EndDate   *string
	Tags      *string
}

// NewGetClickThroughRateOptions creates an instance of the GetClickThroughRateOptions used to add optional parameters to GetClickThroughRateWithOptions.
func NewGetClickThroughRateOptions() *GetClickThroughRateOptions {
	return &GetClickThroughRateOptions{}
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetClickThroughRateOptions) WithStartDate(startDate string) *GetClickThroughRateOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetClickThroughRateOptions) WithEndDate(endDate string) *GetClickThroughRateOptions {
	o.EndDate = &endDate

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetClickThroughRateOptions) WithTags(tags string) *GetClickThroughRateOptions {
	o.Tags = &tags

	return o
}

// GetClickThroughRate Retrieves the click-through rate (CTR) for all your searches with at least one click event, including a daily breakdown.
//
// By default, the analyzed period includes the last eight days including the current day.
//
// **There's a difference between a 0 and null CTR when `clickAnalytics` is enabled:**
//
// - **Null** means there were no queries: since Algolia didn't receive any events, CTR is null.
// - **0** mean there _were_ queries but no [click events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetClickThroughRate(
	ctx context.Context,
	index string,
	optionalParams *GetClickThroughRateOptions,
	opts ...RequestOption,
) (*GetClickThroughRateResponse, error) {
	var returnValue *GetClickThroughRateResponse

	res, resBody, err := c.GetClickThroughRateWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetClickThroughRateWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the click-through rate (CTR) for all your searches with at least one click event, including a daily breakdown.
//
// By default, the analyzed period includes the last eight days including the current day.
//
// **There's a difference between a 0 and null CTR when `clickAnalytics` is enabled:**
//
// - **Null** means there were no queries: since Algolia didn't receive any events, CTR is null.
// - **0** mean there _were_ queries but no [click events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetClickThroughRateWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetClickThroughRateOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/clicks/clickThroughRate"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetClickThroughRate`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetConversionRateOptions represents the optional params for the API call.
type GetConversionRateOptions struct {
	StartDate *string
	EndDate   *string
	Tags      *string
}

// NewGetConversionRateOptions creates an instance of the GetConversionRateOptions used to add optional parameters to GetConversionRateWithOptions.
func NewGetConversionRateOptions() *GetConversionRateOptions {
	return &GetConversionRateOptions{}
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetConversionRateOptions) WithStartDate(startDate string) *GetConversionRateOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetConversionRateOptions) WithEndDate(endDate string) *GetConversionRateOptions {
	o.EndDate = &endDate

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetConversionRateOptions) WithTags(tags string) *GetConversionRateOptions {
	o.Tags = &tags

	return o
}

// GetConversionRate Retrieves the conversion rate (CR) for all your searches with at least one conversion event, including a daily breakdown.
//
// By default, the analyzed period includes the last eight days including the current day.
//
// **There's a difference between a 0 and null CR when `clickAnalytics` is enabled:**
//
// - **Null** means there were no queries: since Algolia didn't receive any events, CR is null.
// - **0** mean there _were_ queries but no [conversion events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetConversionRate(
	ctx context.Context,
	index string,
	optionalParams *GetConversionRateOptions,
	opts ...RequestOption,
) (*GetConversionRateResponse, error) {
	var returnValue *GetConversionRateResponse

	res, resBody, err := c.GetConversionRateWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetConversionRateWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the conversion rate (CR) for all your searches with at least one conversion event, including a daily breakdown.
//
// By default, the analyzed period includes the last eight days including the current day.
//
// **There's a difference between a 0 and null CR when `clickAnalytics` is enabled:**
//
// - **Null** means there were no queries: since Algolia didn't receive any events, CR is null.
// - **0** mean there _were_ queries but no [conversion events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetConversionRateWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetConversionRateOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/conversions/conversionRate"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetConversionRate`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetNoClickRateOptions represents the optional params for the API call.
type GetNoClickRateOptions struct {
	StartDate *string
	EndDate   *string
	Tags      *string
}

// NewGetNoClickRateOptions creates an instance of the GetNoClickRateOptions used to add optional parameters to GetNoClickRateWithOptions.
func NewGetNoClickRateOptions() *GetNoClickRateOptions {
	return &GetNoClickRateOptions{}
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetNoClickRateOptions) WithStartDate(startDate string) *GetNoClickRateOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetNoClickRateOptions) WithEndDate(endDate string) *GetNoClickRateOptions {
	o.EndDate = &endDate

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetNoClickRateOptions) WithTags(tags string) *GetNoClickRateOptions {
	o.Tags = &tags

	return o
}

// GetNoClickRate Retrieves the fraction of searches that didn't lead to any click within a time range, including a daily breakdown.
// It also returns the number of tracked searches and tracked searches without clicks.
//
// By default, the analyzed period includes the last eight days including the current day.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetNoClickRate(
	ctx context.Context,
	index string,
	optionalParams *GetNoClickRateOptions,
	opts ...RequestOption,
) (*GetNoClickRateResponse, error) {
	var returnValue *GetNoClickRateResponse

	res, resBody, err := c.GetNoClickRateWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetNoClickRateWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the fraction of searches that didn't lead to any click within a time range, including a daily breakdown.
// It also returns the number of tracked searches and tracked searches without clicks.
//
// By default, the analyzed period includes the last eight days including the current day.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetNoClickRateWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetNoClickRateOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/searches/noClickRate"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetNoClickRate`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetNoResultsRateOptions represents the optional params for the API call.
type GetNoResultsRateOptions struct {
	StartDate *string
	EndDate   *string
	Tags      *string
}

// NewGetNoResultsRateOptions creates an instance of the GetNoResultsRateOptions used to add optional parameters to GetNoResultsRateWithOptions.
func NewGetNoResultsRateOptions() *GetNoResultsRateOptions {
	return &GetNoResultsRateOptions{}
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetNoResultsRateOptions) WithStartDate(startDate string) *GetNoResultsRateOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetNoResultsRateOptions) WithEndDate(endDate string) *GetNoResultsRateOptions {
	o.EndDate = &endDate

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetNoResultsRateOptions) WithTags(tags string) *GetNoResultsRateOptions {
	o.Tags = &tags

	return o
}

// GetNoResultsRate Retrieves the fraction of searches that didn't return any results within a time range, including a daily breakdown.
// It also returns the count of searches and searches without results used to compute the rates.
//
// By default, the analyzed period includes the last eight days including the current day.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetNoResultsRate(
	ctx context.Context,
	index string,
	optionalParams *GetNoResultsRateOptions,
	opts ...RequestOption,
) (*GetNoResultsRateResponse, error) {
	var returnValue *GetNoResultsRateResponse

	res, resBody, err := c.GetNoResultsRateWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetNoResultsRateWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the fraction of searches that didn't return any results within a time range, including a daily breakdown.
// It also returns the count of searches and searches without results used to compute the rates.
//
// By default, the analyzed period includes the last eight days including the current day.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetNoResultsRateWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetNoResultsRateOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/searches/noResultRate"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetNoResultsRate`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetPurchaseRateOptions represents the optional params for the API call.
type GetPurchaseRateOptions struct {
	StartDate *string
	EndDate   *string
	Tags      *string
}

// NewGetPurchaseRateOptions creates an instance of the GetPurchaseRateOptions used to add optional parameters to GetPurchaseRateWithOptions.
func NewGetPurchaseRateOptions() *GetPurchaseRateOptions {
	return &GetPurchaseRateOptions{}
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetPurchaseRateOptions) WithStartDate(startDate string) *GetPurchaseRateOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetPurchaseRateOptions) WithEndDate(endDate string) *GetPurchaseRateOptions {
	o.EndDate = &endDate

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetPurchaseRateOptions) WithTags(tags string) *GetPurchaseRateOptions {
	o.Tags = &tags

	return o
}

// GetPurchaseRate Retrieves the purchase rate for all your searches with at least one purchase event, including a daily breakdown.
//
// By default, the analyzed period includes the last eight days including the current day.
//
// The rate is the number of purchase conversion events divided by the number of tracked searches.
// A search is tracked if it returns a query ID (`clickAnalytics` is `true`).
// This differs from the response's `count`, which shows the overall number of searches, including those where `clickAnalytics` is `false`.
//
// **There's a difference between a 0 and null purchase rate when `clickAnalytics` is enabled:**
//
// - **Null** means there were no queries: since Algolia didn't receive any events, the purchase rate is null.
// - **0** mean there _were_ queries but no [purchase conversion events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetPurchaseRate(
	ctx context.Context,
	index string,
	optionalParams *GetPurchaseRateOptions,
	opts ...RequestOption,
) (*GetPurchaseRateResponse, error) {
	var returnValue *GetPurchaseRateResponse

	res, resBody, err := c.GetPurchaseRateWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetPurchaseRateWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the purchase rate for all your searches with at least one purchase event, including a daily breakdown.
//
// By default, the analyzed period includes the last eight days including the current day.
//
// The rate is the number of purchase conversion events divided by the number of tracked searches.
// A search is tracked if it returns a query ID (`clickAnalytics` is `true`).
// This differs from the response's `count`, which shows the overall number of searches, including those where `clickAnalytics` is `false`.
//
// **There's a difference between a 0 and null purchase rate when `clickAnalytics` is enabled:**
//
// - **Null** means there were no queries: since Algolia didn't receive any events, the purchase rate is null.
// - **0** mean there _were_ queries but no [purchase conversion events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetPurchaseRateWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetPurchaseRateOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/conversions/purchaseRate"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetPurchaseRate`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetRevenueOptions represents the optional params for the API call.
type GetRevenueOptions struct {
	StartDate *string
	EndDate   *string
	Tags      *string
}

// NewGetRevenueOptions creates an instance of the GetRevenueOptions used to add optional parameters to GetRevenueWithOptions.
func NewGetRevenueOptions() *GetRevenueOptions {
	return &GetRevenueOptions{}
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetRevenueOptions) WithStartDate(startDate string) *GetRevenueOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetRevenueOptions) WithEndDate(endDate string) *GetRevenueOptions {
	o.EndDate = &endDate

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetRevenueOptions) WithTags(tags string) *GetRevenueOptions {
	o.Tags = &tags

	return o
}

// GetRevenue Retrieves revenue-related metrics, such as the total revenue or the average order value.
//
// To retrieve revenue-related metrics, send purchase events.
// By default, the analyzed period includes the last eight days including the current day.
//
// Revenue is based on purchase conversion events (a conversion event with an `eventSubtype` attribute of `purchase`).
// The revenue is the `price` attribute multiplied by the `quantity` attribute for each object in the event's `objectData` array.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetRevenue(ctx context.Context, index string, optionalParams *GetRevenueOptions, opts ...RequestOption) (*GetRevenue, error) {
	var returnValue *GetRevenue

	res, resBody, err := c.GetRevenueWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetRevenueWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves revenue-related metrics, such as the total revenue or the average order value.
//
// To retrieve revenue-related metrics, send purchase events.
// By default, the analyzed period includes the last eight days including the current day.
//
// Revenue is based on purchase conversion events (a conversion event with an `eventSubtype` attribute of `purchase`).
// The revenue is the `price` attribute multiplied by the `quantity` attribute for each object in the event's `objectData` array.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetRevenueWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetRevenueOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/conversions/revenue"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetRevenue`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetSearchesCountOptions represents the optional params for the API call.
type GetSearchesCountOptions struct {
	StartDate *string
	EndDate   *string
	Tags      *string
}

// NewGetSearchesCountOptions creates an instance of the GetSearchesCountOptions used to add optional parameters to GetSearchesCountWithOptions.
func NewGetSearchesCountOptions() *GetSearchesCountOptions {
	return &GetSearchesCountOptions{}
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetSearchesCountOptions) WithStartDate(startDate string) *GetSearchesCountOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetSearchesCountOptions) WithEndDate(endDate string) *GetSearchesCountOptions {
	o.EndDate = &endDate

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetSearchesCountOptions) WithTags(tags string) *GetSearchesCountOptions {
	o.Tags = &tags

	return o
}

// GetSearchesCount Retrieves the number of searches within a time range, including a daily breakdown.
//
// By default, the analyzed period includes the last eight days including the current day.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetSearchesCount(
	ctx context.Context,
	index string,
	optionalParams *GetSearchesCountOptions,
	opts ...RequestOption,
) (*GetSearchesCountResponse, error) {
	var returnValue *GetSearchesCountResponse

	res, resBody, err := c.GetSearchesCountWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetSearchesCountWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the number of searches within a time range, including a daily breakdown.
//
// By default, the analyzed period includes the last eight days including the current day.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetSearchesCountWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetSearchesCountOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/searches/count"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetSearchesCount`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetSearchesNoClicksOptions represents the optional params for the API call.
type GetSearchesNoClicksOptions struct {
	StartDate *string
	EndDate   *string
	Limit     *int
	Offset    *int
	Tags      *string
}

// NewGetSearchesNoClicksOptions creates an instance of the GetSearchesNoClicksOptions used to add optional parameters to GetSearchesNoClicksWithOptions.
func NewGetSearchesNoClicksOptions() *GetSearchesNoClicksOptions {
	return &GetSearchesNoClicksOptions{}
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetSearchesNoClicksOptions) WithStartDate(startDate string) *GetSearchesNoClicksOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetSearchesNoClicksOptions) WithEndDate(endDate string) *GetSearchesNoClicksOptions {
	o.EndDate = &endDate

	return o
}

// WithLimit Number of items to return.
func (o *GetSearchesNoClicksOptions) WithLimit(limit int) *GetSearchesNoClicksOptions {
	o.Limit = &limit

	return o
}

// WithOffset Position of the first item to return.
func (o *GetSearchesNoClicksOptions) WithOffset(offset int) *GetSearchesNoClicksOptions {
	o.Offset = &offset

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetSearchesNoClicksOptions) WithTags(tags string) *GetSearchesNoClicksOptions {
	o.Tags = &tags

	return o
}

// GetSearchesNoClicks Retrieves the most popular searches that didn't lead to any clicks, from the 1,000 most frequent searches.
//
// For each search, it also returns the number of displayed search results that remained unclicked.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - limit - Number of items to return.  (in optionalParams)
//   - offset - Position of the first item to return.  (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetSearchesNoClicks(
	ctx context.Context,
	index string,
	optionalParams *GetSearchesNoClicksOptions,
	opts ...RequestOption,
) (*GetSearchesNoClicksResponse, error) {
	var returnValue *GetSearchesNoClicksResponse

	res, resBody, err := c.GetSearchesNoClicksWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetSearchesNoClicksWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the most popular searches that didn't lead to any clicks, from the 1,000 most frequent searches.
//
// For each search, it also returns the number of displayed search results that remained unclicked.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - limit - Number of items to return.  (in optionalParams)
//   - offset - Position of the first item to return.  (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetSearchesNoClicksWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetSearchesNoClicksOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/searches/noClicks"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetSearchesNoClicks`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Limit) {
		conf.queryParams.Set("limit", utils.QueryParameterToString(*optionalParams.Limit))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*optionalParams.Offset))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetSearchesNoResultsOptions represents the optional params for the API call.
type GetSearchesNoResultsOptions struct {
	StartDate *string
	EndDate   *string
	Limit     *int
	Offset    *int
	Tags      *string
}

// NewGetSearchesNoResultsOptions creates an instance of the GetSearchesNoResultsOptions used to add optional parameters to GetSearchesNoResultsWithOptions.
func NewGetSearchesNoResultsOptions() *GetSearchesNoResultsOptions {
	return &GetSearchesNoResultsOptions{}
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetSearchesNoResultsOptions) WithStartDate(startDate string) *GetSearchesNoResultsOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetSearchesNoResultsOptions) WithEndDate(endDate string) *GetSearchesNoResultsOptions {
	o.EndDate = &endDate

	return o
}

// WithLimit Number of items to return.
func (o *GetSearchesNoResultsOptions) WithLimit(limit int) *GetSearchesNoResultsOptions {
	o.Limit = &limit

	return o
}

// WithOffset Position of the first item to return.
func (o *GetSearchesNoResultsOptions) WithOffset(offset int) *GetSearchesNoResultsOptions {
	o.Offset = &offset

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetSearchesNoResultsOptions) WithTags(tags string) *GetSearchesNoResultsOptions {
	o.Tags = &tags

	return o
}

// GetSearchesNoResults Retrieves the 1,000 most frequent searches that produced zero results.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - limit - Number of items to return.  (in optionalParams)
//   - offset - Position of the first item to return.  (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetSearchesNoResults(
	ctx context.Context,
	index string,
	optionalParams *GetSearchesNoResultsOptions,
	opts ...RequestOption,
) (*GetSearchesNoResultsResponse, error) {
	var returnValue *GetSearchesNoResultsResponse

	res, resBody, err := c.GetSearchesNoResultsWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetSearchesNoResultsWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the 1,000 most frequent searches that produced zero results.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - limit - Number of items to return.  (in optionalParams)
//   - offset - Position of the first item to return.  (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetSearchesNoResultsWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetSearchesNoResultsOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/searches/noResults"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetSearchesNoResults`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Limit) {
		conf.queryParams.Set("limit", utils.QueryParameterToString(*optionalParams.Limit))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*optionalParams.Offset))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetStatus Retrieves the time when the Analytics data for the specified index was last updated.
//
// If the index has been recently created or no search has been performed yet the updated time is `null`.
//
// The Analytics data is updated every 5&nbsp;minutes.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetStatus(ctx context.Context, index string, opts ...RequestOption) (*GetStatusResponse, error) {
	var returnValue *GetStatusResponse

	res, resBody, err := c.GetStatusWithHTTPInfo(ctx, index, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetStatusWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the time when the Analytics data for the specified index was last updated.
//
// If the index has been recently created or no search has been performed yet the updated time is `null`.
//
// The Analytics data is updated every 5&nbsp;minutes.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetStatusWithHTTPInfo(ctx context.Context, index string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/status"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetStatus`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetTopCountriesOptions represents the optional params for the API call.
type GetTopCountriesOptions struct {
	StartDate *string
	EndDate   *string
	Limit     *int
	Offset    *int
	Tags      *string
}

// NewGetTopCountriesOptions creates an instance of the GetTopCountriesOptions used to add optional parameters to GetTopCountriesWithOptions.
func NewGetTopCountriesOptions() *GetTopCountriesOptions {
	return &GetTopCountriesOptions{}
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetTopCountriesOptions) WithStartDate(startDate string) *GetTopCountriesOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetTopCountriesOptions) WithEndDate(endDate string) *GetTopCountriesOptions {
	o.EndDate = &endDate

	return o
}

// WithLimit Number of items to return.
func (o *GetTopCountriesOptions) WithLimit(limit int) *GetTopCountriesOptions {
	o.Limit = &limit

	return o
}

// WithOffset Position of the first item to return.
func (o *GetTopCountriesOptions) WithOffset(offset int) *GetTopCountriesOptions {
	o.Offset = &offset

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetTopCountriesOptions) WithTags(tags string) *GetTopCountriesOptions {
	o.Tags = &tags

	return o
}

// GetTopCountries Retrieves the countries with the most searches in your index.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - limit - Number of items to return.  (in optionalParams)
//   - offset - Position of the first item to return.  (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTopCountries(
	ctx context.Context,
	index string,
	optionalParams *GetTopCountriesOptions,
	opts ...RequestOption,
) (*GetTopCountriesResponse, error) {
	var returnValue *GetTopCountriesResponse

	res, resBody, err := c.GetTopCountriesWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetTopCountriesWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the countries with the most searches in your index.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - limit - Number of items to return.  (in optionalParams)
//   - offset - Position of the first item to return.  (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTopCountriesWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetTopCountriesOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/countries"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetTopCountries`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Limit) {
		conf.queryParams.Set("limit", utils.QueryParameterToString(*optionalParams.Limit))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*optionalParams.Offset))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetTopFilterAttributesOptions represents the optional params for the API call.
type GetTopFilterAttributesOptions struct {
	Search    *string
	StartDate *string
	EndDate   *string
	Limit     *int
	Offset    *int
	Tags      *string
}

// NewGetTopFilterAttributesOptions creates an instance of the GetTopFilterAttributesOptions used to add optional parameters to GetTopFilterAttributesWithOptions.
func NewGetTopFilterAttributesOptions() *GetTopFilterAttributesOptions {
	return &GetTopFilterAttributesOptions{}
}

// WithSearch Search query.
func (o *GetTopFilterAttributesOptions) WithSearch(search string) *GetTopFilterAttributesOptions {
	o.Search = &search

	return o
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetTopFilterAttributesOptions) WithStartDate(startDate string) *GetTopFilterAttributesOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetTopFilterAttributesOptions) WithEndDate(endDate string) *GetTopFilterAttributesOptions {
	o.EndDate = &endDate

	return o
}

// WithLimit Number of items to return.
func (o *GetTopFilterAttributesOptions) WithLimit(limit int) *GetTopFilterAttributesOptions {
	o.Limit = &limit

	return o
}

// WithOffset Position of the first item to return.
func (o *GetTopFilterAttributesOptions) WithOffset(offset int) *GetTopFilterAttributesOptions {
	o.Offset = &offset

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetTopFilterAttributesOptions) WithTags(tags string) *GetTopFilterAttributesOptions {
	o.Tags = &tags

	return o
}

// GetTopFilterAttributes Retrieves the 1,000 most frequently used filter attributes.
//
// These are attributes of your records that you included in the `attributesForFaceting` setting.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - search - Search query. (in optionalParams)
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - limit - Number of items to return.  (in optionalParams)
//   - offset - Position of the first item to return.  (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTopFilterAttributes(
	ctx context.Context,
	index string,
	optionalParams *GetTopFilterAttributesOptions,
	opts ...RequestOption,
) (*GetTopFilterAttributesResponse, error) {
	var returnValue *GetTopFilterAttributesResponse

	res, resBody, err := c.GetTopFilterAttributesWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetTopFilterAttributesWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the 1,000 most frequently used filter attributes.
//
// These are attributes of your records that you included in the `attributesForFaceting` setting.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - search - Search query. (in optionalParams)
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - limit - Number of items to return.  (in optionalParams)
//   - offset - Position of the first item to return.  (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTopFilterAttributesWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetTopFilterAttributesOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/filters"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetTopFilterAttributes`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Search) {
		conf.queryParams.Set("search", utils.QueryParameterToString(*optionalParams.Search))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Limit) {
		conf.queryParams.Set("limit", utils.QueryParameterToString(*optionalParams.Limit))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*optionalParams.Offset))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetTopFilterForAttributeOptions represents the optional params for the API call.
type GetTopFilterForAttributeOptions struct {
	Search    *string
	StartDate *string
	EndDate   *string
	Limit     *int
	Offset    *int
	Tags      *string
}

// NewGetTopFilterForAttributeOptions creates an instance of the GetTopFilterForAttributeOptions used to add optional parameters to GetTopFilterForAttributeWithOptions.
func NewGetTopFilterForAttributeOptions() *GetTopFilterForAttributeOptions {
	return &GetTopFilterForAttributeOptions{}
}

// WithSearch Search query.
func (o *GetTopFilterForAttributeOptions) WithSearch(search string) *GetTopFilterForAttributeOptions {
	o.Search = &search

	return o
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetTopFilterForAttributeOptions) WithStartDate(startDate string) *GetTopFilterForAttributeOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetTopFilterForAttributeOptions) WithEndDate(endDate string) *GetTopFilterForAttributeOptions {
	o.EndDate = &endDate

	return o
}

// WithLimit Number of items to return.
func (o *GetTopFilterForAttributeOptions) WithLimit(limit int) *GetTopFilterForAttributeOptions {
	o.Limit = &limit

	return o
}

// WithOffset Position of the first item to return.
func (o *GetTopFilterForAttributeOptions) WithOffset(offset int) *GetTopFilterForAttributeOptions {
	o.Offset = &offset

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetTopFilterForAttributeOptions) WithTags(tags string) *GetTopFilterForAttributeOptions {
	o.Tags = &tags

	return o
}

// GetTopFilterForAttribute Retrieves the 1,000 most frequent filter (facet) values for a filter attribute.
//
// These are attributes of your records that you included in the `attributesForFaceting` setting.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - attribute - Attribute name.
//   - index - Index name.
//   - search - Search query. (in optionalParams)
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - limit - Number of items to return.  (in optionalParams)
//   - offset - Position of the first item to return.  (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTopFilterForAttribute(
	ctx context.Context,
	attribute string,
	index string,
	optionalParams *GetTopFilterForAttributeOptions,
	opts ...RequestOption,
) (*GetTopFilterForAttributeResponse, error) {
	var returnValue *GetTopFilterForAttributeResponse

	res, resBody, err := c.GetTopFilterForAttributeWithHTTPInfo(ctx, attribute, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetTopFilterForAttributeWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the 1,000 most frequent filter (facet) values for a filter attribute.
//
// These are attributes of your records that you included in the `attributesForFaceting` setting.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - attribute - Attribute name.
//   - index - Index name.
//   - search - Search query. (in optionalParams)
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - limit - Number of items to return.  (in optionalParams)
//   - offset - Position of the first item to return.  (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTopFilterForAttributeWithHTTPInfo(
	ctx context.Context,
	attribute string,
	index string,
	optionalParams *GetTopFilterForAttributeOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/filters/{attribute}"
	requestPath = strings.ReplaceAll(requestPath, "{attribute}", url.PathEscape(utils.ParameterToString(attribute)))

	if attribute == "" {
		return nil, nil, reportError("Parameter `attribute` is required when calling `GetTopFilterForAttribute`.")
	}

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetTopFilterForAttribute`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Search) {
		conf.queryParams.Set("search", utils.QueryParameterToString(*optionalParams.Search))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Limit) {
		conf.queryParams.Set("limit", utils.QueryParameterToString(*optionalParams.Limit))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*optionalParams.Offset))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetTopFiltersNoResultsOptions represents the optional params for the API call.
type GetTopFiltersNoResultsOptions struct {
	Search    *string
	StartDate *string
	EndDate   *string
	Limit     *int
	Offset    *int
	Tags      *string
}

// NewGetTopFiltersNoResultsOptions creates an instance of the GetTopFiltersNoResultsOptions used to add optional parameters to GetTopFiltersNoResultsWithOptions.
func NewGetTopFiltersNoResultsOptions() *GetTopFiltersNoResultsOptions {
	return &GetTopFiltersNoResultsOptions{}
}

// WithSearch Search query.
func (o *GetTopFiltersNoResultsOptions) WithSearch(search string) *GetTopFiltersNoResultsOptions {
	o.Search = &search

	return o
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetTopFiltersNoResultsOptions) WithStartDate(startDate string) *GetTopFiltersNoResultsOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetTopFiltersNoResultsOptions) WithEndDate(endDate string) *GetTopFiltersNoResultsOptions {
	o.EndDate = &endDate

	return o
}

// WithLimit Number of items to return.
func (o *GetTopFiltersNoResultsOptions) WithLimit(limit int) *GetTopFiltersNoResultsOptions {
	o.Limit = &limit

	return o
}

// WithOffset Position of the first item to return.
func (o *GetTopFiltersNoResultsOptions) WithOffset(offset int) *GetTopFiltersNoResultsOptions {
	o.Offset = &offset

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetTopFiltersNoResultsOptions) WithTags(tags string) *GetTopFiltersNoResultsOptions {
	o.Tags = &tags

	return o
}

// GetTopFiltersNoResults Retrieves the 1,000 most frequently used filters for a search that didn't return any results.
//
// To get the most frequent searches without results, use the [Retrieve searches without results](https://www.algolia.com/doc/rest-api/analytics/get-searches-no-results) operation.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - search - Search query. (in optionalParams)
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - limit - Number of items to return.  (in optionalParams)
//   - offset - Position of the first item to return.  (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTopFiltersNoResults(
	ctx context.Context,
	index string,
	optionalParams *GetTopFiltersNoResultsOptions,
	opts ...RequestOption,
) (*GetTopFiltersNoResultsResponse, error) {
	var returnValue *GetTopFiltersNoResultsResponse

	res, resBody, err := c.GetTopFiltersNoResultsWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetTopFiltersNoResultsWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the 1,000 most frequently used filters for a search that didn't return any results.
//
// To get the most frequent searches without results, use the [Retrieve searches without results](https://www.algolia.com/doc/rest-api/analytics/get-searches-no-results) operation.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - search - Search query. (in optionalParams)
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - limit - Number of items to return.  (in optionalParams)
//   - offset - Position of the first item to return.  (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTopFiltersNoResultsWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetTopFiltersNoResultsOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/filters/noResults"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetTopFiltersNoResults`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Search) {
		conf.queryParams.Set("search", utils.QueryParameterToString(*optionalParams.Search))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Limit) {
		conf.queryParams.Set("limit", utils.QueryParameterToString(*optionalParams.Limit))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*optionalParams.Offset))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetTopHitsOptions represents the optional params for the API call.
type GetTopHitsOptions struct {
	Search           *string
	ClickAnalytics   *bool
	RevenueAnalytics *bool
	StartDate        *string
	EndDate          *string
	Limit            *int
	Offset           *int
	Tags             *string
}

// NewGetTopHitsOptions creates an instance of the GetTopHitsOptions used to add optional parameters to GetTopHitsWithOptions.
func NewGetTopHitsOptions() *GetTopHitsOptions {
	return &GetTopHitsOptions{}
}

// WithSearch Search query.
func (o *GetTopHitsOptions) WithSearch(search string) *GetTopHitsOptions {
	o.Search = &search

	return o
}

// WithClickAnalytics Whether to include metrics related to click and conversion events in the response.
func (o *GetTopHitsOptions) WithClickAnalytics(clickAnalytics bool) *GetTopHitsOptions {
	o.ClickAnalytics = &clickAnalytics

	return o
}

// WithRevenueAnalytics Whether to include metrics related to revenue events in the response.
func (o *GetTopHitsOptions) WithRevenueAnalytics(revenueAnalytics bool) *GetTopHitsOptions {
	o.RevenueAnalytics = &revenueAnalytics

	return o
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetTopHitsOptions) WithStartDate(startDate string) *GetTopHitsOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetTopHitsOptions) WithEndDate(endDate string) *GetTopHitsOptions {
	o.EndDate = &endDate

	return o
}

// WithLimit Number of items to return.
func (o *GetTopHitsOptions) WithLimit(limit int) *GetTopHitsOptions {
	o.Limit = &limit

	return o
}

// WithOffset Position of the first item to return.
func (o *GetTopHitsOptions) WithOffset(offset int) *GetTopHitsOptions {
	o.Offset = &offset

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetTopHitsOptions) WithTags(tags string) *GetTopHitsOptions {
	o.Tags = &tags

	return o
}

// GetTopHits Retrieves the object IDs of the 1,000 most frequent search results.
//
// If you set the `clickAnalytics` query parameter to true, the response also includes:
//
// - Tracked searches count. Tracked searches are Search API requests with the `clickAnalytics` parameter set to `true`. This differs from the response's `count`, which shows the overall number of searches, including those where `clickAnalytics` is `false`.
// - Click count
// - Click-through rate (CTR)
// - Conversion count
// - Conversion rate (CR)
// - Average click position
//
// If you set the `revenueAnalytics` parameter to `true`, the response also includes:
//
// - Add-to-cart count
// - Add-to-cart rate (ATCR)
// - Purchase count
// - Purchase rate
// - Revenue details for each currency
//
// **There's a difference between 0% rates and null rates:**
//
// - **Null** means there were no queries: since Algolia didn't receive any events, the rates (CTR, CR, ATCR, purchase rate) are null.
// - **0% rates** mean there _were_ queries but no [click or conversion events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - search - Search query. (in optionalParams)
//   - clickAnalytics - Whether to include metrics related to click and conversion events in the response. (in optionalParams)
//   - revenueAnalytics - Whether to include metrics related to revenue events in the response. (in optionalParams)
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - limit - Number of items to return.  (in optionalParams)
//   - offset - Position of the first item to return.  (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTopHits(
	ctx context.Context,
	index string,
	optionalParams *GetTopHitsOptions,
	opts ...RequestOption,
) (*GetTopHitsResponse, error) {
	var returnValue *GetTopHitsResponse

	res, resBody, err := c.GetTopHitsWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetTopHitsWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the object IDs of the 1,000 most frequent search results.
//
// If you set the `clickAnalytics` query parameter to true, the response also includes:
//
// - Tracked searches count. Tracked searches are Search API requests with the `clickAnalytics` parameter set to `true`. This differs from the response's `count`, which shows the overall number of searches, including those where `clickAnalytics` is `false`.
// - Click count
// - Click-through rate (CTR)
// - Conversion count
// - Conversion rate (CR)
// - Average click position
//
// If you set the `revenueAnalytics` parameter to `true`, the response also includes:
//
// - Add-to-cart count
// - Add-to-cart rate (ATCR)
// - Purchase count
// - Purchase rate
// - Revenue details for each currency
//
// **There's a difference between 0% rates and null rates:**
//
// - **Null** means there were no queries: since Algolia didn't receive any events, the rates (CTR, CR, ATCR, purchase rate) are null.
// - **0% rates** mean there _were_ queries but no [click or conversion events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - search - Search query. (in optionalParams)
//   - clickAnalytics - Whether to include metrics related to click and conversion events in the response. (in optionalParams)
//   - revenueAnalytics - Whether to include metrics related to revenue events in the response. (in optionalParams)
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - limit - Number of items to return.  (in optionalParams)
//   - offset - Position of the first item to return.  (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTopHitsWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetTopHitsOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/hits"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetTopHits`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Search) {
		conf.queryParams.Set("search", utils.QueryParameterToString(*optionalParams.Search))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.ClickAnalytics) {
		conf.queryParams.Set("clickAnalytics", utils.QueryParameterToString(*optionalParams.ClickAnalytics))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.RevenueAnalytics) {
		conf.queryParams.Set("revenueAnalytics", utils.QueryParameterToString(*optionalParams.RevenueAnalytics))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Limit) {
		conf.queryParams.Set("limit", utils.QueryParameterToString(*optionalParams.Limit))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*optionalParams.Offset))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetTopSearchesOptions represents the optional params for the API call.
type GetTopSearchesOptions struct {
	ClickAnalytics   *bool
	RevenueAnalytics *bool
	StartDate        *string
	EndDate          *string
	OrderBy          *OrderBy
	Direction        *Direction
	Limit            *int
	Offset           *int
	Tags             *string
}

// NewGetTopSearchesOptions creates an instance of the GetTopSearchesOptions used to add optional parameters to GetTopSearchesWithOptions.
func NewGetTopSearchesOptions() *GetTopSearchesOptions {
	return &GetTopSearchesOptions{}
}

// WithClickAnalytics Whether to include metrics related to click and conversion events in the response.
func (o *GetTopSearchesOptions) WithClickAnalytics(clickAnalytics bool) *GetTopSearchesOptions {
	o.ClickAnalytics = &clickAnalytics

	return o
}

// WithRevenueAnalytics Whether to include metrics related to revenue events in the response.
func (o *GetTopSearchesOptions) WithRevenueAnalytics(revenueAnalytics bool) *GetTopSearchesOptions {
	o.RevenueAnalytics = &revenueAnalytics

	return o
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetTopSearchesOptions) WithStartDate(startDate string) *GetTopSearchesOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetTopSearchesOptions) WithEndDate(endDate string) *GetTopSearchesOptions {
	o.EndDate = &endDate

	return o
}

// WithOrderBy Attribute by which to order the response items.  If the `clickAnalytics` parameter is false, only `searchCount` is available.
func (o *GetTopSearchesOptions) WithOrderBy(orderBy OrderBy) *GetTopSearchesOptions {
	o.OrderBy = &orderBy

	return o
}

// WithDirection Sorting direction of the results: ascending or descending.
func (o *GetTopSearchesOptions) WithDirection(direction Direction) *GetTopSearchesOptions {
	o.Direction = &direction

	return o
}

// WithLimit Number of items to return.
func (o *GetTopSearchesOptions) WithLimit(limit int) *GetTopSearchesOptions {
	o.Limit = &limit

	return o
}

// WithOffset Position of the first item to return.
func (o *GetTopSearchesOptions) WithOffset(offset int) *GetTopSearchesOptions {
	o.Offset = &offset

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetTopSearchesOptions) WithTags(tags string) *GetTopSearchesOptions {
	o.Tags = &tags

	return o
}

// GetTopSearches Returns the most popular searches. For each search, it also includes the average number of hits.
//
// # If you set the `clickAnalytics` query parameter to `true`, the response also includes
//
// - Tracked searches count. Tracked searches are Search API requests with the `clickAnalytics` parameter set to `true`. This differs from the response's `count`, which shows the overall number of searches, including those where `clickAnalytics` is `false`.
// - Click count
// - Click-through rate (CTR)
// - Conversion count
// - Conversion rate (CR)
// - Average click position
//
// If you set the `revenueAnalytics` query parameter to `true`, the response also includes:
//
// - Add-to-cart count
// - Add-to-cart rate (ATCR)
// - Purchase count
// - Purchase rate
// - Revenue details for each currency
//
// **There's a difference between 0% rates and null rates:**
//
// - **Null** means there were no queries: since Algolia didn't receive any events, the rates (CTR, CR, ATCR, purchase rate) are null.
// - **0% rates** mean there _were_ queries but no [click or conversion events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - clickAnalytics - Whether to include metrics related to click and conversion events in the response. (in optionalParams)
//   - revenueAnalytics - Whether to include metrics related to revenue events in the response. (in optionalParams)
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - orderBy - Attribute by which to order the response items.  If the `clickAnalytics` parameter is false, only `searchCount` is available.  (in optionalParams)
//   - direction - Sorting direction of the results: ascending or descending.  (in optionalParams)
//   - limit - Number of items to return.  (in optionalParams)
//   - offset - Position of the first item to return.  (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTopSearches(
	ctx context.Context,
	index string,
	optionalParams *GetTopSearchesOptions,
	opts ...RequestOption,
) (*GetTopSearchesResponse, error) {
	var returnValue *GetTopSearchesResponse

	res, resBody, err := c.GetTopSearchesWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetTopSearchesWithHTTPInfo calls the API and returns the raw response from it.
// Returns the most popular searches. For each search, it also includes the average number of hits.
//
// # If you set the `clickAnalytics` query parameter to `true`, the response also includes
//
// - Tracked searches count. Tracked searches are Search API requests with the `clickAnalytics` parameter set to `true`. This differs from the response's `count`, which shows the overall number of searches, including those where `clickAnalytics` is `false`.
// - Click count
// - Click-through rate (CTR)
// - Conversion count
// - Conversion rate (CR)
// - Average click position
//
// If you set the `revenueAnalytics` query parameter to `true`, the response also includes:
//
// - Add-to-cart count
// - Add-to-cart rate (ATCR)
// - Purchase count
// - Purchase rate
// - Revenue details for each currency
//
// **There's a difference between 0% rates and null rates:**
//
// - **Null** means there were no queries: since Algolia didn't receive any events, the rates (CTR, CR, ATCR, purchase rate) are null.
// - **0% rates** mean there _were_ queries but no [click or conversion events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - clickAnalytics - Whether to include metrics related to click and conversion events in the response. (in optionalParams)
//   - revenueAnalytics - Whether to include metrics related to revenue events in the response. (in optionalParams)
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - orderBy - Attribute by which to order the response items.  If the `clickAnalytics` parameter is false, only `searchCount` is available.  (in optionalParams)
//   - direction - Sorting direction of the results: ascending or descending.  (in optionalParams)
//   - limit - Number of items to return.  (in optionalParams)
//   - offset - Position of the first item to return.  (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTopSearchesWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetTopSearchesOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/searches"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetTopSearches`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.ClickAnalytics) {
		conf.queryParams.Set("clickAnalytics", utils.QueryParameterToString(*optionalParams.ClickAnalytics))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.RevenueAnalytics) {
		conf.queryParams.Set("revenueAnalytics", utils.QueryParameterToString(*optionalParams.RevenueAnalytics))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.OrderBy) {
		conf.queryParams.Set("orderBy", utils.QueryParameterToString(*optionalParams.OrderBy))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Direction) {
		conf.queryParams.Set("direction", utils.QueryParameterToString(*optionalParams.Direction))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Limit) {
		conf.queryParams.Set("limit", utils.QueryParameterToString(*optionalParams.Limit))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*optionalParams.Offset))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetUsersCountOptions represents the optional params for the API call.
type GetUsersCountOptions struct {
	StartDate *string
	EndDate   *string
	Tags      *string
}

// NewGetUsersCountOptions creates an instance of the GetUsersCountOptions used to add optional parameters to GetUsersCountWithOptions.
func NewGetUsersCountOptions() *GetUsersCountOptions {
	return &GetUsersCountOptions{}
}

// WithStartDate Start date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetUsersCountOptions) WithStartDate(startDate string) *GetUsersCountOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate End date of the period to analyze, in `YYYY-MM-DD` format.
func (o *GetUsersCountOptions) WithEndDate(endDate string) *GetUsersCountOptions {
	o.EndDate = &endDate

	return o
}

// WithTags Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
func (o *GetUsersCountOptions) WithTags(tags string) *GetUsersCountOptions {
	o.Tags = &tags

	return o
}

// GetUsersCount Retrieves the number of unique users within a time range, including a daily breakdown.
//
// Since it returns the number of unique users, the sum of the daily values might be different from the total number.
//
// By default:
//
// - Algolia distinguishes search users by their IP address, _unless_ you include a pseudonymous user identifier in your search requests with the `userToken` API parameter or `x-algolia-usertoken` request header.
// - The analyzed period includes the last eight days including the current day.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetUsersCount(
	ctx context.Context,
	index string,
	optionalParams *GetUsersCountOptions,
	opts ...RequestOption,
) (*GetUsersCountResponse, error) {
	var returnValue *GetUsersCountResponse

	res, resBody, err := c.GetUsersCountWithHTTPInfo(ctx, index, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetUsersCountWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the number of unique users within a time range, including a daily breakdown.
//
// Since it returns the number of unique users, the sum of the daily values might be different from the total number.
//
// By default:
//
// - Algolia distinguishes search users by their IP address, _unless_ you include a pseudonymous user identifier in your search requests with the `userToken` API parameter or `x-algolia-usertoken` request header.
// - The analyzed period includes the last eight days including the current day.
//
// Required API Key ACLs:
//   - analytics
//
// Parameters:
//   - index - Index name.
//   - startDate - Start date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - endDate - End date of the period to analyze, in `YYYY-MM-DD` format. (in optionalParams)
//   - tags - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetUsersCountWithHTTPInfo(
	ctx context.Context,
	index string,
	optionalParams *GetUsersCountOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/users/count"

	if index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetUsersCount`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(index))

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*optionalParams.Tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}
