// The Algolia Search API lets you search, configure, and manage your indices and records.
//
// ## Client libraries
//
// Use Algolia's API clients and libraries to reliably integrate Algolia's APIs with your apps.
// The official API clients are covered by Algolia's [Service Level Agreement](https://www.algolia.com/policies/sla).
//
// See: [Algolia's ecosystem](https://www.algolia.com/doc/guides/getting-started/how-algolia-works/in-depth/ecosystem)
//
// ## Base URLs
//
// The base URLs for requests to the Search API are:
//
//   - `https://{APPLICATION_ID}.algolia.net`
//   - `https://{APPLICATION_ID}-dsn.algolia.net`.
//     If your subscription includes a [Distributed Search Network](https://dashboard.algolia.com/infra),
//     this ensures that requests are sent to servers closest to users.
//
// Both URLs provide high availability by distributing requests with load balancing.
//
// **All requests must use HTTPS.**
//
// ## Retry strategy
//
// To guarantee high availability, implement a retry strategy for all API requests using the URLs of your servers as fallbacks:
//
// - `https://{APPLICATION_ID}-1.algolianet.com`
// - `https://{APPLICATION_ID}-2.algolianet.com`
// - `https://{APPLICATION_ID}-3.algolianet.com`
//
// These URLs use a different DNS provider than the primary URLs.
// You should randomize this list to ensure an even load across the three servers.
//
// All Algolia API clients implement this retry strategy.
//
// ## Authentication
//
// To authenticate your API requests, add these headers:
//
//   - `x-algolia-application-id`. Your Algolia application ID.
//   - `x-algolia-api-key`. An API key with the necessary permissions to make the request.
//     The required access control list (ACL) to make a request is listed in each endpoint's reference.
//
// You can find your application ID and API key in the [Algolia dashboard](https://dashboard.algolia.com/account/api-keys).
//
// ## Request format
//
// Depending on the endpoint, request bodies are either JSON objects or arrays of JSON objects,
//
// ## Parameters
//
// Parameters are passed as query parameters for GET and DELETE requests,
// and in the request body for POST and PUT requests.
//
// Query parameters must be [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding).
// Non-ASCII characters must be UTF-8 encoded.
// Plus characters (`+`) are interpreted as spaces.
// Arrays as query parameters must be one of:
//
// - A comma-separated string: `attributesToRetrieve=title,description`
// - A URL-encoded JSON array: `attributesToRetrieve=%5B%22title%22,%22description%22%D`
//
// ## Response status and errors
//
// The Search API returns JSON responses.
// Since JSON doesn't guarantee any specific ordering, don't rely on the order of attributes in the API response.
//
// Successful responses return a `2xx` status. Client errors return a `4xx` status. Server errors are indicated by a `5xx` status.
// Error responses have a `message` property with more information.
//
// ## Version
//
// The current version of the Search API is version 1, as indicated by the `/1/` in each endpoint's URL.
package search

// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import (
	"cmp"
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/errs"
	"github.com/algolia/algoliasearch-client-go/v4/algolia/next/ingestion"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/transport"
	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type config struct {
	// -- Request options for API calls
	queryParams  url.Values
	headerParams map[string]string
	timeouts     transport.RequestConfiguration

	// -- ChunkedBatch options
	waitForTasks bool
	batchSize    int

	// -- Partial update options
	createIfNotExists bool

	// -- ReplaceAllObjects options
	scopes []ScopeType

	// -- Iterable options
	maxRetries int
	timeout    func(int) time.Duration
	aggregator func(any, error)

	// -- WaitForApiKey options
	apiKey *ApiKey
}

type RequestOption interface {
	apply(*config)
}

type requestOption func(*config)

func (r requestOption) apply(c *config) {
	r(c)
}

func WithHeaderParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.headerParams[key] = utils.ParameterToString(value)
	})
}

func WithQueryParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.queryParams.Set(utils.QueryParameterToString(key), utils.QueryParameterToString(value))
	})
}

func WithReadTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ReadTimeout = &timeout
	})
}

func WithWriteTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.WriteTimeout = &timeout
	})
}

func WithConnectTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ConnectTimeout = &timeout
	})
}

// --------- PartialUpdateObjects options ---------

type PartialUpdateObjectsOption interface {
	ChunkedBatchOption
	partialUpdateObjects()
}

type partialUpdateObjectsOption func(*config)

var (
	_ PartialUpdateObjectsOption = (*partialUpdateObjectsOption)(nil)
	_ PartialUpdateObjectsOption = (*chunkedBatchOption)(nil)
	_ PartialUpdateObjectsOption = (*requestOption)(nil)
)

func (p partialUpdateObjectsOption) apply(c *config) {
	p(c)
}

func (p partialUpdateObjectsOption) partialUpdateObjects() {}

func (p partialUpdateObjectsOption) chunkedBatch() {}

func (c chunkedBatchOption) partialUpdateObjects() {}

func (r requestOption) partialUpdateObjects() {}

// WithCreateIfNotExists to be provided if non-existing objects are passed, otherwise, the call will fail.
func WithCreateIfNotExists(createIfNotExists bool) partialUpdateObjectsOption {
	return partialUpdateObjectsOption(func(c *config) {
		c.createIfNotExists = createIfNotExists
	})
}

// --------- ReplaceAllObjects options ---------

type ReplaceAllObjectsOption interface {
	ChunkedBatchOption
	replaceAllObjects()
}

type replaceAllObjectsOption func(*config)

var (
	_ ReplaceAllObjectsOption = (*replaceAllObjectsOption)(nil)
	_ ReplaceAllObjectsOption = (*chunkedBatchOption)(nil)
	_ ReplaceAllObjectsOption = (*requestOption)(nil)
)

func (p replaceAllObjectsOption) apply(c *config) {
	p(c)
}

func (p replaceAllObjectsOption) replaceAllObjects() {}

func (p replaceAllObjectsOption) chunkedBatch() {}

func (c chunkedBatchOption) replaceAllObjects() {}

func (r requestOption) replaceAllObjects() {}

// WithScopes the `scopes` to keep from the index. Defaults to ['settings', 'rules', 'synonyms'].
func WithScopes(scopes []ScopeType) replaceAllObjectsOption {
	return replaceAllObjectsOption(func(c *config) {
		c.scopes = scopes
	})
}

// --------- WaitForKey options ---------.

type WaitForApiKeyOption interface {
	IterableOption
	waitForApiKey()
}

type waitForApiKeyOption func(*config)

var (
	_ WaitForApiKeyOption = (*waitForApiKeyOption)(nil)
	_ WaitForApiKeyOption = (*iterableOption)(nil)
	_ WaitForApiKeyOption = (*requestOption)(nil)
)

func (w waitForApiKeyOption) apply(c *config) {
	w(c)
}

func (w waitForApiKeyOption) waitForApiKey() {}

func (w waitForApiKeyOption) iterable() {}

func (r requestOption) waitForApiKey() {}

func (i iterableOption) waitForApiKey() {}

// WithApiKey necessary to know if an `update` operation has been processed, compare fields of the response with it. (optional - mandatory if operation is UPDATE).
func WithApiKey(apiKey *ApiKey) waitForApiKeyOption {
	return waitForApiKeyOption(func(c *config) {
		c.apiKey = apiKey
	})
}

// --------- Helper to convert options ---------

func toRequestOptions[T RequestOption](opts []T) []RequestOption {
	requestOpts := make([]RequestOption, 0, len(opts))

	for _, opt := range opts {
		requestOpts = append(requestOpts, opt)
	}

	return requestOpts
}

// toIngestionChunkedBatchOptions converts the current chunked batch opts to ingestion ones.
func toIngestionChunkedBatchOptions(opts []ChunkedBatchOption) []ingestion.ChunkedBatchOption {
	conf := config{}

	for _, opt := range opts {
		opt.apply(&conf)
	}

	ingestionOpts := make([]ingestion.ChunkedBatchOption, 0, len(opts))

	if conf.batchSize > 0 {
		ingestionOpts = append(ingestionOpts, ingestion.WithBatchSize(conf.batchSize))
	}

	ingestionOpts = append(ingestionOpts, ingestion.WithWaitForTasks(conf.waitForTasks))

	return ingestionOpts
}

func toIterableOptions(opts []ChunkedBatchOption) []IterableOption {
	iterableOpts := make([]IterableOption, 0, len(opts))

	for _, opt := range opts {
		if opt, ok := opt.(IterableOption); ok {
			iterableOpts = append(iterableOpts, opt)
		}
	}

	return iterableOpts
}

func waitForApiKeyToIterableOptions(opts []WaitForApiKeyOption) []IterableOption {
	iterableOpts := make([]IterableOption, 0, len(opts))

	for _, opt := range opts {
		if opt, ok := opt.(IterableOption); ok {
			iterableOpts = append(iterableOpts, opt)
		}
	}

	return iterableOpts
}

func replaceAllObjectsToIterableOptions(opts []ReplaceAllObjectsOption) []IterableOption {
	iterableOpts := make([]IterableOption, 0, len(opts))

	for _, opt := range opts {
		if opt, ok := opt.(IterableOption); ok {
			iterableOpts = append(iterableOpts, opt)
		}
	}

	return iterableOpts
}

func partialUpdateObjectsToChunkedBatchOptions(opts []PartialUpdateObjectsOption) []ChunkedBatchOption {
	chunkedBatchOpts := make([]ChunkedBatchOption, 0, len(opts))

	for _, opt := range opts {
		if opt, ok := opt.(ChunkedBatchOption); ok {
			chunkedBatchOpts = append(chunkedBatchOpts, opt)
		}
	}

	return chunkedBatchOpts
}

func replaceAllObjectsToChunkBatchOptions(opts []ReplaceAllObjectsOption) []ChunkedBatchOption {
	chunkedBatchOpts := make([]ChunkedBatchOption, 0, len(opts))

	for _, opt := range opts {
		if opt, ok := opt.(ChunkedBatchOption); ok {
			chunkedBatchOpts = append(chunkedBatchOpts, opt)
		}
	}

	return chunkedBatchOpts
}

// AddApiKeyOptions represents the optional params for the API call.
type AddApiKeyOptions struct {
	Description            *string
	Indexes                *[]string
	MaxHitsPerQuery        *int
	MaxQueriesPerIPPerHour *int
	QueryParameters        *string
	Referers               *[]string
	Validity               *int
}

// NewAddApiKeyOptions creates an instance of the AddApiKeyOptions used to add optional parameters to AddApiKeyWithOptions.
func NewAddApiKeyOptions() *AddApiKeyOptions {
	return &AddApiKeyOptions{}
}

// WithDescription Description of an API key to help you identify this API key.
func (o *AddApiKeyOptions) WithDescription(description string) *AddApiKeyOptions {
	o.Description = &description

	return o
}

// WithIndexes Index names or patterns that this API key can access. By default, an API key can access all indices in the same application.  You can use leading and trailing wildcard characters (`*`):  - `dev_*` matches all indices starting with \"dev_\". - `*_dev` matches all indices ending with \"_dev\". - `*_products_*` matches all indices containing \"_products_\".
func (o *AddApiKeyOptions) WithIndexes(indexes []string) *AddApiKeyOptions {
	o.Indexes = &indexes

	return o
}

// WithMaxHitsPerQuery Maximum number of results this API key can retrieve in one query. By default, there's no limit.
func (o *AddApiKeyOptions) WithMaxHitsPerQuery(maxHitsPerQuery int) *AddApiKeyOptions {
	o.MaxHitsPerQuery = &maxHitsPerQuery

	return o
}

// WithMaxQueriesPerIPPerHour Maximum number of API requests allowed per IP address or [user token](https://www.algolia.com/doc/guides/sending-events/concepts/usertoken) per hour.  If this limit is reached, the API returns an error with status code `429`. By default, there's no limit.
func (o *AddApiKeyOptions) WithMaxQueriesPerIPPerHour(maxQueriesPerIPPerHour int) *AddApiKeyOptions {
	o.MaxQueriesPerIPPerHour = &maxQueriesPerIPPerHour

	return o
}

// WithQueryParameters Query parameters to add when making API requests with this API key.  To restrict this API key to specific IP addresses, add the `restrictSources` parameter. You can only add a single source, but you can provide a range of IP addresses.  Creating an API key fails if the request is made from an IP address outside the restricted range.
func (o *AddApiKeyOptions) WithQueryParameters(queryParameters string) *AddApiKeyOptions {
	o.QueryParameters = &queryParameters

	return o
}

// WithReferers Allowed HTTP referrers for this API key.  By default, all referrers are allowed. You can use leading and trailing wildcard characters (`*`):  - `https://algolia.com/_*` allows all referrers starting with \"https://algolia.com/\" - `*.algolia.com` allows all referrers ending with \".algolia.com\" - `*algolia.com*` allows all referrers in the domain \"algolia.com\".  Like all HTTP headers, referrers can be spoofed. Don't rely on them to secure your data. For more information, see [HTTP referrer restrictions](https://www.algolia.com/doc/guides/security/security-best-practices/#http-referrers-restrictions).
func (o *AddApiKeyOptions) WithReferers(referers []string) *AddApiKeyOptions {
	o.Referers = &referers

	return o
}

// WithValidity Duration (in seconds) after which the API key expires. By default, API keys don't expire.
func (o *AddApiKeyOptions) WithValidity(validity int) *AddApiKeyOptions {
	o.Validity = &validity

	return o
}

// AddApiKey Creates a new API key with specific permissions and restrictions.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - acl - Permissions that determine the type of API requests this key can make. The required ACL is listed in each endpoint's reference. For more information, see [access control list](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl).
//   - description - Description of an API key to help you identify this API key. (in optionalParams)
//   - indexes - Index names or patterns that this API key can access. By default, an API key can access all indices in the same application.  You can use leading and trailing wildcard characters (`*`):  - `dev_*` matches all indices starting with \"dev_\". - `*_dev` matches all indices ending with \"_dev\". - `*_products_*` matches all indices containing \"_products_\".  (in optionalParams)
//   - maxHitsPerQuery - Maximum number of results this API key can retrieve in one query. By default, there's no limit.  (in optionalParams)
//   - maxQueriesPerIPPerHour - Maximum number of API requests allowed per IP address or [user token](https://www.algolia.com/doc/guides/sending-events/concepts/usertoken) per hour.  If this limit is reached, the API returns an error with status code `429`. By default, there's no limit.  (in optionalParams)
//   - queryParameters - Query parameters to add when making API requests with this API key.  To restrict this API key to specific IP addresses, add the `restrictSources` parameter. You can only add a single source, but you can provide a range of IP addresses.  Creating an API key fails if the request is made from an IP address outside the restricted range.  (in optionalParams)
//   - referers - Allowed HTTP referrers for this API key.  By default, all referrers are allowed. You can use leading and trailing wildcard characters (`*`):  - `https://algolia.com/_*` allows all referrers starting with \"https://algolia.com/\" - `*.algolia.com` allows all referrers ending with \".algolia.com\" - `*algolia.com*` allows all referrers in the domain \"algolia.com\".  Like all HTTP headers, referrers can be spoofed. Don't rely on them to secure your data. For more information, see [HTTP referrer restrictions](https://www.algolia.com/doc/guides/security/security-best-practices/#http-referrers-restrictions).  (in optionalParams)
//   - validity - Duration (in seconds) after which the API key expires. By default, API keys don't expire.  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) AddApiKey(ctx context.Context, acl []Acl, optionalParams *AddApiKeyOptions, opts ...RequestOption) (*AddApiKeyResponse, error) {
	var returnValue *AddApiKeyResponse

	res, resBody, err := c.AddApiKeyWithHTTPInfo(ctx, acl, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// AddApiKeyWithHTTPInfo calls the API and returns the raw response from it.
// Creates a new API key with specific permissions and restrictions.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - acl - Permissions that determine the type of API requests this key can make. The required ACL is listed in each endpoint's reference. For more information, see [access control list](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl).
//   - description - Description of an API key to help you identify this API key. (in optionalParams)
//   - indexes - Index names or patterns that this API key can access. By default, an API key can access all indices in the same application.  You can use leading and trailing wildcard characters (`*`):  - `dev_*` matches all indices starting with \"dev_\". - `*_dev` matches all indices ending with \"_dev\". - `*_products_*` matches all indices containing \"_products_\".  (in optionalParams)
//   - maxHitsPerQuery - Maximum number of results this API key can retrieve in one query. By default, there's no limit.  (in optionalParams)
//   - maxQueriesPerIPPerHour - Maximum number of API requests allowed per IP address or [user token](https://www.algolia.com/doc/guides/sending-events/concepts/usertoken) per hour.  If this limit is reached, the API returns an error with status code `429`. By default, there's no limit.  (in optionalParams)
//   - queryParameters - Query parameters to add when making API requests with this API key.  To restrict this API key to specific IP addresses, add the `restrictSources` parameter. You can only add a single source, but you can provide a range of IP addresses.  Creating an API key fails if the request is made from an IP address outside the restricted range.  (in optionalParams)
//   - referers - Allowed HTTP referrers for this API key.  By default, all referrers are allowed. You can use leading and trailing wildcard characters (`*`):  - `https://algolia.com/_*` allows all referrers starting with \"https://algolia.com/\" - `*.algolia.com` allows all referrers ending with \".algolia.com\" - `*algolia.com*` allows all referrers in the domain \"algolia.com\".  Like all HTTP headers, referrers can be spoofed. Don't rely on them to secure your data. For more information, see [HTTP referrer restrictions](https://www.algolia.com/doc/guides/security/security-best-practices/#http-referrers-restrictions).  (in optionalParams)
//   - validity - Duration (in seconds) after which the API key expires. By default, API keys don't expire.  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) AddApiKeyWithHTTPInfo(
	ctx context.Context,
	acl []Acl,
	optionalParams *AddApiKeyOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/keys"

	if len(acl) == 0 {
		return nil, nil, reportError("Parameter `acl` is required when calling `AddApiKey`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Acl                    []Acl     `json:"acl"`
		Description            *string   `json:"description,omitempty"`
		Indexes                *[]string `json:"indexes,omitempty"`
		MaxHitsPerQuery        *int      `json:"maxHitsPerQuery,omitempty"`
		MaxQueriesPerIPPerHour *int      `json:"maxQueriesPerIPPerHour,omitempty"`
		QueryParameters        *string   `json:"queryParameters,omitempty"`
		Referers               *[]string `json:"referers,omitempty"`
		Validity               *int      `json:"validity,omitempty"`
	}{
		Acl: acl,
	}
	if optionalParams != nil {
		postBody.Description = optionalParams.Description
		postBody.Indexes = optionalParams.Indexes
		postBody.MaxHitsPerQuery = optionalParams.MaxHitsPerQuery
		postBody.MaxQueriesPerIPPerHour = optionalParams.MaxQueriesPerIPPerHour
		postBody.QueryParameters = optionalParams.QueryParameters
		postBody.Referers = optionalParams.Referers
		postBody.Validity = optionalParams.Validity
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// AddOrUpdateObject If a record with the specified object ID exists, the existing record is replaced.
// Otherwise, a new record is added to the index.
//
// If you want to use auto-generated object IDs, use the [`saveObject` operation](https://www.algolia.com/doc/rest-api/search/save-object).
// To update _some_ attributes of an existing record, use the [`partial` operation](https://www.algolia.com/doc/rest-api/search/partial-update-object) instead.
// To add, update, or replace multiple records, use the [`batch` operation](https://www.algolia.com/doc/rest-api/search/batch).
//
// Required API Key ACLs:
//   - addObject
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique record identifier.
//   - body - The record. A schemaless object with attributes that are useful in the context of search and discovery.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) AddOrUpdateObject(
	ctx context.Context,
	indexName string,
	objectID string,
	body map[string]any,
	opts ...RequestOption,
) (*UpdatedAtWithObjectIdResponse, error) {
	var returnValue *UpdatedAtWithObjectIdResponse

	res, resBody, err := c.AddOrUpdateObjectWithHTTPInfo(ctx, indexName, objectID, body, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// AddOrUpdateObjectWithHTTPInfo calls the API and returns the raw response from it.
// If a record with the specified object ID exists, the existing record is replaced.
// Otherwise, a new record is added to the index.
//
// If you want to use auto-generated object IDs, use the [`saveObject` operation](https://www.algolia.com/doc/rest-api/search/save-object).
// To update _some_ attributes of an existing record, use the [`partial` operation](https://www.algolia.com/doc/rest-api/search/partial-update-object) instead.
// To add, update, or replace multiple records, use the [`batch` operation](https://www.algolia.com/doc/rest-api/search/batch).
//
// Required API Key ACLs:
//   - addObject
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique record identifier.
//   - body - The record. A schemaless object with attributes that are useful in the context of search and discovery.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) AddOrUpdateObjectWithHTTPInfo(
	ctx context.Context,
	indexName string,
	objectID string,
	body map[string]any,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(objectID)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `AddOrUpdateObject`.")
	}

	if objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `AddOrUpdateObject`.")
	}

	if len(body) == 0 {
		return nil, nil, reportError("Parameter `body` is required when calling `AddOrUpdateObject`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := body

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// AppendSource Adds a source to the list of allowed sources.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - source - IP address range of the source.
//   - description - Source description.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) AppendSource(ctx context.Context, source string, description *string, opts ...RequestOption) (*CreatedAtResponse, error) {
	var returnValue *CreatedAtResponse

	res, resBody, err := c.AppendSourceWithHTTPInfo(ctx, source, description, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// AppendSourceWithHTTPInfo calls the API and returns the raw response from it.
// Adds a source to the list of allowed sources.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - source - IP address range of the source.
//   - description - Source description.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) AppendSourceWithHTTPInfo(
	ctx context.Context,
	source string,
	description *string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/security/sources/append"

	if source == "" {
		return nil, nil, reportError("Parameter `source` is required when calling `AppendSource`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Source      string  `json:"source"`
		Description *string `json:"description,omitempty"`
	}{
		Source:      source,
		Description: description,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// AssignUserId Assigns or moves a user ID to a cluster.
//
// The time it takes to move a user is proportional to the amount of data linked to the user ID.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - xAlgoliaUserID - Unique identifier of the user who makes the search request.
//   - cluster - Cluster name.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: AssignUserId is deprecated.
func (c *APIClient) AssignUserId(ctx context.Context, xAlgoliaUserID string, cluster string, opts ...RequestOption) (*CreatedAtResponse, error) {
	var returnValue *CreatedAtResponse

	res, resBody, err := c.AssignUserIdWithHTTPInfo(ctx, xAlgoliaUserID, cluster, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// AssignUserIdWithHTTPInfo calls the API and returns the raw response from it.
// Assigns or moves a user ID to a cluster.
//
// The time it takes to move a user is proportional to the amount of data linked to the user ID.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - xAlgoliaUserID - Unique identifier of the user who makes the search request.
//   - cluster - Cluster name.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: AssignUserId is deprecated.
func (c *APIClient) AssignUserIdWithHTTPInfo(
	ctx context.Context,
	xAlgoliaUserID string,
	cluster string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/clusters/mapping"

	if xAlgoliaUserID == "" {
		return nil, nil, reportError("Parameter `xAlgoliaUserID` is required when calling `AssignUserId`.")
	}

	if cluster == "" {
		return nil, nil, reportError("Parameter `cluster` is required when calling `AssignUserId`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.headerParams["X-Algolia-User-ID"] = utils.ParameterToString(xAlgoliaUserID)

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Cluster string `json:"cluster"`
	}{
		Cluster: cluster,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// Batch Adds, updates, or deletes records in one index with a single API request.
//
// Batching index updates reduces latency and increases data integrity.
//
// - Actions are applied in the order they're specified.
// - Actions are equivalent to the individual API requests of the same name.
//
// This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).

// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - requests
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) Batch(ctx context.Context, indexName string, requests []BatchRequest, opts ...RequestOption) (*BatchResponse, error) {
	var returnValue *BatchResponse

	res, resBody, err := c.BatchWithHTTPInfo(ctx, indexName, requests, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// BatchWithHTTPInfo calls the API and returns the raw response from it.
// Adds, updates, or deletes records in one index with a single API request.
//
// Batching index updates reduces latency and increases data integrity.
//
// - Actions are applied in the order they're specified.
// - Actions are equivalent to the individual API requests of the same name.
//
// This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).

// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - requests
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) BatchWithHTTPInfo(
	ctx context.Context,
	indexName string,
	requests []BatchRequest,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/batch"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `Batch`.")
	}

	if len(requests) == 0 {
		return nil, nil, reportError("Parameter `requests` is required when calling `Batch`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Requests []BatchRequest `json:"requests"`
	}{
		Requests: requests,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// BatchAssignUserIds Assigns multiple user IDs to a cluster.
//
// **You can't move users with this operation**.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - xAlgoliaUserID - Unique identifier of the user who makes the search request.
//   - cluster - Cluster name.
//   - users - User IDs to assign.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: BatchAssignUserIds is deprecated.
func (c *APIClient) BatchAssignUserIds(
	ctx context.Context,
	xAlgoliaUserID string,
	cluster string,
	users []string,
	opts ...RequestOption,
) (*CreatedAtResponse, error) {
	var returnValue *CreatedAtResponse

	res, resBody, err := c.BatchAssignUserIdsWithHTTPInfo(ctx, xAlgoliaUserID, cluster, users, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// BatchAssignUserIdsWithHTTPInfo calls the API and returns the raw response from it.
// Assigns multiple user IDs to a cluster.
//
// **You can't move users with this operation**.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - xAlgoliaUserID - Unique identifier of the user who makes the search request.
//   - cluster - Cluster name.
//   - users - User IDs to assign.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: BatchAssignUserIds is deprecated.
func (c *APIClient) BatchAssignUserIdsWithHTTPInfo(
	ctx context.Context,
	xAlgoliaUserID string,
	cluster string,
	users []string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/clusters/mapping/batch"

	if xAlgoliaUserID == "" {
		return nil, nil, reportError("Parameter `xAlgoliaUserID` is required when calling `BatchAssignUserIds`.")
	}

	if cluster == "" {
		return nil, nil, reportError("Parameter `cluster` is required when calling `BatchAssignUserIds`.")
	}

	if len(users) == 0 {
		return nil, nil, reportError("Parameter `users` is required when calling `BatchAssignUserIds`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.headerParams["X-Algolia-User-ID"] = utils.ParameterToString(xAlgoliaUserID)

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Cluster string   `json:"cluster"`
		Users   []string `json:"users"`
	}{
		Cluster: cluster,
		Users:   users,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// BatchDictionaryEntries Adds or deletes multiple entries from your plurals, segmentation, or stop word dictionaries.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - dictionaryName - Dictionary type in which to search.
//   - requests - List of additions and deletions to your dictionaries.
//   - clearExistingDictionaryEntries - Whether to replace all custom entries in the dictionary with the ones sent with this request.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) BatchDictionaryEntries(
	ctx context.Context,
	dictionaryName DictionaryType,
	requests []BatchDictionaryEntriesRequest,
	clearExistingDictionaryEntries *bool,
	opts ...RequestOption,
) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.BatchDictionaryEntriesWithHTTPInfo(ctx, dictionaryName, requests, clearExistingDictionaryEntries, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// BatchDictionaryEntriesWithHTTPInfo calls the API and returns the raw response from it.
// Adds or deletes multiple entries from your plurals, segmentation, or stop word dictionaries.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - dictionaryName - Dictionary type in which to search.
//   - requests - List of additions and deletions to your dictionaries.
//   - clearExistingDictionaryEntries - Whether to replace all custom entries in the dictionary with the ones sent with this request.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) BatchDictionaryEntriesWithHTTPInfo(
	ctx context.Context,
	dictionaryName DictionaryType,
	requests []BatchDictionaryEntriesRequest,
	clearExistingDictionaryEntries *bool,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/dictionaries/{dictionaryName}/batch"
	requestPath = strings.ReplaceAll(requestPath, "{dictionaryName}", url.PathEscape(utils.ParameterToString(dictionaryName)))

	if len(requests) == 0 {
		return nil, nil, reportError("Parameter `requests` is required when calling `BatchDictionaryEntries`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		ClearExistingDictionaryEntries *bool                           `json:"clearExistingDictionaryEntries,omitempty"`
		Requests                       []BatchDictionaryEntriesRequest `json:"requests"`
	}{
		ClearExistingDictionaryEntries: clearExistingDictionaryEntries,
		Requests:                       requests,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// Browse Retrieves records from an index, up to 1,000 per request.
//
// While searching retrieves _hits_ (records augmented with attributes for highlighting and ranking details),
// browsing _just_ returns matching records.
// This can be useful if you want to export your indices.
//
//   - The Analytics API doesn't collect data when using `browse`.
//   - Records are ranked by attributes and custom ranking.
//   - There's no ranking for: typo-tolerance, number of matched words, proximity, geo distance.
//
// Browse requests automatically apply these settings:
//   - `advancedSyntax`: `false`
//   - `attributesToHighlight`: `[]`
//   - `attributesToSnippet`: `[]`
//   - `distinct`: `false`
//   - `enablePersonalization`: `false`
//   - `enableRules`: `false`
//   - `facets`: `[]`
//   - `getRankingInfo`: `false`
//   - `ignorePlurals`: `false`
//   - `optionalFilters`: `[]`
//   - `typoTolerance`: `true` or `false` (`min` and `strict` evaluate to `true`)
//
// If you send these parameters with your browse requests, they'll be ignored.
//
// Required API Key ACLs:
//   - browse
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - browseParams
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) Browse(ctx context.Context, indexName string, browseParams *BrowseParams, opts ...RequestOption) (*BrowseResponse, error) {
	var returnValue *BrowseResponse

	res, resBody, err := c.BrowseWithHTTPInfo(ctx, indexName, browseParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// BrowseWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves records from an index, up to 1,000 per request.
//
// While searching retrieves _hits_ (records augmented with attributes for highlighting and ranking details),
// browsing _just_ returns matching records.
// This can be useful if you want to export your indices.
//
//   - The Analytics API doesn't collect data when using `browse`.
//   - Records are ranked by attributes and custom ranking.
//   - There's no ranking for: typo-tolerance, number of matched words, proximity, geo distance.
//
// Browse requests automatically apply these settings:
//   - `advancedSyntax`: `false`
//   - `attributesToHighlight`: `[]`
//   - `attributesToSnippet`: `[]`
//   - `distinct`: `false`
//   - `enablePersonalization`: `false`
//   - `enableRules`: `false`
//   - `facets`: `[]`
//   - `getRankingInfo`: `false`
//   - `ignorePlurals`: `false`
//   - `optionalFilters`: `[]`
//   - `typoTolerance`: `true` or `false` (`min` and `strict` evaluate to `true`)
//
// If you send these parameters with your browse requests, they'll be ignored.
//
// Required API Key ACLs:
//   - browse
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - browseParams
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) BrowseWithHTTPInfo(
	ctx context.Context,
	indexName string,
	browseParams *BrowseParams,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/browse"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `Browse`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	var postBody any = "{}"
	if !utils.IsNilOrEmpty(browseParams) {
		postBody = browseParams
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}

// ClearObjects Deletes only the records from an index while keeping settings, synonyms, and rules.
// This operation is resource-intensive and subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
//
// Required API Key ACLs:
//   - deleteIndex
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ClearObjects(ctx context.Context, indexName string, opts ...RequestOption) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.ClearObjectsWithHTTPInfo(ctx, indexName, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ClearObjectsWithHTTPInfo calls the API and returns the raw response from it.
// Deletes only the records from an index while keeping settings, synonyms, and rules.
// This operation is resource-intensive and subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
//
// Required API Key ACLs:
//   - deleteIndex
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ClearObjectsWithHTTPInfo(ctx context.Context, indexName string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/clear"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `ClearObjects`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ClearRules Deletes all rules from the index.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - forwardToReplicas - Whether changes are applied to replica indices.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ClearRules(ctx context.Context, indexName string, forwardToReplicas *bool, opts ...RequestOption) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.ClearRulesWithHTTPInfo(ctx, indexName, forwardToReplicas, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ClearRulesWithHTTPInfo calls the API and returns the raw response from it.
// Deletes all rules from the index.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - forwardToReplicas - Whether changes are applied to replica indices.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ClearRulesWithHTTPInfo(
	ctx context.Context,
	indexName string,
	forwardToReplicas *bool,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/rules/clear"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `ClearRules`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(forwardToReplicas) {
		conf.queryParams.Set("forwardToReplicas", utils.QueryParameterToString(*forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ClearSynonyms Deletes all synonyms from the index.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - forwardToReplicas - Whether changes are applied to replica indices.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ClearSynonyms(ctx context.Context, indexName string, forwardToReplicas *bool, opts ...RequestOption) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.ClearSynonymsWithHTTPInfo(ctx, indexName, forwardToReplicas, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ClearSynonymsWithHTTPInfo calls the API and returns the raw response from it.
// Deletes all synonyms from the index.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - forwardToReplicas - Whether changes are applied to replica indices.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ClearSynonymsWithHTTPInfo(
	ctx context.Context,
	indexName string,
	forwardToReplicas *bool,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/synonyms/clear"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `ClearSynonyms`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(forwardToReplicas) {
		conf.queryParams.Set("forwardToReplicas", utils.QueryParameterToString(*forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomDelete This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomDelete(ctx context.Context, path string, parameters map[string]any, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomDeleteWithHTTPInfo(ctx, path, parameters, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomDeleteWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomDeleteWithHTTPInfo(
	ctx context.Context,
	path string,
	parameters map[string]any,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(parameters) {
		for k, v := range parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomGet This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomGet(ctx context.Context, path string, parameters map[string]any, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomGetWithHTTPInfo(ctx, path, parameters, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomGetWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomGetWithHTTPInfo(
	ctx context.Context,
	path string,
	parameters map[string]any,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(parameters) {
		for k, v := range parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomPostOptions represents the optional params for the API call.
type CustomPostOptions struct {
	Parameters map[string]any
	Body       map[string]any
}

// NewCustomPostOptions creates an instance of the CustomPostOptions used to add optional parameters to CustomPostWithOptions.
func NewCustomPostOptions() *CustomPostOptions {
	return &CustomPostOptions{}
}

// WithParameters Query parameters to apply to the current query.
func (o *CustomPostOptions) WithParameters(parameters map[string]any) *CustomPostOptions {
	o.Parameters = parameters

	return o
}

// WithBody Parameters to send with the custom request.
func (o *CustomPostOptions) WithBody(body map[string]any) *CustomPostOptions {
	o.Body = body

	return o
}

// CustomPost This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPost(ctx context.Context, path string, optionalParams *CustomPostOptions, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPostWithHTTPInfo(ctx, path, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomPostWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPostWithHTTPInfo(
	ctx context.Context,
	path string,
	optionalParams *CustomPostOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Parameters) {
		for k, v := range optionalParams.Parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	var postBody any = "{}"
	if optionalParams != nil {
		postBody = optionalParams.Body
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomPutOptions represents the optional params for the API call.
type CustomPutOptions struct {
	Parameters map[string]any
	Body       map[string]any
}

// NewCustomPutOptions creates an instance of the CustomPutOptions used to add optional parameters to CustomPutWithOptions.
func NewCustomPutOptions() *CustomPutOptions {
	return &CustomPutOptions{}
}

// WithParameters Query parameters to apply to the current query.
func (o *CustomPutOptions) WithParameters(parameters map[string]any) *CustomPutOptions {
	o.Parameters = parameters

	return o
}

// WithBody Parameters to send with the custom request.
func (o *CustomPutOptions) WithBody(body map[string]any) *CustomPutOptions {
	o.Body = body

	return o
}

// CustomPut This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPut(ctx context.Context, path string, optionalParams *CustomPutOptions, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPutWithHTTPInfo(ctx, path, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomPutWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPutWithHTTPInfo(
	ctx context.Context,
	path string,
	optionalParams *CustomPutOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Parameters) {
		for k, v := range optionalParams.Parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	var postBody any = "{}"
	if optionalParams != nil {
		postBody = optionalParams.Body
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteApiKey Deletes the API key.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - key - API key.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteApiKey(ctx context.Context, key string, opts ...RequestOption) (*DeleteApiKeyResponse, error) {
	var returnValue *DeleteApiKeyResponse

	res, resBody, err := c.DeleteApiKeyWithHTTPInfo(ctx, key, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteApiKeyWithHTTPInfo calls the API and returns the raw response from it.
// Deletes the API key.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - key - API key.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteApiKeyWithHTTPInfo(ctx context.Context, key string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/keys/{key}"
	requestPath = strings.ReplaceAll(requestPath, "{key}", url.PathEscape(utils.ParameterToString(key)))

	if key == "" {
		return nil, nil, reportError("Parameter `key` is required when calling `DeleteApiKey`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteByOptions represents the optional params for the API call.
type DeleteByOptions struct {
	FacetFilters      *FacetFilters
	Filters           *string
	NumericFilters    *NumericFilters
	TagFilters        *TagFilters
	AroundLatLng      *string
	AroundRadius      *AroundRadius
	InsideBoundingBox *InsideBoundingBox
	InsidePolygon     *[][]float64
}

// NewDeleteByOptions creates an instance of the DeleteByOptions used to add optional parameters to DeleteByWithOptions.
func NewDeleteByOptions() *DeleteByOptions {
	return &DeleteByOptions{}
}

// WithFacetFilters adds the facetFilters to the ApiDeleteByRequest and returns the request for chaining.
func (o *DeleteByOptions) WithFacetFilters(facetFilters *FacetFilters) *DeleteByOptions {
	o.FacetFilters = facetFilters

	return o
}

// WithFilters Filter expression to only include items that match the filter criteria in the response.  You can use these filter expressions:  - **Numeric filters.** `<facet> <op> <number>`, where `<op>` is one of `<`, `<=`, `=`, `!=`, `>`, `>=`. - **Ranges.** `<facet>:<lower> TO <upper>` where `<lower>` and `<upper>` are the lower and upper limits of the range (inclusive). - **Facet filters.** `<facet>:<value>` where `<facet>` is a facet attribute (case-sensitive) and `<value>` a facet value. - **Tag filters.** `_tags:<value>` or just `<value>` (case-sensitive). - **Boolean filters.** `<facet>: true | false`.  You can combine filters with `AND`, `OR`, and `NOT` operators with the following restrictions:  - You can only combine filters of the same type with `OR`.   **Not supported:** `facet:value OR num > 3`. - You can't use `NOT` with combinations of filters.   **Not supported:** `NOT(facet:value OR facet:value)` - You can't combine conjunctions (`AND`) with `OR`.   **Not supported:** `facet:value OR (facet:value AND facet:value)`  Use quotes around your filters, if the facet attribute name or facet value has spaces, keywords (`OR`, `AND`, `NOT`), or quotes. If a facet attribute is an array, the filter matches if it matches at least one element of the array.  For more information, see [Filters](https://www.algolia.com/doc/guides/managing-results/refine-results/filtering).
func (o *DeleteByOptions) WithFilters(filters string) *DeleteByOptions {
	o.Filters = &filters

	return o
}

// WithNumericFilters adds the numericFilters to the ApiDeleteByRequest and returns the request for chaining.
func (o *DeleteByOptions) WithNumericFilters(numericFilters *NumericFilters) *DeleteByOptions {
	o.NumericFilters = numericFilters

	return o
}

// WithTagFilters adds the tagFilters to the ApiDeleteByRequest and returns the request for chaining.
func (o *DeleteByOptions) WithTagFilters(tagFilters *TagFilters) *DeleteByOptions {
	o.TagFilters = tagFilters

	return o
}

// WithAroundLatLng Coordinates for the center of a circle, expressed as a comma-separated string of latitude and longitude.  Only records included within a circle around this central location are included in the results. The radius of the circle is determined by the `aroundRadius` and `minimumAroundRadius` settings. This parameter is ignored if you also specify `insidePolygon` or `insideBoundingBox`.
func (o *DeleteByOptions) WithAroundLatLng(aroundLatLng string) *DeleteByOptions {
	o.AroundLatLng = &aroundLatLng

	return o
}

// WithAroundRadius adds the aroundRadius to the ApiDeleteByRequest and returns the request for chaining.
func (o *DeleteByOptions) WithAroundRadius(aroundRadius *AroundRadius) *DeleteByOptions {
	o.AroundRadius = aroundRadius

	return o
}

// WithInsideBoundingBox adds the insideBoundingBox to the ApiDeleteByRequest and returns the request for chaining.
func (o *DeleteByOptions) WithInsideBoundingBox(insideBoundingBox *InsideBoundingBox) *DeleteByOptions {
	o.InsideBoundingBox = insideBoundingBox

	return o
}

// WithInsidePolygon Coordinates of a polygon in which to search.  Polygons are defined by 3 to 10,000 points. Each point is represented by its latitude and longitude. Provide multiple polygons as nested arrays. For more information, see [filtering inside polygons](https://www.algolia.com/doc/guides/managing-results/refine-results/geolocation/#filtering-inside-rectangular-or-polygonal-areas). This parameter is ignored if you also specify `insideBoundingBox`.
func (o *DeleteByOptions) WithInsidePolygon(insidePolygon [][]float64) *DeleteByOptions {
	o.InsidePolygon = &insidePolygon

	return o
}

// DeleteBy This operation doesn't accept empty filters.
//
// This operation is resource-intensive.
// You should only use it if you can't get the object IDs of the records you want to delete.
// It's more efficient to get a list of object IDs with the [`browse` operation](https://www.algolia.com/doc/rest-api/search/browse),
// and then delete the records using the [`batch` operation](https://www.algolia.com/doc/rest-api/search/batch).
//
// This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
//
// Required API Key ACLs:
//   - deleteIndex
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - facetFilters  (in optionalParams)
//   - filters - Filter expression to only include items that match the filter criteria in the response.  You can use these filter expressions:  - **Numeric filters.** `<facet> <op> <number>`, where `<op>` is one of `<`, `<=`, `=`, `!=`, `>`, `>=`. - **Ranges.** `<facet>:<lower> TO <upper>` where `<lower>` and `<upper>` are the lower and upper limits of the range (inclusive). - **Facet filters.** `<facet>:<value>` where `<facet>` is a facet attribute (case-sensitive) and `<value>` a facet value. - **Tag filters.** `_tags:<value>` or just `<value>` (case-sensitive). - **Boolean filters.** `<facet>: true | false`.  You can combine filters with `AND`, `OR`, and `NOT` operators with the following restrictions:  - You can only combine filters of the same type with `OR`.   **Not supported:** `facet:value OR num > 3`. - You can't use `NOT` with combinations of filters.   **Not supported:** `NOT(facet:value OR facet:value)` - You can't combine conjunctions (`AND`) with `OR`.   **Not supported:** `facet:value OR (facet:value AND facet:value)`  Use quotes around your filters, if the facet attribute name or facet value has spaces, keywords (`OR`, `AND`, `NOT`), or quotes. If a facet attribute is an array, the filter matches if it matches at least one element of the array.  For more information, see [Filters](https://www.algolia.com/doc/guides/managing-results/refine-results/filtering).  (in optionalParams)
//   - numericFilters  (in optionalParams)
//   - tagFilters  (in optionalParams)
//   - aroundLatLng - Coordinates for the center of a circle, expressed as a comma-separated string of latitude and longitude.  Only records included within a circle around this central location are included in the results. The radius of the circle is determined by the `aroundRadius` and `minimumAroundRadius` settings. This parameter is ignored if you also specify `insidePolygon` or `insideBoundingBox`.  (in optionalParams)
//   - aroundRadius  (in optionalParams)
//   - insideBoundingBox  (in optionalParams)
//   - insidePolygon - Coordinates of a polygon in which to search.  Polygons are defined by 3 to 10,000 points. Each point is represented by its latitude and longitude. Provide multiple polygons as nested arrays. For more information, see [filtering inside polygons](https://www.algolia.com/doc/guides/managing-results/refine-results/geolocation/#filtering-inside-rectangular-or-polygonal-areas). This parameter is ignored if you also specify `insideBoundingBox`.  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteBy(
	ctx context.Context,
	indexName string,
	optionalParams *DeleteByOptions,
	opts ...RequestOption,
) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.DeleteByWithHTTPInfo(ctx, indexName, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteByWithHTTPInfo calls the API and returns the raw response from it.
// This operation doesn't accept empty filters.
//
// This operation is resource-intensive.
// You should only use it if you can't get the object IDs of the records you want to delete.
// It's more efficient to get a list of object IDs with the [`browse` operation](https://www.algolia.com/doc/rest-api/search/browse),
// and then delete the records using the [`batch` operation](https://www.algolia.com/doc/rest-api/search/batch).
//
// This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
//
// Required API Key ACLs:
//   - deleteIndex
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - facetFilters  (in optionalParams)
//   - filters - Filter expression to only include items that match the filter criteria in the response.  You can use these filter expressions:  - **Numeric filters.** `<facet> <op> <number>`, where `<op>` is one of `<`, `<=`, `=`, `!=`, `>`, `>=`. - **Ranges.** `<facet>:<lower> TO <upper>` where `<lower>` and `<upper>` are the lower and upper limits of the range (inclusive). - **Facet filters.** `<facet>:<value>` where `<facet>` is a facet attribute (case-sensitive) and `<value>` a facet value. - **Tag filters.** `_tags:<value>` or just `<value>` (case-sensitive). - **Boolean filters.** `<facet>: true | false`.  You can combine filters with `AND`, `OR`, and `NOT` operators with the following restrictions:  - You can only combine filters of the same type with `OR`.   **Not supported:** `facet:value OR num > 3`. - You can't use `NOT` with combinations of filters.   **Not supported:** `NOT(facet:value OR facet:value)` - You can't combine conjunctions (`AND`) with `OR`.   **Not supported:** `facet:value OR (facet:value AND facet:value)`  Use quotes around your filters, if the facet attribute name or facet value has spaces, keywords (`OR`, `AND`, `NOT`), or quotes. If a facet attribute is an array, the filter matches if it matches at least one element of the array.  For more information, see [Filters](https://www.algolia.com/doc/guides/managing-results/refine-results/filtering).  (in optionalParams)
//   - numericFilters  (in optionalParams)
//   - tagFilters  (in optionalParams)
//   - aroundLatLng - Coordinates for the center of a circle, expressed as a comma-separated string of latitude and longitude.  Only records included within a circle around this central location are included in the results. The radius of the circle is determined by the `aroundRadius` and `minimumAroundRadius` settings. This parameter is ignored if you also specify `insidePolygon` or `insideBoundingBox`.  (in optionalParams)
//   - aroundRadius  (in optionalParams)
//   - insideBoundingBox  (in optionalParams)
//   - insidePolygon - Coordinates of a polygon in which to search.  Polygons are defined by 3 to 10,000 points. Each point is represented by its latitude and longitude. Provide multiple polygons as nested arrays. For more information, see [filtering inside polygons](https://www.algolia.com/doc/guides/managing-results/refine-results/geolocation/#filtering-inside-rectangular-or-polygonal-areas). This parameter is ignored if you also specify `insideBoundingBox`.  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteByWithHTTPInfo(
	ctx context.Context,
	indexName string,
	optionalParams *DeleteByOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/deleteByQuery"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `DeleteBy`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		FacetFilters      *FacetFilters      `json:"facetFilters,omitempty"`
		Filters           *string            `json:"filters,omitempty"`
		NumericFilters    *NumericFilters    `json:"numericFilters,omitempty"`
		TagFilters        *TagFilters        `json:"tagFilters,omitempty"`
		AroundLatLng      *string            `json:"aroundLatLng,omitempty"`
		AroundRadius      *AroundRadius      `json:"aroundRadius,omitempty"`
		InsideBoundingBox *InsideBoundingBox `json:"insideBoundingBox,omitempty"`
		InsidePolygon     *[][]float64       `json:"insidePolygon,omitempty"`
	}{}
	if optionalParams != nil {
		postBody.FacetFilters = optionalParams.FacetFilters
		postBody.Filters = optionalParams.Filters
		postBody.NumericFilters = optionalParams.NumericFilters
		postBody.TagFilters = optionalParams.TagFilters
		postBody.AroundLatLng = optionalParams.AroundLatLng
		postBody.AroundRadius = optionalParams.AroundRadius
		postBody.InsideBoundingBox = optionalParams.InsideBoundingBox
		postBody.InsidePolygon = optionalParams.InsidePolygon
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteIndex Deletes an index and all its settings.
//
//   - Deleting an index doesn't delete its analytics data.
//   - If you try to delete a non-existing index, the operation is ignored without warning.
//   - If the index you want to delete has replica indices, the replicas become independent indices.
//   - If the index you want to delete is a replica index, you must first unlink it from its primary index before you can delete it.
//     For more information, see [Delete replica indices](https://www.algolia.com/doc/guides/managing-results/refine-results/sorting/how-to/deleting-replicas).
//
// Required API Key ACLs:
//   - deleteIndex
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteIndex(ctx context.Context, indexName string, opts ...RequestOption) (*DeletedAtResponse, error) {
	var returnValue *DeletedAtResponse

	res, resBody, err := c.DeleteIndexWithHTTPInfo(ctx, indexName, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteIndexWithHTTPInfo calls the API and returns the raw response from it.
// Deletes an index and all its settings.
//
//   - Deleting an index doesn't delete its analytics data.
//   - If you try to delete a non-existing index, the operation is ignored without warning.
//   - If the index you want to delete has replica indices, the replicas become independent indices.
//   - If the index you want to delete is a replica index, you must first unlink it from its primary index before you can delete it.
//     For more information, see [Delete replica indices](https://www.algolia.com/doc/guides/managing-results/refine-results/sorting/how-to/deleting-replicas).
//
// Required API Key ACLs:
//   - deleteIndex
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteIndexWithHTTPInfo(ctx context.Context, indexName string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `DeleteIndex`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteObject Deletes a record by its object ID.
//
// To delete more than one record, use the [`batch` operation](https://www.algolia.com/doc/rest-api/search/batch).
// To delete records matching a query, use the [`deleteBy` operation](https://www.algolia.com/doc/rest-api/search/delete-by).
//
// Required API Key ACLs:
//   - deleteObject
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique record identifier.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteObject(ctx context.Context, indexName string, objectID string, opts ...RequestOption) (*DeletedAtResponse, error) {
	var returnValue *DeletedAtResponse

	res, resBody, err := c.DeleteObjectWithHTTPInfo(ctx, indexName, objectID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteObjectWithHTTPInfo calls the API and returns the raw response from it.
// Deletes a record by its object ID.
//
// To delete more than one record, use the [`batch` operation](https://www.algolia.com/doc/rest-api/search/batch).
// To delete records matching a query, use the [`deleteBy` operation](https://www.algolia.com/doc/rest-api/search/delete-by).
//
// Required API Key ACLs:
//   - deleteObject
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique record identifier.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteObjectWithHTTPInfo(
	ctx context.Context,
	indexName string,
	objectID string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(objectID)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `DeleteObject`.")
	}

	if objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `DeleteObject`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteRule Deletes a rule by its ID.
// To find the object ID for rules,
// use the [`search` operation](https://www.algolia.com/doc/rest-api/search/search-rules).
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique identifier of a rule object.
//   - forwardToReplicas - Whether changes are applied to replica indices.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteRule(
	ctx context.Context,
	indexName string,
	objectID string,
	forwardToReplicas *bool,
	opts ...RequestOption,
) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.DeleteRuleWithHTTPInfo(ctx, indexName, objectID, forwardToReplicas, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteRuleWithHTTPInfo calls the API and returns the raw response from it.
// Deletes a rule by its ID.
// To find the object ID for rules,
// use the [`search` operation](https://www.algolia.com/doc/rest-api/search/search-rules).
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique identifier of a rule object.
//   - forwardToReplicas - Whether changes are applied to replica indices.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteRuleWithHTTPInfo(
	ctx context.Context,
	indexName string,
	objectID string,
	forwardToReplicas *bool,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/rules/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(objectID)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `DeleteRule`.")
	}

	if objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `DeleteRule`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(forwardToReplicas) {
		conf.queryParams.Set("forwardToReplicas", utils.QueryParameterToString(*forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteSource Deletes a source from the list of allowed sources.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - source - IP address range of the source.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteSource(ctx context.Context, source string, opts ...RequestOption) (*DeleteSourceResponse, error) {
	var returnValue *DeleteSourceResponse

	res, resBody, err := c.DeleteSourceWithHTTPInfo(ctx, source, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteSourceWithHTTPInfo calls the API and returns the raw response from it.
// Deletes a source from the list of allowed sources.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - source - IP address range of the source.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteSourceWithHTTPInfo(ctx context.Context, source string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/security/sources/{source}"
	requestPath = strings.ReplaceAll(requestPath, "{source}", url.PathEscape(utils.ParameterToString(source)))

	if source == "" {
		return nil, nil, reportError("Parameter `source` is required when calling `DeleteSource`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteSynonym Deletes a synonym by its ID.
// To find the object IDs of your synonyms, use the [`search` operation](https://www.algolia.com/doc/rest-api/search/search-synonyms).
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique identifier of a synonym object.
//   - forwardToReplicas - Whether changes are applied to replica indices.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteSynonym(
	ctx context.Context,
	indexName string,
	objectID string,
	forwardToReplicas *bool,
	opts ...RequestOption,
) (*DeletedAtResponse, error) {
	var returnValue *DeletedAtResponse

	res, resBody, err := c.DeleteSynonymWithHTTPInfo(ctx, indexName, objectID, forwardToReplicas, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteSynonymWithHTTPInfo calls the API and returns the raw response from it.
// Deletes a synonym by its ID.
// To find the object IDs of your synonyms, use the [`search` operation](https://www.algolia.com/doc/rest-api/search/search-synonyms).
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique identifier of a synonym object.
//   - forwardToReplicas - Whether changes are applied to replica indices.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteSynonymWithHTTPInfo(
	ctx context.Context,
	indexName string,
	objectID string,
	forwardToReplicas *bool,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/synonyms/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(objectID)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `DeleteSynonym`.")
	}

	if objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `DeleteSynonym`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(forwardToReplicas) {
		conf.queryParams.Set("forwardToReplicas", utils.QueryParameterToString(*forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetApiKey Gets the permissions and restrictions of an API key.
//
// When authenticating with the admin API key, you can request information for any of your application's keys.
// When authenticating with other API keys, you can only retrieve information for that key,
// with the description replaced by `<redacted>`.

// Parameters:
//   - key - API key.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetApiKey(ctx context.Context, key string, opts ...RequestOption) (*GetApiKeyResponse, error) {
	var returnValue *GetApiKeyResponse

	res, resBody, err := c.GetApiKeyWithHTTPInfo(ctx, key, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetApiKeyWithHTTPInfo calls the API and returns the raw response from it.
// Gets the permissions and restrictions of an API key.
//
// When authenticating with the admin API key, you can request information for any of your application's keys.
// When authenticating with other API keys, you can only retrieve information for that key,
// with the description replaced by `<redacted>`.

// Parameters:
//   - key - API key.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetApiKeyWithHTTPInfo(ctx context.Context, key string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/keys/{key}"
	requestPath = strings.ReplaceAll(requestPath, "{key}", url.PathEscape(utils.ParameterToString(key)))

	if key == "" {
		return nil, nil, reportError("Parameter `key` is required when calling `GetApiKey`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetAppTask Checks the status of a given application task.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - taskID - Unique task identifier.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetAppTask(ctx context.Context, taskID int64, opts ...RequestOption) (*GetTaskResponse, error) {
	var returnValue *GetTaskResponse

	res, resBody, err := c.GetAppTaskWithHTTPInfo(ctx, taskID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetAppTaskWithHTTPInfo calls the API and returns the raw response from it.
// Checks the status of a given application task.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - taskID - Unique task identifier.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetAppTaskWithHTTPInfo(ctx context.Context, taskID int64, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/task/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetDictionaryLanguages Lists supported languages with their supported dictionary types and number of custom entries.
//
// Required API Key ACLs:
//   - settings
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetDictionaryLanguages(ctx context.Context, opts ...RequestOption) (*map[string]Languages, error) {
	var returnValue *map[string]Languages

	res, resBody, err := c.GetDictionaryLanguagesWithHTTPInfo(ctx, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetDictionaryLanguagesWithHTTPInfo calls the API and returns the raw response from it.
// Lists supported languages with their supported dictionary types and number of custom entries.
//
// Required API Key ACLs:
//   - settings
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetDictionaryLanguagesWithHTTPInfo(ctx context.Context, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/dictionaries/*/languages"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetDictionarySettings Retrieves the languages for which standard dictionary entries are turned off.
//
// Required API Key ACLs:
//   - settings
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetDictionarySettings(ctx context.Context, opts ...RequestOption) (*GetDictionarySettingsResponse, error) {
	var returnValue *GetDictionarySettingsResponse

	res, resBody, err := c.GetDictionarySettingsWithHTTPInfo(ctx, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetDictionarySettingsWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the languages for which standard dictionary entries are turned off.
//
// Required API Key ACLs:
//   - settings
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetDictionarySettingsWithHTTPInfo(ctx context.Context, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/dictionaries/*/settings"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetLogsOptions represents the optional params for the API call.
type GetLogsOptions struct {
	Offset    *int
	Length    *int
	IndexName *string
	Type      *LogType
}

// NewGetLogsOptions creates an instance of the GetLogsOptions used to add optional parameters to GetLogsWithOptions.
func NewGetLogsOptions() *GetLogsOptions {
	return &GetLogsOptions{}
}

// WithOffset First log entry to retrieve. The most recent entries are listed first.
func (o *GetLogsOptions) WithOffset(offset int) *GetLogsOptions {
	o.Offset = &offset

	return o
}

// WithLength Maximum number of entries to retrieve.
func (o *GetLogsOptions) WithLength(length int) *GetLogsOptions {
	o.Length = &length

	return o
}

// WithIndexName Index for which to retrieve log entries. By default, log entries are retrieved for all indices.
func (o *GetLogsOptions) WithIndexName(indexName string) *GetLogsOptions {
	o.IndexName = &indexName

	return o
}

// WithType Type of log entries to retrieve. By default, all log entries are retrieved.
func (o *GetLogsOptions) WithType(type_ LogType) *GetLogsOptions {
	o.Type = &type_

	return o
}

// GetLogs The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl).
//
// - Logs are held for the last seven days.
// - Up to 1,000 API requests per server are logged.
// - This request counts towards your [operations quota](https://support.algolia.com/hc/articles/17245378392977-How-does-Algolia-count-records-and-operations) but doesn't appear in the logs itself.
//
// Required API Key ACLs:
//   - logs
//
// Parameters:
//   - offset - First log entry to retrieve. The most recent entries are listed first. (in optionalParams)
//   - length - Maximum number of entries to retrieve. (in optionalParams)
//   - indexName - Index for which to retrieve log entries. By default, log entries are retrieved for all indices.  (in optionalParams)
//   - type_ - Type of log entries to retrieve. By default, all log entries are retrieved.  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetLogs(ctx context.Context, optionalParams *GetLogsOptions, opts ...RequestOption) (*GetLogsResponse, error) {
	var returnValue *GetLogsResponse

	res, resBody, err := c.GetLogsWithHTTPInfo(ctx, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetLogsWithHTTPInfo calls the API and returns the raw response from it.
// The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl).
//
// - Logs are held for the last seven days.
// - Up to 1,000 API requests per server are logged.
// - This request counts towards your [operations quota](https://support.algolia.com/hc/articles/17245378392977-How-does-Algolia-count-records-and-operations) but doesn't appear in the logs itself.
//
// Required API Key ACLs:
//   - logs
//
// Parameters:
//   - offset - First log entry to retrieve. The most recent entries are listed first. (in optionalParams)
//   - length - Maximum number of entries to retrieve. (in optionalParams)
//   - indexName - Index for which to retrieve log entries. By default, log entries are retrieved for all indices.  (in optionalParams)
//   - type_ - Type of log entries to retrieve. By default, all log entries are retrieved.  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetLogsWithHTTPInfo(ctx context.Context, optionalParams *GetLogsOptions, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/logs"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*optionalParams.Offset))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Length) {
		conf.queryParams.Set("length", utils.QueryParameterToString(*optionalParams.Length))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.IndexName) {
		conf.queryParams.Set("indexName", utils.QueryParameterToString(*optionalParams.IndexName))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Type) {
		conf.queryParams.Set("type", utils.QueryParameterToString(*optionalParams.Type))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetObject Retrieves one record by its object ID.
//
// To retrieve more than one record, use the [`objects` operation](https://www.algolia.com/doc/rest-api/search/get-objects).
//
// Required API Key ACLs:
//   - search
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique record identifier.
//   - attributesToRetrieve - Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned.  `objectID` is always retrieved.  Attributes included in `unretrievableAttributes` won't be retrieved unless the request is authenticated with the admin API key.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetObject(
	ctx context.Context,
	indexName string,
	objectID string,
	attributesToRetrieve *[]string,
	opts ...RequestOption,
) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.GetObjectWithHTTPInfo(ctx, indexName, objectID, attributesToRetrieve, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetObjectWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves one record by its object ID.
//
// To retrieve more than one record, use the [`objects` operation](https://www.algolia.com/doc/rest-api/search/get-objects).
//
// Required API Key ACLs:
//   - search
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique record identifier.
//   - attributesToRetrieve - Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned.  `objectID` is always retrieved.  Attributes included in `unretrievableAttributes` won't be retrieved unless the request is authenticated with the admin API key.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetObjectWithHTTPInfo(
	ctx context.Context,
	indexName string,
	objectID string,
	attributesToRetrieve *[]string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(objectID)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetObject`.")
	}

	if objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `GetObject`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(attributesToRetrieve) {
		conf.queryParams.Set("attributesToRetrieve", utils.QueryParameterToString(*attributesToRetrieve))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetObjects Retrieves one or more records, potentially from different indices.
//
// Records are returned in the same order as the requests.
//
// Required API Key ACLs:
//   - search
//
// Parameters:
//   - requests
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetObjects(ctx context.Context, requests []GetObjectsRequest, opts ...RequestOption) (*GetObjectsResponse, error) {
	var returnValue *GetObjectsResponse

	res, resBody, err := c.GetObjectsWithHTTPInfo(ctx, requests, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetObjectsWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves one or more records, potentially from different indices.
//
// Records are returned in the same order as the requests.
//
// Required API Key ACLs:
//   - search
//
// Parameters:
//   - requests
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetObjectsWithHTTPInfo(ctx context.Context, requests []GetObjectsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/*/objects"

	if len(requests) == 0 {
		return nil, nil, reportError("Parameter `requests` is required when calling `GetObjects`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Requests []GetObjectsRequest `json:"requests"`
	}{
		Requests: requests,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}

// GetRule Retrieves a rule by its ID.
// To find the object ID of rules, use the [`search` operation](https://www.algolia.com/doc/rest-api/search/search-rules).
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique identifier of a rule object.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetRule(ctx context.Context, indexName string, objectID string, opts ...RequestOption) (*Rule, error) {
	var returnValue *Rule

	res, resBody, err := c.GetRuleWithHTTPInfo(ctx, indexName, objectID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetRuleWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a rule by its ID.
// To find the object ID of rules, use the [`search` operation](https://www.algolia.com/doc/rest-api/search/search-rules).
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique identifier of a rule object.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetRuleWithHTTPInfo(
	ctx context.Context,
	indexName string,
	objectID string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/rules/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(objectID)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetRule`.")
	}

	if objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `GetRule`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetSettings Retrieves an object with non-null index settings.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - getVersion - When set to 2, the endpoint will not include `synonyms` in the response. This parameter is here for backward compatibility.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetSettings(ctx context.Context, indexName string, getVersion *int, opts ...RequestOption) (*SettingsResponse, error) {
	var returnValue *SettingsResponse

	res, resBody, err := c.GetSettingsWithHTTPInfo(ctx, indexName, getVersion, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetSettingsWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves an object with non-null index settings.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - getVersion - When set to 2, the endpoint will not include `synonyms` in the response. This parameter is here for backward compatibility.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetSettingsWithHTTPInfo(
	ctx context.Context,
	indexName string,
	getVersion *int,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/settings"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetSettings`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(getVersion) {
		conf.queryParams.Set("getVersion", utils.QueryParameterToString(*getVersion))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetSources Retrieves all allowed IP addresses with access to your application.
//
// Required API Key ACLs:
//   - admin
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetSources(ctx context.Context, opts ...RequestOption) ([]Source, error) {
	var returnValue []Source

	res, resBody, err := c.GetSourcesWithHTTPInfo(ctx, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetSourcesWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves all allowed IP addresses with access to your application.
//
// Required API Key ACLs:
//   - admin
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetSourcesWithHTTPInfo(ctx context.Context, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/security/sources"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetSynonym Retrieves a synonym by its ID.
// To find the object IDs for your synonyms,
// use the [`search` operation](https://www.algolia.com/doc/rest-api/search/search-synonyms).
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique identifier of a synonym object.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetSynonym(ctx context.Context, indexName string, objectID string, opts ...RequestOption) (*SynonymHit, error) {
	var returnValue *SynonymHit

	res, resBody, err := c.GetSynonymWithHTTPInfo(ctx, indexName, objectID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetSynonymWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a synonym by its ID.
// To find the object IDs for your synonyms,
// use the [`search` operation](https://www.algolia.com/doc/rest-api/search/search-synonyms).
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique identifier of a synonym object.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetSynonymWithHTTPInfo(
	ctx context.Context,
	indexName string,
	objectID string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/synonyms/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(objectID)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetSynonym`.")
	}

	if objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `GetSynonym`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetTask Checks the status of a given task.
//
// Indexing tasks are asynchronous.
// When you add, update, or delete records or indices,
// a task is created on a queue and completed depending on the load on the server.
//
// The indexing tasks' responses include a task ID that you can use to check the status.
//
// Required API Key ACLs:
//   - addObject
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - taskID - Unique task identifier.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTask(ctx context.Context, indexName string, taskID int64, opts ...RequestOption) (*GetTaskResponse, error) {
	var returnValue *GetTaskResponse

	res, resBody, err := c.GetTaskWithHTTPInfo(ctx, indexName, taskID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetTaskWithHTTPInfo calls the API and returns the raw response from it.
// Checks the status of a given task.
//
// Indexing tasks are asynchronous.
// When you add, update, or delete records or indices,
// a task is created on a queue and completed depending on the load on the server.
//
// The indexing tasks' responses include a task ID that you can use to check the status.
//
// Required API Key ACLs:
//   - addObject
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - taskID - Unique task identifier.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTaskWithHTTPInfo(ctx context.Context, indexName string, taskID int64, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/task/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetTask`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetTopUserIds Get the IDs of the 10 users with the highest number of records per cluster.
//
// Since it can take a few seconds to get the data from the different clusters,
// the response isn't real-time.
//
// Required API Key ACLs:
//   - admin
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: GetTopUserIds is deprecated.
func (c *APIClient) GetTopUserIds(ctx context.Context, opts ...RequestOption) (*GetTopUserIdsResponse, error) {
	var returnValue *GetTopUserIdsResponse

	res, resBody, err := c.GetTopUserIdsWithHTTPInfo(ctx, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetTopUserIdsWithHTTPInfo calls the API and returns the raw response from it.
// Get the IDs of the 10 users with the highest number of records per cluster.
//
// Since it can take a few seconds to get the data from the different clusters,
// the response isn't real-time.
//
// Required API Key ACLs:
//   - admin
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: GetTopUserIds is deprecated.
func (c *APIClient) GetTopUserIdsWithHTTPInfo(ctx context.Context, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/clusters/mapping/top"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetUserId Returns the user ID data stored in the mapping.
//
// Since it can take a few seconds to get the data from the different clusters,
// the response isn't real-time.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - userID - Unique identifier of the user who makes the search request.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: GetUserId is deprecated.
func (c *APIClient) GetUserId(ctx context.Context, userID string, opts ...RequestOption) (*UserId, error) {
	var returnValue *UserId

	res, resBody, err := c.GetUserIdWithHTTPInfo(ctx, userID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetUserIdWithHTTPInfo calls the API and returns the raw response from it.
// Returns the user ID data stored in the mapping.
//
// Since it can take a few seconds to get the data from the different clusters,
// the response isn't real-time.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - userID - Unique identifier of the user who makes the search request.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: GetUserId is deprecated.
func (c *APIClient) GetUserIdWithHTTPInfo(ctx context.Context, userID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/clusters/mapping/{userID}"
	requestPath = strings.ReplaceAll(requestPath, "{userID}", url.PathEscape(utils.ParameterToString(userID)))

	if userID == "" {
		return nil, nil, reportError("Parameter `userID` is required when calling `GetUserId`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// HasPendingMappings To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - getClusters - Whether to include the cluster's pending mapping state in the response.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: HasPendingMappings is deprecated.
func (c *APIClient) HasPendingMappings(ctx context.Context, getClusters *bool, opts ...RequestOption) (*HasPendingMappingsResponse, error) {
	var returnValue *HasPendingMappingsResponse

	res, resBody, err := c.HasPendingMappingsWithHTTPInfo(ctx, getClusters, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// HasPendingMappingsWithHTTPInfo calls the API and returns the raw response from it.
// To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - getClusters - Whether to include the cluster's pending mapping state in the response.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: HasPendingMappings is deprecated.
func (c *APIClient) HasPendingMappingsWithHTTPInfo(ctx context.Context, getClusters *bool, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/clusters/mapping/pending"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(getClusters) {
		conf.queryParams.Set("getClusters", utils.QueryParameterToString(*getClusters))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ListApiKeys Lists all API keys associated with your Algolia application, including their permissions and restrictions.
//
// Required API Key ACLs:
//   - admin
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListApiKeys(ctx context.Context, opts ...RequestOption) (*ListApiKeysResponse, error) {
	var returnValue *ListApiKeysResponse

	res, resBody, err := c.ListApiKeysWithHTTPInfo(ctx, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ListApiKeysWithHTTPInfo calls the API and returns the raw response from it.
// Lists all API keys associated with your Algolia application, including their permissions and restrictions.
//
// Required API Key ACLs:
//   - admin
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListApiKeysWithHTTPInfo(ctx context.Context, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/keys"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ListClusters Lists the available clusters in a multi-cluster setup.
//
// Required API Key ACLs:
//   - admin
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: ListClusters is deprecated.
func (c *APIClient) ListClusters(ctx context.Context, opts ...RequestOption) (*ListClustersResponse, error) {
	var returnValue *ListClustersResponse

	res, resBody, err := c.ListClustersWithHTTPInfo(ctx, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ListClustersWithHTTPInfo calls the API and returns the raw response from it.
// Lists the available clusters in a multi-cluster setup.
//
// Required API Key ACLs:
//   - admin
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: ListClusters is deprecated.
func (c *APIClient) ListClustersWithHTTPInfo(ctx context.Context, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/clusters"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ListIndicesOptions represents the optional params for the API call.
type ListIndicesOptions struct {
	Page        *int
	HitsPerPage *int
}

// NewListIndicesOptions creates an instance of the ListIndicesOptions used to add optional parameters to ListIndicesWithOptions.
func NewListIndicesOptions() *ListIndicesOptions {
	return &ListIndicesOptions{}
}

// WithPage Requested page of the API response. If `null`, the API response is not paginated.
func (o *ListIndicesOptions) WithPage(page int) *ListIndicesOptions {
	o.Page = &page

	return o
}

// WithHitsPerPage Number of hits per page.
func (o *ListIndicesOptions) WithHitsPerPage(hitsPerPage int) *ListIndicesOptions {
	o.HitsPerPage = &hitsPerPage

	return o
}

// ListIndices Lists all indices in the current Algolia application.
//
// The request follows any index restrictions of the API key you use to make the request.
//
// Required API Key ACLs:
//   - listIndexes
//
// Parameters:
//   - page - Requested page of the API response. If `null`, the API response is not paginated.  (in optionalParams)
//   - hitsPerPage - Number of hits per page. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListIndices(ctx context.Context, optionalParams *ListIndicesOptions, opts ...RequestOption) (*ListIndicesResponse, error) {
	var returnValue *ListIndicesResponse

	res, resBody, err := c.ListIndicesWithHTTPInfo(ctx, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ListIndicesWithHTTPInfo calls the API and returns the raw response from it.
// Lists all indices in the current Algolia application.
//
// The request follows any index restrictions of the API key you use to make the request.
//
// Required API Key ACLs:
//   - listIndexes
//
// Parameters:
//   - page - Requested page of the API response. If `null`, the API response is not paginated.  (in optionalParams)
//   - hitsPerPage - Number of hits per page. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListIndicesWithHTTPInfo(
	ctx context.Context,
	optionalParams *ListIndicesOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*optionalParams.Page))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.HitsPerPage) {
		conf.queryParams.Set("hitsPerPage", utils.QueryParameterToString(*optionalParams.HitsPerPage))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ListUserIdsOptions represents the optional params for the API call.
type ListUserIdsOptions struct {
	Page        *int
	HitsPerPage *int
}

// Deprecated: ListUserIdsOptions is deprecated
// NewListUserIdsOptions creates an instance of the ListUserIdsOptions used to add optional parameters to ListUserIdsWithOptions.
func NewListUserIdsOptions() *ListUserIdsOptions {
	return &ListUserIdsOptions{}
}

// WithPage Requested page of the API response. If `null`, the API response is not paginated.
func (o *ListUserIdsOptions) WithPage(page int) *ListUserIdsOptions {
	o.Page = &page

	return o
}

// WithHitsPerPage Number of hits per page.
func (o *ListUserIdsOptions) WithHitsPerPage(hitsPerPage int) *ListUserIdsOptions {
	o.HitsPerPage = &hitsPerPage

	return o
}

// ListUserIds Lists the userIDs assigned to a multi-cluster application.
//
// Since it can take a few seconds to get the data from the different clusters,
// the response isn't real-time.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - page - Requested page of the API response. If `null`, the API response is not paginated.  (in optionalParams)
//   - hitsPerPage - Number of hits per page. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: ListUserIds is deprecated.
func (c *APIClient) ListUserIds(ctx context.Context, optionalParams *ListUserIdsOptions, opts ...RequestOption) (*ListUserIdsResponse, error) {
	var returnValue *ListUserIdsResponse

	res, resBody, err := c.ListUserIdsWithHTTPInfo(ctx, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ListUserIdsWithHTTPInfo calls the API and returns the raw response from it.
// Lists the userIDs assigned to a multi-cluster application.
//
// Since it can take a few seconds to get the data from the different clusters,
// the response isn't real-time.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - page - Requested page of the API response. If `null`, the API response is not paginated.  (in optionalParams)
//   - hitsPerPage - Number of hits per page. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: ListUserIds is deprecated.
func (c *APIClient) ListUserIdsWithHTTPInfo(
	ctx context.Context,
	optionalParams *ListUserIdsOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/clusters/mapping"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*optionalParams.Page))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.HitsPerPage) {
		conf.queryParams.Set("hitsPerPage", utils.QueryParameterToString(*optionalParams.HitsPerPage))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// MultipleBatch Adds, updates, or deletes records in multiple indices with a single API request.
//
// - Actions are applied in the order they are specified.
// - Actions are equivalent to the individual API requests of the same name.
//
// This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).

// Parameters:
//   - requests
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) MultipleBatch(ctx context.Context, requests []MultipleBatchRequest, opts ...RequestOption) (*MultipleBatchResponse, error) {
	var returnValue *MultipleBatchResponse

	res, resBody, err := c.MultipleBatchWithHTTPInfo(ctx, requests, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// MultipleBatchWithHTTPInfo calls the API and returns the raw response from it.
// Adds, updates, or deletes records in multiple indices with a single API request.
//
// - Actions are applied in the order they are specified.
// - Actions are equivalent to the individual API requests of the same name.
//
// This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).

// Parameters:
//   - requests
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) MultipleBatchWithHTTPInfo(
	ctx context.Context,
	requests []MultipleBatchRequest,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/*/batch"

	if len(requests) == 0 {
		return nil, nil, reportError("Parameter `requests` is required when calling `MultipleBatch`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Requests []MultipleBatchRequest `json:"requests"`
	}{
		Requests: requests,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// OperationIndex Copies or moves (renames) an index within the same Algolia application.
//
// - Existing destination indices are overwritten, except for their analytics data.
// - If the destination index doesn't exist yet, it'll be created.
// - This operation is resource-intensive.
//
// **Copy**
//
// - Copying a source index that doesn't exist creates a new index with 0 records and default settings.
// - The API keys of the source index are merged with the existing keys in the destination index.
// - You can't copy the `enableReRanking`, `mode`, and `replicas` settings.
// - You can't copy to a destination index that already has replicas.
// - Be aware of the [size limits](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits).
// - Related guide: [Copy indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/copy-indices)
//
// **Move**
//
//   - Moving a source index that doesn't exist is ignored without returning an error.
//   - When moving an index, the analytics data keeps its original name, and a new set of analytics data is started for the new name.
//     To access the original analytics in the dashboard, create an index with the original name.
//   - If the destination index has replicas, moving will overwrite the existing index and copy the data to the replica indices.
//   - Related guide: [Move indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/move-indices).
//
// This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
//
// Required API Key ACLs:
//   - addObject
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - operation
//   - destination - Index name (case-sensitive).
//   - scope - **Only for copying.**  If you specify a scope, only the selected scopes are copied. Records and the other scopes are left unchanged. If you omit the `scope` parameter, everything is copied: records, settings, synonyms, and rules.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) OperationIndex(
	ctx context.Context,
	indexName string,
	operation OperationType,
	destination string,
	scope *[]ScopeType,
	opts ...RequestOption,
) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.OperationIndexWithHTTPInfo(ctx, indexName, operation, destination, scope, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// OperationIndexWithHTTPInfo calls the API and returns the raw response from it.
// Copies or moves (renames) an index within the same Algolia application.
//
// - Existing destination indices are overwritten, except for their analytics data.
// - If the destination index doesn't exist yet, it'll be created.
// - This operation is resource-intensive.
//
// **Copy**
//
// - Copying a source index that doesn't exist creates a new index with 0 records and default settings.
// - The API keys of the source index are merged with the existing keys in the destination index.
// - You can't copy the `enableReRanking`, `mode`, and `replicas` settings.
// - You can't copy to a destination index that already has replicas.
// - Be aware of the [size limits](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits).
// - Related guide: [Copy indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/copy-indices)
//
// **Move**
//
//   - Moving a source index that doesn't exist is ignored without returning an error.
//   - When moving an index, the analytics data keeps its original name, and a new set of analytics data is started for the new name.
//     To access the original analytics in the dashboard, create an index with the original name.
//   - If the destination index has replicas, moving will overwrite the existing index and copy the data to the replica indices.
//   - Related guide: [Move indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/move-indices).
//
// This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
//
// Required API Key ACLs:
//   - addObject
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - operation
//   - destination - Index name (case-sensitive).
//   - scope - **Only for copying.**  If you specify a scope, only the selected scopes are copied. Records and the other scopes are left unchanged. If you omit the `scope` parameter, everything is copied: records, settings, synonyms, and rules.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) OperationIndexWithHTTPInfo(
	ctx context.Context,
	indexName string,
	operation OperationType,
	destination string,
	scope *[]ScopeType,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/operation"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `OperationIndex`.")
	}

	if destination == "" {
		return nil, nil, reportError("Parameter `destination` is required when calling `OperationIndex`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Operation   OperationType `json:"operation"`
		Destination string        `json:"destination"`
		Scope       *[]ScopeType  `json:"scope,omitempty"`
	}{
		Operation:   operation,
		Destination: destination,
		Scope:       scope,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// PartialUpdateObject Adds new attributes to a record, or updates existing ones.
//
//   - If a record with the specified object ID doesn't exist,
//     a new record is added to the index **if** `createIfNotExists` is true.
//   - If the index doesn't exist yet, this method creates a new index.
//   - You can use any first-level attribute but not nested attributes.
//     If you specify a nested attribute, this operation replaces its first-level ancestor.
//
// To update an attribute without pushing the entire record, you can use these built-in operations.
// These operations can be helpful if you don't have access to your initial data.
//
// - Increment: increment a numeric attribute
// - Decrement: decrement a numeric attribute
// - Add: append a number or string element to an array attribute
// - Remove: remove all matching number or string elements from an array attribute made of numbers or strings
// - AddUnique: add a number or string element to an array attribute made of numbers or strings only if it's not already present
// - IncrementFrom: increment a numeric integer attribute only if the provided value matches the current value, and otherwise ignore the whole object update. For example, if you pass an IncrementFrom value of 2 for the version attribute, but the current value of the attribute is 1, the engine ignores the update. If the object doesn't exist, the engine only creates it if you pass an IncrementFrom value of 0.
// - IncrementSet: increment a numeric integer attribute only if the provided value is greater than the current value, and otherwise ignore the whole object update. For example, if you pass an IncrementSet value of 2 for the version attribute, and the current value of the attribute is 1, the engine updates the object. If the object doesn't exist yet, the engine only creates it if you pass an IncrementSet value greater than 0.
//
// You can specify an operation by providing an object with the attribute to update as the key and its value being an object with the following properties:
//
// - _operation: the operation to apply on the attribute
// - value: the right-hand side argument to the operation, for example, increment or decrement step, value to add or remove.
//
// When updating multiple attributes or using multiple operations targeting the same record, you should use a single partial update for faster processing.
//
// This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
//
// Required API Key ACLs:
//   - addObject
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique record identifier.
//   - attributesToUpdate - Attributes with their values.
//   - createIfNotExists - Whether to create a new record if it doesn't exist.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) PartialUpdateObject(
	ctx context.Context,
	indexName string,
	objectID string,
	attributesToUpdate map[string]any,
	createIfNotExists *bool,
	opts ...RequestOption,
) (*UpdatedAtWithObjectIdResponse, error) {
	var returnValue *UpdatedAtWithObjectIdResponse

	res, resBody, err := c.PartialUpdateObjectWithHTTPInfo(ctx, indexName, objectID, attributesToUpdate, createIfNotExists, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// PartialUpdateObjectWithHTTPInfo calls the API and returns the raw response from it.
// Adds new attributes to a record, or updates existing ones.
//
//   - If a record with the specified object ID doesn't exist,
//     a new record is added to the index **if** `createIfNotExists` is true.
//   - If the index doesn't exist yet, this method creates a new index.
//   - You can use any first-level attribute but not nested attributes.
//     If you specify a nested attribute, this operation replaces its first-level ancestor.
//
// To update an attribute without pushing the entire record, you can use these built-in operations.
// These operations can be helpful if you don't have access to your initial data.
//
// - Increment: increment a numeric attribute
// - Decrement: decrement a numeric attribute
// - Add: append a number or string element to an array attribute
// - Remove: remove all matching number or string elements from an array attribute made of numbers or strings
// - AddUnique: add a number or string element to an array attribute made of numbers or strings only if it's not already present
// - IncrementFrom: increment a numeric integer attribute only if the provided value matches the current value, and otherwise ignore the whole object update. For example, if you pass an IncrementFrom value of 2 for the version attribute, but the current value of the attribute is 1, the engine ignores the update. If the object doesn't exist, the engine only creates it if you pass an IncrementFrom value of 0.
// - IncrementSet: increment a numeric integer attribute only if the provided value is greater than the current value, and otherwise ignore the whole object update. For example, if you pass an IncrementSet value of 2 for the version attribute, and the current value of the attribute is 1, the engine updates the object. If the object doesn't exist yet, the engine only creates it if you pass an IncrementSet value greater than 0.
//
// You can specify an operation by providing an object with the attribute to update as the key and its value being an object with the following properties:
//
// - _operation: the operation to apply on the attribute
// - value: the right-hand side argument to the operation, for example, increment or decrement step, value to add or remove.
//
// When updating multiple attributes or using multiple operations targeting the same record, you should use a single partial update for faster processing.
//
// This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
//
// Required API Key ACLs:
//   - addObject
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique record identifier.
//   - attributesToUpdate - Attributes with their values.
//   - createIfNotExists - Whether to create a new record if it doesn't exist.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) PartialUpdateObjectWithHTTPInfo(
	ctx context.Context,
	indexName string,
	objectID string,
	attributesToUpdate map[string]any,
	createIfNotExists *bool,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/{objectID}/partial"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(objectID)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `PartialUpdateObject`.")
	}

	if objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `PartialUpdateObject`.")
	}

	if len(attributesToUpdate) == 0 {
		return nil, nil, reportError("Parameter `attributesToUpdate` is required when calling `PartialUpdateObject`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(createIfNotExists) {
		conf.queryParams.Set("createIfNotExists", utils.QueryParameterToString(*createIfNotExists))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := attributesToUpdate

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// RemoveUserId Deletes a user ID and its associated data from the clusters.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - userID - Unique identifier of the user who makes the search request.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: RemoveUserId is deprecated.
func (c *APIClient) RemoveUserId(ctx context.Context, userID string, opts ...RequestOption) (*RemoveUserIdResponse, error) {
	var returnValue *RemoveUserIdResponse

	res, resBody, err := c.RemoveUserIdWithHTTPInfo(ctx, userID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// RemoveUserIdWithHTTPInfo calls the API and returns the raw response from it.
// Deletes a user ID and its associated data from the clusters.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - userID - Unique identifier of the user who makes the search request.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: RemoveUserId is deprecated.
func (c *APIClient) RemoveUserIdWithHTTPInfo(ctx context.Context, userID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/clusters/mapping/{userID}"
	requestPath = strings.ReplaceAll(requestPath, "{userID}", url.PathEscape(utils.ParameterToString(userID)))

	if userID == "" {
		return nil, nil, reportError("Parameter `userID` is required when calling `RemoveUserId`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ReplaceSources Replaces the list of allowed sources.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - source - Allowed sources.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ReplaceSources(ctx context.Context, source []Source, opts ...RequestOption) (*ReplaceSourceResponse, error) {
	var returnValue *ReplaceSourceResponse

	res, resBody, err := c.ReplaceSourcesWithHTTPInfo(ctx, source, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ReplaceSourcesWithHTTPInfo calls the API and returns the raw response from it.
// Replaces the list of allowed sources.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - source - Allowed sources.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ReplaceSourcesWithHTTPInfo(ctx context.Context, source []Source, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/security/sources"

	if len(source) == 0 {
		return nil, nil, reportError("Parameter `source` is required when calling `ReplaceSources`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := source

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// RestoreApiKey Restores a deleted API key.
//
// Restoring resets the `validity` attribute to `0`.
//
// Algolia stores up to 1,000 API keys per application.
// If you create more, the oldest API keys are deleted and can't be restored.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - key - API key.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) RestoreApiKey(ctx context.Context, key string, opts ...RequestOption) (*AddApiKeyResponse, error) {
	var returnValue *AddApiKeyResponse

	res, resBody, err := c.RestoreApiKeyWithHTTPInfo(ctx, key, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// RestoreApiKeyWithHTTPInfo calls the API and returns the raw response from it.
// Restores a deleted API key.
//
// Restoring resets the `validity` attribute to `0`.
//
// Algolia stores up to 1,000 API keys per application.
// If you create more, the oldest API keys are deleted and can't be restored.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - key - API key.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) RestoreApiKeyWithHTTPInfo(ctx context.Context, key string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/keys/{key}/restore"
	requestPath = strings.ReplaceAll(requestPath, "{key}", url.PathEscape(utils.ParameterToString(key)))

	if key == "" {
		return nil, nil, reportError("Parameter `key` is required when calling `RestoreApiKey`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// SaveObject Adds a record to an index or replaces it.
//
// - If the record doesn't have an object ID, a new record with an auto-generated object ID is added to your index.
// - If a record with the specified object ID exists, the existing record is replaced.
// - If a record with the specified object ID doesn't exist, a new record is added to your index.
// - If you add a record to an index that doesn't exist yet, a new index is created.
//
// To update _some_ attributes of a record, use the [`partial` operation](https://www.algolia.com/doc/rest-api/search/partial-update-object).
// To add, update, or replace multiple records, use the [`batch` operation](https://www.algolia.com/doc/rest-api/search/batch).
//
// This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
//
// Required API Key ACLs:
//   - addObject
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - body - The record. A schemaless object with attributes that are useful in the context of search and discovery.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SaveObject(ctx context.Context, indexName string, body map[string]any, opts ...RequestOption) (*SaveObjectResponse, error) {
	var returnValue *SaveObjectResponse

	res, resBody, err := c.SaveObjectWithHTTPInfo(ctx, indexName, body, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SaveObjectWithHTTPInfo calls the API and returns the raw response from it.
// Adds a record to an index or replaces it.
//
// - If the record doesn't have an object ID, a new record with an auto-generated object ID is added to your index.
// - If a record with the specified object ID exists, the existing record is replaced.
// - If a record with the specified object ID doesn't exist, a new record is added to your index.
// - If you add a record to an index that doesn't exist yet, a new index is created.
//
// To update _some_ attributes of a record, use the [`partial` operation](https://www.algolia.com/doc/rest-api/search/partial-update-object).
// To add, update, or replace multiple records, use the [`batch` operation](https://www.algolia.com/doc/rest-api/search/batch).
//
// This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
//
// Required API Key ACLs:
//   - addObject
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - body - The record. A schemaless object with attributes that are useful in the context of search and discovery.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SaveObjectWithHTTPInfo(
	ctx context.Context,
	indexName string,
	body map[string]any,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SaveObject`.")
	}

	if len(body) == 0 {
		return nil, nil, reportError("Parameter `body` is required when calling `SaveObject`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := body

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// SaveRule If a rule with the specified object ID doesn't exist, it's created.
// Otherwise, the existing rule is replaced.
//
// To create or update more than one rule, use the [`batch` operation](https://www.algolia.com/doc/rest-api/search/save-rules).
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique identifier of a rule object.
//   - rule
//   - forwardToReplicas - Whether changes are applied to replica indices.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SaveRule(
	ctx context.Context,
	indexName string,
	objectID string,
	rule *Rule,
	forwardToReplicas *bool,
	opts ...RequestOption,
) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.SaveRuleWithHTTPInfo(ctx, indexName, objectID, rule, forwardToReplicas, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SaveRuleWithHTTPInfo calls the API and returns the raw response from it.
// If a rule with the specified object ID doesn't exist, it's created.
// Otherwise, the existing rule is replaced.
//
// To create or update more than one rule, use the [`batch` operation](https://www.algolia.com/doc/rest-api/search/save-rules).
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique identifier of a rule object.
//   - rule
//   - forwardToReplicas - Whether changes are applied to replica indices.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SaveRuleWithHTTPInfo(
	ctx context.Context,
	indexName string,
	objectID string,
	rule *Rule,
	forwardToReplicas *bool,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/rules/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(objectID)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SaveRule`.")
	}

	if objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `SaveRule`.")
	}

	if rule == nil {
		return nil, nil, reportError("Parameter `rule` is required when calling `SaveRule`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(forwardToReplicas) {
		conf.queryParams.Set("forwardToReplicas", utils.QueryParameterToString(*forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := rule

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// SaveRulesOptions represents the optional params for the API call.
type SaveRulesOptions struct {
	ForwardToReplicas  *bool
	ClearExistingRules *bool
}

// NewSaveRulesOptions creates an instance of the SaveRulesOptions used to add optional parameters to SaveRulesWithOptions.
func NewSaveRulesOptions() *SaveRulesOptions {
	return &SaveRulesOptions{}
}

// WithForwardToReplicas Whether changes are applied to replica indices.
func (o *SaveRulesOptions) WithForwardToReplicas(forwardToReplicas bool) *SaveRulesOptions {
	o.ForwardToReplicas = &forwardToReplicas

	return o
}

// WithClearExistingRules Whether existing rules should be deleted before adding this batch.
func (o *SaveRulesOptions) WithClearExistingRules(clearExistingRules bool) *SaveRulesOptions {
	o.ClearExistingRules = &clearExistingRules

	return o
}

// SaveRules Create or update multiple rules.
//
// If a rule with the specified object ID doesn't exist, Algolia creates a new one.
// Otherwise, existing rules are replaced.
//
// This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - rules
//   - forwardToReplicas - Whether changes are applied to replica indices. (in optionalParams)
//   - clearExistingRules - Whether existing rules should be deleted before adding this batch. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SaveRules(
	ctx context.Context,
	indexName string,
	rules []Rule,
	optionalParams *SaveRulesOptions,
	opts ...RequestOption,
) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.SaveRulesWithHTTPInfo(ctx, indexName, rules, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SaveRulesWithHTTPInfo calls the API and returns the raw response from it.
// Create or update multiple rules.
//
// If a rule with the specified object ID doesn't exist, Algolia creates a new one.
// Otherwise, existing rules are replaced.
//
// This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - rules
//   - forwardToReplicas - Whether changes are applied to replica indices. (in optionalParams)
//   - clearExistingRules - Whether existing rules should be deleted before adding this batch. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SaveRulesWithHTTPInfo(
	ctx context.Context,
	indexName string,
	rules []Rule,
	optionalParams *SaveRulesOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/rules/batch"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SaveRules`.")
	}

	if len(rules) == 0 {
		return nil, nil, reportError("Parameter `rules` is required when calling `SaveRules`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.ForwardToReplicas) {
		conf.queryParams.Set("forwardToReplicas", utils.QueryParameterToString(*optionalParams.ForwardToReplicas))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.ClearExistingRules) {
		conf.queryParams.Set("clearExistingRules", utils.QueryParameterToString(*optionalParams.ClearExistingRules))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := rules

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// SaveSynonym If a synonym with the specified object ID doesn't exist, Algolia adds a new one.
// Otherwise, the existing synonym is replaced.
// To add multiple synonyms in a single API request, use the [`batch` operation](https://www.algolia.com/doc/rest-api/search/save-synonyms).
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique identifier of a synonym object.
//   - synonymHit
//   - forwardToReplicas - Whether changes are applied to replica indices.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SaveSynonym(
	ctx context.Context,
	indexName string,
	objectID string,
	synonymHit *SynonymHit,
	forwardToReplicas *bool,
	opts ...RequestOption,
) (*SaveSynonymResponse, error) {
	var returnValue *SaveSynonymResponse

	res, resBody, err := c.SaveSynonymWithHTTPInfo(ctx, indexName, objectID, synonymHit, forwardToReplicas, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SaveSynonymWithHTTPInfo calls the API and returns the raw response from it.
// If a synonym with the specified object ID doesn't exist, Algolia adds a new one.
// Otherwise, the existing synonym is replaced.
// To add multiple synonyms in a single API request, use the [`batch` operation](https://www.algolia.com/doc/rest-api/search/save-synonyms).
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - objectID - Unique identifier of a synonym object.
//   - synonymHit
//   - forwardToReplicas - Whether changes are applied to replica indices.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SaveSynonymWithHTTPInfo(
	ctx context.Context,
	indexName string,
	objectID string,
	synonymHit *SynonymHit,
	forwardToReplicas *bool,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/synonyms/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(objectID)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SaveSynonym`.")
	}

	if objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `SaveSynonym`.")
	}

	if synonymHit == nil {
		return nil, nil, reportError("Parameter `synonymHit` is required when calling `SaveSynonym`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(forwardToReplicas) {
		conf.queryParams.Set("forwardToReplicas", utils.QueryParameterToString(*forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := synonymHit

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// SaveSynonymsOptions represents the optional params for the API call.
type SaveSynonymsOptions struct {
	ForwardToReplicas       *bool
	ReplaceExistingSynonyms *bool
}

// NewSaveSynonymsOptions creates an instance of the SaveSynonymsOptions used to add optional parameters to SaveSynonymsWithOptions.
func NewSaveSynonymsOptions() *SaveSynonymsOptions {
	return &SaveSynonymsOptions{}
}

// WithForwardToReplicas Whether changes are applied to replica indices.
func (o *SaveSynonymsOptions) WithForwardToReplicas(forwardToReplicas bool) *SaveSynonymsOptions {
	o.ForwardToReplicas = &forwardToReplicas

	return o
}

// WithReplaceExistingSynonyms Whether to replace all synonyms in the index with the ones sent with this request.
func (o *SaveSynonymsOptions) WithReplaceExistingSynonyms(replaceExistingSynonyms bool) *SaveSynonymsOptions {
	o.ReplaceExistingSynonyms = &replaceExistingSynonyms

	return o
}

// SaveSynonyms If a synonym with the `objectID` doesn't exist, Algolia adds a new one.
// Otherwise, existing synonyms are replaced.
//
// This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - synonymHit
//   - forwardToReplicas - Whether changes are applied to replica indices. (in optionalParams)
//   - replaceExistingSynonyms - Whether to replace all synonyms in the index with the ones sent with this request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SaveSynonyms(
	ctx context.Context,
	indexName string,
	synonymHit []SynonymHit,
	optionalParams *SaveSynonymsOptions,
	opts ...RequestOption,
) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.SaveSynonymsWithHTTPInfo(ctx, indexName, synonymHit, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SaveSynonymsWithHTTPInfo calls the API and returns the raw response from it.
// If a synonym with the `objectID` doesn't exist, Algolia adds a new one.
// Otherwise, existing synonyms are replaced.
//
// This operation is subject to [indexing rate limits](https://support.algolia.com/hc/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - synonymHit
//   - forwardToReplicas - Whether changes are applied to replica indices. (in optionalParams)
//   - replaceExistingSynonyms - Whether to replace all synonyms in the index with the ones sent with this request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SaveSynonymsWithHTTPInfo(
	ctx context.Context,
	indexName string,
	synonymHit []SynonymHit,
	optionalParams *SaveSynonymsOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/synonyms/batch"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SaveSynonyms`.")
	}

	if len(synonymHit) == 0 {
		return nil, nil, reportError("Parameter `synonymHit` is required when calling `SaveSynonyms`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.ForwardToReplicas) {
		conf.queryParams.Set("forwardToReplicas", utils.QueryParameterToString(*optionalParams.ForwardToReplicas))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.ReplaceExistingSynonyms) {
		conf.queryParams.Set("replaceExistingSynonyms", utils.QueryParameterToString(*optionalParams.ReplaceExistingSynonyms))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := synonymHit

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// Search Sends multiple search requests to one or more indices.
//
// This can be useful in these cases:
//
//   - Different indices for different purposes, such as, one index for products, another one for marketing content.
//   - Multiple searches to the same indexfor example, with different filters.
//
// Use the helper `searchForHits` or `searchForFacets` to get the results in a more convenient format, if you already know the return type you want.
//
// Required API Key ACLs:
//   - search
//
// Parameters:
//   - requests
//   - strategy
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) Search(ctx context.Context, requests []SearchQuery, strategy *SearchStrategy, opts ...RequestOption) (*SearchResponses, error) {
	var returnValue *SearchResponses

	res, resBody, err := c.SearchWithHTTPInfo(ctx, requests, strategy, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchWithHTTPInfo calls the API and returns the raw response from it.
// Sends multiple search requests to one or more indices.
//
// This can be useful in these cases:
//
//   - Different indices for different purposes, such as, one index for products, another one for marketing content.
//   - Multiple searches to the same indexfor example, with different filters.
//
// Use the helper `searchForHits` or `searchForFacets` to get the results in a more convenient format, if you already know the return type you want.
//
// Required API Key ACLs:
//   - search
//
// Parameters:
//   - requests
//   - strategy
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchWithHTTPInfo(
	ctx context.Context,
	requests []SearchQuery,
	strategy *SearchStrategy,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/*/queries"

	if len(requests) == 0 {
		return nil, nil, reportError("Parameter `requests` is required when calling `Search`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Requests []SearchQuery   `json:"requests"`
		Strategy *SearchStrategy `json:"strategy,omitempty"`
	}{
		Requests: requests,
		Strategy: strategy,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}

// SearchDictionaryEntriesOptions represents the optional params for the API call.
type SearchDictionaryEntriesOptions struct {
	Page        *int
	HitsPerPage *int
	Language    *SupportedLanguage
}

// NewSearchDictionaryEntriesOptions creates an instance of the SearchDictionaryEntriesOptions used to add optional parameters to SearchDictionaryEntriesWithOptions.
func NewSearchDictionaryEntriesOptions() *SearchDictionaryEntriesOptions {
	return &SearchDictionaryEntriesOptions{}
}

// WithPage Page of search results to retrieve.
func (o *SearchDictionaryEntriesOptions) WithPage(page int) *SearchDictionaryEntriesOptions {
	o.Page = &page

	return o
}

// WithHitsPerPage Number of hits per page.
func (o *SearchDictionaryEntriesOptions) WithHitsPerPage(hitsPerPage int) *SearchDictionaryEntriesOptions {
	o.HitsPerPage = &hitsPerPage

	return o
}

// WithLanguage adds the language to the ApiSearchDictionaryEntriesRequest and returns the request for chaining.
func (o *SearchDictionaryEntriesOptions) WithLanguage(language SupportedLanguage) *SearchDictionaryEntriesOptions {
	o.Language = &language

	return o
}

// SearchDictionaryEntries Searches for standard and custom dictionary entries.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - dictionaryName - Dictionary type in which to search.
//   - query - Search query.
//   - page - Page of search results to retrieve. (in optionalParams)
//   - hitsPerPage - Number of hits per page. (in optionalParams)
//   - language  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchDictionaryEntries(
	ctx context.Context,
	dictionaryName DictionaryType,
	query string,
	optionalParams *SearchDictionaryEntriesOptions,
	opts ...RequestOption,
) (*SearchDictionaryEntriesResponse, error) {
	var returnValue *SearchDictionaryEntriesResponse

	res, resBody, err := c.SearchDictionaryEntriesWithHTTPInfo(ctx, dictionaryName, query, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchDictionaryEntriesWithHTTPInfo calls the API and returns the raw response from it.
// Searches for standard and custom dictionary entries.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - dictionaryName - Dictionary type in which to search.
//   - query - Search query.
//   - page - Page of search results to retrieve. (in optionalParams)
//   - hitsPerPage - Number of hits per page. (in optionalParams)
//   - language  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchDictionaryEntriesWithHTTPInfo(
	ctx context.Context,
	dictionaryName DictionaryType,
	query string,
	optionalParams *SearchDictionaryEntriesOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/dictionaries/{dictionaryName}/search"
	requestPath = strings.ReplaceAll(requestPath, "{dictionaryName}", url.PathEscape(utils.ParameterToString(dictionaryName)))

	if query == "" {
		return nil, nil, reportError("Parameter `query` is required when calling `SearchDictionaryEntries`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Query       string             `json:"query"`
		Page        *int               `json:"page,omitempty"`
		HitsPerPage *int               `json:"hitsPerPage,omitempty"`
		Language    *SupportedLanguage `json:"language,omitempty"`
	}{
		Query: query,
	}
	if optionalParams != nil {
		postBody.Page = optionalParams.Page
		postBody.HitsPerPage = optionalParams.HitsPerPage
		postBody.Language = optionalParams.Language
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}

// SearchForFacetValuesOptions represents the optional params for the API call.
type SearchForFacetValuesOptions struct {
	Params       *string
	FacetQuery   *string
	MaxFacetHits *int
}

// NewSearchForFacetValuesOptions creates an instance of the SearchForFacetValuesOptions used to add optional parameters to SearchForFacetValuesWithOptions.
func NewSearchForFacetValuesOptions() *SearchForFacetValuesOptions {
	return &SearchForFacetValuesOptions{}
}

// WithParams Search parameters as a URL-encoded query string.
func (o *SearchForFacetValuesOptions) WithParams(params string) *SearchForFacetValuesOptions {
	o.Params = &params

	return o
}

// WithFacetQuery Text to search inside the facet's values.
func (o *SearchForFacetValuesOptions) WithFacetQuery(facetQuery string) *SearchForFacetValuesOptions {
	o.FacetQuery = &facetQuery

	return o
}

// WithMaxFacetHits Maximum number of facet values to return when [searching for facet values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values).
func (o *SearchForFacetValuesOptions) WithMaxFacetHits(maxFacetHits int) *SearchForFacetValuesOptions {
	o.MaxFacetHits = &maxFacetHits

	return o
}

// SearchForFacetValues Searches for values of a specified facet attribute.
//
//   - By default, facet values are sorted by decreasing count.
//     You can adjust this with the `sortFacetValueBy` parameter.
//   - Searching for facet values doesn't work if you have **more than 65 searchable facets and searchable attributes combined**.
//
// Required API Key ACLs:
//   - search
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - facetName - Facet attribute in which to search for values.  This attribute must be included in the `attributesForFaceting` index setting with the `searchable()` modifier.
//   - params - Search parameters as a URL-encoded query string. (in optionalParams)
//   - facetQuery - Text to search inside the facet's values. (in optionalParams)
//   - maxFacetHits - Maximum number of facet values to return when [searching for facet values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values). (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchForFacetValues(
	ctx context.Context,
	indexName string,
	facetName string,
	optionalParams *SearchForFacetValuesOptions,
	opts ...RequestOption,
) (*SearchForFacetValuesResponse, error) {
	var returnValue *SearchForFacetValuesResponse

	res, resBody, err := c.SearchForFacetValuesWithHTTPInfo(ctx, indexName, facetName, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchForFacetValuesWithHTTPInfo calls the API and returns the raw response from it.
// Searches for values of a specified facet attribute.
//
//   - By default, facet values are sorted by decreasing count.
//     You can adjust this with the `sortFacetValueBy` parameter.
//   - Searching for facet values doesn't work if you have **more than 65 searchable facets and searchable attributes combined**.
//
// Required API Key ACLs:
//   - search
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - facetName - Facet attribute in which to search for values.  This attribute must be included in the `attributesForFaceting` index setting with the `searchable()` modifier.
//   - params - Search parameters as a URL-encoded query string. (in optionalParams)
//   - facetQuery - Text to search inside the facet's values. (in optionalParams)
//   - maxFacetHits - Maximum number of facet values to return when [searching for facet values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values). (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchForFacetValuesWithHTTPInfo(
	ctx context.Context,
	indexName string,
	facetName string,
	optionalParams *SearchForFacetValuesOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/facets/{facetName}/query"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{facetName}", url.PathEscape(utils.ParameterToString(facetName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SearchForFacetValues`.")
	}

	if facetName == "" {
		return nil, nil, reportError("Parameter `facetName` is required when calling `SearchForFacetValues`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Params       *string `json:"params,omitempty"`
		FacetQuery   *string `json:"facetQuery,omitempty"`
		MaxFacetHits *int    `json:"maxFacetHits,omitempty"`
	}{}
	if optionalParams != nil {
		postBody.Params = optionalParams.Params
		postBody.FacetQuery = optionalParams.FacetQuery
		postBody.MaxFacetHits = optionalParams.MaxFacetHits
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}

// SearchRulesOptions represents the optional params for the API call.
type SearchRulesOptions struct {
	Query       *string
	Anchoring   *Anchoring
	Context     *string
	Page        *int
	HitsPerPage *int
	Enabled     *bool
}

// NewSearchRulesOptions creates an instance of the SearchRulesOptions used to add optional parameters to SearchRulesWithOptions.
func NewSearchRulesOptions() *SearchRulesOptions {
	return &SearchRulesOptions{}
}

// WithQuery Search query for rules.
func (o *SearchRulesOptions) WithQuery(query string) *SearchRulesOptions {
	o.Query = &query

	return o
}

// WithAnchoring adds the anchoring to the ApiSearchRulesRequest and returns the request for chaining.
func (o *SearchRulesOptions) WithAnchoring(anchoring Anchoring) *SearchRulesOptions {
	o.Anchoring = &anchoring

	return o
}

// WithContext Only return rules that match the context (exact match).
func (o *SearchRulesOptions) WithContext(context string) *SearchRulesOptions {
	o.Context = &context

	return o
}

// WithPage Requested page of the API response.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.
func (o *SearchRulesOptions) WithPage(page int) *SearchRulesOptions {
	o.Page = &page

	return o
}

// WithHitsPerPage Maximum number of hits per page.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.
func (o *SearchRulesOptions) WithHitsPerPage(hitsPerPage int) *SearchRulesOptions {
	o.HitsPerPage = &hitsPerPage

	return o
}

// WithEnabled If `true`, return only enabled rules. If `false`, return only inactive rules. By default, _all_ rules are returned.
func (o *SearchRulesOptions) WithEnabled(enabled bool) *SearchRulesOptions {
	o.Enabled = &enabled

	return o
}

// SearchRules Searches for rules in your index.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - query - Search query for rules. (in optionalParams)
//   - anchoring  (in optionalParams)
//   - context - Only return rules that match the context (exact match). (in optionalParams)
//   - page - Requested page of the API response.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.  (in optionalParams)
//   - hitsPerPage - Maximum number of hits per page.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.  (in optionalParams)
//   - enabled - If `true`, return only enabled rules. If `false`, return only inactive rules. By default, _all_ rules are returned.  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchRules(
	ctx context.Context,
	indexName string,
	optionalParams *SearchRulesOptions,
	opts ...RequestOption,
) (*SearchRulesResponse, error) {
	var returnValue *SearchRulesResponse

	res, resBody, err := c.SearchRulesWithHTTPInfo(ctx, indexName, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchRulesWithHTTPInfo calls the API and returns the raw response from it.
// Searches for rules in your index.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - query - Search query for rules. (in optionalParams)
//   - anchoring  (in optionalParams)
//   - context - Only return rules that match the context (exact match). (in optionalParams)
//   - page - Requested page of the API response.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.  (in optionalParams)
//   - hitsPerPage - Maximum number of hits per page.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.  (in optionalParams)
//   - enabled - If `true`, return only enabled rules. If `false`, return only inactive rules. By default, _all_ rules are returned.  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchRulesWithHTTPInfo(
	ctx context.Context,
	indexName string,
	optionalParams *SearchRulesOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/rules/search"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SearchRules`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Query       *string    `json:"query,omitempty"`
		Anchoring   *Anchoring `json:"anchoring,omitempty"`
		Context     *string    `json:"context,omitempty"`
		Page        *int       `json:"page,omitempty"`
		HitsPerPage *int       `json:"hitsPerPage,omitempty"`
		Enabled     *bool      `json:"enabled,omitempty"`
	}{}
	if optionalParams != nil {
		postBody.Query = optionalParams.Query
		postBody.Anchoring = optionalParams.Anchoring
		postBody.Context = optionalParams.Context
		postBody.Page = optionalParams.Page
		postBody.HitsPerPage = optionalParams.HitsPerPage
		postBody.Enabled = optionalParams.Enabled
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}

// SearchSingleIndex Searches a single index and returns matching search results as hits.
//
// This method lets you retrieve up to 1,000 hits.
// If you need more, use the [`browse` operation](https://www.algolia.com/doc/rest-api/search/browse) or increase the `paginatedLimitedTo` index setting.
//
// Required API Key ACLs:
//   - search
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - searchParams
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchSingleIndex(
	ctx context.Context,
	indexName string,
	searchParams *SearchParams,
	opts ...RequestOption,
) (*SearchResponse, error) {
	var returnValue *SearchResponse

	res, resBody, err := c.SearchSingleIndexWithHTTPInfo(ctx, indexName, searchParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchSingleIndexWithHTTPInfo calls the API and returns the raw response from it.
// Searches a single index and returns matching search results as hits.
//
// This method lets you retrieve up to 1,000 hits.
// If you need more, use the [`browse` operation](https://www.algolia.com/doc/rest-api/search/browse) or increase the `paginatedLimitedTo` index setting.
//
// Required API Key ACLs:
//   - search
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - searchParams
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchSingleIndexWithHTTPInfo(
	ctx context.Context,
	indexName string,
	searchParams *SearchParams,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/query"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SearchSingleIndex`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	var postBody any = "{}"
	if !utils.IsNilOrEmpty(searchParams) {
		postBody = searchParams
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}

// SearchSynonymsOptions represents the optional params for the API call.
type SearchSynonymsOptions struct {
	Query       *string
	Type        *SynonymType
	Page        *int
	HitsPerPage *int
}

// NewSearchSynonymsOptions creates an instance of the SearchSynonymsOptions used to add optional parameters to SearchSynonymsWithOptions.
func NewSearchSynonymsOptions() *SearchSynonymsOptions {
	return &SearchSynonymsOptions{}
}

// WithQuery Search query.
func (o *SearchSynonymsOptions) WithQuery(query string) *SearchSynonymsOptions {
	o.Query = &query

	return o
}

// WithType adds the type_ to the ApiSearchSynonymsRequest and returns the request for chaining.
func (o *SearchSynonymsOptions) WithType(type_ SynonymType) *SearchSynonymsOptions {
	o.Type = &type_

	return o
}

// WithPage Page of search results to retrieve.
func (o *SearchSynonymsOptions) WithPage(page int) *SearchSynonymsOptions {
	o.Page = &page

	return o
}

// WithHitsPerPage Number of hits per page.
func (o *SearchSynonymsOptions) WithHitsPerPage(hitsPerPage int) *SearchSynonymsOptions {
	o.HitsPerPage = &hitsPerPage

	return o
}

// SearchSynonyms Searches for synonyms in your index.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - query - Search query. (in optionalParams)
//   - type_  (in optionalParams)
//   - page - Page of search results to retrieve. (in optionalParams)
//   - hitsPerPage - Number of hits per page. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchSynonyms(
	ctx context.Context,
	indexName string,
	optionalParams *SearchSynonymsOptions,
	opts ...RequestOption,
) (*SearchSynonymsResponse, error) {
	var returnValue *SearchSynonymsResponse

	res, resBody, err := c.SearchSynonymsWithHTTPInfo(ctx, indexName, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchSynonymsWithHTTPInfo calls the API and returns the raw response from it.
// Searches for synonyms in your index.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - query - Search query. (in optionalParams)
//   - type_  (in optionalParams)
//   - page - Page of search results to retrieve. (in optionalParams)
//   - hitsPerPage - Number of hits per page. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchSynonymsWithHTTPInfo(
	ctx context.Context,
	indexName string,
	optionalParams *SearchSynonymsOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/synonyms/search"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SearchSynonyms`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Query       *string      `json:"query,omitempty"`
		Type        *SynonymType `json:"type,omitempty"`
		Page        *int         `json:"page,omitempty"`
		HitsPerPage *int         `json:"hitsPerPage,omitempty"`
	}{}
	if optionalParams != nil {
		postBody.Query = optionalParams.Query
		postBody.Type = optionalParams.Type
		postBody.Page = optionalParams.Page
		postBody.HitsPerPage = optionalParams.HitsPerPage
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}

// SearchUserIdsOptions represents the optional params for the API call.
type SearchUserIdsOptions struct {
	ClusterName *string
	Page        *int
	HitsPerPage *int
}

// Deprecated: SearchUserIdsOptions is deprecated
// NewSearchUserIdsOptions creates an instance of the SearchUserIdsOptions used to add optional parameters to SearchUserIdsWithOptions.
func NewSearchUserIdsOptions() *SearchUserIdsOptions {
	return &SearchUserIdsOptions{}
}

// WithClusterName Cluster name.
func (o *SearchUserIdsOptions) WithClusterName(clusterName string) *SearchUserIdsOptions {
	o.ClusterName = &clusterName

	return o
}

// WithPage Page of search results to retrieve.
func (o *SearchUserIdsOptions) WithPage(page int) *SearchUserIdsOptions {
	o.Page = &page

	return o
}

// WithHitsPerPage Number of hits per page.
func (o *SearchUserIdsOptions) WithHitsPerPage(hitsPerPage int) *SearchUserIdsOptions {
	o.HitsPerPage = &hitsPerPage

	return o
}

// SearchUserIds Since it can take a few seconds to get the data from the different clusters,
// the response isn't real-time.
//
// To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - query
//   - clusterName - Cluster name. (in optionalParams)
//   - page - Page of search results to retrieve. (in optionalParams)
//   - hitsPerPage - Number of hits per page. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: SearchUserIds is deprecated.
func (c *APIClient) SearchUserIds(
	ctx context.Context,
	query string,
	optionalParams *SearchUserIdsOptions,
	opts ...RequestOption,
) (*SearchUserIdsResponse, error) {
	var returnValue *SearchUserIdsResponse

	res, resBody, err := c.SearchUserIdsWithHTTPInfo(ctx, query, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchUserIdsWithHTTPInfo calls the API and returns the raw response from it.
// Since it can take a few seconds to get the data from the different clusters,
// the response isn't real-time.
//
// To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - query
//   - clusterName - Cluster name. (in optionalParams)
//   - page - Page of search results to retrieve. (in optionalParams)
//   - hitsPerPage - Number of hits per page. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: SearchUserIds is deprecated.
func (c *APIClient) SearchUserIdsWithHTTPInfo(
	ctx context.Context,
	query string,
	optionalParams *SearchUserIdsOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/clusters/mapping/search"

	if query == "" {
		return nil, nil, reportError("Parameter `query` is required when calling `SearchUserIds`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Query       string  `json:"query"`
		ClusterName *string `json:"clusterName,omitempty"`
		Page        *int    `json:"page,omitempty"`
		HitsPerPage *int    `json:"hitsPerPage,omitempty"`
	}{
		Query: query,
	}
	if optionalParams != nil {
		postBody.ClusterName = optionalParams.ClusterName
		postBody.Page = optionalParams.Page
		postBody.HitsPerPage = optionalParams.HitsPerPage
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}

// SetDictionarySettings Turns standard stop word dictionary entries on or off for a given language.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - disableStandardEntries
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SetDictionarySettings(
	ctx context.Context,
	disableStandardEntries *StandardEntries,
	opts ...RequestOption,
) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.SetDictionarySettingsWithHTTPInfo(ctx, disableStandardEntries, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SetDictionarySettingsWithHTTPInfo calls the API and returns the raw response from it.
// Turns standard stop word dictionary entries on or off for a given language.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - disableStandardEntries
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SetDictionarySettingsWithHTTPInfo(
	ctx context.Context,
	disableStandardEntries *StandardEntries,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/dictionaries/*/settings"

	if disableStandardEntries == nil {
		return nil, nil, reportError("Parameter `disableStandardEntries` is required when calling `SetDictionarySettings`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		DisableStandardEntries *StandardEntries `json:"disableStandardEntries"`
	}{
		DisableStandardEntries: disableStandardEntries,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// SetSettings Update the specified index settings.
//
// Index settings that you don't specify are left unchanged.
// Specify `null` to reset a setting to its default value.
//
// For best performance, update the index settings before you add new records to your index.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - indexSettings
//   - forwardToReplicas - Whether changes are applied to replica indices.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SetSettings(
	ctx context.Context,
	indexName string,
	indexSettings *IndexSettings,
	forwardToReplicas *bool,
	opts ...RequestOption,
) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.SetSettingsWithHTTPInfo(ctx, indexName, indexSettings, forwardToReplicas, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SetSettingsWithHTTPInfo calls the API and returns the raw response from it.
// Update the specified index settings.
//
// Index settings that you don't specify are left unchanged.
// Specify `null` to reset a setting to its default value.
//
// For best performance, update the index settings before you add new records to your index.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - indexSettings
//   - forwardToReplicas - Whether changes are applied to replica indices.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SetSettingsWithHTTPInfo(
	ctx context.Context,
	indexName string,
	indexSettings *IndexSettings,
	forwardToReplicas *bool,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/settings"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SetSettings`.")
	}

	if indexSettings == nil {
		return nil, nil, reportError("Parameter `indexSettings` is required when calling `SetSettings`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(forwardToReplicas) {
		conf.queryParams.Set("forwardToReplicas", utils.QueryParameterToString(*forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := indexSettings

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// UpdateApiKeyOptions represents the optional params for the API call.
type UpdateApiKeyOptions struct {
	Description            *string
	Indexes                *[]string
	MaxHitsPerQuery        *int
	MaxQueriesPerIPPerHour *int
	QueryParameters        *string
	Referers               *[]string
	Validity               *int
}

// NewUpdateApiKeyOptions creates an instance of the UpdateApiKeyOptions used to add optional parameters to UpdateApiKeyWithOptions.
func NewUpdateApiKeyOptions() *UpdateApiKeyOptions {
	return &UpdateApiKeyOptions{}
}

// WithDescription Description of an API key to help you identify this API key.
func (o *UpdateApiKeyOptions) WithDescription(description string) *UpdateApiKeyOptions {
	o.Description = &description

	return o
}

// WithIndexes Index names or patterns that this API key can access. By default, an API key can access all indices in the same application.  You can use leading and trailing wildcard characters (`*`):  - `dev_*` matches all indices starting with \"dev_\". - `*_dev` matches all indices ending with \"_dev\". - `*_products_*` matches all indices containing \"_products_\".
func (o *UpdateApiKeyOptions) WithIndexes(indexes []string) *UpdateApiKeyOptions {
	o.Indexes = &indexes

	return o
}

// WithMaxHitsPerQuery Maximum number of results this API key can retrieve in one query. By default, there's no limit.
func (o *UpdateApiKeyOptions) WithMaxHitsPerQuery(maxHitsPerQuery int) *UpdateApiKeyOptions {
	o.MaxHitsPerQuery = &maxHitsPerQuery

	return o
}

// WithMaxQueriesPerIPPerHour Maximum number of API requests allowed per IP address or [user token](https://www.algolia.com/doc/guides/sending-events/concepts/usertoken) per hour.  If this limit is reached, the API returns an error with status code `429`. By default, there's no limit.
func (o *UpdateApiKeyOptions) WithMaxQueriesPerIPPerHour(maxQueriesPerIPPerHour int) *UpdateApiKeyOptions {
	o.MaxQueriesPerIPPerHour = &maxQueriesPerIPPerHour

	return o
}

// WithQueryParameters Query parameters to add when making API requests with this API key.  To restrict this API key to specific IP addresses, add the `restrictSources` parameter. You can only add a single source, but you can provide a range of IP addresses.  Creating an API key fails if the request is made from an IP address outside the restricted range.
func (o *UpdateApiKeyOptions) WithQueryParameters(queryParameters string) *UpdateApiKeyOptions {
	o.QueryParameters = &queryParameters

	return o
}

// WithReferers Allowed HTTP referrers for this API key.  By default, all referrers are allowed. You can use leading and trailing wildcard characters (`*`):  - `https://algolia.com/_*` allows all referrers starting with \"https://algolia.com/\" - `*.algolia.com` allows all referrers ending with \".algolia.com\" - `*algolia.com*` allows all referrers in the domain \"algolia.com\".  Like all HTTP headers, referrers can be spoofed. Don't rely on them to secure your data. For more information, see [HTTP referrer restrictions](https://www.algolia.com/doc/guides/security/security-best-practices/#http-referrers-restrictions).
func (o *UpdateApiKeyOptions) WithReferers(referers []string) *UpdateApiKeyOptions {
	o.Referers = &referers

	return o
}

// WithValidity Duration (in seconds) after which the API key expires. By default, API keys don't expire.
func (o *UpdateApiKeyOptions) WithValidity(validity int) *UpdateApiKeyOptions {
	o.Validity = &validity

	return o
}

// UpdateApiKey Replaces the permissions of an existing API key.
//
// Any unspecified attribute resets that attribute to its default value.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - key - API key.
//   - acl - Permissions that determine the type of API requests this key can make. The required ACL is listed in each endpoint's reference. For more information, see [access control list](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl).
//   - description - Description of an API key to help you identify this API key. (in optionalParams)
//   - indexes - Index names or patterns that this API key can access. By default, an API key can access all indices in the same application.  You can use leading and trailing wildcard characters (`*`):  - `dev_*` matches all indices starting with \"dev_\". - `*_dev` matches all indices ending with \"_dev\". - `*_products_*` matches all indices containing \"_products_\".  (in optionalParams)
//   - maxHitsPerQuery - Maximum number of results this API key can retrieve in one query. By default, there's no limit.  (in optionalParams)
//   - maxQueriesPerIPPerHour - Maximum number of API requests allowed per IP address or [user token](https://www.algolia.com/doc/guides/sending-events/concepts/usertoken) per hour.  If this limit is reached, the API returns an error with status code `429`. By default, there's no limit.  (in optionalParams)
//   - queryParameters - Query parameters to add when making API requests with this API key.  To restrict this API key to specific IP addresses, add the `restrictSources` parameter. You can only add a single source, but you can provide a range of IP addresses.  Creating an API key fails if the request is made from an IP address outside the restricted range.  (in optionalParams)
//   - referers - Allowed HTTP referrers for this API key.  By default, all referrers are allowed. You can use leading and trailing wildcard characters (`*`):  - `https://algolia.com/_*` allows all referrers starting with \"https://algolia.com/\" - `*.algolia.com` allows all referrers ending with \".algolia.com\" - `*algolia.com*` allows all referrers in the domain \"algolia.com\".  Like all HTTP headers, referrers can be spoofed. Don't rely on them to secure your data. For more information, see [HTTP referrer restrictions](https://www.algolia.com/doc/guides/security/security-best-practices/#http-referrers-restrictions).  (in optionalParams)
//   - validity - Duration (in seconds) after which the API key expires. By default, API keys don't expire.  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) UpdateApiKey(
	ctx context.Context,
	key string,
	acl []Acl,
	optionalParams *UpdateApiKeyOptions,
	opts ...RequestOption,
) (*UpdateApiKeyResponse, error) {
	var returnValue *UpdateApiKeyResponse

	res, resBody, err := c.UpdateApiKeyWithHTTPInfo(ctx, key, acl, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// UpdateApiKeyWithHTTPInfo calls the API and returns the raw response from it.
// Replaces the permissions of an existing API key.
//
// Any unspecified attribute resets that attribute to its default value.
//
// Required API Key ACLs:
//   - admin
//
// Parameters:
//   - key - API key.
//   - acl - Permissions that determine the type of API requests this key can make. The required ACL is listed in each endpoint's reference. For more information, see [access control list](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl).
//   - description - Description of an API key to help you identify this API key. (in optionalParams)
//   - indexes - Index names or patterns that this API key can access. By default, an API key can access all indices in the same application.  You can use leading and trailing wildcard characters (`*`):  - `dev_*` matches all indices starting with \"dev_\". - `*_dev` matches all indices ending with \"_dev\". - `*_products_*` matches all indices containing \"_products_\".  (in optionalParams)
//   - maxHitsPerQuery - Maximum number of results this API key can retrieve in one query. By default, there's no limit.  (in optionalParams)
//   - maxQueriesPerIPPerHour - Maximum number of API requests allowed per IP address or [user token](https://www.algolia.com/doc/guides/sending-events/concepts/usertoken) per hour.  If this limit is reached, the API returns an error with status code `429`. By default, there's no limit.  (in optionalParams)
//   - queryParameters - Query parameters to add when making API requests with this API key.  To restrict this API key to specific IP addresses, add the `restrictSources` parameter. You can only add a single source, but you can provide a range of IP addresses.  Creating an API key fails if the request is made from an IP address outside the restricted range.  (in optionalParams)
//   - referers - Allowed HTTP referrers for this API key.  By default, all referrers are allowed. You can use leading and trailing wildcard characters (`*`):  - `https://algolia.com/_*` allows all referrers starting with \"https://algolia.com/\" - `*.algolia.com` allows all referrers ending with \".algolia.com\" - `*algolia.com*` allows all referrers in the domain \"algolia.com\".  Like all HTTP headers, referrers can be spoofed. Don't rely on them to secure your data. For more information, see [HTTP referrer restrictions](https://www.algolia.com/doc/guides/security/security-best-practices/#http-referrers-restrictions).  (in optionalParams)
//   - validity - Duration (in seconds) after which the API key expires. By default, API keys don't expire.  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) UpdateApiKeyWithHTTPInfo(
	ctx context.Context,
	key string,
	acl []Acl,
	optionalParams *UpdateApiKeyOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/keys/{key}"
	requestPath = strings.ReplaceAll(requestPath, "{key}", url.PathEscape(utils.ParameterToString(key)))

	if key == "" {
		return nil, nil, reportError("Parameter `key` is required when calling `UpdateApiKey`.")
	}

	if len(acl) == 0 {
		return nil, nil, reportError("Parameter `acl` is required when calling `UpdateApiKey`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Acl                    []Acl     `json:"acl"`
		Description            *string   `json:"description,omitempty"`
		Indexes                *[]string `json:"indexes,omitempty"`
		MaxHitsPerQuery        *int      `json:"maxHitsPerQuery,omitempty"`
		MaxQueriesPerIPPerHour *int      `json:"maxQueriesPerIPPerHour,omitempty"`
		QueryParameters        *string   `json:"queryParameters,omitempty"`
		Referers               *[]string `json:"referers,omitempty"`
		Validity               *int      `json:"validity,omitempty"`
	}{
		Acl: acl,
	}
	if optionalParams != nil {
		postBody.Description = optionalParams.Description
		postBody.Indexes = optionalParams.Indexes
		postBody.MaxHitsPerQuery = optionalParams.MaxHitsPerQuery
		postBody.MaxQueriesPerIPPerHour = optionalParams.MaxQueriesPerIPPerHour
		postBody.QueryParameters = optionalParams.QueryParameters
		postBody.Referers = optionalParams.Referers
		postBody.Validity = optionalParams.Validity
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// --------- ChunkedBatch options ---------

type ChunkedBatchOption interface {
	RequestOption
	chunkedBatch()
}

type chunkedBatchOption func(*config)

var (
	_ ChunkedBatchOption = (*chunkedBatchOption)(nil)
	_ ChunkedBatchOption = (*requestOption)(nil)
)

func (c chunkedBatchOption) apply(conf *config) {
	c(conf)
}

func (c chunkedBatchOption) chunkedBatch() {}

func (r requestOption) chunkedBatch() {}

// WithWaitForTasks whether or not we should wait until every `batch` tasks has been processed, this operation may slow the total execution time of this method but is more reliable.
func WithWaitForTasks(waitForTasks bool) chunkedBatchOption {
	return chunkedBatchOption(func(c *config) {
		c.waitForTasks = waitForTasks
	})
}

// WithBatchSize the size of the chunk of `objects`. The number of `batch` calls will be equal to `length(objects) / batchSize`. Defaults to 1000.
func WithBatchSize(batchSize int) chunkedBatchOption {
	return chunkedBatchOption(func(c *config) {
		c.batchSize = batchSize
	})
}

// --------- Iterable options ---------.

type IterableOption interface {
	RequestOption
	iterable()
}

type iterableOption func(*config)

var (
	_ IterableOption = (*iterableOption)(nil)
	_ IterableOption = (*requestOption)(nil)
)

func (i iterableOption) apply(c *config) {
	i(c)
}

func (r requestOption) iterable() {}

func (i iterableOption) iterable() {}

// WithMaxRetries the maximum number of retry. Default to 50.
func WithMaxRetries(maxRetries int) iterableOption {
	return iterableOption(func(c *config) {
		c.maxRetries = maxRetries
	})
}

// WithTimeout he function to decide how long to wait between retries. Default to min(retryCount * 200, 5000).
func WithTimeout(timeout func(int) time.Duration) iterableOption {
	return iterableOption(func(c *config) {
		c.timeout = timeout
	})
}

// WithAggregator the function to aggregate the results of the iterable.
func WithAggregator(aggregator func(any, error)) iterableOption {
	return iterableOption(func(c *config) {
		c.aggregator = aggregator
	})
}

func CreateIterable[T any](execute func(*T, error) (*T, error), validate func(*T, error) (bool, error), opts ...IterableOption) (*T, error) {
	conf := config{
		headerParams: map[string]string{},
		maxRetries:   -1,
		timeout: func(count int) time.Duration {
			return 0 * time.Millisecond
		},
	}

	for _, opt := range opts {
		opt.apply(&conf)
	}

	var executor func(*T, error) (*T, error)

	retryCount := 0

	executor = func(previousResponse *T, previousError error) (*T, error) {
		response, responseErr := execute(previousResponse, previousError)

		retryCount++

		if conf.aggregator != nil {
			conf.aggregator(response, responseErr)
		}

		canStop, err := validate(response, responseErr)
		if canStop || err != nil {
			return response, err
		}

		if conf.maxRetries >= 0 && retryCount >= conf.maxRetries {
			return nil, errs.NewWaitError(fmt.Sprintf("The maximum number of retries exceeded. (%d/%d)", retryCount, conf.maxRetries))
		}

		time.Sleep(conf.timeout(retryCount))

		return executor(response, responseErr)
	}

	return executor(nil, nil)
}

// SearchForHits calls the `search` method but with certainty that we will only request Algolia records (hits) and not facets.
// Disclaimer: We don't assert that the parameters you pass to this method only contains `hits` requests to prevent impacting search performances, this helper is purely for typing purposes.
func (c *APIClient) SearchForHits(
	ctx context.Context,
	requests []SearchQuery,
	strategy *SearchStrategy,
	opts ...RequestOption,
) ([]SearchResponse, error) {
	res, err := c.Search(ctx, requests, strategy, opts...)
	if err != nil {
		return nil, err
	}

	hits := make([]SearchResponse, 0, len(res.GetResults()))

	for _, hit := range res.GetResults() {
		if hit.SearchResponse != nil {
			hits = append(hits, *hit.SearchResponse)
		}
	}

	return slices.Clip(hits), nil
}

// SearchForFacets calls the `search` method but with certainty that we will only request Algolia facets and not records (hits).
// Disclaimer: We don't assert that the parameters you pass to this method only contains `facets` requests to prevent impacting search performances, this helper is purely for typing purposes.
func (c *APIClient) SearchForFacets(
	ctx context.Context,
	requests []SearchQuery,
	strategy *SearchStrategy,
	opts ...RequestOption,
) ([]SearchForFacetValuesResponse, error) {
	res, err := c.Search(ctx, requests, strategy, opts...)
	if err != nil {
		return nil, err
	}

	facetHits := make([]SearchForFacetValuesResponse, 0, len(res.GetResults()))

	for _, hit := range res.GetResults() {
		if hit.SearchForFacetValuesResponse != nil {
			facetHits = append(facetHits, *hit.SearchForFacetValuesResponse)
		}
	}

	return slices.Clip(facetHits), nil
}

// WaitForTask waits for a task to be published.
// It returns the task response if the operation was successful.
// It returns an error if the operation failed.
func (c *APIClient) WaitForTask(
	ctx context.Context,
	indexName string,
	taskID int64,
	opts ...IterableOption,
) (*GetTaskResponse, error) {
	// provide a default timeout function
	opts = append([]IterableOption{WithTimeout(func(count int) time.Duration {
		return time.Duration(min(200*count, 5000)) * time.Millisecond
	}), WithMaxRetries(50)}, opts...)

	return CreateIterable(
		func(*GetTaskResponse, error) (*GetTaskResponse, error) {
			return c.GetTask(ctx, indexName, taskID, toRequestOptions(opts)...)
		},
		func(response *GetTaskResponse, err error) (bool, error) {
			if err != nil || response == nil {
				return false, err
			}

			return response.Status == TASK_STATUS_PUBLISHED, nil
		},
		opts...,
	)
}

// WaitForAppTask waits for an application-level task to be published.
// It returns the task response if the operation was successful.
// It returns an error if the operation failed.
func (c *APIClient) WaitForAppTask(
	ctx context.Context,
	taskID int64,
	opts ...IterableOption,
) (*GetTaskResponse, error) {
	// provide a default timeout function
	opts = append([]IterableOption{WithTimeout(func(count int) time.Duration {
		return time.Duration(min(200*count, 5000)) * time.Millisecond
	}), WithMaxRetries(50)}, opts...)

	return CreateIterable(
		func(*GetTaskResponse, error) (*GetTaskResponse, error) {
			return c.GetAppTask(ctx, taskID, toRequestOptions(opts)...)
		},
		func(response *GetTaskResponse, err error) (bool, error) {
			if err != nil || response == nil {
				return false, err
			}

			return response.Status == TASK_STATUS_PUBLISHED, nil
		},
		opts...,
	)
}

func slicesEqualUnordered[T cmp.Ordered](a []T, b []T) bool {
	if len(a) != len(b) {
		return false
	}

	// make a copy and sort it to avoid modifying the original slice
	aCopy := make([]T, len(a))
	copy(aCopy, a)

	bCopy := make([]T, len(b))
	copy(bCopy, b)

	slices.Sort(aCopy)
	slices.Sort(bCopy)

	return slices.Equal(aCopy, bCopy)
}

// WaitForApiKey waits for an API key to be created, deleted or updated.
// It returns the API key response if the operation was successful.
// It returns an error if the operation failed.
//
// The operation can be one of the following:
//   - "add": wait for the API key to be created
//   - "delete": wait for the API key to be deleted
//   - "update": wait for the API key to be updated
//
// If the operation is "update", the apiKey parameter must be set.
// If the operation is "delete" or "add", the apiKey parameter is not used.
func (c *APIClient) WaitForApiKey(
	ctx context.Context,
	key string,
	operation ApiKeyOperation,
	opts ...WaitForApiKeyOption,
) (*GetApiKeyResponse, error) {
	conf := config{headerParams: map[string]string{}}

	for _, opt := range opts {
		opt.apply(&conf)
	}

	var validateFunc func(*GetApiKeyResponse, error) (bool, error)

	switch operation {
	case API_KEY_OPERATION_UPDATE:
		if conf.apiKey == nil {
			return nil, &errs.WaitKeyUpdateError{}
		}

		validateFunc = func(response *GetApiKeyResponse, err error) (bool, error) {
			if err != nil || response == nil {
				return false, err
			}

			if conf.apiKey.GetDescription() != response.GetDescription() {
				return false, nil
			}

			if conf.apiKey.GetQueryParameters() != response.GetQueryParameters() {
				return false, nil
			}

			if conf.apiKey.GetMaxHitsPerQuery() != response.GetMaxHitsPerQuery() {
				return false, nil
			}

			if conf.apiKey.GetMaxQueriesPerIPPerHour() != response.GetMaxQueriesPerIPPerHour() {
				return false, nil
			}

			if conf.apiKey.GetValidity() != response.GetValidity() {
				return false, nil
			}

			if !slicesEqualUnordered(conf.apiKey.Acl, response.Acl) {
				return false, nil
			}

			if !slicesEqualUnordered(conf.apiKey.Indexes, response.Indexes) {
				return false, nil
			}

			return slicesEqualUnordered(conf.apiKey.Referers, response.Referers), nil
		}
	case API_KEY_OPERATION_ADD:
		validateFunc = func(response *GetApiKeyResponse, err error) (bool, error) {
			var apiErr *APIError
			if errors.As(err, &apiErr) {
				return apiErr.Status != 404, nil
			}

			return true, err
		}
	case API_KEY_OPERATION_DELETE:
		validateFunc = func(response *GetApiKeyResponse, err error) (bool, error) {
			var apiErr *APIError
			if errors.As(err, &apiErr) {
				return apiErr.Status == 404, nil
			}

			return false, err
		}
	default:
		return nil, &errs.WaitKeyOperationError{}
	}

	// provide a default timeout function
	opts = append([]WaitForApiKeyOption{WithTimeout(func(count int) time.Duration {
		return time.Duration(min(200*count, 5000)) * time.Millisecond
	}), WithMaxRetries(50)}, opts...)

	return CreateIterable(
		func(*GetApiKeyResponse, error) (*GetApiKeyResponse, error) {
			return c.GetApiKey(ctx, key, toRequestOptions(opts)...)
		},
		validateFunc,
		waitForApiKeyToIterableOptions(opts)...,
	)
}

// BrowseObjects allows to aggregate all the hits returned by the API calls.
// Use the `WithAggregator` option to collect all the responses.
func (c *APIClient) BrowseObjects(
	ctx context.Context,
	indexName string,
	browseParams BrowseParamsObject,
	opts ...IterableOption,
) error {
	if browseParams.HitsPerPage == nil {
		browseParams.HitsPerPage = utils.ToPtr(1000)
	}

	_, err := CreateIterable(
		func(previousResponse *BrowseResponse, previousErr error) (*BrowseResponse, error) {
			if previousResponse != nil {
				browseParams.Cursor = previousResponse.Cursor
			}

			return c.Browse(
				ctx, indexName, BrowseParamsObjectAsBrowseParams(&browseParams),
				toRequestOptions(opts)...,
			)
		},
		func(response *BrowseResponse, err error) (bool, error) {
			return err != nil || response != nil && response.Cursor == nil, err
		},
		opts...,
	)

	return err
}

// BrowseRules allows to aggregate all the rules returned by the API calls.
// Use the `WithAggregator` option to collect all the responses.
func (c *APIClient) BrowseRules(
	ctx context.Context,
	indexName string,
	optionalParams *SearchRulesOptions,
	opts ...IterableOption,
) error {
	hitsPerPage := 1000

	if optionalParams == nil {
		optionalParams = NewSearchRulesOptions()
	}

	if optionalParams.HitsPerPage != nil {
		hitsPerPage = *optionalParams.HitsPerPage
	}

	_, err := CreateIterable(
		func(previousResponse *SearchRulesResponse, previousErr error) (*SearchRulesResponse, error) {
			optionalParams.HitsPerPage = &hitsPerPage

			if previousResponse != nil {
				optionalParams.Page = utils.ToPtr(previousResponse.Page + 1)
			}

			if optionalParams.Page == nil {
				optionalParams.Page = utils.ToPtr(0)
			}

			return c.SearchRules(ctx, indexName, optionalParams, toRequestOptions(opts)...)
		},
		func(response *SearchRulesResponse, err error) (bool, error) {
			return err != nil || (response != nil && len(response.Hits) < hitsPerPage), err
		},
		opts...,
	)

	return err
}

// BrowseSynonyms allows to aggregate all the synonyms returned by the API calls.
// Use the `WithAggregator` option to collect all the responses.
func (c *APIClient) BrowseSynonyms(
	ctx context.Context,
	indexName string,
	optionalParams *SearchSynonymsOptions,
	opts ...IterableOption,
) error {
	hitsPerPage := 1000

	if optionalParams == nil {
		optionalParams = NewSearchSynonymsOptions()
	}

	if optionalParams.HitsPerPage != nil {
		hitsPerPage = *optionalParams.HitsPerPage
	}

	if optionalParams.Page == nil {
		optionalParams.Page = utils.ToPtr(0)
	}

	_, err := CreateIterable(
		func(previousResponse *SearchSynonymsResponse, previousErr error) (*SearchSynonymsResponse, error) {
			optionalParams.HitsPerPage = &hitsPerPage

			defer func() {
				optionalParams.Page = utils.ToPtr(*optionalParams.Page + 1)
			}()

			return c.SearchSynonyms(ctx, indexName, optionalParams, toRequestOptions(opts)...)
		},
		func(response *SearchSynonymsResponse, err error) (bool, error) {
			return err != nil || (response != nil && len(response.Hits) < hitsPerPage), err
		},
		opts...,
	)

	return err
}

func encodeRestrictions(restrictions *SecuredApiKeyRestrictions) (string, error) {
	if restrictions == nil {
		return "", nil
	}

	toSerialize := map[string]any{}
	if restrictions.Filters != nil {
		toSerialize["filters"] = *restrictions.Filters
	}

	if restrictions.ValidUntil != nil {
		toSerialize["validUntil"] = *restrictions.ValidUntil
	}

	if restrictions.RestrictIndices != nil {
		toSerialize["restrictIndices"] = restrictions.RestrictIndices
	}

	if restrictions.RestrictSources != nil {
		toSerialize["restrictSources"] = *restrictions.RestrictSources
	}

	if restrictions.UserToken != nil {
		toSerialize["userToken"] = *restrictions.UserToken
	}

	if restrictions.SearchParams != nil {
		// merge with searchParams
		serializedParams, err := restrictions.SearchParams.MarshalJSON()
		if err != nil {
			return "", fmt.Errorf("failed to marshal SearchParams: %w", err)
		}

		err = json.Unmarshal(serializedParams, &toSerialize)
		if err != nil {
			return "", fmt.Errorf("failed to unmarshal SearchParams: %w", err)
		}
	}

	// sort the keys to ensure consistent encoding
	keys := make([]string, 0, len(toSerialize))
	for k := range toSerialize {
		keys = append(keys, k)
	}

	sort.Strings(keys)

	queryString := make([]string, 0, len(toSerialize))
	for _, k := range keys {
		queryString = append(queryString, k+"="+utils.QueryParameterToString(toSerialize[k]))
	}

	return strings.Join(queryString, "&"), nil
}

// GenerateSecuredApiKey generates a public API key intended to restrict access to certain records. This new key is built upon the existing key named `parentApiKey` and the following options.
func (c *APIClient) GenerateSecuredApiKey(parentApiKey string, restrictions *SecuredApiKeyRestrictions) (string, error) {
	h := hmac.New(sha256.New, []byte(parentApiKey))

	message, err := encodeRestrictions(restrictions)
	if err != nil {
		return "", err
	}

	_, err = h.Write([]byte(message))
	if err != nil {
		return "", fmt.Errorf("failed to compute HMAC: %w", err)
	}

	checksum := hex.EncodeToString(h.Sum(nil))
	key := base64.StdEncoding.EncodeToString([]byte(checksum + message))

	return key, nil
}

// GetSecuredApiKeyRemainingValidity retrieves the remaining validity of the previously generated `securedApiKey`, the `ValidUntil` parameter must have been provided.
func (c *APIClient) GetSecuredApiKeyRemainingValidity(securedApiKey string) (time.Duration, error) {
	if len(securedApiKey) == 0 {
		return 0, fmt.Errorf("given secured API key is empty: %s", securedApiKey)
	}

	decoded, err := base64.StdEncoding.DecodeString(securedApiKey)
	if err != nil {
		return 0, fmt.Errorf("unable to decode given secured API key: %w", err)
	}

	submatch := regexp.MustCompile(`validUntil=(\d{1,10})`).FindSubmatch(decoded)

	if len(submatch) != 2 {
		return 0, fmt.Errorf("unable to find `validUntil` parameter in the given secured API key: %s", string(decoded))
	}

	ts, err := strconv.Atoi(string(submatch[1]))
	if err != nil {
		return 0, fmt.Errorf("invalid format for the received `validUntil` value: %s", string(submatch[1]))
	}

	return time.Until(time.Unix(int64(ts), 0)), nil
}

// Helper: Saves the given array of objects in the given index. The `chunkedBatch` helper is used under the hood, which creates a `batch` requests with at most 1000 objects in it.
func (c *APIClient) SaveObjects(
	ctx context.Context,
	indexName string,
	objects []map[string]any,
	opts ...ChunkedBatchOption,
) ([]BatchResponse, error) {
	return c.ChunkedBatch(ctx, indexName, objects, ACTION_ADD_OBJECT, opts...)
}

// Helper: Deletes every records for the given objectIDs. The `chunkedBatch` helper is used under the hood, which creates a `batch` requests with at most 1000 objectIDs in it.
func (c *APIClient) DeleteObjects(ctx context.Context, indexName string, objectIDs []string, opts ...ChunkedBatchOption) ([]BatchResponse, error) {
	objects := make([]map[string]any, 0, len(objectIDs))

	for _, id := range objectIDs {
		objects = append(objects, map[string]any{"objectID": id})
	}

	return c.ChunkedBatch(ctx, indexName, objects, ACTION_DELETE_OBJECT, opts...)
}

// Helper: Replaces object content of all the given objects according to their respective `objectID` field. The `chunkedBatch` helper is used under the hood, which creates a `batch` requests with at most 1000 objects in it.
func (c *APIClient) PartialUpdateObjects(
	ctx context.Context,
	indexName string,
	objects []map[string]any,
	opts ...PartialUpdateObjectsOption,
) ([]BatchResponse, error) {
	conf := config{
		headerParams:      map[string]string{},
		createIfNotExists: true,
	}

	for _, opt := range opts {
		opt.apply(&conf)
	}

	var action Action

	if conf.createIfNotExists {
		action = ACTION_PARTIAL_UPDATE_OBJECT
	} else {
		action = ACTION_PARTIAL_UPDATE_OBJECT_NO_CREATE
	}

	return c.ChunkedBatch(ctx, indexName, objects, action, partialUpdateObjectsToChunkedBatchOptions(opts)...)
}

// ChunkedBatch chunks the given `objects` list in subset of 1000 elements max in order to make it fit in `batch` requests.
func (c *APIClient) ChunkedBatch(
	ctx context.Context,
	indexName string,
	objects []map[string]any,
	action Action,
	opts ...ChunkedBatchOption,
) ([]BatchResponse, error) {
	conf := config{
		headerParams: map[string]string{},
		waitForTasks: false,
		batchSize:    1000,
	}

	for _, opt := range opts {
		opt.apply(&conf)
	}

	requests := make([]BatchRequest, 0, len(objects)%conf.batchSize)
	responses := make([]BatchResponse, 0, len(objects)%conf.batchSize)

	for i, obj := range objects {
		requests = append(requests, *NewBatchRequest(action, obj))

		if len(requests) == conf.batchSize || i == len(objects)-1 {
			resp, err := c.Batch(ctx, indexName, requests, toRequestOptions(opts)...)
			if err != nil {
				return nil, err
			}

			responses = append(responses, *resp)
			requests = make([]BatchRequest, 0, len(objects)%conf.batchSize)
		}
	}

	if conf.waitForTasks {
		for _, resp := range responses {
			_, err := c.WaitForTask(ctx, indexName, resp.TaskID, toIterableOptions(opts)...)
			if err != nil {
				return nil, err
			}
		}
	}

	return responses, nil
}

// ReplaceAllObjectsWithTransformation is similar to the `replaceAllObjects` method but requires a Push connector (https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/connectors/push/) to be created first, in order to transform records before indexing them to Algolia. The `region` must have been passed to the client instantiation method.
// See https://api-clients-automation.netlify.app/docs/custom-helpers/#replaceallobjects for implementation details.
func (c *APIClient) ReplaceAllObjectsWithTransformation(
	ctx context.Context,
	indexName string,
	objects []map[string]any,
	opts ...ReplaceAllObjectsOption,
) (*ReplaceAllObjectsWithTransformationResponse, error) {
	if c.ingestionTransporter == nil {
		return nil, reportError("`region` must be provided at client instantiation before calling this method.")
	}

	tmpIndexName := fmt.Sprintf("%s_tmp_%d", indexName, time.Now().UnixNano())

	conf := config{
		headerParams: map[string]string{},
		scopes:       []ScopeType{SCOPE_TYPE_SETTINGS, SCOPE_TYPE_RULES, SCOPE_TYPE_SYNONYMS},
	}

	for _, opt := range opts {
		opt.apply(&conf)
	}

	opts = append(opts, WithWaitForTasks(true))

	copyResp, err := c.OperationIndex(ctx, indexName, OPERATION_TYPE_COPY, tmpIndexName, &conf.scopes, toRequestOptions(opts)...)
	if err != nil {
		return nil, err
	}

	watchResp, err := c.ingestionTransporter.ChunkedPush(
		ctx,
		tmpIndexName,
		objects,
		ingestion.Action(ACTION_ADD_OBJECT),
		&indexName,
		toIngestionChunkedBatchOptions(replaceAllObjectsToChunkBatchOptions(opts))...)
	if err != nil {
		_, _ = c.DeleteIndex(ctx, tmpIndexName)

		return nil, err
	}

	_, err = c.WaitForTask(ctx, tmpIndexName, copyResp.TaskID, replaceAllObjectsToIterableOptions(opts)...)
	if err != nil {
		_, _ = c.DeleteIndex(ctx, tmpIndexName)

		return nil, err
	}

	copyResp, err = c.OperationIndex(ctx, indexName, OPERATION_TYPE_COPY, tmpIndexName, &conf.scopes, toRequestOptions(opts)...)
	if err != nil {
		_, _ = c.DeleteIndex(ctx, tmpIndexName)

		return nil, err
	}

	_, err = c.WaitForTask(ctx, tmpIndexName, copyResp.TaskID, replaceAllObjectsToIterableOptions(opts)...)
	if err != nil {
		_, _ = c.DeleteIndex(ctx, tmpIndexName)

		return nil, err
	}

	moveResp, err := c.OperationIndex(ctx, tmpIndexName, OPERATION_TYPE_MOVE, indexName, nil, toRequestOptions(opts)...)
	if err != nil {
		_, _ = c.DeleteIndex(ctx, tmpIndexName)

		return nil, err
	}

	_, err = c.WaitForTask(ctx, tmpIndexName, moveResp.TaskID, replaceAllObjectsToIterableOptions(opts)...)
	if err != nil {
		_, _ = c.DeleteIndex(ctx, tmpIndexName)

		return nil, err
	}

	var searchWatchResp []WatchResponse

	rawResp, err := json.Marshal(watchResp)
	if err != nil {
		return nil, fmt.Errorf("unable to convert the ingestion WatchResponse to search WatchResponse: %w", err)
	}

	err = json.Unmarshal(rawResp, &searchWatchResp)
	if err != nil {
		return nil, fmt.Errorf("unable to convert the ingestion WatchResponse to search WatchResponse: %w", err)
	}

	return &ReplaceAllObjectsWithTransformationResponse{
		CopyOperationResponse: *copyResp,
		WatchResponses:        searchWatchResp,
		MoveOperationResponse: *moveResp,
	}, nil
}

// ReplaceAllObjects replaces all objects (records) in the given `indexName` with the given `objects`. A temporary index is created during this process in order to backup your data.
// See https://api-clients-automation.netlify.app/docs/add-new-api-client#5-helpers for implementation details.
func (c *APIClient) ReplaceAllObjects(
	ctx context.Context,
	indexName string,
	objects []map[string]any,
	opts ...ReplaceAllObjectsOption,
) (*ReplaceAllObjectsResponse, error) {
	tmpIndexName := fmt.Sprintf("%s_tmp_%d", indexName, time.Now().UnixNano())

	conf := config{
		headerParams: map[string]string{},
		scopes:       []ScopeType{SCOPE_TYPE_SETTINGS, SCOPE_TYPE_RULES, SCOPE_TYPE_SYNONYMS},
	}

	for _, opt := range opts {
		opt.apply(&conf)
	}

	opts = append(opts, WithWaitForTasks(true))

	copyResp, err := c.OperationIndex(ctx, indexName, OPERATION_TYPE_COPY, tmpIndexName, &conf.scopes, toRequestOptions(opts)...)
	if err != nil {
		return nil, err
	}

	batchResp, err := c.ChunkedBatch(ctx, tmpIndexName, objects, ACTION_ADD_OBJECT, replaceAllObjectsToChunkBatchOptions(opts)...)
	if err != nil {
		_, _ = c.DeleteIndex(ctx, tmpIndexName)

		return nil, err
	}

	_, err = c.WaitForTask(ctx, tmpIndexName, copyResp.TaskID, replaceAllObjectsToIterableOptions(opts)...)
	if err != nil {
		_, _ = c.DeleteIndex(ctx, tmpIndexName)

		return nil, err
	}

	copyResp, err = c.OperationIndex(ctx, indexName, OPERATION_TYPE_COPY, tmpIndexName, &conf.scopes, toRequestOptions(opts)...)
	if err != nil {
		_, _ = c.DeleteIndex(ctx, tmpIndexName)

		return nil, err
	}

	_, err = c.WaitForTask(ctx, tmpIndexName, copyResp.TaskID, replaceAllObjectsToIterableOptions(opts)...)
	if err != nil {
		_, _ = c.DeleteIndex(ctx, tmpIndexName)

		return nil, err
	}

	moveResp, err := c.OperationIndex(ctx, tmpIndexName, OPERATION_TYPE_MOVE, indexName, nil, toRequestOptions(opts)...)
	if err != nil {
		_, _ = c.DeleteIndex(ctx, tmpIndexName)

		return nil, err
	}

	_, err = c.WaitForTask(ctx, tmpIndexName, moveResp.TaskID, replaceAllObjectsToIterableOptions(opts)...)
	if err != nil {
		_, _ = c.DeleteIndex(ctx, tmpIndexName)

		return nil, err
	}

	return &ReplaceAllObjectsResponse{
		CopyOperationResponse: *copyResp,
		BatchResponses:        batchResp,
		MoveOperationResponse: *moveResp,
	}, nil
}

// Exists returns whether an initialized index exists or not, along with a nil
// error. When encountering a network error, a non-nil error is returned along
// with false.
func (c *APIClient) IndexExists(ctx context.Context, indexName string) (bool, error) {
	_, err := c.GetSettings(ctx, indexName, nil)
	if err == nil {
		return true, nil
	}

	var apiErr *APIError
	if errors.As(err, &apiErr) && apiErr.Status == http.StatusNotFound {
		return false, nil
	}

	return false, err
}

// Helper: Similar to the `SaveObjects` method but requires a Push connector (https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/connectors/push/) to be created first, in order to transform records before indexing them to Algolia. The `region` must've been passed to the client's config at instantiation.
//
// Parameters:
//   - indexName string - the index name to save objects into.
//   - objects []map[string]any - List of objects to save.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SaveObjectsWithTransformation(
	ctx context.Context,
	indexName string,
	objects []map[string]any,
	opts ...ChunkedBatchOption,
) ([]ingestion.WatchResponse, error) {
	if c.ingestionTransporter == nil {
		return nil, reportError("`region` must be provided at client instantiation before calling this method.")
	}

	return c.ingestionTransporter.ChunkedPush(
		ctx,
		indexName,
		objects,
		ingestion.Action(ACTION_ADD_OBJECT),
		nil,
		toIngestionChunkedBatchOptions(opts)...)
}

// Helper: Similar to the `PartialUpdateObjects` method but requires a Push connector (https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/connectors/push/) to be created first, in order to transform records before indexing them to Algolia. The `region` must've been passed to the client instantiation method.
//
// Parameters:
//   - ctx context.Context - The context to use for the request.
//   - indexName string - the index name to save objects into.
//   - objects []map[string]any - List of objects to save.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) PartialUpdateObjectsWithTransformation(
	ctx context.Context,
	indexName string,
	objects []map[string]any,
	opts ...PartialUpdateObjectsOption,
) ([]ingestion.WatchResponse, error) {
	if c.ingestionTransporter == nil {
		return nil, reportError("`region` must be provided at client instantiation before calling this method.")
	}

	conf := config{
		headerParams:      map[string]string{},
		createIfNotExists: true,
	}

	for _, opt := range opts {
		opt.apply(&conf)
	}

	var action Action

	if conf.createIfNotExists {
		action = ACTION_PARTIAL_UPDATE_OBJECT
	} else {
		action = ACTION_PARTIAL_UPDATE_OBJECT_NO_CREATE
	}

	return c.ingestionTransporter.ChunkedPush(
		ctx,
		indexName,
		objects,
		ingestion.Action(action),
		nil,
		toIngestionChunkedBatchOptions(partialUpdateObjectsToChunkedBatchOptions(opts))...)
}
