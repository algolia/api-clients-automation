// The Algolia Composition API lets you run composed search requests on your Compositions.
//
// ## Client libraries
//
// Use Algolia's API clients and libraries to reliably integrate Algolia's APIs with your apps.
//
// See: [Algolia's ecosystem](https://www.algolia.com/doc/guides/getting-started/how-algolia-works/in-depth/ecosystem)
//
// ## Base URLs
//
// The base URLs for requests to the Composition API are:
//
//   - `https://{APPLICATION_ID}.algolia.net`
//   - `https://{APPLICATION_ID}-dsn.algolia.net`.
//     If your subscription includes a [Distributed Search Network](https://dashboard.algolia.com/infra),
//     this ensures that requests are sent to servers closest to users.
//
// Both URLs provide high availability by distributing requests with load balancing.
//
// **All requests must use HTTPS.**
//
// ## Retry strategy
//
// To guarantee high availability, implement a retry strategy for all API requests using the URLs of your servers as fallbacks:
//
// - `https://{APPLICATION_ID}-1.algolianet.com`
// - `https://{APPLICATION_ID}-2.algolianet.com`
// - `https://{APPLICATION_ID}-3.algolianet.com`
//
// These URLs use a different DNS provider than the primary URLs.
// You should randomize this list to ensure an even load across the three servers.
//
// All Algolia API clients implement this retry strategy.
//
// ## Authentication
//
// To authenticate your API requests, add these headers:
//
//   - `x-algolia-application-id`. Your Algolia application ID.
//   - `x-algolia-api-key`. An API key with the necessary permissions to make the request.
//     The required access control list (ACL) to make a request is listed in each endpoint's reference.
//
// You can find your application ID and API key in the [Algolia dashboard](https://dashboard.algolia.com/account/api-keys).
//
// ## Request format
//
// Depending on the endpoint, request bodies are either JSON objects or arrays of JSON objects,
//
// ## Parameters
//
// Parameters are passed in the request body for POST and PUT requests.
// Query parameters must be [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding).
// Non-ASCII characters must be UTF-8 encoded.
// Plus characters (`+`) are interpreted as spaces.
//
// ## Response status and errors
//
// The Composition API returns JSON responses.
// Since JSON doesn't guarantee any specific ordering, don't rely on the order of attributes in the API response.
//
// Successful responses return a `2xx` status. Client errors return a `4xx` status. Server errors are indicated by a `5xx` status.
// Error responses have a `message` property with more information.
//
// ## Version
//
// The current version of the Composition API is version 1, as indicated by the `/1/` in each endpoint's URL.
package composition

// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import (
	"context"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/transport"
	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type config struct {
	// -- Request options for API calls
	queryParams  url.Values
	headerParams map[string]string
	timeouts     transport.RequestConfiguration
}

type RequestOption interface {
	apply(*config)
}

type requestOption func(*config)

func (r requestOption) apply(c *config) {
	r(c)
}

func WithHeaderParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.headerParams[key] = utils.ParameterToString(value)
	})
}

func WithQueryParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.queryParams.Set(utils.QueryParameterToString(key), utils.QueryParameterToString(value))
	})
}

func WithReadTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ReadTimeout = &timeout
	})
}

func WithWriteTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.WriteTimeout = &timeout
	})
}

func WithConnectTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ConnectTimeout = &timeout
	})
}

// CustomDelete This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomDelete(ctx context.Context, path string, parameters map[string]any, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomDeleteWithHTTPInfo(ctx, path, parameters, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomDeleteWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomDeleteWithHTTPInfo(
	ctx context.Context,
	path string,
	parameters map[string]any,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(parameters) {
		for k, v := range parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomGet This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomGet(ctx context.Context, path string, parameters map[string]any, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomGetWithHTTPInfo(ctx, path, parameters, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomGetWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomGetWithHTTPInfo(
	ctx context.Context,
	path string,
	parameters map[string]any,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(parameters) {
		for k, v := range parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomPostOptions represents the optional params for the API call.
type CustomPostOptions struct {
	Parameters map[string]any
	Body       map[string]any
}

// NewCustomPostOptions creates an instance of the CustomPostOptions used to add optional parameters to CustomPostWithOptions.
func NewCustomPostOptions() *CustomPostOptions {
	return &CustomPostOptions{}
}

// WithParameters Query parameters to apply to the current query.
func (o *CustomPostOptions) WithParameters(parameters map[string]any) *CustomPostOptions {
	o.Parameters = parameters

	return o
}

// WithBody Parameters to send with the custom request.
func (o *CustomPostOptions) WithBody(body map[string]any) *CustomPostOptions {
	o.Body = body

	return o
}

// CustomPost This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPost(ctx context.Context, path string, optionalParams *CustomPostOptions, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPostWithHTTPInfo(ctx, path, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomPostWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPostWithHTTPInfo(
	ctx context.Context,
	path string,
	optionalParams *CustomPostOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Parameters) {
		for k, v := range optionalParams.Parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	var postBody any = "{}"
	if optionalParams != nil {
		postBody = optionalParams.Body
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomPutOptions represents the optional params for the API call.
type CustomPutOptions struct {
	Parameters map[string]any
	Body       map[string]any
}

// NewCustomPutOptions creates an instance of the CustomPutOptions used to add optional parameters to CustomPutWithOptions.
func NewCustomPutOptions() *CustomPutOptions {
	return &CustomPutOptions{}
}

// WithParameters Query parameters to apply to the current query.
func (o *CustomPutOptions) WithParameters(parameters map[string]any) *CustomPutOptions {
	o.Parameters = parameters

	return o
}

// WithBody Parameters to send with the custom request.
func (o *CustomPutOptions) WithBody(body map[string]any) *CustomPutOptions {
	o.Body = body

	return o
}

// CustomPut This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPut(ctx context.Context, path string, optionalParams *CustomPutOptions, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPutWithHTTPInfo(ctx, path, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomPutWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPutWithHTTPInfo(
	ctx context.Context,
	path string,
	optionalParams *CustomPutOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Parameters) {
		for k, v := range optionalParams.Parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	var postBody any = "{}"
	if optionalParams != nil {
		postBody = optionalParams.Body
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteComposition Delete a composition from the current Algolia application.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteComposition(ctx context.Context, compositionID string, opts ...RequestOption) (*TaskIDResponse, error) {
	var returnValue *TaskIDResponse

	res, resBody, err := c.DeleteCompositionWithHTTPInfo(ctx, compositionID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteCompositionWithHTTPInfo calls the API and returns the raw response from it.
// Delete a composition from the current Algolia application.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteCompositionWithHTTPInfo(ctx context.Context, compositionID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/compositions/{compositionID}"
	requestPath = strings.ReplaceAll(requestPath, "{compositionID}", url.PathEscape(utils.ParameterToString(compositionID)))

	if compositionID == "" {
		return nil, nil, reportError("Parameter `compositionID` is required when calling `DeleteComposition`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteCompositionRule Delete a Composition Rule from the specified Composition ID.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - objectID - Unique identifier of a rule object.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteCompositionRule(
	ctx context.Context,
	compositionID string,
	objectID string,
	opts ...RequestOption,
) (*TaskIDResponse, error) {
	var returnValue *TaskIDResponse

	res, resBody, err := c.DeleteCompositionRuleWithHTTPInfo(ctx, compositionID, objectID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteCompositionRuleWithHTTPInfo calls the API and returns the raw response from it.
// Delete a Composition Rule from the specified Composition ID.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - objectID - Unique identifier of a rule object.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteCompositionRuleWithHTTPInfo(
	ctx context.Context,
	compositionID string,
	objectID string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/compositions/{compositionID}/rules/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{compositionID}", url.PathEscape(utils.ParameterToString(compositionID)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(objectID)))

	if compositionID == "" {
		return nil, nil, reportError("Parameter `compositionID` is required when calling `DeleteCompositionRule`.")
	}

	if objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `DeleteCompositionRule`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetComposition Retrieve a single composition in the current Algolia application.
//
// Required API Key ACLs:
//   - editSettings
//   - settings
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetComposition(ctx context.Context, compositionID string, opts ...RequestOption) (*Composition, error) {
	var returnValue *Composition

	res, resBody, err := c.GetCompositionWithHTTPInfo(ctx, compositionID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetCompositionWithHTTPInfo calls the API and returns the raw response from it.
// Retrieve a single composition in the current Algolia application.
//
// Required API Key ACLs:
//   - editSettings
//   - settings
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetCompositionWithHTTPInfo(ctx context.Context, compositionID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/compositions/{compositionID}"
	requestPath = strings.ReplaceAll(requestPath, "{compositionID}", url.PathEscape(utils.ParameterToString(compositionID)))

	if compositionID == "" {
		return nil, nil, reportError("Parameter `compositionID` is required when calling `GetComposition`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetRule Retrieves a rule by its ID.
//
// To find the object ID of a rule, use the [`search` operation](https://www.algolia.com/doc/rest-api/composition/search-composition-rules).
//
// Required API Key ACLs:
//   - editSettings
//   - settings
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - objectID - Unique identifier of a rule object.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetRule(ctx context.Context, compositionID string, objectID string, opts ...RequestOption) (*CompositionRule, error) {
	var returnValue *CompositionRule

	res, resBody, err := c.GetRuleWithHTTPInfo(ctx, compositionID, objectID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetRuleWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a rule by its ID.
//
// To find the object ID of a rule, use the [`search` operation](https://www.algolia.com/doc/rest-api/composition/search-composition-rules).
//
// Required API Key ACLs:
//   - editSettings
//   - settings
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - objectID - Unique identifier of a rule object.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetRuleWithHTTPInfo(
	ctx context.Context,
	compositionID string,
	objectID string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/compositions/{compositionID}/rules/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{compositionID}", url.PathEscape(utils.ParameterToString(compositionID)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(objectID)))

	if compositionID == "" {
		return nil, nil, reportError("Parameter `compositionID` is required when calling `GetRule`.")
	}

	if objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `GetRule`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetTask Checks the status of a given task.
//
// Required API Key ACLs:
//   - editSettings
//   - settings
//   - addObject
//   - deleteObject
//   - deleteIndex
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - taskID - Unique task identifier.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTask(ctx context.Context, compositionID string, taskID int64, opts ...RequestOption) (*GetTaskResponse, error) {
	var returnValue *GetTaskResponse

	res, resBody, err := c.GetTaskWithHTTPInfo(ctx, compositionID, taskID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetTaskWithHTTPInfo calls the API and returns the raw response from it.
// Checks the status of a given task.
//
// Required API Key ACLs:
//   - editSettings
//   - settings
//   - addObject
//   - deleteObject
//   - deleteIndex
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - taskID - Unique task identifier.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTaskWithHTTPInfo(
	ctx context.Context,
	compositionID string,
	taskID int64,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/compositions/{compositionID}/task/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{compositionID}", url.PathEscape(utils.ParameterToString(compositionID)))
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if compositionID == "" {
		return nil, nil, reportError("Parameter `compositionID` is required when calling `GetTask`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ListCompositionsOptions represents the optional params for the API call.
type ListCompositionsOptions struct {
	Page        *int
	HitsPerPage *int
}

// NewListCompositionsOptions creates an instance of the ListCompositionsOptions used to add optional parameters to ListCompositionsWithOptions.
func NewListCompositionsOptions() *ListCompositionsOptions {
	return &ListCompositionsOptions{}
}

// WithPage Requested page of the API response. If `null`, the API response is not paginated.
func (o *ListCompositionsOptions) WithPage(page int) *ListCompositionsOptions {
	o.Page = &page

	return o
}

// WithHitsPerPage Number of hits per page.
func (o *ListCompositionsOptions) WithHitsPerPage(hitsPerPage int) *ListCompositionsOptions {
	o.HitsPerPage = &hitsPerPage

	return o
}

// ListCompositions Lists all compositions in the current Algolia application.
//
// Required API Key ACLs:
//   - editSettings
//   - settings
//
// Parameters:
//   - page - Requested page of the API response. If `null`, the API response is not paginated.  (in optionalParams)
//   - hitsPerPage - Number of hits per page. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListCompositions(
	ctx context.Context,
	optionalParams *ListCompositionsOptions,
	opts ...RequestOption,
) (*ListCompositionsResponse, error) {
	var returnValue *ListCompositionsResponse

	res, resBody, err := c.ListCompositionsWithHTTPInfo(ctx, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ListCompositionsWithHTTPInfo calls the API and returns the raw response from it.
// Lists all compositions in the current Algolia application.
//
// Required API Key ACLs:
//   - editSettings
//   - settings
//
// Parameters:
//   - page - Requested page of the API response. If `null`, the API response is not paginated.  (in optionalParams)
//   - hitsPerPage - Number of hits per page. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListCompositionsWithHTTPInfo(
	ctx context.Context,
	optionalParams *ListCompositionsOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/compositions"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*optionalParams.Page))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.HitsPerPage) {
		conf.queryParams.Set("hitsPerPage", utils.QueryParameterToString(*optionalParams.HitsPerPage))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// MultipleBatch Adds, updates, or deletes compositions with a single API request.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - requests
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) MultipleBatch(ctx context.Context, requests []MultipleBatchRequest, opts ...RequestOption) (*MultipleBatchResponse, error) {
	var returnValue *MultipleBatchResponse

	res, resBody, err := c.MultipleBatchWithHTTPInfo(ctx, requests, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// MultipleBatchWithHTTPInfo calls the API and returns the raw response from it.
// Adds, updates, or deletes compositions with a single API request.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - requests
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) MultipleBatchWithHTTPInfo(
	ctx context.Context,
	requests []MultipleBatchRequest,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/compositions/*/batch"

	if len(requests) == 0 {
		return nil, nil, reportError("Parameter `requests` is required when calling `MultipleBatch`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Requests []MultipleBatchRequest `json:"requests"`
	}{
		Requests: requests,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// PutComposition Upsert a composition in the current Algolia application.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - objectID - Composition unique identifier.
//   - name - Composition name.
//   - behavior
//   - description - Composition description.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) PutComposition(
	ctx context.Context,
	compositionID string,
	objectID string,
	name string,
	behavior *CompositionBehavior,
	description *string,
	opts ...RequestOption,
) (*TaskIDResponse, error) {
	var returnValue *TaskIDResponse

	res, resBody, err := c.PutCompositionWithHTTPInfo(ctx, compositionID, objectID, name, behavior, description, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// PutCompositionWithHTTPInfo calls the API and returns the raw response from it.
// Upsert a composition in the current Algolia application.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - objectID - Composition unique identifier.
//   - name - Composition name.
//   - behavior
//   - description - Composition description.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) PutCompositionWithHTTPInfo(
	ctx context.Context,
	compositionID string,
	objectID string,
	name string,
	behavior *CompositionBehavior,
	description *string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/compositions/{compositionID}"
	requestPath = strings.ReplaceAll(requestPath, "{compositionID}", url.PathEscape(utils.ParameterToString(compositionID)))

	if compositionID == "" {
		return nil, nil, reportError("Parameter `compositionID` is required when calling `PutComposition`.")
	}

	if objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `PutComposition`.")
	}

	if name == "" {
		return nil, nil, reportError("Parameter `name` is required when calling `PutComposition`.")
	}

	if behavior == nil {
		return nil, nil, reportError("Parameter `behavior` is required when calling `PutComposition`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		ObjectID    string               `json:"objectID"`
		Name        string               `json:"name"`
		Description *string              `json:"description,omitempty"`
		Behavior    *CompositionBehavior `json:"behavior"`
	}{
		ObjectID:    objectID,
		Name:        name,
		Description: description,
		Behavior:    behavior,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// PutCompositionRule If a composition rule with the provided ID already exists,
// it's replaced. Otherwise, a new one is added.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - objectID - Unique identifier of a rule object.
//   - compositionRule
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) PutCompositionRule(
	ctx context.Context,
	compositionID string,
	objectID string,
	compositionRule *CompositionRule,
	opts ...RequestOption,
) (*TaskIDResponse, error) {
	var returnValue *TaskIDResponse

	res, resBody, err := c.PutCompositionRuleWithHTTPInfo(ctx, compositionID, objectID, compositionRule, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// PutCompositionRuleWithHTTPInfo calls the API and returns the raw response from it.
// If a composition rule with the provided ID already exists,
// it's replaced. Otherwise, a new one is added.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - objectID - Unique identifier of a rule object.
//   - compositionRule
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) PutCompositionRuleWithHTTPInfo(
	ctx context.Context,
	compositionID string,
	objectID string,
	compositionRule *CompositionRule,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/compositions/{compositionID}/rules/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{compositionID}", url.PathEscape(utils.ParameterToString(compositionID)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(objectID)))

	if compositionID == "" {
		return nil, nil, reportError("Parameter `compositionID` is required when calling `PutCompositionRule`.")
	}

	if objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `PutCompositionRule`.")
	}

	if compositionRule == nil {
		return nil, nil, reportError("Parameter `compositionRule` is required when calling `PutCompositionRule`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := compositionRule

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// SaveRules Create or update or delete multiple composition rules.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - requests
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SaveRules(
	ctx context.Context,
	compositionID string,
	requests *[]RulesMultipleBatchRequest,
	opts ...RequestOption,
) (*RulesMultipleBatchResponse, error) {
	var returnValue *RulesMultipleBatchResponse

	res, resBody, err := c.SaveRulesWithHTTPInfo(ctx, compositionID, requests, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SaveRulesWithHTTPInfo calls the API and returns the raw response from it.
// Create or update or delete multiple composition rules.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - requests
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SaveRulesWithHTTPInfo(
	ctx context.Context,
	compositionID string,
	requests *[]RulesMultipleBatchRequest,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/compositions/{compositionID}/rules/batch"
	requestPath = strings.ReplaceAll(requestPath, "{compositionID}", url.PathEscape(utils.ParameterToString(compositionID)))

	if compositionID == "" {
		return nil, nil, reportError("Parameter `compositionID` is required when calling `SaveRules`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Requests *[]RulesMultipleBatchRequest `json:"requests,omitempty"`
	}{
		Requests: requests,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// Search Runs a query on a single composition and returns matching results.
//
// Required API Key ACLs:
//   - search
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - params
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) Search(ctx context.Context, compositionID string, params *Params, opts ...RequestOption) (*SearchResponse, error) {
	var returnValue *SearchResponse

	res, resBody, err := c.SearchWithHTTPInfo(ctx, compositionID, params, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchWithHTTPInfo calls the API and returns the raw response from it.
// Runs a query on a single composition and returns matching results.
//
// Required API Key ACLs:
//   - search
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - params
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchWithHTTPInfo(
	ctx context.Context,
	compositionID string,
	params *Params,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/compositions/{compositionID}/run"
	requestPath = strings.ReplaceAll(requestPath, "{compositionID}", url.PathEscape(utils.ParameterToString(compositionID)))

	if compositionID == "" {
		return nil, nil, reportError("Parameter `compositionID` is required when calling `Search`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Params *Params `json:"params,omitempty"`
	}{
		Params: params,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}

// SearchCompositionRulesOptions represents the optional params for the API call.
type SearchCompositionRulesOptions struct {
	Query       *string
	Anchoring   *Anchoring
	Context     *string
	Page        *int
	HitsPerPage *int
	Enabled     *bool
}

// NewSearchCompositionRulesOptions creates an instance of the SearchCompositionRulesOptions used to add optional parameters to SearchCompositionRulesWithOptions.
func NewSearchCompositionRulesOptions() *SearchCompositionRulesOptions {
	return &SearchCompositionRulesOptions{}
}

// WithQuery Search query for rules.
func (o *SearchCompositionRulesOptions) WithQuery(query string) *SearchCompositionRulesOptions {
	o.Query = &query

	return o
}

// WithAnchoring adds the anchoring to the ApiSearchCompositionRulesRequest and returns the request for chaining.
func (o *SearchCompositionRulesOptions) WithAnchoring(anchoring Anchoring) *SearchCompositionRulesOptions {
	o.Anchoring = &anchoring

	return o
}

// WithContext Only return composition rules that match the context (exact match).
func (o *SearchCompositionRulesOptions) WithContext(context string) *SearchCompositionRulesOptions {
	o.Context = &context

	return o
}

// WithPage Requested page of the API response.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.
func (o *SearchCompositionRulesOptions) WithPage(page int) *SearchCompositionRulesOptions {
	o.Page = &page

	return o
}

// WithHitsPerPage Maximum number of hits per page.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.
func (o *SearchCompositionRulesOptions) WithHitsPerPage(hitsPerPage int) *SearchCompositionRulesOptions {
	o.HitsPerPage = &hitsPerPage

	return o
}

// WithEnabled If `true`, return only enabled composition rules. If `false`, return only inactive composition rules. By default, _all_ composition rules are returned.
func (o *SearchCompositionRulesOptions) WithEnabled(enabled bool) *SearchCompositionRulesOptions {
	o.Enabled = &enabled

	return o
}

// SearchCompositionRules Searches for composition rules in your index.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - query - Search query for rules. (in optionalParams)
//   - anchoring  (in optionalParams)
//   - context - Only return composition rules that match the context (exact match). (in optionalParams)
//   - page - Requested page of the API response.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.  (in optionalParams)
//   - hitsPerPage - Maximum number of hits per page.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.  (in optionalParams)
//   - enabled - If `true`, return only enabled composition rules. If `false`, return only inactive composition rules. By default, _all_ composition rules are returned.  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchCompositionRules(
	ctx context.Context,
	compositionID string,
	optionalParams *SearchCompositionRulesOptions,
	opts ...RequestOption,
) (*SearchCompositionRulesResponse, error) {
	var returnValue *SearchCompositionRulesResponse

	res, resBody, err := c.SearchCompositionRulesWithHTTPInfo(ctx, compositionID, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchCompositionRulesWithHTTPInfo calls the API and returns the raw response from it.
// Searches for composition rules in your index.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - query - Search query for rules. (in optionalParams)
//   - anchoring  (in optionalParams)
//   - context - Only return composition rules that match the context (exact match). (in optionalParams)
//   - page - Requested page of the API response.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.  (in optionalParams)
//   - hitsPerPage - Maximum number of hits per page.  Algolia uses `page` and `hitsPerPage` to control how search results are displayed ([paginated](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/pagination/js)).  - `hitsPerPage`: sets the number of search results (_hits_) displayed per page. - `page`: specifies the page number of the search results you want to retrieve. Page numbering starts at 0, so the first page is `page=0`, the second is `page=1`, and so on.  For example, to display 10 results per page starting from the third page, set `hitsPerPage` to 10 and `page` to 2.  (in optionalParams)
//   - enabled - If `true`, return only enabled composition rules. If `false`, return only inactive composition rules. By default, _all_ composition rules are returned.  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchCompositionRulesWithHTTPInfo(
	ctx context.Context,
	compositionID string,
	optionalParams *SearchCompositionRulesOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/compositions/{compositionID}/rules/search"
	requestPath = strings.ReplaceAll(requestPath, "{compositionID}", url.PathEscape(utils.ParameterToString(compositionID)))

	if compositionID == "" {
		return nil, nil, reportError("Parameter `compositionID` is required when calling `SearchCompositionRules`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Query       *string    `json:"query,omitempty"`
		Anchoring   *Anchoring `json:"anchoring,omitempty"`
		Context     *string    `json:"context,omitempty"`
		Page        *int       `json:"page,omitempty"`
		HitsPerPage *int       `json:"hitsPerPage,omitempty"`
		Enabled     *bool      `json:"enabled,omitempty"`
	}{}
	if optionalParams != nil {
		postBody.Query = optionalParams.Query
		postBody.Anchoring = optionalParams.Anchoring
		postBody.Context = optionalParams.Context
		postBody.Page = optionalParams.Page
		postBody.HitsPerPage = optionalParams.HitsPerPage
		postBody.Enabled = optionalParams.Enabled
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// SearchForFacetValues Searches for values of a specified facet attribute on the composition's main source's index.
//
//   - By default, facet values are sorted by decreasing count.
//     You can adjust this with the `sortFacetValueBy` parameter.
//   - Searching for facet values doesn't work if you have **more than 65 searchable facets and searchable attributes combined**.
//
// Required API Key ACLs:
//   - search
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - facetName - Facet attribute in which to search for values.  This attribute must be included in the `attributesForFaceting` index setting with the `searchable()` modifier.
//   - params
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchForFacetValues(
	ctx context.Context,
	compositionID string,
	facetName string,
	params *SearchForFacetValuesParams,
	opts ...RequestOption,
) (*SearchForFacetValuesResponse, error) {
	var returnValue *SearchForFacetValuesResponse

	res, resBody, err := c.SearchForFacetValuesWithHTTPInfo(ctx, compositionID, facetName, params, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchForFacetValuesWithHTTPInfo calls the API and returns the raw response from it.
// Searches for values of a specified facet attribute on the composition's main source's index.
//
//   - By default, facet values are sorted by decreasing count.
//     You can adjust this with the `sortFacetValueBy` parameter.
//   - Searching for facet values doesn't work if you have **more than 65 searchable facets and searchable attributes combined**.
//
// Required API Key ACLs:
//   - search
//
// Parameters:
//   - compositionID - Unique Composition ObjectID.
//   - facetName - Facet attribute in which to search for values.  This attribute must be included in the `attributesForFaceting` index setting with the `searchable()` modifier.
//   - params
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchForFacetValuesWithHTTPInfo(
	ctx context.Context,
	compositionID string,
	facetName string,
	params *SearchForFacetValuesParams,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/compositions/{compositionID}/facets/{facetName}/query"
	requestPath = strings.ReplaceAll(requestPath, "{compositionID}", url.PathEscape(utils.ParameterToString(compositionID)))
	requestPath = strings.ReplaceAll(requestPath, "{facetName}", url.PathEscape(utils.ParameterToString(facetName)))

	if compositionID == "" {
		return nil, nil, reportError("Parameter `compositionID` is required when calling `SearchForFacetValues`.")
	}

	if facetName == "" {
		return nil, nil, reportError("Parameter `facetName` is required when calling `SearchForFacetValues`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Params *SearchForFacetValuesParams `json:"params,omitempty"`
	}{
		Params: params,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}
