// The Query Suggestions API lets you manage your Query Suggestions configurations.
// Query Suggestions add new indices to your Algolia application with popular search queries, external suggestions, or facet values.
// In your user interface, you can query the Query Suggestions indices like regular indices and add [suggested searches](https://www.algolia.com/doc/guides/building-search-ui/ui-and-ux-patterns/query-suggestions/js) to guide users and speed up their search.
//
// ## Base URLs
//
// The base URLs for requests to the Query Suggestions API are:
//
// - `https://query-suggestions.us.algolia.com`
// - `https://query-suggestions.eu.algolia.com`
//
// Use the URL that matches your [analytics region](https://dashboard.algolia.com/account/infrastructure/analytics).
//
// **All requests must use HTTPS.**
//
// ## Authentication
//
// To authenticate your API requests, add these headers:
//
//   - `x-algolia-application-id`. Your Algolia application ID.
//   - `x-algolia-api-key`. An API key with the necessary permissions to make the request.
//     The required access control list (ACL) to make a request is listed in each endpoint's reference.
//
// You can find your application ID and API key in the [Algolia dashboard](https://dashboard.algolia.com/account/api-keys).
//
// ## Request format
//
// Request bodies must be JSON objects.
//
// ## Response status and errors
//
// Response bodies are JSON objects.
// Deleting a user token returns an empty response body with rate-limiting information as headers.
//
// Successful responses return a `2xx` status. Client errors return a `4xx` status. Server errors are indicated by a `5xx` status.
// Error responses have a `message` property with more information.
//
// ## Version
//
// The current version of the Query Suggestions API is version 1, as indicated by the `/1/` in each endpoint's URL.
package suggestions

// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import (
	"context"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/transport"
	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type config struct {
	// -- Request options for API calls
	queryParams  url.Values
	headerParams map[string]string
	timeouts     transport.RequestConfiguration
}

type RequestOption interface {
	apply(*config)
}

type requestOption func(*config)

func (r requestOption) apply(c *config) {
	r(c)
}

func WithHeaderParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.headerParams[key] = utils.ParameterToString(value)
	})
}

func WithQueryParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.queryParams.Set(utils.QueryParameterToString(key), utils.QueryParameterToString(value))
	})
}

func WithReadTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ReadTimeout = &timeout
	})
}

func WithWriteTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.WriteTimeout = &timeout
	})
}

func WithConnectTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ConnectTimeout = &timeout
	})
}

// CreateConfig Creates a new Query Suggestions configuration.
//
// You can have up to 100 configurations per Algolia application.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - configurationWithIndex
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CreateConfig(ctx context.Context, configurationWithIndex *ConfigurationWithIndex, opts ...RequestOption) (*BaseResponse, error) {
	var returnValue *BaseResponse

	res, resBody, err := c.CreateConfigWithHTTPInfo(ctx, configurationWithIndex, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CreateConfigWithHTTPInfo calls the API and returns the raw response from it.
// Creates a new Query Suggestions configuration.
//
// You can have up to 100 configurations per Algolia application.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - configurationWithIndex
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CreateConfigWithHTTPInfo(
	ctx context.Context,
	configurationWithIndex *ConfigurationWithIndex,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/configs"

	if configurationWithIndex == nil {
		return nil, nil, reportError("Parameter `configurationWithIndex` is required when calling `CreateConfig`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := configurationWithIndex

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomDelete This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomDelete(ctx context.Context, path string, parameters map[string]any, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomDeleteWithHTTPInfo(ctx, path, parameters, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomDeleteWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomDeleteWithHTTPInfo(
	ctx context.Context,
	path string,
	parameters map[string]any,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(parameters) {
		for k, v := range parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomGet This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomGet(ctx context.Context, path string, parameters map[string]any, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomGetWithHTTPInfo(ctx, path, parameters, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomGetWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomGetWithHTTPInfo(
	ctx context.Context,
	path string,
	parameters map[string]any,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(parameters) {
		for k, v := range parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomPostOptions represents the optional params for the API call.
type CustomPostOptions struct {
	Parameters map[string]any
	Body       map[string]any
}

// NewCustomPostOptions creates an instance of the CustomPostOptions used to add optional parameters to CustomPostWithOptions.
func NewCustomPostOptions() *CustomPostOptions {
	return &CustomPostOptions{}
}

// WithParameters Query parameters to apply to the current query.
func (o *CustomPostOptions) WithParameters(parameters map[string]any) *CustomPostOptions {
	o.Parameters = parameters

	return o
}

// WithBody Parameters to send with the custom request.
func (o *CustomPostOptions) WithBody(body map[string]any) *CustomPostOptions {
	o.Body = body

	return o
}

// CustomPost This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPost(ctx context.Context, path string, optionalParams *CustomPostOptions, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPostWithHTTPInfo(ctx, path, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomPostWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPostWithHTTPInfo(
	ctx context.Context,
	path string,
	optionalParams *CustomPostOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Parameters) {
		for k, v := range optionalParams.Parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	var postBody any = "{}"
	if optionalParams != nil {
		postBody = optionalParams.Body
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomPutOptions represents the optional params for the API call.
type CustomPutOptions struct {
	Parameters map[string]any
	Body       map[string]any
}

// NewCustomPutOptions creates an instance of the CustomPutOptions used to add optional parameters to CustomPutWithOptions.
func NewCustomPutOptions() *CustomPutOptions {
	return &CustomPutOptions{}
}

// WithParameters Query parameters to apply to the current query.
func (o *CustomPutOptions) WithParameters(parameters map[string]any) *CustomPutOptions {
	o.Parameters = parameters

	return o
}

// WithBody Parameters to send with the custom request.
func (o *CustomPutOptions) WithBody(body map[string]any) *CustomPutOptions {
	o.Body = body

	return o
}

// CustomPut This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPut(ctx context.Context, path string, optionalParams *CustomPutOptions, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPutWithHTTPInfo(ctx, path, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomPutWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPutWithHTTPInfo(
	ctx context.Context,
	path string,
	optionalParams *CustomPutOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Parameters) {
		for k, v := range optionalParams.Parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	var postBody any = "{}"
	if optionalParams != nil {
		postBody = optionalParams.Body
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteConfig Deletes a Query Suggestions configuration.
//
// Deleting only removes the configuration and stops updates to the Query Suggestions index.
// To delete the Query Suggestions index itself, use the Search API and the `Delete an index` operation.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Query Suggestions index name.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteConfig(ctx context.Context, indexName string, opts ...RequestOption) (*BaseResponse, error) {
	var returnValue *BaseResponse

	res, resBody, err := c.DeleteConfigWithHTTPInfo(ctx, indexName, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteConfigWithHTTPInfo calls the API and returns the raw response from it.
// Deletes a Query Suggestions configuration.
//
// Deleting only removes the configuration and stops updates to the Query Suggestions index.
// To delete the Query Suggestions index itself, use the Search API and the `Delete an index` operation.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Query Suggestions index name.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteConfigWithHTTPInfo(ctx context.Context, indexName string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/configs/{indexName}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `DeleteConfig`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetAllConfigs Retrieves all Query Suggestions configurations of your Algolia application.
//
// Required API Key ACLs:
//   - settings
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetAllConfigs(ctx context.Context, opts ...RequestOption) ([]ConfigurationResponse, error) {
	var returnValue []ConfigurationResponse

	res, resBody, err := c.GetAllConfigsWithHTTPInfo(ctx, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetAllConfigsWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves all Query Suggestions configurations of your Algolia application.
//
// Required API Key ACLs:
//   - settings
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetAllConfigsWithHTTPInfo(ctx context.Context, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/configs"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetConfig Retrieves a single Query Suggestions configuration by its index name.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Query Suggestions index name.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetConfig(ctx context.Context, indexName string, opts ...RequestOption) (*ConfigurationResponse, error) {
	var returnValue *ConfigurationResponse

	res, resBody, err := c.GetConfigWithHTTPInfo(ctx, indexName, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetConfigWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a single Query Suggestions configuration by its index name.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Query Suggestions index name.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetConfigWithHTTPInfo(ctx context.Context, indexName string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/configs/{indexName}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetConfig`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetConfigStatus Reports the status of a Query Suggestions index.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Query Suggestions index name.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetConfigStatus(ctx context.Context, indexName string, opts ...RequestOption) (*ConfigStatus, error) {
	var returnValue *ConfigStatus

	res, resBody, err := c.GetConfigStatusWithHTTPInfo(ctx, indexName, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetConfigStatusWithHTTPInfo calls the API and returns the raw response from it.
// Reports the status of a Query Suggestions index.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Query Suggestions index name.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetConfigStatusWithHTTPInfo(ctx context.Context, indexName string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/configs/{indexName}/status"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetConfigStatus`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetLogFile Retrieves the logs for a single Query Suggestions index.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Query Suggestions index name.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetLogFile(ctx context.Context, indexName string, opts ...RequestOption) (*LogFile, error) {
	var returnValue *LogFile

	res, resBody, err := c.GetLogFileWithHTTPInfo(ctx, indexName, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetLogFileWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves the logs for a single Query Suggestions index.
//
// Required API Key ACLs:
//   - settings
//
// Parameters:
//   - indexName - Query Suggestions index name.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetLogFileWithHTTPInfo(ctx context.Context, indexName string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/logs/{indexName}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetLogFile`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// UpdateConfigOptions represents the optional params for the API call.
type UpdateConfigOptions struct {
	Languages              *Languages
	Exclude                *[]string
	EnablePersonalization  *bool
	AllowSpecialCharacters *bool
}

// NewUpdateConfigOptions creates an instance of the UpdateConfigOptions used to add optional parameters to UpdateConfigWithOptions.
func NewUpdateConfigOptions() *UpdateConfigOptions {
	return &UpdateConfigOptions{}
}

// WithLanguages adds the languages to the ApiUpdateConfigRequest and returns the request for chaining.
func (o *UpdateConfigOptions) WithLanguages(languages *Languages) *UpdateConfigOptions {
	o.Languages = languages

	return o
}

// WithExclude adds the exclude to the ApiUpdateConfigRequest and returns the request for chaining.
func (o *UpdateConfigOptions) WithExclude(exclude []string) *UpdateConfigOptions {
	o.Exclude = &exclude

	return o
}

// WithEnablePersonalization Whether to turn on personalized query suggestions.
func (o *UpdateConfigOptions) WithEnablePersonalization(enablePersonalization bool) *UpdateConfigOptions {
	o.EnablePersonalization = &enablePersonalization

	return o
}

// WithAllowSpecialCharacters Whether to include suggestions with special characters.
func (o *UpdateConfigOptions) WithAllowSpecialCharacters(allowSpecialCharacters bool) *UpdateConfigOptions {
	o.AllowSpecialCharacters = &allowSpecialCharacters

	return o
}

// UpdateConfig Updates a QuerySuggestions configuration.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Query Suggestions index name.
//   - sourceIndices - Algolia indices from which to get the popular searches for query suggestions.
//   - languages  (in optionalParams)
//   - exclude  (in optionalParams)
//   - enablePersonalization - Whether to turn on personalized query suggestions. (in optionalParams)
//   - allowSpecialCharacters - Whether to include suggestions with special characters. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) UpdateConfig(
	ctx context.Context,
	indexName string,
	sourceIndices []SourceIndex,
	optionalParams *UpdateConfigOptions,
	opts ...RequestOption,
) (*BaseResponse, error) {
	var returnValue *BaseResponse

	res, resBody, err := c.UpdateConfigWithHTTPInfo(ctx, indexName, sourceIndices, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// UpdateConfigWithHTTPInfo calls the API and returns the raw response from it.
// Updates a QuerySuggestions configuration.
//
// Required API Key ACLs:
//   - editSettings
//
// Parameters:
//   - indexName - Query Suggestions index name.
//   - sourceIndices - Algolia indices from which to get the popular searches for query suggestions.
//   - languages  (in optionalParams)
//   - exclude  (in optionalParams)
//   - enablePersonalization - Whether to turn on personalized query suggestions. (in optionalParams)
//   - allowSpecialCharacters - Whether to include suggestions with special characters. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) UpdateConfigWithHTTPInfo(
	ctx context.Context,
	indexName string,
	sourceIndices []SourceIndex,
	optionalParams *UpdateConfigOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/configs/{indexName}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `UpdateConfig`.")
	}

	if len(sourceIndices) == 0 {
		return nil, nil, reportError("Parameter `sourceIndices` is required when calling `UpdateConfig`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		SourceIndices          []SourceIndex `json:"sourceIndices"`
		Languages              *Languages    `json:"languages,omitempty"`
		Exclude                *[]string     `json:"exclude,omitempty"`
		EnablePersonalization  *bool         `json:"enablePersonalization,omitempty"`
		AllowSpecialCharacters *bool         `json:"allowSpecialCharacters,omitempty"`
	}{
		SourceIndices: sourceIndices,
	}
	if optionalParams != nil {
		postBody.Languages = optionalParams.Languages
		postBody.Exclude = optionalParams.Exclude
		postBody.EnablePersonalization = optionalParams.EnablePersonalization
		postBody.AllowSpecialCharacters = optionalParams.AllowSpecialCharacters
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}
