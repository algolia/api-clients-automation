// The Ingestion API lets you connect third-party services and platforms with Algolia and schedule tasks to ingest your data.
// The Ingestion API powers the no-code [data connectors](https://dashboard.algolia.com/connectors).
//
// ## Base URLs
//
// The base URLs for requests to the Ingestion API are:
//
// - `https://data.us.algolia.com`
// - `https://data.eu.algolia.com`
//
// Use the URL that matches your [analytics region](https://dashboard.algolia.com/account/infrastructure/analytics).
//
// **All requests must use HTTPS.**
//
// ## Authentication
//
// To authenticate your API requests, add these headers:
//
//   - `x-algolia-application-id`. Your Algolia application ID.
//   - `x-algolia-api-key`. An API key with the necessary permissions to make the request.
//     The required access control list (ACL) to make a request is listed in each endpoint's reference.
//
// You can find your application ID and API key in the [Algolia dashboard](https://dashboard.algolia.com/account/api-keys).
//
// ## Request format
//
// Request bodies must be JSON objects.
//
// ## Response status and errors
//
// Response bodies are JSON objects.
//
// Successful responses return a `2xx` status. Client errors return a `4xx` status. Server errors are indicated by a `5xx` status.
// Error responses have a `message` property with more information.
//
// ## Version
//
// The current version of the Ingestion API is version 1, as indicated by the `/1/` in each endpoint's URL.
package ingestion

// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/errs"
	"github.com/algolia/algoliasearch-client-go/v4/algolia/transport"
	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type config struct {
	// -- Request options for API calls
	queryParams  url.Values
	headerParams map[string]string
	timeouts     transport.RequestConfiguration

	// -- ChunkedPush options
	waitForTasks bool
	batchSize    int

	// -- Iterable options
	maxRetries int
	timeout    func(int) time.Duration
	aggregator func(any, error)
}

type RequestOption interface {
	apply(*config)
}

type requestOption func(*config)

func (r requestOption) apply(c *config) {
	r(c)
}

func WithHeaderParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.headerParams[key] = utils.ParameterToString(value)
	})
}

func WithQueryParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.queryParams.Set(utils.QueryParameterToString(key), utils.QueryParameterToString(value))
	})
}

func WithReadTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ReadTimeout = &timeout
	})
}

func WithWriteTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.WriteTimeout = &timeout
	})
}

func WithConnectTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ConnectTimeout = &timeout
	})
}

// CreateAuthentication Creates a new authentication resource.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - type_
//   - name - Descriptive name for the resource.
//   - input
//   - platform
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CreateAuthentication(
	ctx context.Context,
	type_ AuthenticationType,
	name string,
	input *AuthInput,
	platform *Platform,
	opts ...RequestOption,
) (*AuthenticationCreateResponse, error) {
	var returnValue *AuthenticationCreateResponse

	res, resBody, err := c.CreateAuthenticationWithHTTPInfo(ctx, type_, name, input, platform, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CreateAuthenticationWithHTTPInfo calls the API and returns the raw response from it.
// Creates a new authentication resource.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - type_
//   - name - Descriptive name for the resource.
//   - input
//   - platform
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CreateAuthenticationWithHTTPInfo(
	ctx context.Context,
	type_ AuthenticationType,
	name string,
	input *AuthInput,
	platform *Platform,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/authentications"

	if name == "" {
		return nil, nil, reportError("Parameter `name` is required when calling `CreateAuthentication`.")
	}

	if input == nil {
		return nil, nil, reportError("Parameter `input` is required when calling `CreateAuthentication`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Type     AuthenticationType `json:"type"`
		Name     string             `json:"name"`
		Platform *Platform          `json:"platform,omitempty"`
		Input    *AuthInput         `json:"input"`
	}{
		Type:     type_,
		Name:     name,
		Platform: platform,
		Input:    input,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CreateDestinationOptions represents the optional params for the API call.
type CreateDestinationOptions struct {
	AuthenticationID  *string
	TransformationIDs *[]string
}

// NewCreateDestinationOptions creates an instance of the CreateDestinationOptions used to add optional parameters to CreateDestinationWithOptions.
func NewCreateDestinationOptions() *CreateDestinationOptions {
	return &CreateDestinationOptions{}
}

// WithAuthenticationID Universally unique identifier (UUID) of an authentication resource.
func (o *CreateDestinationOptions) WithAuthenticationID(authenticationID string) *CreateDestinationOptions {
	o.AuthenticationID = &authenticationID

	return o
}

// WithTransformationIDs adds the transformationIDs to the ApiCreateDestinationRequest and returns the request for chaining.
func (o *CreateDestinationOptions) WithTransformationIDs(transformationIDs []string) *CreateDestinationOptions {
	o.TransformationIDs = &transformationIDs

	return o
}

// CreateDestination Creates a new destination.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - type_
//   - name - Descriptive name for the resource.
//   - input
//   - authenticationID - Universally unique identifier (UUID) of an authentication resource. (in optionalParams)
//   - transformationIDs  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CreateDestination(
	ctx context.Context,
	type_ DestinationType,
	name string,
	input *DestinationInput,
	optionalParams *CreateDestinationOptions,
	opts ...RequestOption,
) (*DestinationCreateResponse, error) {
	var returnValue *DestinationCreateResponse

	res, resBody, err := c.CreateDestinationWithHTTPInfo(ctx, type_, name, input, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CreateDestinationWithHTTPInfo calls the API and returns the raw response from it.
// Creates a new destination.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - type_
//   - name - Descriptive name for the resource.
//   - input
//   - authenticationID - Universally unique identifier (UUID) of an authentication resource. (in optionalParams)
//   - transformationIDs  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CreateDestinationWithHTTPInfo(
	ctx context.Context,
	type_ DestinationType,
	name string,
	input *DestinationInput,
	optionalParams *CreateDestinationOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/destinations"

	if name == "" {
		return nil, nil, reportError("Parameter `name` is required when calling `CreateDestination`.")
	}

	if input == nil {
		return nil, nil, reportError("Parameter `input` is required when calling `CreateDestination`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Type              DestinationType   `json:"type"`
		Name              string            `json:"name"`
		Input             *DestinationInput `json:"input"`
		AuthenticationID  *string           `json:"authenticationID,omitempty"`
		TransformationIDs *[]string         `json:"transformationIDs,omitempty"`
	}{
		Type:  type_,
		Name:  name,
		Input: input,
	}
	if optionalParams != nil {
		postBody.AuthenticationID = optionalParams.AuthenticationID
		postBody.TransformationIDs = optionalParams.TransformationIDs
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CreateSourceOptions represents the optional params for the API call.
type CreateSourceOptions struct {
	Input            *SourceInput
	AuthenticationID *string
}

// NewCreateSourceOptions creates an instance of the CreateSourceOptions used to add optional parameters to CreateSourceWithOptions.
func NewCreateSourceOptions() *CreateSourceOptions {
	return &CreateSourceOptions{}
}

// WithInput adds the input to the ApiCreateSourceRequest and returns the request for chaining.
func (o *CreateSourceOptions) WithInput(input *SourceInput) *CreateSourceOptions {
	o.Input = input

	return o
}

// WithAuthenticationID Universally unique identifier (UUID) of an authentication resource.
func (o *CreateSourceOptions) WithAuthenticationID(authenticationID string) *CreateSourceOptions {
	o.AuthenticationID = &authenticationID

	return o
}

// CreateSource Creates a new source.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - type_
//   - name - Descriptive name of the source.
//   - input  (in optionalParams)
//   - authenticationID - Universally unique identifier (UUID) of an authentication resource. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CreateSource(
	ctx context.Context,
	type_ SourceType,
	name string,
	optionalParams *CreateSourceOptions,
	opts ...RequestOption,
) (*SourceCreateResponse, error) {
	var returnValue *SourceCreateResponse

	res, resBody, err := c.CreateSourceWithHTTPInfo(ctx, type_, name, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CreateSourceWithHTTPInfo calls the API and returns the raw response from it.
// Creates a new source.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - type_
//   - name - Descriptive name of the source.
//   - input  (in optionalParams)
//   - authenticationID - Universally unique identifier (UUID) of an authentication resource. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CreateSourceWithHTTPInfo(
	ctx context.Context,
	type_ SourceType,
	name string,
	optionalParams *CreateSourceOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/sources"

	if name == "" {
		return nil, nil, reportError("Parameter `name` is required when calling `CreateSource`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Type             SourceType   `json:"type"`
		Name             string       `json:"name"`
		Input            *SourceInput `json:"input,omitempty"`
		AuthenticationID *string      `json:"authenticationID,omitempty"`
	}{
		Type: type_,
		Name: name,
	}
	if optionalParams != nil {
		postBody.Input = optionalParams.Input
		postBody.AuthenticationID = optionalParams.AuthenticationID
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CreateTaskOptions represents the optional params for the API call.
type CreateTaskOptions struct {
	SubscriptionAction *ActionType
	Cron               *string
	Enabled            *bool
	FailureThreshold   *int
	Input              *TaskInput
	Cursor             *string
	Notifications      *Notifications
	Policies           *Policies
}

// NewCreateTaskOptions creates an instance of the CreateTaskOptions used to add optional parameters to CreateTaskWithOptions.
func NewCreateTaskOptions() *CreateTaskOptions {
	return &CreateTaskOptions{}
}

// WithSubscriptionAction adds the subscriptionAction to the ApiCreateTaskRequest and returns the request for chaining.
func (o *CreateTaskOptions) WithSubscriptionAction(subscriptionAction ActionType) *CreateTaskOptions {
	o.SubscriptionAction = &subscriptionAction

	return o
}

// WithCron Cron expression for the task's schedule.
func (o *CreateTaskOptions) WithCron(cron string) *CreateTaskOptions {
	o.Cron = &cron

	return o
}

// WithEnabled Whether the task is enabled.
func (o *CreateTaskOptions) WithEnabled(enabled bool) *CreateTaskOptions {
	o.Enabled = &enabled

	return o
}

// WithFailureThreshold Maximum accepted percentage of failures for a task run to finish successfully.
func (o *CreateTaskOptions) WithFailureThreshold(failureThreshold int) *CreateTaskOptions {
	o.FailureThreshold = &failureThreshold

	return o
}

// WithInput adds the input to the ApiCreateTaskRequest and returns the request for chaining.
func (o *CreateTaskOptions) WithInput(input *TaskInput) *CreateTaskOptions {
	o.Input = input

	return o
}

// WithCursor Date of the last cursor in RFC 3339 format.
func (o *CreateTaskOptions) WithCursor(cursor string) *CreateTaskOptions {
	o.Cursor = &cursor

	return o
}

// WithNotifications adds the notifications to the ApiCreateTaskRequest and returns the request for chaining.
func (o *CreateTaskOptions) WithNotifications(notifications *Notifications) *CreateTaskOptions {
	o.Notifications = notifications

	return o
}

// WithPolicies adds the policies to the ApiCreateTaskRequest and returns the request for chaining.
func (o *CreateTaskOptions) WithPolicies(policies *Policies) *CreateTaskOptions {
	o.Policies = policies

	return o
}

// CreateTask Creates a new task.

// Parameters:
//   - sourceID - Universally uniqud identifier (UUID) of a source.
//   - destinationID - Universally unique identifier (UUID) of a destination resource.
//   - action
//   - subscriptionAction  (in optionalParams)
//   - cron - Cron expression for the task's schedule. (in optionalParams)
//   - enabled - Whether the task is enabled. (in optionalParams)
//   - failureThreshold - Maximum accepted percentage of failures for a task run to finish successfully. (in optionalParams)
//   - input  (in optionalParams)
//   - cursor - Date of the last cursor in RFC 3339 format. (in optionalParams)
//   - notifications  (in optionalParams)
//   - policies  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CreateTask(
	ctx context.Context,
	sourceID string,
	destinationID string,
	action ActionType,
	optionalParams *CreateTaskOptions,
	opts ...RequestOption,
) (*TaskCreateResponse, error) {
	var returnValue *TaskCreateResponse

	res, resBody, err := c.CreateTaskWithHTTPInfo(ctx, sourceID, destinationID, action, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CreateTaskWithHTTPInfo calls the API and returns the raw response from it.
// Creates a new task.

// Parameters:
//   - sourceID - Universally uniqud identifier (UUID) of a source.
//   - destinationID - Universally unique identifier (UUID) of a destination resource.
//   - action
//   - subscriptionAction  (in optionalParams)
//   - cron - Cron expression for the task's schedule. (in optionalParams)
//   - enabled - Whether the task is enabled. (in optionalParams)
//   - failureThreshold - Maximum accepted percentage of failures for a task run to finish successfully. (in optionalParams)
//   - input  (in optionalParams)
//   - cursor - Date of the last cursor in RFC 3339 format. (in optionalParams)
//   - notifications  (in optionalParams)
//   - policies  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CreateTaskWithHTTPInfo(
	ctx context.Context,
	sourceID string,
	destinationID string,
	action ActionType,
	optionalParams *CreateTaskOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/tasks"

	if sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `CreateTask`.")
	}

	if destinationID == "" {
		return nil, nil, reportError("Parameter `destinationID` is required when calling `CreateTask`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		SourceID           string         `json:"sourceID"`
		DestinationID      string         `json:"destinationID"`
		Action             ActionType     `json:"action"`
		SubscriptionAction *ActionType    `json:"subscriptionAction,omitempty"`
		Cron               *string        `json:"cron,omitempty"`
		Enabled            *bool          `json:"enabled,omitempty"`
		FailureThreshold   *int           `json:"failureThreshold,omitempty"`
		Input              *TaskInput     `json:"input,omitempty"`
		Cursor             *string        `json:"cursor,omitempty"`
		Notifications      *Notifications `json:"notifications,omitempty"`
		Policies           *Policies      `json:"policies,omitempty"`
	}{
		SourceID:      sourceID,
		DestinationID: destinationID,
		Action:        action,
	}
	if optionalParams != nil {
		postBody.SubscriptionAction = optionalParams.SubscriptionAction
		postBody.Cron = optionalParams.Cron
		postBody.Enabled = optionalParams.Enabled
		postBody.FailureThreshold = optionalParams.FailureThreshold
		postBody.Input = optionalParams.Input
		postBody.Cursor = optionalParams.Cursor
		postBody.Notifications = optionalParams.Notifications
		postBody.Policies = optionalParams.Policies
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CreateTaskV1Options represents the optional params for the API call.
type CreateTaskV1Options struct {
	Enabled          *bool
	FailureThreshold *int
	Input            *TaskInput
	Cursor           *string
}

// Deprecated: CreateTaskV1Options is deprecated
// NewCreateTaskV1Options creates an instance of the CreateTaskV1Options used to add optional parameters to CreateTaskV1WithOptions.
func NewCreateTaskV1Options() *CreateTaskV1Options {
	return &CreateTaskV1Options{}
}

// WithEnabled Whether the task is enabled.
func (o *CreateTaskV1Options) WithEnabled(enabled bool) *CreateTaskV1Options {
	o.Enabled = &enabled

	return o
}

// WithFailureThreshold Maximum accepted percentage of failures for a task run to finish successfully.
func (o *CreateTaskV1Options) WithFailureThreshold(failureThreshold int) *CreateTaskV1Options {
	o.FailureThreshold = &failureThreshold

	return o
}

// WithInput adds the input to the ApiCreateTaskV1Request and returns the request for chaining.
func (o *CreateTaskV1Options) WithInput(input *TaskInput) *CreateTaskV1Options {
	o.Input = input

	return o
}

// WithCursor Date of the last cursor in RFC 3339 format.
func (o *CreateTaskV1Options) WithCursor(cursor string) *CreateTaskV1Options {
	o.Cursor = &cursor

	return o
}

// CreateTaskV1 Creates a new task using the v1 endpoint, please use `createTask` instead.

// Parameters:
//   - sourceID - Universally uniqud identifier (UUID) of a source.
//   - destinationID - Universally unique identifier (UUID) of a destination resource.
//   - trigger
//   - action
//   - enabled - Whether the task is enabled. (in optionalParams)
//   - failureThreshold - Maximum accepted percentage of failures for a task run to finish successfully. (in optionalParams)
//   - input  (in optionalParams)
//   - cursor - Date of the last cursor in RFC 3339 format. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: CreateTaskV1 is deprecated.
func (c *APIClient) CreateTaskV1(
	ctx context.Context,
	sourceID string,
	destinationID string,
	trigger *TaskCreateTrigger,
	action ActionType,
	optionalParams *CreateTaskV1Options,
	opts ...RequestOption,
) (*TaskCreateResponse, error) {
	var returnValue *TaskCreateResponse

	res, resBody, err := c.CreateTaskV1WithHTTPInfo(ctx, sourceID, destinationID, trigger, action, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CreateTaskV1WithHTTPInfo calls the API and returns the raw response from it.
// Creates a new task using the v1 endpoint, please use `createTask` instead.

// Parameters:
//   - sourceID - Universally uniqud identifier (UUID) of a source.
//   - destinationID - Universally unique identifier (UUID) of a destination resource.
//   - trigger
//   - action
//   - enabled - Whether the task is enabled. (in optionalParams)
//   - failureThreshold - Maximum accepted percentage of failures for a task run to finish successfully. (in optionalParams)
//   - input  (in optionalParams)
//   - cursor - Date of the last cursor in RFC 3339 format. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: CreateTaskV1 is deprecated.
func (c *APIClient) CreateTaskV1WithHTTPInfo(
	ctx context.Context,
	sourceID string,
	destinationID string,
	trigger *TaskCreateTrigger,
	action ActionType,
	optionalParams *CreateTaskV1Options,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/tasks"

	if sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `CreateTaskV1`.")
	}

	if destinationID == "" {
		return nil, nil, reportError("Parameter `destinationID` is required when calling `CreateTaskV1`.")
	}

	if trigger == nil {
		return nil, nil, reportError("Parameter `trigger` is required when calling `CreateTaskV1`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		SourceID         string             `json:"sourceID"`
		DestinationID    string             `json:"destinationID"`
		Trigger          *TaskCreateTrigger `json:"trigger"`
		Action           ActionType         `json:"action"`
		Enabled          *bool              `json:"enabled,omitempty"`
		FailureThreshold *int               `json:"failureThreshold,omitempty"`
		Input            *TaskInput         `json:"input,omitempty"`
		Cursor           *string            `json:"cursor,omitempty"`
	}{
		SourceID:      sourceID,
		DestinationID: destinationID,
		Trigger:       trigger,
		Action:        action,
	}
	if optionalParams != nil {
		postBody.Enabled = optionalParams.Enabled
		postBody.FailureThreshold = optionalParams.FailureThreshold
		postBody.Input = optionalParams.Input
		postBody.Cursor = optionalParams.Cursor
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CreateTransformationOptions represents the optional params for the API call.
type CreateTransformationOptions struct {
	Code              *string
	Type              *TransformationType
	Input             *TransformationInput
	Description       *string
	AuthenticationIDs *[]string
}

// NewCreateTransformationOptions creates an instance of the CreateTransformationOptions used to add optional parameters to CreateTransformationWithOptions.
func NewCreateTransformationOptions() *CreateTransformationOptions {
	return &CreateTransformationOptions{}
}

// WithCode It is deprecated. Use the `input` field with proper `type` instead to specify the transformation code.
func (o *CreateTransformationOptions) WithCode(code string) *CreateTransformationOptions {
	o.Code = &code

	return o
}

// WithType adds the type_ to the ApiCreateTransformationRequest and returns the request for chaining.
func (o *CreateTransformationOptions) WithType(type_ TransformationType) *CreateTransformationOptions {
	o.Type = &type_

	return o
}

// WithInput adds the input to the ApiCreateTransformationRequest and returns the request for chaining.
func (o *CreateTransformationOptions) WithInput(input *TransformationInput) *CreateTransformationOptions {
	o.Input = input

	return o
}

// WithDescription A descriptive name for your transformation of what it does.
func (o *CreateTransformationOptions) WithDescription(description string) *CreateTransformationOptions {
	o.Description = &description

	return o
}

// WithAuthenticationIDs The authentications associated with the current transformation.
func (o *CreateTransformationOptions) WithAuthenticationIDs(authenticationIDs []string) *CreateTransformationOptions {
	o.AuthenticationIDs = &authenticationIDs

	return o
}

// CreateTransformation Creates a new transformation.

// Parameters:
//   - name - The uniquely identified name of your transformation.
//   - code - It is deprecated. Use the `input` field with proper `type` instead to specify the transformation code. (in optionalParams)
//   - type_  (in optionalParams)
//   - input  (in optionalParams)
//   - description - A descriptive name for your transformation of what it does. (in optionalParams)
//   - authenticationIDs - The authentications associated with the current transformation. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CreateTransformation(
	ctx context.Context,
	name string,
	optionalParams *CreateTransformationOptions,
	opts ...RequestOption,
) (*TransformationCreateResponse, error) {
	var returnValue *TransformationCreateResponse

	res, resBody, err := c.CreateTransformationWithHTTPInfo(ctx, name, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CreateTransformationWithHTTPInfo calls the API and returns the raw response from it.
// Creates a new transformation.

// Parameters:
//   - name - The uniquely identified name of your transformation.
//   - code - It is deprecated. Use the `input` field with proper `type` instead to specify the transformation code. (in optionalParams)
//   - type_  (in optionalParams)
//   - input  (in optionalParams)
//   - description - A descriptive name for your transformation of what it does. (in optionalParams)
//   - authenticationIDs - The authentications associated with the current transformation. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CreateTransformationWithHTTPInfo(
	ctx context.Context,
	name string,
	optionalParams *CreateTransformationOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/transformations"

	if name == "" {
		return nil, nil, reportError("Parameter `name` is required when calling `CreateTransformation`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Code              *string              `json:"code,omitempty"`
		Name              string               `json:"name"`
		Type              *TransformationType  `json:"type,omitempty"`
		Input             *TransformationInput `json:"input,omitempty"`
		Description       *string              `json:"description,omitempty"`
		AuthenticationIDs *[]string            `json:"authenticationIDs,omitempty"`
	}{
		Name: name,
	}
	if optionalParams != nil {
		postBody.Code = optionalParams.Code
		postBody.Type = optionalParams.Type
		postBody.Input = optionalParams.Input
		postBody.Description = optionalParams.Description
		postBody.AuthenticationIDs = optionalParams.AuthenticationIDs
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomDelete This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomDelete(ctx context.Context, path string, parameters map[string]any, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomDeleteWithHTTPInfo(ctx, path, parameters, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomDeleteWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomDeleteWithHTTPInfo(
	ctx context.Context,
	path string,
	parameters map[string]any,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(parameters) {
		for k, v := range parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomGet This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomGet(ctx context.Context, path string, parameters map[string]any, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomGetWithHTTPInfo(ctx, path, parameters, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomGetWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomGetWithHTTPInfo(
	ctx context.Context,
	path string,
	parameters map[string]any,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(parameters) {
		for k, v := range parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomPostOptions represents the optional params for the API call.
type CustomPostOptions struct {
	Parameters map[string]any
	Body       map[string]any
}

// NewCustomPostOptions creates an instance of the CustomPostOptions used to add optional parameters to CustomPostWithOptions.
func NewCustomPostOptions() *CustomPostOptions {
	return &CustomPostOptions{}
}

// WithParameters Query parameters to apply to the current query.
func (o *CustomPostOptions) WithParameters(parameters map[string]any) *CustomPostOptions {
	o.Parameters = parameters

	return o
}

// WithBody Parameters to send with the custom request.
func (o *CustomPostOptions) WithBody(body map[string]any) *CustomPostOptions {
	o.Body = body

	return o
}

// CustomPost This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPost(ctx context.Context, path string, optionalParams *CustomPostOptions, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPostWithHTTPInfo(ctx, path, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomPostWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPostWithHTTPInfo(
	ctx context.Context,
	path string,
	optionalParams *CustomPostOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Parameters) {
		for k, v := range optionalParams.Parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	var postBody any = "{}"
	if optionalParams != nil {
		postBody = optionalParams.Body
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// CustomPutOptions represents the optional params for the API call.
type CustomPutOptions struct {
	Parameters map[string]any
	Body       map[string]any
}

// NewCustomPutOptions creates an instance of the CustomPutOptions used to add optional parameters to CustomPutWithOptions.
func NewCustomPutOptions() *CustomPutOptions {
	return &CustomPutOptions{}
}

// WithParameters Query parameters to apply to the current query.
func (o *CustomPutOptions) WithParameters(parameters map[string]any) *CustomPutOptions {
	o.Parameters = parameters

	return o
}

// WithBody Parameters to send with the custom request.
func (o *CustomPutOptions) WithBody(body map[string]any) *CustomPutOptions {
	o.Body = body

	return o
}

// CustomPut This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPut(ctx context.Context, path string, optionalParams *CustomPutOptions, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPutWithHTTPInfo(ctx, path, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// CustomPutWithHTTPInfo calls the API and returns the raw response from it.
// This method lets you send requests to the Algolia REST API.

// Parameters:
//   - path - Path of the endpoint, for example `1/newFeature`.
//   - parameters - Query parameters to apply to the current query. (in optionalParams)
//   - body - Parameters to send with the custom request. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) CustomPutWithHTTPInfo(
	ctx context.Context,
	path string,
	optionalParams *CustomPutOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(path))

	if path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Parameters) {
		for k, v := range optionalParams.Parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	var postBody any = "{}"
	if optionalParams != nil {
		postBody = optionalParams.Body
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteAuthentication Deletes an authentication resource. You can't delete authentication resources that are used by a source or a destination.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - authenticationID - Unique identifier of an authentication resource.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteAuthentication(ctx context.Context, authenticationID string, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteAuthenticationWithHTTPInfo(ctx, authenticationID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteAuthenticationWithHTTPInfo calls the API and returns the raw response from it.
// Deletes an authentication resource. You can't delete authentication resources that are used by a source or a destination.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - authenticationID - Unique identifier of an authentication resource.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteAuthenticationWithHTTPInfo(
	ctx context.Context,
	authenticationID string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.ReplaceAll(requestPath, "{authenticationID}", url.PathEscape(utils.ParameterToString(authenticationID)))

	if authenticationID == "" {
		return nil, nil, reportError("Parameter `authenticationID` is required when calling `DeleteAuthentication`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteDestination Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - destinationID - Unique identifier of a destination.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteDestination(ctx context.Context, destinationID string, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteDestinationWithHTTPInfo(ctx, destinationID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteDestinationWithHTTPInfo calls the API and returns the raw response from it.
// Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - destinationID - Unique identifier of a destination.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteDestinationWithHTTPInfo(ctx context.Context, destinationID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.ReplaceAll(requestPath, "{destinationID}", url.PathEscape(utils.ParameterToString(destinationID)))

	if destinationID == "" {
		return nil, nil, reportError("Parameter `destinationID` is required when calling `DeleteDestination`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteSource Deletes a source by its ID. You can't delete sources that are referenced in tasks.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - sourceID - Unique identifier of a source.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteSource(ctx context.Context, sourceID string, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteSourceWithHTTPInfo(ctx, sourceID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteSourceWithHTTPInfo calls the API and returns the raw response from it.
// Deletes a source by its ID. You can't delete sources that are referenced in tasks.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - sourceID - Unique identifier of a source.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteSourceWithHTTPInfo(ctx context.Context, sourceID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(sourceID)))

	if sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `DeleteSource`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteTask Deletes a task by its ID.

// Parameters:
//   - taskID - Unique identifier of a task.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteTask(ctx context.Context, taskID string, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteTaskWithHTTPInfo(ctx, taskID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteTaskWithHTTPInfo calls the API and returns the raw response from it.
// Deletes a task by its ID.

// Parameters:
//   - taskID - Unique identifier of a task.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteTaskWithHTTPInfo(ctx context.Context, taskID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `DeleteTask`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteTaskV1 Deletes a task by its ID using the v1 endpoint, please use `deleteTask` instead.

// Parameters:
//   - taskID - Unique identifier of a task.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: DeleteTaskV1 is deprecated.
func (c *APIClient) DeleteTaskV1(ctx context.Context, taskID string, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteTaskV1WithHTTPInfo(ctx, taskID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteTaskV1WithHTTPInfo calls the API and returns the raw response from it.
// Deletes a task by its ID using the v1 endpoint, please use `deleteTask` instead.

// Parameters:
//   - taskID - Unique identifier of a task.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: DeleteTaskV1 is deprecated.
func (c *APIClient) DeleteTaskV1WithHTTPInfo(ctx context.Context, taskID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `DeleteTaskV1`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DeleteTransformation Deletes a transformation by its ID.

// Parameters:
//   - transformationID - Unique identifier of a transformation.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteTransformation(ctx context.Context, transformationID string, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteTransformationWithHTTPInfo(ctx, transformationID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DeleteTransformationWithHTTPInfo calls the API and returns the raw response from it.
// Deletes a transformation by its ID.

// Parameters:
//   - transformationID - Unique identifier of a transformation.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DeleteTransformationWithHTTPInfo(
	ctx context.Context,
	transformationID string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/{transformationID}"
	requestPath = strings.ReplaceAll(requestPath, "{transformationID}", url.PathEscape(utils.ParameterToString(transformationID)))

	if transformationID == "" {
		return nil, nil, reportError("Parameter `transformationID` is required when calling `DeleteTransformation`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DisableTask Disables a task.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DisableTask(ctx context.Context, taskID string, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.DisableTaskWithHTTPInfo(ctx, taskID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DisableTaskWithHTTPInfo calls the API and returns the raw response from it.
// Disables a task.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) DisableTaskWithHTTPInfo(ctx context.Context, taskID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}/disable"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `DisableTask`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// DisableTaskV1 Disables a task using the v1 endpoint, please use `disableTask` instead.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: DisableTaskV1 is deprecated.
func (c *APIClient) DisableTaskV1(ctx context.Context, taskID string, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.DisableTaskV1WithHTTPInfo(ctx, taskID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// DisableTaskV1WithHTTPInfo calls the API and returns the raw response from it.
// Disables a task using the v1 endpoint, please use `disableTask` instead.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: DisableTaskV1 is deprecated.
func (c *APIClient) DisableTaskV1WithHTTPInfo(ctx context.Context, taskID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}/disable"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `DisableTaskV1`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// EnableTask Enables a task.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) EnableTask(ctx context.Context, taskID string, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.EnableTaskWithHTTPInfo(ctx, taskID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// EnableTaskWithHTTPInfo calls the API and returns the raw response from it.
// Enables a task.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) EnableTaskWithHTTPInfo(ctx context.Context, taskID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}/enable"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `EnableTask`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// EnableTaskV1 Enables a task using the v1 endpoint, please use `enableTask` instead.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: EnableTaskV1 is deprecated.
func (c *APIClient) EnableTaskV1(ctx context.Context, taskID string, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.EnableTaskV1WithHTTPInfo(ctx, taskID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// EnableTaskV1WithHTTPInfo calls the API and returns the raw response from it.
// Enables a task using the v1 endpoint, please use `enableTask` instead.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: EnableTaskV1 is deprecated.
func (c *APIClient) EnableTaskV1WithHTTPInfo(ctx context.Context, taskID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}/enable"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `EnableTaskV1`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetAuthentication Retrieves an authentication resource by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - authenticationID - Unique identifier of an authentication resource.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetAuthentication(ctx context.Context, authenticationID string, opts ...RequestOption) (*Authentication, error) {
	var returnValue *Authentication

	res, resBody, err := c.GetAuthenticationWithHTTPInfo(ctx, authenticationID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetAuthenticationWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves an authentication resource by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - authenticationID - Unique identifier of an authentication resource.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetAuthenticationWithHTTPInfo(
	ctx context.Context,
	authenticationID string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.ReplaceAll(requestPath, "{authenticationID}", url.PathEscape(utils.ParameterToString(authenticationID)))

	if authenticationID == "" {
		return nil, nil, reportError("Parameter `authenticationID` is required when calling `GetAuthentication`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetDestination Retrieves a destination by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - destinationID - Unique identifier of a destination.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetDestination(ctx context.Context, destinationID string, opts ...RequestOption) (*Destination, error) {
	var returnValue *Destination

	res, resBody, err := c.GetDestinationWithHTTPInfo(ctx, destinationID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetDestinationWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a destination by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - destinationID - Unique identifier of a destination.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetDestinationWithHTTPInfo(ctx context.Context, destinationID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.ReplaceAll(requestPath, "{destinationID}", url.PathEscape(utils.ParameterToString(destinationID)))

	if destinationID == "" {
		return nil, nil, reportError("Parameter `destinationID` is required when calling `GetDestination`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetEvent Retrieves a single task run event by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - runID - Unique identifier of a task run.
//   - eventID - Unique identifier of an event.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetEvent(ctx context.Context, runID string, eventID string, opts ...RequestOption) (*Event, error) {
	var returnValue *Event

	res, resBody, err := c.GetEventWithHTTPInfo(ctx, runID, eventID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetEventWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a single task run event by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - runID - Unique identifier of a task run.
//   - eventID - Unique identifier of an event.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetEventWithHTTPInfo(ctx context.Context, runID string, eventID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/runs/{runID}/events/{eventID}"
	requestPath = strings.ReplaceAll(requestPath, "{runID}", url.PathEscape(utils.ParameterToString(runID)))
	requestPath = strings.ReplaceAll(requestPath, "{eventID}", url.PathEscape(utils.ParameterToString(eventID)))

	if runID == "" {
		return nil, nil, reportError("Parameter `runID` is required when calling `GetEvent`.")
	}

	if eventID == "" {
		return nil, nil, reportError("Parameter `eventID` is required when calling `GetEvent`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetRun Retrieve a single task run by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - runID - Unique identifier of a task run.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetRun(ctx context.Context, runID string, opts ...RequestOption) (*Run, error) {
	var returnValue *Run

	res, resBody, err := c.GetRunWithHTTPInfo(ctx, runID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetRunWithHTTPInfo calls the API and returns the raw response from it.
// Retrieve a single task run by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - runID - Unique identifier of a task run.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetRunWithHTTPInfo(ctx context.Context, runID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/runs/{runID}"
	requestPath = strings.ReplaceAll(requestPath, "{runID}", url.PathEscape(utils.ParameterToString(runID)))

	if runID == "" {
		return nil, nil, reportError("Parameter `runID` is required when calling `GetRun`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetSource Retrieve a source by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - sourceID - Unique identifier of a source.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetSource(ctx context.Context, sourceID string, opts ...RequestOption) (*Source, error) {
	var returnValue *Source

	res, resBody, err := c.GetSourceWithHTTPInfo(ctx, sourceID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetSourceWithHTTPInfo calls the API and returns the raw response from it.
// Retrieve a source by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - sourceID - Unique identifier of a source.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetSourceWithHTTPInfo(ctx context.Context, sourceID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(sourceID)))

	if sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `GetSource`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetTask Retrieves a task by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTask(ctx context.Context, taskID string, opts ...RequestOption) (*Task, error) {
	var returnValue *Task

	res, resBody, err := c.GetTaskWithHTTPInfo(ctx, taskID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetTaskWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a task by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTaskWithHTTPInfo(ctx context.Context, taskID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `GetTask`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetTaskV1 Retrieves a task by its ID using the v1 endpoint, please use `getTask` instead.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: GetTaskV1 is deprecated.
func (c *APIClient) GetTaskV1(ctx context.Context, taskID string, opts ...RequestOption) (*TaskV1, error) {
	var returnValue *TaskV1

	res, resBody, err := c.GetTaskV1WithHTTPInfo(ctx, taskID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetTaskV1WithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a task by its ID using the v1 endpoint, please use `getTask` instead.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: GetTaskV1 is deprecated.
func (c *APIClient) GetTaskV1WithHTTPInfo(ctx context.Context, taskID string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `GetTaskV1`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// GetTransformation Retrieves a transformation by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - transformationID - Unique identifier of a transformation.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTransformation(ctx context.Context, transformationID string, opts ...RequestOption) (*Transformation, error) {
	var returnValue *Transformation

	res, resBody, err := c.GetTransformationWithHTTPInfo(ctx, transformationID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// GetTransformationWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a transformation by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - transformationID - Unique identifier of a transformation.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) GetTransformationWithHTTPInfo(
	ctx context.Context,
	transformationID string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/{transformationID}"
	requestPath = strings.ReplaceAll(requestPath, "{transformationID}", url.PathEscape(utils.ParameterToString(transformationID)))

	if transformationID == "" {
		return nil, nil, reportError("Parameter `transformationID` is required when calling `GetTransformation`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ListAuthenticationsOptions represents the optional params for the API call.
type ListAuthenticationsOptions struct {
	ItemsPerPage *int
	Page         *int
	Type         *[]AuthenticationType
	Platform     *[]PlatformWithNone
	Sort         *AuthenticationSortKeys
	Order        *OrderKeys
}

// NewListAuthenticationsOptions creates an instance of the ListAuthenticationsOptions used to add optional parameters to ListAuthenticationsWithOptions.
func NewListAuthenticationsOptions() *ListAuthenticationsOptions {
	return &ListAuthenticationsOptions{}
}

// WithItemsPerPage Number of items per page.
func (o *ListAuthenticationsOptions) WithItemsPerPage(itemsPerPage int) *ListAuthenticationsOptions {
	o.ItemsPerPage = &itemsPerPage

	return o
}

// WithPage Page number of the paginated API response.
func (o *ListAuthenticationsOptions) WithPage(page int) *ListAuthenticationsOptions {
	o.Page = &page

	return o
}

// WithType Type of authentication resource to retrieve.
func (o *ListAuthenticationsOptions) WithType(type_ []AuthenticationType) *ListAuthenticationsOptions {
	o.Type = &type_

	return o
}

// WithPlatform Ecommerce platform for which to retrieve authentications.
func (o *ListAuthenticationsOptions) WithPlatform(platform []PlatformWithNone) *ListAuthenticationsOptions {
	o.Platform = &platform

	return o
}

// WithSort Property by which to sort the list of authentications.
func (o *ListAuthenticationsOptions) WithSort(sort AuthenticationSortKeys) *ListAuthenticationsOptions {
	o.Sort = &sort

	return o
}

// WithOrder Sort order of the response, ascending or descending.
func (o *ListAuthenticationsOptions) WithOrder(order OrderKeys) *ListAuthenticationsOptions {
	o.Order = &order

	return o
}

// ListAuthentications Retrieves a list of all authentication resources.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - itemsPerPage - Number of items per page. (in optionalParams)
//   - page - Page number of the paginated API response. (in optionalParams)
//   - type_ - Type of authentication resource to retrieve. (in optionalParams)
//   - platform - Ecommerce platform for which to retrieve authentications. (in optionalParams)
//   - sort - Property by which to sort the list of authentications. (in optionalParams)
//   - order - Sort order of the response, ascending or descending. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListAuthentications(
	ctx context.Context,
	optionalParams *ListAuthenticationsOptions,
	opts ...RequestOption,
) (*ListAuthenticationsResponse, error) {
	var returnValue *ListAuthenticationsResponse

	res, resBody, err := c.ListAuthenticationsWithHTTPInfo(ctx, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ListAuthenticationsWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a list of all authentication resources.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - itemsPerPage - Number of items per page. (in optionalParams)
//   - page - Page number of the paginated API response. (in optionalParams)
//   - type_ - Type of authentication resource to retrieve. (in optionalParams)
//   - platform - Ecommerce platform for which to retrieve authentications. (in optionalParams)
//   - sort - Property by which to sort the list of authentications. (in optionalParams)
//   - order - Sort order of the response, ascending or descending. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListAuthenticationsWithHTTPInfo(
	ctx context.Context,
	optionalParams *ListAuthenticationsOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/authentications"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.ItemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*optionalParams.ItemsPerPage))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*optionalParams.Page))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Type) {
		conf.queryParams.Set("type", utils.QueryParameterToString(*optionalParams.Type))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Platform) {
		conf.queryParams.Set("platform", utils.QueryParameterToString(*optionalParams.Platform))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(*optionalParams.Sort))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(*optionalParams.Order))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ListDestinationsOptions represents the optional params for the API call.
type ListDestinationsOptions struct {
	ItemsPerPage     *int
	Page             *int
	Type             *[]DestinationType
	AuthenticationID *[]string
	TransformationID *string
	Sort             *DestinationSortKeys
	Order            *OrderKeys
}

// NewListDestinationsOptions creates an instance of the ListDestinationsOptions used to add optional parameters to ListDestinationsWithOptions.
func NewListDestinationsOptions() *ListDestinationsOptions {
	return &ListDestinationsOptions{}
}

// WithItemsPerPage Number of items per page.
func (o *ListDestinationsOptions) WithItemsPerPage(itemsPerPage int) *ListDestinationsOptions {
	o.ItemsPerPage = &itemsPerPage

	return o
}

// WithPage Page number of the paginated API response.
func (o *ListDestinationsOptions) WithPage(page int) *ListDestinationsOptions {
	o.Page = &page

	return o
}

// WithType Destination type.
func (o *ListDestinationsOptions) WithType(type_ []DestinationType) *ListDestinationsOptions {
	o.Type = &type_

	return o
}

// WithAuthenticationID Authentication ID used by destinations.
func (o *ListDestinationsOptions) WithAuthenticationID(authenticationID []string) *ListDestinationsOptions {
	o.AuthenticationID = &authenticationID

	return o
}

// WithTransformationID Get the list of destinations used by a transformation.
func (o *ListDestinationsOptions) WithTransformationID(transformationID string) *ListDestinationsOptions {
	o.TransformationID = &transformationID

	return o
}

// WithSort Property by which to sort the destinations.
func (o *ListDestinationsOptions) WithSort(sort DestinationSortKeys) *ListDestinationsOptions {
	o.Sort = &sort

	return o
}

// WithOrder Sort order of the response, ascending or descending.
func (o *ListDestinationsOptions) WithOrder(order OrderKeys) *ListDestinationsOptions {
	o.Order = &order

	return o
}

// ListDestinations Retrieves a list of destinations.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - itemsPerPage - Number of items per page. (in optionalParams)
//   - page - Page number of the paginated API response. (in optionalParams)
//   - type_ - Destination type. (in optionalParams)
//   - authenticationID - Authentication ID used by destinations. (in optionalParams)
//   - transformationID - Get the list of destinations used by a transformation. (in optionalParams)
//   - sort - Property by which to sort the destinations. (in optionalParams)
//   - order - Sort order of the response, ascending or descending. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListDestinations(
	ctx context.Context,
	optionalParams *ListDestinationsOptions,
	opts ...RequestOption,
) (*ListDestinationsResponse, error) {
	var returnValue *ListDestinationsResponse

	res, resBody, err := c.ListDestinationsWithHTTPInfo(ctx, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ListDestinationsWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a list of destinations.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - itemsPerPage - Number of items per page. (in optionalParams)
//   - page - Page number of the paginated API response. (in optionalParams)
//   - type_ - Destination type. (in optionalParams)
//   - authenticationID - Authentication ID used by destinations. (in optionalParams)
//   - transformationID - Get the list of destinations used by a transformation. (in optionalParams)
//   - sort - Property by which to sort the destinations. (in optionalParams)
//   - order - Sort order of the response, ascending or descending. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListDestinationsWithHTTPInfo(
	ctx context.Context,
	optionalParams *ListDestinationsOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/destinations"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.ItemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*optionalParams.ItemsPerPage))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*optionalParams.Page))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Type) {
		conf.queryParams.Set("type", utils.QueryParameterToString(*optionalParams.Type))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.AuthenticationID) {
		conf.queryParams.Set("authenticationID", utils.QueryParameterToString(*optionalParams.AuthenticationID))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.TransformationID) {
		conf.queryParams.Set("transformationID", utils.QueryParameterToString(*optionalParams.TransformationID))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(*optionalParams.Sort))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(*optionalParams.Order))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ListEventsOptions represents the optional params for the API call.
type ListEventsOptions struct {
	ItemsPerPage *int
	Page         *int
	Status       *[]EventStatus
	Type         *[]EventType
	Sort         *EventSortKeys
	Order        *OrderKeys
	StartDate    *string
	EndDate      *string
}

// NewListEventsOptions creates an instance of the ListEventsOptions used to add optional parameters to ListEventsWithOptions.
func NewListEventsOptions() *ListEventsOptions {
	return &ListEventsOptions{}
}

// WithItemsPerPage Number of items per page.
func (o *ListEventsOptions) WithItemsPerPage(itemsPerPage int) *ListEventsOptions {
	o.ItemsPerPage = &itemsPerPage

	return o
}

// WithPage Page number of the paginated API response.
func (o *ListEventsOptions) WithPage(page int) *ListEventsOptions {
	o.Page = &page

	return o
}

// WithStatus Event status for filtering the list of task runs.
func (o *ListEventsOptions) WithStatus(status []EventStatus) *ListEventsOptions {
	o.Status = &status

	return o
}

// WithType Event type for filtering the list of task runs.
func (o *ListEventsOptions) WithType(type_ []EventType) *ListEventsOptions {
	o.Type = &type_

	return o
}

// WithSort Property by which to sort the list of task run events.
func (o *ListEventsOptions) WithSort(sort EventSortKeys) *ListEventsOptions {
	o.Sort = &sort

	return o
}

// WithOrder Sort order of the response, ascending or descending.
func (o *ListEventsOptions) WithOrder(order OrderKeys) *ListEventsOptions {
	o.Order = &order

	return o
}

// WithStartDate Date and time in RFC 3339 format for the earliest events to retrieve. By default, the current time minus three hours is used.
func (o *ListEventsOptions) WithStartDate(startDate string) *ListEventsOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate Date and time in RFC 3339 format for the latest events to retrieve. By default, the current time is used.
func (o *ListEventsOptions) WithEndDate(endDate string) *ListEventsOptions {
	o.EndDate = &endDate

	return o
}

// ListEvents Retrieves a list of events for a task run, identified by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - runID - Unique identifier of a task run.
//   - itemsPerPage - Number of items per page. (in optionalParams)
//   - page - Page number of the paginated API response. (in optionalParams)
//   - status - Event status for filtering the list of task runs. (in optionalParams)
//   - type_ - Event type for filtering the list of task runs. (in optionalParams)
//   - sort - Property by which to sort the list of task run events. (in optionalParams)
//   - order - Sort order of the response, ascending or descending. (in optionalParams)
//   - startDate - Date and time in RFC 3339 format for the earliest events to retrieve. By default, the current time minus three hours is used. (in optionalParams)
//   - endDate - Date and time in RFC 3339 format for the latest events to retrieve. By default, the current time is used. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListEvents(
	ctx context.Context,
	runID string,
	optionalParams *ListEventsOptions,
	opts ...RequestOption,
) (*ListEventsResponse, error) {
	var returnValue *ListEventsResponse

	res, resBody, err := c.ListEventsWithHTTPInfo(ctx, runID, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ListEventsWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a list of events for a task run, identified by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - runID - Unique identifier of a task run.
//   - itemsPerPage - Number of items per page. (in optionalParams)
//   - page - Page number of the paginated API response. (in optionalParams)
//   - status - Event status for filtering the list of task runs. (in optionalParams)
//   - type_ - Event type for filtering the list of task runs. (in optionalParams)
//   - sort - Property by which to sort the list of task run events. (in optionalParams)
//   - order - Sort order of the response, ascending or descending. (in optionalParams)
//   - startDate - Date and time in RFC 3339 format for the earliest events to retrieve. By default, the current time minus three hours is used. (in optionalParams)
//   - endDate - Date and time in RFC 3339 format for the latest events to retrieve. By default, the current time is used. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListEventsWithHTTPInfo(
	ctx context.Context,
	runID string,
	optionalParams *ListEventsOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/runs/{runID}/events"
	requestPath = strings.ReplaceAll(requestPath, "{runID}", url.PathEscape(utils.ParameterToString(runID)))

	if runID == "" {
		return nil, nil, reportError("Parameter `runID` is required when calling `ListEvents`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.ItemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*optionalParams.ItemsPerPage))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*optionalParams.Page))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Status) {
		conf.queryParams.Set("status", utils.QueryParameterToString(*optionalParams.Status))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Type) {
		conf.queryParams.Set("type", utils.QueryParameterToString(*optionalParams.Type))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(*optionalParams.Sort))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(*optionalParams.Order))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ListRunsOptions represents the optional params for the API call.
type ListRunsOptions struct {
	ItemsPerPage *int
	Page         *int
	Status       *[]RunStatus
	Type         *[]RunType
	TaskID       *string
	Sort         *RunSortKeys
	Order        *OrderKeys
	StartDate    *string
	EndDate      *string
}

// NewListRunsOptions creates an instance of the ListRunsOptions used to add optional parameters to ListRunsWithOptions.
func NewListRunsOptions() *ListRunsOptions {
	return &ListRunsOptions{}
}

// WithItemsPerPage Number of items per page.
func (o *ListRunsOptions) WithItemsPerPage(itemsPerPage int) *ListRunsOptions {
	o.ItemsPerPage = &itemsPerPage

	return o
}

// WithPage Page number of the paginated API response.
func (o *ListRunsOptions) WithPage(page int) *ListRunsOptions {
	o.Page = &page

	return o
}

// WithStatus Run status for filtering the list of task runs.
func (o *ListRunsOptions) WithStatus(status []RunStatus) *ListRunsOptions {
	o.Status = &status

	return o
}

// WithType Run type for filtering the list of task runs.
func (o *ListRunsOptions) WithType(type_ []RunType) *ListRunsOptions {
	o.Type = &type_

	return o
}

// WithTaskID Task ID for filtering the list of task runs.
func (o *ListRunsOptions) WithTaskID(taskID string) *ListRunsOptions {
	o.TaskID = &taskID

	return o
}

// WithSort Property by which to sort the list of task runs.
func (o *ListRunsOptions) WithSort(sort RunSortKeys) *ListRunsOptions {
	o.Sort = &sort

	return o
}

// WithOrder Sort order of the response, ascending or descending.
func (o *ListRunsOptions) WithOrder(order OrderKeys) *ListRunsOptions {
	o.Order = &order

	return o
}

// WithStartDate Date in RFC 3339 format for the earliest run to retrieve. By default, the current day minus seven days is used.
func (o *ListRunsOptions) WithStartDate(startDate string) *ListRunsOptions {
	o.StartDate = &startDate

	return o
}

// WithEndDate Date in RFC 3339 format for the latest run to retrieve. By default, the current day is used.
func (o *ListRunsOptions) WithEndDate(endDate string) *ListRunsOptions {
	o.EndDate = &endDate

	return o
}

// ListRuns Retrieve a list of task runs.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - itemsPerPage - Number of items per page. (in optionalParams)
//   - page - Page number of the paginated API response. (in optionalParams)
//   - status - Run status for filtering the list of task runs. (in optionalParams)
//   - type_ - Run type for filtering the list of task runs. (in optionalParams)
//   - taskID - Task ID for filtering the list of task runs. (in optionalParams)
//   - sort - Property by which to sort the list of task runs. (in optionalParams)
//   - order - Sort order of the response, ascending or descending. (in optionalParams)
//   - startDate - Date in RFC 3339 format for the earliest run to retrieve. By default, the current day minus seven days is used. (in optionalParams)
//   - endDate - Date in RFC 3339 format for the latest run to retrieve. By default, the current day is used. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListRuns(ctx context.Context, optionalParams *ListRunsOptions, opts ...RequestOption) (*RunListResponse, error) {
	var returnValue *RunListResponse

	res, resBody, err := c.ListRunsWithHTTPInfo(ctx, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ListRunsWithHTTPInfo calls the API and returns the raw response from it.
// Retrieve a list of task runs.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - itemsPerPage - Number of items per page. (in optionalParams)
//   - page - Page number of the paginated API response. (in optionalParams)
//   - status - Run status for filtering the list of task runs. (in optionalParams)
//   - type_ - Run type for filtering the list of task runs. (in optionalParams)
//   - taskID - Task ID for filtering the list of task runs. (in optionalParams)
//   - sort - Property by which to sort the list of task runs. (in optionalParams)
//   - order - Sort order of the response, ascending or descending. (in optionalParams)
//   - startDate - Date in RFC 3339 format for the earliest run to retrieve. By default, the current day minus seven days is used. (in optionalParams)
//   - endDate - Date in RFC 3339 format for the latest run to retrieve. By default, the current day is used. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListRunsWithHTTPInfo(
	ctx context.Context,
	optionalParams *ListRunsOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/runs"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.ItemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*optionalParams.ItemsPerPage))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*optionalParams.Page))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Status) {
		conf.queryParams.Set("status", utils.QueryParameterToString(*optionalParams.Status))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Type) {
		conf.queryParams.Set("type", utils.QueryParameterToString(*optionalParams.Type))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.TaskID) {
		conf.queryParams.Set("taskID", utils.QueryParameterToString(*optionalParams.TaskID))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(*optionalParams.Sort))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(*optionalParams.Order))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.StartDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*optionalParams.StartDate))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.EndDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*optionalParams.EndDate))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ListSourcesOptions represents the optional params for the API call.
type ListSourcesOptions struct {
	ItemsPerPage     *int
	Page             *int
	Type             *[]SourceType
	AuthenticationID *[]string
	Sort             *SourceSortKeys
	Order            *OrderKeys
}

// NewListSourcesOptions creates an instance of the ListSourcesOptions used to add optional parameters to ListSourcesWithOptions.
func NewListSourcesOptions() *ListSourcesOptions {
	return &ListSourcesOptions{}
}

// WithItemsPerPage Number of items per page.
func (o *ListSourcesOptions) WithItemsPerPage(itemsPerPage int) *ListSourcesOptions {
	o.ItemsPerPage = &itemsPerPage

	return o
}

// WithPage Page number of the paginated API response.
func (o *ListSourcesOptions) WithPage(page int) *ListSourcesOptions {
	o.Page = &page

	return o
}

// WithType Source type. Some sources require authentication.
func (o *ListSourcesOptions) WithType(type_ []SourceType) *ListSourcesOptions {
	o.Type = &type_

	return o
}

// WithAuthenticationID Authentication IDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication.
func (o *ListSourcesOptions) WithAuthenticationID(authenticationID []string) *ListSourcesOptions {
	o.AuthenticationID = &authenticationID

	return o
}

// WithSort Property by which to sort the list of sources.
func (o *ListSourcesOptions) WithSort(sort SourceSortKeys) *ListSourcesOptions {
	o.Sort = &sort

	return o
}

// WithOrder Sort order of the response, ascending or descending.
func (o *ListSourcesOptions) WithOrder(order OrderKeys) *ListSourcesOptions {
	o.Order = &order

	return o
}

// ListSources Retrieves a list of sources.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - itemsPerPage - Number of items per page. (in optionalParams)
//   - page - Page number of the paginated API response. (in optionalParams)
//   - type_ - Source type. Some sources require authentication. (in optionalParams)
//   - authenticationID - Authentication IDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication.  (in optionalParams)
//   - sort - Property by which to sort the list of sources. (in optionalParams)
//   - order - Sort order of the response, ascending or descending. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListSources(ctx context.Context, optionalParams *ListSourcesOptions, opts ...RequestOption) (*ListSourcesResponse, error) {
	var returnValue *ListSourcesResponse

	res, resBody, err := c.ListSourcesWithHTTPInfo(ctx, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ListSourcesWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a list of sources.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - itemsPerPage - Number of items per page. (in optionalParams)
//   - page - Page number of the paginated API response. (in optionalParams)
//   - type_ - Source type. Some sources require authentication. (in optionalParams)
//   - authenticationID - Authentication IDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication.  (in optionalParams)
//   - sort - Property by which to sort the list of sources. (in optionalParams)
//   - order - Sort order of the response, ascending or descending. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListSourcesWithHTTPInfo(
	ctx context.Context,
	optionalParams *ListSourcesOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/sources"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.ItemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*optionalParams.ItemsPerPage))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*optionalParams.Page))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Type) {
		conf.queryParams.Set("type", utils.QueryParameterToString(*optionalParams.Type))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.AuthenticationID) {
		conf.queryParams.Set("authenticationID", utils.QueryParameterToString(*optionalParams.AuthenticationID))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(*optionalParams.Sort))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(*optionalParams.Order))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ListTasksOptions represents the optional params for the API call.
type ListTasksOptions struct {
	ItemsPerPage           *int
	Page                   *int
	Action                 *[]ActionType
	Enabled                *bool
	SourceID               *[]string
	SourceType             *[]SourceType
	DestinationID          *[]string
	TriggerType            *[]TriggerType
	WithEmailNotifications *bool
	Sort                   *TaskSortKeys
	Order                  *OrderKeys
}

// NewListTasksOptions creates an instance of the ListTasksOptions used to add optional parameters to ListTasksWithOptions.
func NewListTasksOptions() *ListTasksOptions {
	return &ListTasksOptions{}
}

// WithItemsPerPage Number of items per page.
func (o *ListTasksOptions) WithItemsPerPage(itemsPerPage int) *ListTasksOptions {
	o.ItemsPerPage = &itemsPerPage

	return o
}

// WithPage Page number of the paginated API response.
func (o *ListTasksOptions) WithPage(page int) *ListTasksOptions {
	o.Page = &page

	return o
}

// WithAction Actions for filtering the list of tasks.
func (o *ListTasksOptions) WithAction(action []ActionType) *ListTasksOptions {
	o.Action = &action

	return o
}

// WithEnabled Whether to filter the list of tasks by the `enabled` status.
func (o *ListTasksOptions) WithEnabled(enabled bool) *ListTasksOptions {
	o.Enabled = &enabled

	return o
}

// WithSourceID Source IDs for filtering the list of tasks.
func (o *ListTasksOptions) WithSourceID(sourceID []string) *ListTasksOptions {
	o.SourceID = &sourceID

	return o
}

// WithSourceType Filters the tasks with the specified source type.
func (o *ListTasksOptions) WithSourceType(sourceType []SourceType) *ListTasksOptions {
	o.SourceType = &sourceType

	return o
}

// WithDestinationID Destination IDs for filtering the list of tasks.
func (o *ListTasksOptions) WithDestinationID(destinationID []string) *ListTasksOptions {
	o.DestinationID = &destinationID

	return o
}

// WithTriggerType Type of task trigger for filtering the list of tasks.
func (o *ListTasksOptions) WithTriggerType(triggerType []TriggerType) *ListTasksOptions {
	o.TriggerType = &triggerType

	return o
}

// WithWithEmailNotifications If specified, the response only includes tasks with notifications.email.enabled set to this value.
func (o *ListTasksOptions) WithWithEmailNotifications(withEmailNotifications bool) *ListTasksOptions {
	o.WithEmailNotifications = &withEmailNotifications

	return o
}

// WithSort Property by which to sort the list of tasks.
func (o *ListTasksOptions) WithSort(sort TaskSortKeys) *ListTasksOptions {
	o.Sort = &sort

	return o
}

// WithOrder Sort order of the response, ascending or descending.
func (o *ListTasksOptions) WithOrder(order OrderKeys) *ListTasksOptions {
	o.Order = &order

	return o
}

// ListTasks Retrieves a list of tasks.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - itemsPerPage - Number of items per page. (in optionalParams)
//   - page - Page number of the paginated API response. (in optionalParams)
//   - action - Actions for filtering the list of tasks. (in optionalParams)
//   - enabled - Whether to filter the list of tasks by the `enabled` status. (in optionalParams)
//   - sourceID - Source IDs for filtering the list of tasks. (in optionalParams)
//   - sourceType - Filters the tasks with the specified source type. (in optionalParams)
//   - destinationID - Destination IDs for filtering the list of tasks. (in optionalParams)
//   - triggerType - Type of task trigger for filtering the list of tasks. (in optionalParams)
//   - withEmailNotifications - If specified, the response only includes tasks with notifications.email.enabled set to this value. (in optionalParams)
//   - sort - Property by which to sort the list of tasks. (in optionalParams)
//   - order - Sort order of the response, ascending or descending. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListTasks(ctx context.Context, optionalParams *ListTasksOptions, opts ...RequestOption) (*ListTasksResponse, error) {
	var returnValue *ListTasksResponse

	res, resBody, err := c.ListTasksWithHTTPInfo(ctx, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ListTasksWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a list of tasks.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - itemsPerPage - Number of items per page. (in optionalParams)
//   - page - Page number of the paginated API response. (in optionalParams)
//   - action - Actions for filtering the list of tasks. (in optionalParams)
//   - enabled - Whether to filter the list of tasks by the `enabled` status. (in optionalParams)
//   - sourceID - Source IDs for filtering the list of tasks. (in optionalParams)
//   - sourceType - Filters the tasks with the specified source type. (in optionalParams)
//   - destinationID - Destination IDs for filtering the list of tasks. (in optionalParams)
//   - triggerType - Type of task trigger for filtering the list of tasks. (in optionalParams)
//   - withEmailNotifications - If specified, the response only includes tasks with notifications.email.enabled set to this value. (in optionalParams)
//   - sort - Property by which to sort the list of tasks. (in optionalParams)
//   - order - Sort order of the response, ascending or descending. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListTasksWithHTTPInfo(
	ctx context.Context,
	optionalParams *ListTasksOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/tasks"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.ItemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*optionalParams.ItemsPerPage))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*optionalParams.Page))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Action) {
		conf.queryParams.Set("action", utils.QueryParameterToString(*optionalParams.Action))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Enabled) {
		conf.queryParams.Set("enabled", utils.QueryParameterToString(*optionalParams.Enabled))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.SourceID) {
		conf.queryParams.Set("sourceID", utils.QueryParameterToString(*optionalParams.SourceID))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.SourceType) {
		conf.queryParams.Set("sourceType", utils.QueryParameterToString(*optionalParams.SourceType))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.DestinationID) {
		conf.queryParams.Set("destinationID", utils.QueryParameterToString(*optionalParams.DestinationID))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.TriggerType) {
		conf.queryParams.Set("triggerType", utils.QueryParameterToString(*optionalParams.TriggerType))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.WithEmailNotifications) {
		conf.queryParams.Set("withEmailNotifications", utils.QueryParameterToString(*optionalParams.WithEmailNotifications))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(*optionalParams.Sort))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(*optionalParams.Order))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ListTasksV1Options represents the optional params for the API call.
type ListTasksV1Options struct {
	ItemsPerPage  *int
	Page          *int
	Action        *[]ActionType
	Enabled       *bool
	SourceID      *[]string
	DestinationID *[]string
	TriggerType   *[]TriggerType
	Sort          *TaskSortKeys
	Order         *OrderKeys
}

// Deprecated: ListTasksV1Options is deprecated
// NewListTasksV1Options creates an instance of the ListTasksV1Options used to add optional parameters to ListTasksV1WithOptions.
func NewListTasksV1Options() *ListTasksV1Options {
	return &ListTasksV1Options{}
}

// WithItemsPerPage Number of items per page.
func (o *ListTasksV1Options) WithItemsPerPage(itemsPerPage int) *ListTasksV1Options {
	o.ItemsPerPage = &itemsPerPage

	return o
}

// WithPage Page number of the paginated API response.
func (o *ListTasksV1Options) WithPage(page int) *ListTasksV1Options {
	o.Page = &page

	return o
}

// WithAction Actions for filtering the list of tasks.
func (o *ListTasksV1Options) WithAction(action []ActionType) *ListTasksV1Options {
	o.Action = &action

	return o
}

// WithEnabled Whether to filter the list of tasks by the `enabled` status.
func (o *ListTasksV1Options) WithEnabled(enabled bool) *ListTasksV1Options {
	o.Enabled = &enabled

	return o
}

// WithSourceID Source IDs for filtering the list of tasks.
func (o *ListTasksV1Options) WithSourceID(sourceID []string) *ListTasksV1Options {
	o.SourceID = &sourceID

	return o
}

// WithDestinationID Destination IDs for filtering the list of tasks.
func (o *ListTasksV1Options) WithDestinationID(destinationID []string) *ListTasksV1Options {
	o.DestinationID = &destinationID

	return o
}

// WithTriggerType Type of task trigger for filtering the list of tasks.
func (o *ListTasksV1Options) WithTriggerType(triggerType []TriggerType) *ListTasksV1Options {
	o.TriggerType = &triggerType

	return o
}

// WithSort Property by which to sort the list of tasks.
func (o *ListTasksV1Options) WithSort(sort TaskSortKeys) *ListTasksV1Options {
	o.Sort = &sort

	return o
}

// WithOrder Sort order of the response, ascending or descending.
func (o *ListTasksV1Options) WithOrder(order OrderKeys) *ListTasksV1Options {
	o.Order = &order

	return o
}

// ListTasksV1 Retrieves a list of tasks using the v1 endpoint, please use `getTasks` instead.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - itemsPerPage - Number of items per page. (in optionalParams)
//   - page - Page number of the paginated API response. (in optionalParams)
//   - action - Actions for filtering the list of tasks. (in optionalParams)
//   - enabled - Whether to filter the list of tasks by the `enabled` status. (in optionalParams)
//   - sourceID - Source IDs for filtering the list of tasks. (in optionalParams)
//   - destinationID - Destination IDs for filtering the list of tasks. (in optionalParams)
//   - triggerType - Type of task trigger for filtering the list of tasks. (in optionalParams)
//   - sort - Property by which to sort the list of tasks. (in optionalParams)
//   - order - Sort order of the response, ascending or descending. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: ListTasksV1 is deprecated.
func (c *APIClient) ListTasksV1(ctx context.Context, optionalParams *ListTasksV1Options, opts ...RequestOption) (*ListTasksResponseV1, error) {
	var returnValue *ListTasksResponseV1

	res, resBody, err := c.ListTasksV1WithHTTPInfo(ctx, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ListTasksV1WithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a list of tasks using the v1 endpoint, please use `getTasks` instead.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - itemsPerPage - Number of items per page. (in optionalParams)
//   - page - Page number of the paginated API response. (in optionalParams)
//   - action - Actions for filtering the list of tasks. (in optionalParams)
//   - enabled - Whether to filter the list of tasks by the `enabled` status. (in optionalParams)
//   - sourceID - Source IDs for filtering the list of tasks. (in optionalParams)
//   - destinationID - Destination IDs for filtering the list of tasks. (in optionalParams)
//   - triggerType - Type of task trigger for filtering the list of tasks. (in optionalParams)
//   - sort - Property by which to sort the list of tasks. (in optionalParams)
//   - order - Sort order of the response, ascending or descending. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: ListTasksV1 is deprecated.
func (c *APIClient) ListTasksV1WithHTTPInfo(
	ctx context.Context,
	optionalParams *ListTasksV1Options,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/tasks"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.ItemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*optionalParams.ItemsPerPage))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*optionalParams.Page))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Action) {
		conf.queryParams.Set("action", utils.QueryParameterToString(*optionalParams.Action))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Enabled) {
		conf.queryParams.Set("enabled", utils.QueryParameterToString(*optionalParams.Enabled))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.SourceID) {
		conf.queryParams.Set("sourceID", utils.QueryParameterToString(*optionalParams.SourceID))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.DestinationID) {
		conf.queryParams.Set("destinationID", utils.QueryParameterToString(*optionalParams.DestinationID))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.TriggerType) {
		conf.queryParams.Set("triggerType", utils.QueryParameterToString(*optionalParams.TriggerType))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(*optionalParams.Sort))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(*optionalParams.Order))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ListTransformationsOptions represents the optional params for the API call.
type ListTransformationsOptions struct {
	ItemsPerPage *int
	Page         *int
	Sort         *TransformationSortKeys
	Order        *OrderKeys
	Type         *TransformationType
}

// NewListTransformationsOptions creates an instance of the ListTransformationsOptions used to add optional parameters to ListTransformationsWithOptions.
func NewListTransformationsOptions() *ListTransformationsOptions {
	return &ListTransformationsOptions{}
}

// WithItemsPerPage Number of items per page.
func (o *ListTransformationsOptions) WithItemsPerPage(itemsPerPage int) *ListTransformationsOptions {
	o.ItemsPerPage = &itemsPerPage

	return o
}

// WithPage Page number of the paginated API response.
func (o *ListTransformationsOptions) WithPage(page int) *ListTransformationsOptions {
	o.Page = &page

	return o
}

// WithSort Property by which to sort the list of transformations.
func (o *ListTransformationsOptions) WithSort(sort TransformationSortKeys) *ListTransformationsOptions {
	o.Sort = &sort

	return o
}

// WithOrder Sort order of the response, ascending or descending.
func (o *ListTransformationsOptions) WithOrder(order OrderKeys) *ListTransformationsOptions {
	o.Order = &order

	return o
}

// WithType Whether to filter the list of transformations by the type of transformation.
func (o *ListTransformationsOptions) WithType(type_ TransformationType) *ListTransformationsOptions {
	o.Type = &type_

	return o
}

// ListTransformations Retrieves a list of transformations.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - itemsPerPage - Number of items per page. (in optionalParams)
//   - page - Page number of the paginated API response. (in optionalParams)
//   - sort - Property by which to sort the list of transformations. (in optionalParams)
//   - order - Sort order of the response, ascending or descending. (in optionalParams)
//   - type_ - Whether to filter the list of transformations by the type of transformation. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListTransformations(
	ctx context.Context,
	optionalParams *ListTransformationsOptions,
	opts ...RequestOption,
) (*ListTransformationsResponse, error) {
	var returnValue *ListTransformationsResponse

	res, resBody, err := c.ListTransformationsWithHTTPInfo(ctx, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ListTransformationsWithHTTPInfo calls the API and returns the raw response from it.
// Retrieves a list of transformations.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - itemsPerPage - Number of items per page. (in optionalParams)
//   - page - Page number of the paginated API response. (in optionalParams)
//   - sort - Property by which to sort the list of transformations. (in optionalParams)
//   - order - Sort order of the response, ascending or descending. (in optionalParams)
//   - type_ - Whether to filter the list of transformations by the type of transformation. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ListTransformationsWithHTTPInfo(
	ctx context.Context,
	optionalParams *ListTransformationsOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/transformations"

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.ItemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*optionalParams.ItemsPerPage))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*optionalParams.Page))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(*optionalParams.Sort))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(*optionalParams.Order))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Type) {
		conf.queryParams.Set("type", utils.QueryParameterToString(*optionalParams.Type))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// PushOptions represents the optional params for the API call.
type PushOptions struct {
	Watch              *bool
	ReferenceIndexName *string
}

// NewPushOptions creates an instance of the PushOptions used to add optional parameters to PushWithOptions.
func NewPushOptions() *PushOptions {
	return &PushOptions{}
}

// WithWatch When provided, the push operation will be synchronous and the API will wait for the ingestion to be finished before responding.
func (o *PushOptions) WithWatch(watch bool) *PushOptions {
	o.Watch = &watch

	return o
}

// WithReferenceIndexName This is required when targeting an index that does not have a push connector setup (e.g. a tmp index), but you wish to attach another index's transformation to it (e.g. the source index name).
func (o *PushOptions) WithReferenceIndexName(referenceIndexName string) *PushOptions {
	o.ReferenceIndexName = &referenceIndexName

	return o
}

// Push Pushes records through the Pipeline, directly to an index. You can make the call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the observability endpoints and/or debugger dashboard to see the status of your task.
// If you want to leverage the [pre-indexing data transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data), this is the recommended way of ingesting your records.
// This method is similar to `pushTask`, but requires an `indexName` instead of a `taskID`. If zero or many tasks are found, an error will be returned.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - action
//   - records
//   - watch - When provided, the push operation will be synchronous and the API will wait for the ingestion to be finished before responding. (in optionalParams)
//   - referenceIndexName - This is required when targeting an index that does not have a push connector setup (e.g. a tmp index), but you wish to attach another index's transformation to it (e.g. the source index name). (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) Push(
	ctx context.Context,
	indexName string,
	action Action,
	records []PushTaskRecords,
	optionalParams *PushOptions,
	opts ...RequestOption,
) (*WatchResponse, error) {
	var returnValue *WatchResponse

	res, resBody, err := c.PushWithHTTPInfo(ctx, indexName, action, records, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// PushWithHTTPInfo calls the API and returns the raw response from it.
// Pushes records through the Pipeline, directly to an index. You can make the call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the observability endpoints and/or debugger dashboard to see the status of your task.
// If you want to leverage the [pre-indexing data transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data), this is the recommended way of ingesting your records.
// This method is similar to `pushTask`, but requires an `indexName` instead of a `taskID`. If zero or many tasks are found, an error will be returned.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - indexName - Name of the index on which to perform the operation.
//   - action
//   - records
//   - watch - When provided, the push operation will be synchronous and the API will wait for the ingestion to be finished before responding. (in optionalParams)
//   - referenceIndexName - This is required when targeting an index that does not have a push connector setup (e.g. a tmp index), but you wish to attach another index's transformation to it (e.g. the source index name). (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) PushWithHTTPInfo(
	ctx context.Context,
	indexName string,
	action Action,
	records []PushTaskRecords,
	optionalParams *PushOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/push/{indexName}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(indexName)))

	if indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `Push`.")
	}

	if len(records) == 0 {
		return nil, nil, reportError("Parameter `records` is required when calling `Push`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
		timeouts: transport.RequestConfiguration{
			ReadTimeout:    utils.ToPtr(180000 * time.Millisecond),
			WriteTimeout:   utils.ToPtr(180000 * time.Millisecond),
			ConnectTimeout: utils.ToPtr(180000 * time.Millisecond),
		},
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.Watch) {
		conf.queryParams.Set("watch", utils.QueryParameterToString(*optionalParams.Watch))
	}

	if optionalParams != nil && !utils.IsNilOrEmpty(optionalParams.ReferenceIndexName) {
		conf.queryParams.Set("referenceIndexName", utils.QueryParameterToString(*optionalParams.ReferenceIndexName))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Action  Action            `json:"action"`
		Records []PushTaskRecords `json:"records"`
	}{
		Action:  action,
		Records: records,
	}

	if optionalParams != nil {
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// PushTask Pushes records through the pipeline, directly to an index. You can make the call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the observability endpoints or the debugger dashboard to see the status of your task.
// If you want to transform your data before indexing, this is the recommended way of ingesting your records.
// This method is similar to `push`, but requires a `taskID` instead of a `indexName`, which is useful when many `destinations` target the same `indexName`.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - action
//   - records
//   - watch - When provided, the push operation will be synchronous and the API will wait for the ingestion to be finished before responding.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) PushTask(
	ctx context.Context,
	taskID string,
	action Action,
	records []PushTaskRecords,
	watch *bool,
	opts ...RequestOption,
) (*WatchResponse, error) {
	var returnValue *WatchResponse

	res, resBody, err := c.PushTaskWithHTTPInfo(ctx, taskID, action, records, watch, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// PushTaskWithHTTPInfo calls the API and returns the raw response from it.
// Pushes records through the pipeline, directly to an index. You can make the call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the observability endpoints or the debugger dashboard to see the status of your task.
// If you want to transform your data before indexing, this is the recommended way of ingesting your records.
// This method is similar to `push`, but requires a `taskID` instead of a `indexName`, which is useful when many `destinations` target the same `indexName`.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - action
//   - records
//   - watch - When provided, the push operation will be synchronous and the API will wait for the ingestion to be finished before responding.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) PushTaskWithHTTPInfo(
	ctx context.Context,
	taskID string,
	action Action,
	records []PushTaskRecords,
	watch *bool,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}/push"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `PushTask`.")
	}

	if len(records) == 0 {
		return nil, nil, reportError("Parameter `records` is required when calling `PushTask`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
		timeouts: transport.RequestConfiguration{
			ReadTimeout:    utils.ToPtr(180000 * time.Millisecond),
			WriteTimeout:   utils.ToPtr(180000 * time.Millisecond),
			ConnectTimeout: utils.ToPtr(180000 * time.Millisecond),
		},
	}

	if !utils.IsNilOrEmpty(watch) {
		conf.queryParams.Set("watch", utils.QueryParameterToString(*watch))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Action  Action            `json:"action"`
		Records []PushTaskRecords `json:"records"`
	}{
		Action:  action,
		Records: records,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ReplaceTaskOptions represents the optional params for the API call.
type ReplaceTaskOptions struct {
	SubscriptionAction *ActionType
	Cron               *string
	Enabled            *bool
	FailureThreshold   *int
	Input              *TaskInput
	Cursor             *string
	Notifications      *Notifications
	Policies           *Policies
}

// NewReplaceTaskOptions creates an instance of the ReplaceTaskOptions used to add optional parameters to ReplaceTaskWithOptions.
func NewReplaceTaskOptions() *ReplaceTaskOptions {
	return &ReplaceTaskOptions{}
}

// WithSubscriptionAction adds the subscriptionAction to the ApiReplaceTaskRequest and returns the request for chaining.
func (o *ReplaceTaskOptions) WithSubscriptionAction(subscriptionAction ActionType) *ReplaceTaskOptions {
	o.SubscriptionAction = &subscriptionAction

	return o
}

// WithCron Cron expression for the task's schedule.
func (o *ReplaceTaskOptions) WithCron(cron string) *ReplaceTaskOptions {
	o.Cron = &cron

	return o
}

// WithEnabled Whether the task is enabled.
func (o *ReplaceTaskOptions) WithEnabled(enabled bool) *ReplaceTaskOptions {
	o.Enabled = &enabled

	return o
}

// WithFailureThreshold Maximum accepted percentage of failures for a task run to finish successfully.
func (o *ReplaceTaskOptions) WithFailureThreshold(failureThreshold int) *ReplaceTaskOptions {
	o.FailureThreshold = &failureThreshold

	return o
}

// WithInput adds the input to the ApiReplaceTaskRequest and returns the request for chaining.
func (o *ReplaceTaskOptions) WithInput(input *TaskInput) *ReplaceTaskOptions {
	o.Input = input

	return o
}

// WithCursor Date of the last cursor in RFC 3339 format.
func (o *ReplaceTaskOptions) WithCursor(cursor string) *ReplaceTaskOptions {
	o.Cursor = &cursor

	return o
}

// WithNotifications adds the notifications to the ApiReplaceTaskRequest and returns the request for chaining.
func (o *ReplaceTaskOptions) WithNotifications(notifications *Notifications) *ReplaceTaskOptions {
	o.Notifications = notifications

	return o
}

// WithPolicies adds the policies to the ApiReplaceTaskRequest and returns the request for chaining.
func (o *ReplaceTaskOptions) WithPolicies(policies *Policies) *ReplaceTaskOptions {
	o.Policies = policies

	return o
}

// ReplaceTask Fully updates a task by its ID, use partialUpdateTask if you only want to update a subset of fields.

// Parameters:
//   - taskID - Unique identifier of a task.
//   - destinationID - Universally unique identifier (UUID) of a destination resource.
//   - action
//   - subscriptionAction  (in optionalParams)
//   - cron - Cron expression for the task's schedule. (in optionalParams)
//   - enabled - Whether the task is enabled. (in optionalParams)
//   - failureThreshold - Maximum accepted percentage of failures for a task run to finish successfully. (in optionalParams)
//   - input  (in optionalParams)
//   - cursor - Date of the last cursor in RFC 3339 format. (in optionalParams)
//   - notifications  (in optionalParams)
//   - policies  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ReplaceTask(
	ctx context.Context,
	taskID string,
	destinationID string,
	action ActionType,
	optionalParams *ReplaceTaskOptions,
	opts ...RequestOption,
) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.ReplaceTaskWithHTTPInfo(ctx, taskID, destinationID, action, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ReplaceTaskWithHTTPInfo calls the API and returns the raw response from it.
// Fully updates a task by its ID, use partialUpdateTask if you only want to update a subset of fields.

// Parameters:
//   - taskID - Unique identifier of a task.
//   - destinationID - Universally unique identifier (UUID) of a destination resource.
//   - action
//   - subscriptionAction  (in optionalParams)
//   - cron - Cron expression for the task's schedule. (in optionalParams)
//   - enabled - Whether the task is enabled. (in optionalParams)
//   - failureThreshold - Maximum accepted percentage of failures for a task run to finish successfully. (in optionalParams)
//   - input  (in optionalParams)
//   - cursor - Date of the last cursor in RFC 3339 format. (in optionalParams)
//   - notifications  (in optionalParams)
//   - policies  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ReplaceTaskWithHTTPInfo(
	ctx context.Context,
	taskID string,
	destinationID string,
	action ActionType,
	optionalParams *ReplaceTaskOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `ReplaceTask`.")
	}

	if destinationID == "" {
		return nil, nil, reportError("Parameter `destinationID` is required when calling `ReplaceTask`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		DestinationID      string         `json:"destinationID"`
		Action             ActionType     `json:"action"`
		SubscriptionAction *ActionType    `json:"subscriptionAction,omitempty"`
		Cron               *string        `json:"cron,omitempty"`
		Enabled            *bool          `json:"enabled,omitempty"`
		FailureThreshold   *int           `json:"failureThreshold,omitempty"`
		Input              *TaskInput     `json:"input,omitempty"`
		Cursor             *string        `json:"cursor,omitempty"`
		Notifications      *Notifications `json:"notifications,omitempty"`
		Policies           *Policies      `json:"policies,omitempty"`
	}{
		DestinationID: destinationID,
		Action:        action,
	}
	if optionalParams != nil {
		postBody.SubscriptionAction = optionalParams.SubscriptionAction
		postBody.Cron = optionalParams.Cron
		postBody.Enabled = optionalParams.Enabled
		postBody.FailureThreshold = optionalParams.FailureThreshold
		postBody.Input = optionalParams.Input
		postBody.Cursor = optionalParams.Cursor
		postBody.Notifications = optionalParams.Notifications
		postBody.Policies = optionalParams.Policies
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// RunSourceOptions represents the optional params for the API call.
type RunSourceOptions struct {
	IndexToInclude *[]string
	IndexToExclude *[]string
	EntityIDs      *[]string
	EntityType     *EntityType
	RunMetadata    map[string]any
}

// NewRunSourceOptions creates an instance of the RunSourceOptions used to add optional parameters to RunSourceWithOptions.
func NewRunSourceOptions() *RunSourceOptions {
	return &RunSourceOptions{}
}

// WithIndexToInclude List of index names to include in reindex/update.
func (o *RunSourceOptions) WithIndexToInclude(indexToInclude []string) *RunSourceOptions {
	o.IndexToInclude = &indexToInclude

	return o
}

// WithIndexToExclude List of index names to exclude in reindex/update.
func (o *RunSourceOptions) WithIndexToExclude(indexToExclude []string) *RunSourceOptions {
	o.IndexToExclude = &indexToExclude

	return o
}

// WithEntityIDs List of entityIDs to update.
func (o *RunSourceOptions) WithEntityIDs(entityIDs []string) *RunSourceOptions {
	o.EntityIDs = &entityIDs

	return o
}

// WithEntityType adds the entityType to the ApiRunSourceRequest and returns the request for chaining.
func (o *RunSourceOptions) WithEntityType(entityType EntityType) *RunSourceOptions {
	o.EntityType = &entityType

	return o
}

// WithRunMetadata Additional information that will be passed to the created runs.
func (o *RunSourceOptions) WithRunMetadata(runMetadata map[string]any) *RunSourceOptions {
	o.RunMetadata = runMetadata

	return o
}

// RunSource Runs all tasks linked to a source, only available for Shopify, BigCommerce and commercetools sources. Creates one run per task.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - sourceID - Unique identifier of a source.
//   - indexToInclude - List of index names to include in reindex/update. (in optionalParams)
//   - indexToExclude - List of index names to exclude in reindex/update. (in optionalParams)
//   - entityIDs - List of entityIDs to update. (in optionalParams)
//   - entityType  (in optionalParams)
//   - runMetadata - Additional information that will be passed to the created runs. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) RunSource(
	ctx context.Context,
	sourceID string,
	optionalParams *RunSourceOptions,
	opts ...RequestOption,
) (*RunSourceResponse, error) {
	var returnValue *RunSourceResponse

	res, resBody, err := c.RunSourceWithHTTPInfo(ctx, sourceID, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// RunSourceWithHTTPInfo calls the API and returns the raw response from it.
// Runs all tasks linked to a source, only available for Shopify, BigCommerce and commercetools sources. Creates one run per task.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - sourceID - Unique identifier of a source.
//   - indexToInclude - List of index names to include in reindex/update. (in optionalParams)
//   - indexToExclude - List of index names to exclude in reindex/update. (in optionalParams)
//   - entityIDs - List of entityIDs to update. (in optionalParams)
//   - entityType  (in optionalParams)
//   - runMetadata - Additional information that will be passed to the created runs. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) RunSourceWithHTTPInfo(
	ctx context.Context,
	sourceID string,
	optionalParams *RunSourceOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}/run"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(sourceID)))

	if sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `RunSource`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		IndexToInclude *[]string      `json:"indexToInclude,omitempty"`
		IndexToExclude *[]string      `json:"indexToExclude,omitempty"`
		EntityIDs      *[]string      `json:"entityIDs,omitempty"`
		EntityType     *EntityType    `json:"entityType,omitempty"`
		RunMetadata    map[string]any `json:"runMetadata,omitempty"`
	}{}
	if optionalParams != nil {
		postBody.IndexToInclude = optionalParams.IndexToInclude
		postBody.IndexToExclude = optionalParams.IndexToExclude
		postBody.EntityIDs = optionalParams.EntityIDs
		postBody.EntityType = optionalParams.EntityType
		postBody.RunMetadata = optionalParams.RunMetadata
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// RunTask Runs a task. You can check the status of task runs with the observability endpoints.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - runMetadata - Additional information that will be passed to the created run.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) RunTask(ctx context.Context, taskID string, runMetadata map[string]any, opts ...RequestOption) (*RunResponse, error) {
	var returnValue *RunResponse

	res, resBody, err := c.RunTaskWithHTTPInfo(ctx, taskID, runMetadata, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// RunTaskWithHTTPInfo calls the API and returns the raw response from it.
// Runs a task. You can check the status of task runs with the observability endpoints.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - runMetadata - Additional information that will be passed to the created run.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) RunTaskWithHTTPInfo(
	ctx context.Context,
	taskID string,
	runMetadata map[string]any,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}/run"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `RunTask`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		RunMetadata map[string]any `json:"runMetadata,omitempty"`
	}{
		RunMetadata: runMetadata,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// RunTaskV1 Runs a task using the v1 endpoint, please use `runTask` instead. You can check the status of task runs with the observability endpoints.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - runMetadata - Additional information that will be passed to the created run.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: RunTaskV1 is deprecated.
func (c *APIClient) RunTaskV1(ctx context.Context, taskID string, runMetadata map[string]any, opts ...RequestOption) (*RunResponse, error) {
	var returnValue *RunResponse

	res, resBody, err := c.RunTaskV1WithHTTPInfo(ctx, taskID, runMetadata, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// RunTaskV1WithHTTPInfo calls the API and returns the raw response from it.
// Runs a task using the v1 endpoint, please use `runTask` instead. You can check the status of task runs with the observability endpoints.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskID - Unique identifier of a task.
//   - runMetadata - Additional information that will be passed to the created run.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: RunTaskV1 is deprecated.
func (c *APIClient) RunTaskV1WithHTTPInfo(
	ctx context.Context,
	taskID string,
	runMetadata map[string]any,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}/run"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `RunTaskV1`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		RunMetadata map[string]any `json:"runMetadata,omitempty"`
	}{
		RunMetadata: runMetadata,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// SearchAuthentications Searches for authentication resources.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - authenticationIDs
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchAuthentications(ctx context.Context, authenticationIDs []string, opts ...RequestOption) ([]Authentication, error) {
	var returnValue []Authentication

	res, resBody, err := c.SearchAuthenticationsWithHTTPInfo(ctx, authenticationIDs, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchAuthenticationsWithHTTPInfo calls the API and returns the raw response from it.
// Searches for authentication resources.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - authenticationIDs
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchAuthenticationsWithHTTPInfo(
	ctx context.Context,
	authenticationIDs []string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/authentications/search"

	if len(authenticationIDs) == 0 {
		return nil, nil, reportError("Parameter `authenticationIDs` is required when calling `SearchAuthentications`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		AuthenticationIDs []string `json:"authenticationIDs"`
	}{
		AuthenticationIDs: authenticationIDs,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// SearchDestinations Searches for destinations.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - destinationIDs
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchDestinations(ctx context.Context, destinationIDs []string, opts ...RequestOption) ([]Destination, error) {
	var returnValue []Destination

	res, resBody, err := c.SearchDestinationsWithHTTPInfo(ctx, destinationIDs, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchDestinationsWithHTTPInfo calls the API and returns the raw response from it.
// Searches for destinations.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - destinationIDs
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchDestinationsWithHTTPInfo(
	ctx context.Context,
	destinationIDs []string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/destinations/search"

	if len(destinationIDs) == 0 {
		return nil, nil, reportError("Parameter `destinationIDs` is required when calling `SearchDestinations`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		DestinationIDs []string `json:"destinationIDs"`
	}{
		DestinationIDs: destinationIDs,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// SearchSources Searches for sources.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - sourceIDs
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchSources(ctx context.Context, sourceIDs []string, opts ...RequestOption) ([]Source, error) {
	var returnValue []Source

	res, resBody, err := c.SearchSourcesWithHTTPInfo(ctx, sourceIDs, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchSourcesWithHTTPInfo calls the API and returns the raw response from it.
// Searches for sources.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - sourceIDs
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchSourcesWithHTTPInfo(ctx context.Context, sourceIDs []string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/search"

	if len(sourceIDs) == 0 {
		return nil, nil, reportError("Parameter `sourceIDs` is required when calling `SearchSources`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		SourceIDs []string `json:"sourceIDs"`
	}{
		SourceIDs: sourceIDs,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// SearchTasks Searches for tasks.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskIDs
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchTasks(ctx context.Context, taskIDs []string, opts ...RequestOption) ([]Task, error) {
	var returnValue []Task

	res, resBody, err := c.SearchTasksWithHTTPInfo(ctx, taskIDs, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchTasksWithHTTPInfo calls the API and returns the raw response from it.
// Searches for tasks.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskIDs
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchTasksWithHTTPInfo(ctx context.Context, taskIDs []string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/search"

	if len(taskIDs) == 0 {
		return nil, nil, reportError("Parameter `taskIDs` is required when calling `SearchTasks`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		TaskIDs []string `json:"taskIDs"`
	}{
		TaskIDs: taskIDs,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// SearchTasksV1 Searches for tasks using the v1 endpoint, please use `searchTasks` instead.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskIDs
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: SearchTasksV1 is deprecated.
func (c *APIClient) SearchTasksV1(ctx context.Context, taskIDs []string, opts ...RequestOption) ([]TaskV1, error) {
	var returnValue []TaskV1

	res, resBody, err := c.SearchTasksV1WithHTTPInfo(ctx, taskIDs, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchTasksV1WithHTTPInfo calls the API and returns the raw response from it.
// Searches for tasks using the v1 endpoint, please use `searchTasks` instead.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - taskIDs
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: SearchTasksV1 is deprecated.
func (c *APIClient) SearchTasksV1WithHTTPInfo(ctx context.Context, taskIDs []string, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/search"

	if len(taskIDs) == 0 {
		return nil, nil, reportError("Parameter `taskIDs` is required when calling `SearchTasksV1`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		TaskIDs []string `json:"taskIDs"`
	}{
		TaskIDs: taskIDs,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// SearchTransformations Searches for transformations.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - transformationIDs
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchTransformations(ctx context.Context, transformationIDs []string, opts ...RequestOption) ([]Transformation, error) {
	var returnValue []Transformation

	res, resBody, err := c.SearchTransformationsWithHTTPInfo(ctx, transformationIDs, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// SearchTransformationsWithHTTPInfo calls the API and returns the raw response from it.
// Searches for transformations.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - transformationIDs
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) SearchTransformationsWithHTTPInfo(
	ctx context.Context,
	transformationIDs []string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/search"

	if len(transformationIDs) == 0 {
		return nil, nil, reportError("Parameter `transformationIDs` is required when calling `SearchTransformations`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		TransformationIDs []string `json:"transformationIDs"`
	}{
		TransformationIDs: transformationIDs,
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// TriggerDockerSourceDiscover Triggers a stream-listing request for a source.
// Triggering stream-listing requests only works with sources with `type: docker` and `imageType: airbyte`.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - sourceID - Unique identifier of a source.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) TriggerDockerSourceDiscover(ctx context.Context, sourceID string, opts ...RequestOption) (*WatchResponse, error) {
	var returnValue *WatchResponse

	res, resBody, err := c.TriggerDockerSourceDiscoverWithHTTPInfo(ctx, sourceID, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// TriggerDockerSourceDiscoverWithHTTPInfo calls the API and returns the raw response from it.
// Triggers a stream-listing request for a source.
// Triggering stream-listing requests only works with sources with `type: docker` and `imageType: airbyte`.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - sourceID - Unique identifier of a source.
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) TriggerDockerSourceDiscoverWithHTTPInfo(
	ctx context.Context,
	sourceID string,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}/discover"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(sourceID)))

	if sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `TriggerDockerSourceDiscover`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
		timeouts: transport.RequestConfiguration{
			ReadTimeout:    utils.ToPtr(180000 * time.Millisecond),
			WriteTimeout:   utils.ToPtr(180000 * time.Millisecond),
			ConnectTimeout: utils.ToPtr(180000 * time.Millisecond),
		},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, nil, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// TryTransformationOptions represents the optional params for the API call.
type TryTransformationOptions struct {
	Code            *string
	Type            *TransformationType
	Input           *TransformationInput
	Authentications *[]AuthenticationCreate
}

// NewTryTransformationOptions creates an instance of the TryTransformationOptions used to add optional parameters to TryTransformationWithOptions.
func NewTryTransformationOptions() *TryTransformationOptions {
	return &TryTransformationOptions{}
}

// WithCode It is deprecated. Use the `input` field with proper `type` instead to specify the transformation code.
func (o *TryTransformationOptions) WithCode(code string) *TryTransformationOptions {
	o.Code = &code

	return o
}

// WithType adds the type_ to the ApiTryTransformationRequest and returns the request for chaining.
func (o *TryTransformationOptions) WithType(type_ TransformationType) *TryTransformationOptions {
	o.Type = &type_

	return o
}

// WithInput adds the input to the ApiTryTransformationRequest and returns the request for chaining.
func (o *TryTransformationOptions) WithInput(input *TransformationInput) *TryTransformationOptions {
	o.Input = input

	return o
}

// WithAuthentications adds the authentications to the ApiTryTransformationRequest and returns the request for chaining.
func (o *TryTransformationOptions) WithAuthentications(authentications []AuthenticationCreate) *TryTransformationOptions {
	o.Authentications = &authentications

	return o
}

// TryTransformation Try a transformation before creating it.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - sampleRecord - The record to apply the given code to.
//   - code - It is deprecated. Use the `input` field with proper `type` instead to specify the transformation code. (in optionalParams)
//   - type_  (in optionalParams)
//   - input  (in optionalParams)
//   - authentications  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) TryTransformation(
	ctx context.Context,
	sampleRecord map[string]any,
	optionalParams *TryTransformationOptions,
	opts ...RequestOption,
) (*TransformationTryResponse, error) {
	var returnValue *TransformationTryResponse

	res, resBody, err := c.TryTransformationWithHTTPInfo(ctx, sampleRecord, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// TryTransformationWithHTTPInfo calls the API and returns the raw response from it.
// Try a transformation before creating it.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - sampleRecord - The record to apply the given code to.
//   - code - It is deprecated. Use the `input` field with proper `type` instead to specify the transformation code. (in optionalParams)
//   - type_  (in optionalParams)
//   - input  (in optionalParams)
//   - authentications  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) TryTransformationWithHTTPInfo(
	ctx context.Context,
	sampleRecord map[string]any,
	optionalParams *TryTransformationOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/try"

	if sampleRecord == nil {
		return nil, nil, reportError("Parameter `sampleRecord` is required when calling `TryTransformation`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Code            *string                 `json:"code,omitempty"`
		Type            *TransformationType     `json:"type,omitempty"`
		Input           *TransformationInput    `json:"input,omitempty"`
		SampleRecord    map[string]any          `json:"sampleRecord"`
		Authentications *[]AuthenticationCreate `json:"authentications,omitempty"`
	}{
		SampleRecord: sampleRecord,
	}
	if optionalParams != nil {
		postBody.Code = optionalParams.Code
		postBody.Type = optionalParams.Type
		postBody.Input = optionalParams.Input
		postBody.Authentications = optionalParams.Authentications
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// TryTransformationBeforeUpdateOptions represents the optional params for the API call.
type TryTransformationBeforeUpdateOptions struct {
	Code            *string
	Type            *TransformationType
	Input           *TransformationInput
	Authentications *[]AuthenticationCreate
}

// NewTryTransformationBeforeUpdateOptions creates an instance of the TryTransformationBeforeUpdateOptions used to add optional parameters to TryTransformationBeforeUpdateWithOptions.
func NewTryTransformationBeforeUpdateOptions() *TryTransformationBeforeUpdateOptions {
	return &TryTransformationBeforeUpdateOptions{}
}

// WithCode It is deprecated. Use the `input` field with proper `type` instead to specify the transformation code.
func (o *TryTransformationBeforeUpdateOptions) WithCode(code string) *TryTransformationBeforeUpdateOptions {
	o.Code = &code

	return o
}

// WithType adds the type_ to the ApiTryTransformationBeforeUpdateRequest and returns the request for chaining.
func (o *TryTransformationBeforeUpdateOptions) WithType(type_ TransformationType) *TryTransformationBeforeUpdateOptions {
	o.Type = &type_

	return o
}

// WithInput adds the input to the ApiTryTransformationBeforeUpdateRequest and returns the request for chaining.
func (o *TryTransformationBeforeUpdateOptions) WithInput(input *TransformationInput) *TryTransformationBeforeUpdateOptions {
	o.Input = input

	return o
}

// WithAuthentications adds the authentications to the ApiTryTransformationBeforeUpdateRequest and returns the request for chaining.
func (o *TryTransformationBeforeUpdateOptions) WithAuthentications(authentications []AuthenticationCreate) *TryTransformationBeforeUpdateOptions {
	o.Authentications = &authentications

	return o
}

// TryTransformationBeforeUpdate Try a transformation before updating it.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - transformationID - Unique identifier of a transformation.
//   - sampleRecord - The record to apply the given code to.
//   - code - It is deprecated. Use the `input` field with proper `type` instead to specify the transformation code. (in optionalParams)
//   - type_  (in optionalParams)
//   - input  (in optionalParams)
//   - authentications  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) TryTransformationBeforeUpdate(
	ctx context.Context,
	transformationID string,
	sampleRecord map[string]any,
	optionalParams *TryTransformationBeforeUpdateOptions,
	opts ...RequestOption,
) (*TransformationTryResponse, error) {
	var returnValue *TransformationTryResponse

	res, resBody, err := c.TryTransformationBeforeUpdateWithHTTPInfo(ctx, transformationID, sampleRecord, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// TryTransformationBeforeUpdateWithHTTPInfo calls the API and returns the raw response from it.
// Try a transformation before updating it.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - transformationID - Unique identifier of a transformation.
//   - sampleRecord - The record to apply the given code to.
//   - code - It is deprecated. Use the `input` field with proper `type` instead to specify the transformation code. (in optionalParams)
//   - type_  (in optionalParams)
//   - input  (in optionalParams)
//   - authentications  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) TryTransformationBeforeUpdateWithHTTPInfo(
	ctx context.Context,
	transformationID string,
	sampleRecord map[string]any,
	optionalParams *TryTransformationBeforeUpdateOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/{transformationID}/try"
	requestPath = strings.ReplaceAll(requestPath, "{transformationID}", url.PathEscape(utils.ParameterToString(transformationID)))

	if transformationID == "" {
		return nil, nil, reportError("Parameter `transformationID` is required when calling `TryTransformationBeforeUpdate`.")
	}

	if sampleRecord == nil {
		return nil, nil, reportError("Parameter `sampleRecord` is required when calling `TryTransformationBeforeUpdate`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Code            *string                 `json:"code,omitempty"`
		Type            *TransformationType     `json:"type,omitempty"`
		Input           *TransformationInput    `json:"input,omitempty"`
		SampleRecord    map[string]any          `json:"sampleRecord"`
		Authentications *[]AuthenticationCreate `json:"authentications,omitempty"`
	}{
		SampleRecord: sampleRecord,
	}
	if optionalParams != nil {
		postBody.Code = optionalParams.Code
		postBody.Type = optionalParams.Type
		postBody.Input = optionalParams.Input
		postBody.Authentications = optionalParams.Authentications
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// UpdateAuthenticationOptions represents the optional params for the API call.
type UpdateAuthenticationOptions struct {
	Type     *AuthenticationType
	Name     *string
	Platform *Platform
	Input    *AuthInputPartial
}

// NewUpdateAuthenticationOptions creates an instance of the UpdateAuthenticationOptions used to add optional parameters to UpdateAuthenticationWithOptions.
func NewUpdateAuthenticationOptions() *UpdateAuthenticationOptions {
	return &UpdateAuthenticationOptions{}
}

// WithType adds the type_ to the ApiUpdateAuthenticationRequest and returns the request for chaining.
func (o *UpdateAuthenticationOptions) WithType(type_ AuthenticationType) *UpdateAuthenticationOptions {
	o.Type = &type_

	return o
}

// WithName Descriptive name for the resource.
func (o *UpdateAuthenticationOptions) WithName(name string) *UpdateAuthenticationOptions {
	o.Name = &name

	return o
}

// WithPlatform adds the platform to the ApiUpdateAuthenticationRequest and returns the request for chaining.
func (o *UpdateAuthenticationOptions) WithPlatform(platform Platform) *UpdateAuthenticationOptions {
	o.Platform = &platform

	return o
}

// WithInput adds the input to the ApiUpdateAuthenticationRequest and returns the request for chaining.
func (o *UpdateAuthenticationOptions) WithInput(input *AuthInputPartial) *UpdateAuthenticationOptions {
	o.Input = input

	return o
}

// UpdateAuthentication Updates an authentication resource.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - authenticationID - Unique identifier of an authentication resource.
//   - type_  (in optionalParams)
//   - name - Descriptive name for the resource. (in optionalParams)
//   - platform  (in optionalParams)
//   - input  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) UpdateAuthentication(
	ctx context.Context,
	authenticationID string,
	optionalParams *UpdateAuthenticationOptions,
	opts ...RequestOption,
) (*AuthenticationUpdateResponse, error) {
	var returnValue *AuthenticationUpdateResponse

	res, resBody, err := c.UpdateAuthenticationWithHTTPInfo(ctx, authenticationID, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// UpdateAuthenticationWithHTTPInfo calls the API and returns the raw response from it.
// Updates an authentication resource.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - authenticationID - Unique identifier of an authentication resource.
//   - type_  (in optionalParams)
//   - name - Descriptive name for the resource. (in optionalParams)
//   - platform  (in optionalParams)
//   - input  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) UpdateAuthenticationWithHTTPInfo(
	ctx context.Context,
	authenticationID string,
	optionalParams *UpdateAuthenticationOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.ReplaceAll(requestPath, "{authenticationID}", url.PathEscape(utils.ParameterToString(authenticationID)))

	if authenticationID == "" {
		return nil, nil, reportError("Parameter `authenticationID` is required when calling `UpdateAuthentication`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Type     *AuthenticationType `json:"type,omitempty"`
		Name     *string             `json:"name,omitempty"`
		Platform *Platform           `json:"platform,omitempty"`
		Input    *AuthInputPartial   `json:"input,omitempty"`
	}{}
	if optionalParams != nil {
		postBody.Type = optionalParams.Type
		postBody.Name = optionalParams.Name
		postBody.Platform = optionalParams.Platform
		postBody.Input = optionalParams.Input
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// UpdateDestinationOptions represents the optional params for the API call.
type UpdateDestinationOptions struct {
	Type              *DestinationType
	Name              *string
	Input             *DestinationInput
	AuthenticationID  *string
	TransformationIDs *[]string
}

// NewUpdateDestinationOptions creates an instance of the UpdateDestinationOptions used to add optional parameters to UpdateDestinationWithOptions.
func NewUpdateDestinationOptions() *UpdateDestinationOptions {
	return &UpdateDestinationOptions{}
}

// WithType adds the type_ to the ApiUpdateDestinationRequest and returns the request for chaining.
func (o *UpdateDestinationOptions) WithType(type_ DestinationType) *UpdateDestinationOptions {
	o.Type = &type_

	return o
}

// WithName Descriptive name for the resource.
func (o *UpdateDestinationOptions) WithName(name string) *UpdateDestinationOptions {
	o.Name = &name

	return o
}

// WithInput adds the input to the ApiUpdateDestinationRequest and returns the request for chaining.
func (o *UpdateDestinationOptions) WithInput(input *DestinationInput) *UpdateDestinationOptions {
	o.Input = input

	return o
}

// WithAuthenticationID Universally unique identifier (UUID) of an authentication resource.
func (o *UpdateDestinationOptions) WithAuthenticationID(authenticationID string) *UpdateDestinationOptions {
	o.AuthenticationID = &authenticationID

	return o
}

// WithTransformationIDs adds the transformationIDs to the ApiUpdateDestinationRequest and returns the request for chaining.
func (o *UpdateDestinationOptions) WithTransformationIDs(transformationIDs []string) *UpdateDestinationOptions {
	o.TransformationIDs = &transformationIDs

	return o
}

// UpdateDestination Updates the destination by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - destinationID - Unique identifier of a destination.
//   - type_  (in optionalParams)
//   - name - Descriptive name for the resource. (in optionalParams)
//   - input  (in optionalParams)
//   - authenticationID - Universally unique identifier (UUID) of an authentication resource. (in optionalParams)
//   - transformationIDs  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) UpdateDestination(
	ctx context.Context,
	destinationID string,
	optionalParams *UpdateDestinationOptions,
	opts ...RequestOption,
) (*DestinationUpdateResponse, error) {
	var returnValue *DestinationUpdateResponse

	res, resBody, err := c.UpdateDestinationWithHTTPInfo(ctx, destinationID, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// UpdateDestinationWithHTTPInfo calls the API and returns the raw response from it.
// Updates the destination by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - destinationID - Unique identifier of a destination.
//   - type_  (in optionalParams)
//   - name - Descriptive name for the resource. (in optionalParams)
//   - input  (in optionalParams)
//   - authenticationID - Universally unique identifier (UUID) of an authentication resource. (in optionalParams)
//   - transformationIDs  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) UpdateDestinationWithHTTPInfo(
	ctx context.Context,
	destinationID string,
	optionalParams *UpdateDestinationOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.ReplaceAll(requestPath, "{destinationID}", url.PathEscape(utils.ParameterToString(destinationID)))

	if destinationID == "" {
		return nil, nil, reportError("Parameter `destinationID` is required when calling `UpdateDestination`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Type              *DestinationType  `json:"type,omitempty"`
		Name              *string           `json:"name,omitempty"`
		Input             *DestinationInput `json:"input,omitempty"`
		AuthenticationID  *string           `json:"authenticationID,omitempty"`
		TransformationIDs *[]string         `json:"transformationIDs,omitempty"`
	}{}
	if optionalParams != nil {
		postBody.Type = optionalParams.Type
		postBody.Name = optionalParams.Name
		postBody.Input = optionalParams.Input
		postBody.AuthenticationID = optionalParams.AuthenticationID
		postBody.TransformationIDs = optionalParams.TransformationIDs
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// UpdateSourceOptions represents the optional params for the API call.
type UpdateSourceOptions struct {
	Name             *string
	Input            *SourceUpdateInput
	AuthenticationID *string
}

// NewUpdateSourceOptions creates an instance of the UpdateSourceOptions used to add optional parameters to UpdateSourceWithOptions.
func NewUpdateSourceOptions() *UpdateSourceOptions {
	return &UpdateSourceOptions{}
}

// WithName Descriptive name of the source.
func (o *UpdateSourceOptions) WithName(name string) *UpdateSourceOptions {
	o.Name = &name

	return o
}

// WithInput adds the input to the ApiUpdateSourceRequest and returns the request for chaining.
func (o *UpdateSourceOptions) WithInput(input *SourceUpdateInput) *UpdateSourceOptions {
	o.Input = input

	return o
}

// WithAuthenticationID Universally unique identifier (UUID) of an authentication resource.
func (o *UpdateSourceOptions) WithAuthenticationID(authenticationID string) *UpdateSourceOptions {
	o.AuthenticationID = &authenticationID

	return o
}

// UpdateSource Updates a source by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - sourceID - Unique identifier of a source.
//   - name - Descriptive name of the source. (in optionalParams)
//   - input  (in optionalParams)
//   - authenticationID - Universally unique identifier (UUID) of an authentication resource. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) UpdateSource(
	ctx context.Context,
	sourceID string,
	optionalParams *UpdateSourceOptions,
	opts ...RequestOption,
) (*SourceUpdateResponse, error) {
	var returnValue *SourceUpdateResponse

	res, resBody, err := c.UpdateSourceWithHTTPInfo(ctx, sourceID, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// UpdateSourceWithHTTPInfo calls the API and returns the raw response from it.
// Updates a source by its ID.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - sourceID - Unique identifier of a source.
//   - name - Descriptive name of the source. (in optionalParams)
//   - input  (in optionalParams)
//   - authenticationID - Universally unique identifier (UUID) of an authentication resource. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) UpdateSourceWithHTTPInfo(
	ctx context.Context,
	sourceID string,
	optionalParams *UpdateSourceOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(sourceID)))

	if sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `UpdateSource`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Name             *string            `json:"name,omitempty"`
		Input            *SourceUpdateInput `json:"input,omitempty"`
		AuthenticationID *string            `json:"authenticationID,omitempty"`
	}{}
	if optionalParams != nil {
		postBody.Name = optionalParams.Name
		postBody.Input = optionalParams.Input
		postBody.AuthenticationID = optionalParams.AuthenticationID
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// UpdateTaskOptions represents the optional params for the API call.
type UpdateTaskOptions struct {
	DestinationID      *string
	Cron               *string
	Input              *TaskInput
	Enabled            *bool
	SubscriptionAction *ActionType
	FailureThreshold   *int
	Notifications      *Notifications
	Policies           *Policies
}

// NewUpdateTaskOptions creates an instance of the UpdateTaskOptions used to add optional parameters to UpdateTaskWithOptions.
func NewUpdateTaskOptions() *UpdateTaskOptions {
	return &UpdateTaskOptions{}
}

// WithDestinationID Universally unique identifier (UUID) of a destination resource.
func (o *UpdateTaskOptions) WithDestinationID(destinationID string) *UpdateTaskOptions {
	o.DestinationID = &destinationID

	return o
}

// WithCron Cron expression for the task's schedule.
func (o *UpdateTaskOptions) WithCron(cron string) *UpdateTaskOptions {
	o.Cron = &cron

	return o
}

// WithInput adds the input to the ApiUpdateTaskRequest and returns the request for chaining.
func (o *UpdateTaskOptions) WithInput(input *TaskInput) *UpdateTaskOptions {
	o.Input = input

	return o
}

// WithEnabled Whether the task is enabled.
func (o *UpdateTaskOptions) WithEnabled(enabled bool) *UpdateTaskOptions {
	o.Enabled = &enabled

	return o
}

// WithSubscriptionAction adds the subscriptionAction to the ApiUpdateTaskRequest and returns the request for chaining.
func (o *UpdateTaskOptions) WithSubscriptionAction(subscriptionAction ActionType) *UpdateTaskOptions {
	o.SubscriptionAction = &subscriptionAction

	return o
}

// WithFailureThreshold Maximum accepted percentage of failures for a task run to finish successfully.
func (o *UpdateTaskOptions) WithFailureThreshold(failureThreshold int) *UpdateTaskOptions {
	o.FailureThreshold = &failureThreshold

	return o
}

// WithNotifications adds the notifications to the ApiUpdateTaskRequest and returns the request for chaining.
func (o *UpdateTaskOptions) WithNotifications(notifications *Notifications) *UpdateTaskOptions {
	o.Notifications = notifications

	return o
}

// WithPolicies adds the policies to the ApiUpdateTaskRequest and returns the request for chaining.
func (o *UpdateTaskOptions) WithPolicies(policies *Policies) *UpdateTaskOptions {
	o.Policies = policies

	return o
}

// UpdateTask Partially updates a task by its ID.

// Parameters:
//   - taskID - Unique identifier of a task.
//   - destinationID - Universally unique identifier (UUID) of a destination resource. (in optionalParams)
//   - cron - Cron expression for the task's schedule. (in optionalParams)
//   - input  (in optionalParams)
//   - enabled - Whether the task is enabled. (in optionalParams)
//   - subscriptionAction  (in optionalParams)
//   - failureThreshold - Maximum accepted percentage of failures for a task run to finish successfully. (in optionalParams)
//   - notifications  (in optionalParams)
//   - policies  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) UpdateTask(
	ctx context.Context,
	taskID string,
	optionalParams *UpdateTaskOptions,
	opts ...RequestOption,
) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.UpdateTaskWithHTTPInfo(ctx, taskID, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// UpdateTaskWithHTTPInfo calls the API and returns the raw response from it.
// Partially updates a task by its ID.

// Parameters:
//   - taskID - Unique identifier of a task.
//   - destinationID - Universally unique identifier (UUID) of a destination resource. (in optionalParams)
//   - cron - Cron expression for the task's schedule. (in optionalParams)
//   - input  (in optionalParams)
//   - enabled - Whether the task is enabled. (in optionalParams)
//   - subscriptionAction  (in optionalParams)
//   - failureThreshold - Maximum accepted percentage of failures for a task run to finish successfully. (in optionalParams)
//   - notifications  (in optionalParams)
//   - policies  (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) UpdateTaskWithHTTPInfo(
	ctx context.Context,
	taskID string,
	optionalParams *UpdateTaskOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `UpdateTask`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		DestinationID      *string        `json:"destinationID,omitempty"`
		Cron               *string        `json:"cron,omitempty"`
		Input              *TaskInput     `json:"input,omitempty"`
		Enabled            *bool          `json:"enabled,omitempty"`
		SubscriptionAction *ActionType    `json:"subscriptionAction,omitempty"`
		FailureThreshold   *int           `json:"failureThreshold,omitempty"`
		Notifications      *Notifications `json:"notifications,omitempty"`
		Policies           *Policies      `json:"policies,omitempty"`
	}{}
	if optionalParams != nil {
		postBody.DestinationID = optionalParams.DestinationID
		postBody.Cron = optionalParams.Cron
		postBody.Input = optionalParams.Input
		postBody.Enabled = optionalParams.Enabled
		postBody.SubscriptionAction = optionalParams.SubscriptionAction
		postBody.FailureThreshold = optionalParams.FailureThreshold
		postBody.Notifications = optionalParams.Notifications
		postBody.Policies = optionalParams.Policies
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// UpdateTaskV1Options represents the optional params for the API call.
type UpdateTaskV1Options struct {
	DestinationID    *string
	Trigger          *TriggerUpdateInput
	Input            *TaskInput
	Enabled          *bool
	FailureThreshold *int
}

// Deprecated: UpdateTaskV1Options is deprecated
// NewUpdateTaskV1Options creates an instance of the UpdateTaskV1Options used to add optional parameters to UpdateTaskV1WithOptions.
func NewUpdateTaskV1Options() *UpdateTaskV1Options {
	return &UpdateTaskV1Options{}
}

// WithDestinationID Universally unique identifier (UUID) of a destination resource.
func (o *UpdateTaskV1Options) WithDestinationID(destinationID string) *UpdateTaskV1Options {
	o.DestinationID = &destinationID

	return o
}

// WithTrigger adds the trigger to the ApiUpdateTaskV1Request and returns the request for chaining.
func (o *UpdateTaskV1Options) WithTrigger(trigger *TriggerUpdateInput) *UpdateTaskV1Options {
	o.Trigger = trigger

	return o
}

// WithInput adds the input to the ApiUpdateTaskV1Request and returns the request for chaining.
func (o *UpdateTaskV1Options) WithInput(input *TaskInput) *UpdateTaskV1Options {
	o.Input = input

	return o
}

// WithEnabled Whether the task is enabled.
func (o *UpdateTaskV1Options) WithEnabled(enabled bool) *UpdateTaskV1Options {
	o.Enabled = &enabled

	return o
}

// WithFailureThreshold Maximum accepted percentage of failures for a task run to finish successfully.
func (o *UpdateTaskV1Options) WithFailureThreshold(failureThreshold int) *UpdateTaskV1Options {
	o.FailureThreshold = &failureThreshold

	return o
}

// UpdateTaskV1 Updates a task by its ID using the v1 endpoint, please use `updateTask` instead.

// Parameters:
//   - taskID - Unique identifier of a task.
//   - destinationID - Universally unique identifier (UUID) of a destination resource. (in optionalParams)
//   - trigger  (in optionalParams)
//   - input  (in optionalParams)
//   - enabled - Whether the task is enabled. (in optionalParams)
//   - failureThreshold - Maximum accepted percentage of failures for a task run to finish successfully. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: UpdateTaskV1 is deprecated.
func (c *APIClient) UpdateTaskV1(
	ctx context.Context,
	taskID string,
	optionalParams *UpdateTaskV1Options,
	opts ...RequestOption,
) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.UpdateTaskV1WithHTTPInfo(ctx, taskID, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// UpdateTaskV1WithHTTPInfo calls the API and returns the raw response from it.
// Updates a task by its ID using the v1 endpoint, please use `updateTask` instead.

// Parameters:
//   - taskID - Unique identifier of a task.
//   - destinationID - Universally unique identifier (UUID) of a destination resource. (in optionalParams)
//   - trigger  (in optionalParams)
//   - input  (in optionalParams)
//   - enabled - Whether the task is enabled. (in optionalParams)
//   - failureThreshold - Maximum accepted percentage of failures for a task run to finish successfully. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
//
// Deprecated: UpdateTaskV1 is deprecated.
func (c *APIClient) UpdateTaskV1WithHTTPInfo(
	ctx context.Context,
	taskID string,
	optionalParams *UpdateTaskV1Options,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(taskID)))

	if taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `UpdateTaskV1`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		DestinationID    *string             `json:"destinationID,omitempty"`
		Trigger          *TriggerUpdateInput `json:"trigger,omitempty"`
		Input            *TaskInput          `json:"input,omitempty"`
		Enabled          *bool               `json:"enabled,omitempty"`
		FailureThreshold *int                `json:"failureThreshold,omitempty"`
	}{}
	if optionalParams != nil {
		postBody.DestinationID = optionalParams.DestinationID
		postBody.Trigger = optionalParams.Trigger
		postBody.Input = optionalParams.Input
		postBody.Enabled = optionalParams.Enabled
		postBody.FailureThreshold = optionalParams.FailureThreshold
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// UpdateTransformationOptions represents the optional params for the API call.
type UpdateTransformationOptions struct {
	Code              *string
	Type              *TransformationType
	Input             *TransformationInput
	Description       *string
	AuthenticationIDs *[]string
}

// NewUpdateTransformationOptions creates an instance of the UpdateTransformationOptions used to add optional parameters to UpdateTransformationWithOptions.
func NewUpdateTransformationOptions() *UpdateTransformationOptions {
	return &UpdateTransformationOptions{}
}

// WithCode It is deprecated. Use the `input` field with proper `type` instead to specify the transformation code.
func (o *UpdateTransformationOptions) WithCode(code string) *UpdateTransformationOptions {
	o.Code = &code

	return o
}

// WithType adds the type_ to the ApiUpdateTransformationRequest and returns the request for chaining.
func (o *UpdateTransformationOptions) WithType(type_ TransformationType) *UpdateTransformationOptions {
	o.Type = &type_

	return o
}

// WithInput adds the input to the ApiUpdateTransformationRequest and returns the request for chaining.
func (o *UpdateTransformationOptions) WithInput(input *TransformationInput) *UpdateTransformationOptions {
	o.Input = input

	return o
}

// WithDescription A descriptive name for your transformation of what it does.
func (o *UpdateTransformationOptions) WithDescription(description string) *UpdateTransformationOptions {
	o.Description = &description

	return o
}

// WithAuthenticationIDs The authentications associated with the current transformation.
func (o *UpdateTransformationOptions) WithAuthenticationIDs(authenticationIDs []string) *UpdateTransformationOptions {
	o.AuthenticationIDs = &authenticationIDs

	return o
}

// UpdateTransformation Updates a transformation by its ID.

// Parameters:
//   - transformationID - Unique identifier of a transformation.
//   - name - The uniquely identified name of your transformation.
//   - code - It is deprecated. Use the `input` field with proper `type` instead to specify the transformation code. (in optionalParams)
//   - type_  (in optionalParams)
//   - input  (in optionalParams)
//   - description - A descriptive name for your transformation of what it does. (in optionalParams)
//   - authenticationIDs - The authentications associated with the current transformation. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) UpdateTransformation(
	ctx context.Context,
	transformationID string,
	name string,
	optionalParams *UpdateTransformationOptions,
	opts ...RequestOption,
) (*TransformationUpdateResponse, error) {
	var returnValue *TransformationUpdateResponse

	res, resBody, err := c.UpdateTransformationWithHTTPInfo(ctx, transformationID, name, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// UpdateTransformationWithHTTPInfo calls the API and returns the raw response from it.
// Updates a transformation by its ID.

// Parameters:
//   - transformationID - Unique identifier of a transformation.
//   - name - The uniquely identified name of your transformation.
//   - code - It is deprecated. Use the `input` field with proper `type` instead to specify the transformation code. (in optionalParams)
//   - type_  (in optionalParams)
//   - input  (in optionalParams)
//   - description - A descriptive name for your transformation of what it does. (in optionalParams)
//   - authenticationIDs - The authentications associated with the current transformation. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) UpdateTransformationWithHTTPInfo(
	ctx context.Context,
	transformationID string,
	name string,
	optionalParams *UpdateTransformationOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/{transformationID}"
	requestPath = strings.ReplaceAll(requestPath, "{transformationID}", url.PathEscape(utils.ParameterToString(transformationID)))

	if transformationID == "" {
		return nil, nil, reportError("Parameter `transformationID` is required when calling `UpdateTransformation`.")
	}

	if name == "" {
		return nil, nil, reportError("Parameter `name` is required when calling `UpdateTransformation`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Code              *string              `json:"code,omitempty"`
		Name              string               `json:"name"`
		Type              *TransformationType  `json:"type,omitempty"`
		Input             *TransformationInput `json:"input,omitempty"`
		Description       *string              `json:"description,omitempty"`
		AuthenticationIDs *[]string            `json:"authenticationIDs,omitempty"`
	}{
		Name: name,
	}
	if optionalParams != nil {
		postBody.Code = optionalParams.Code
		postBody.Type = optionalParams.Type
		postBody.Input = optionalParams.Input
		postBody.Description = optionalParams.Description
		postBody.AuthenticationIDs = optionalParams.AuthenticationIDs
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ValidateSourceOptions represents the optional params for the API call.
type ValidateSourceOptions struct {
	Input            *SourceInput
	AuthenticationID *string
}

// NewValidateSourceOptions creates an instance of the ValidateSourceOptions used to add optional parameters to ValidateSourceWithOptions.
func NewValidateSourceOptions() *ValidateSourceOptions {
	return &ValidateSourceOptions{}
}

// WithInput adds the input to the ApiValidateSourceRequest and returns the request for chaining.
func (o *ValidateSourceOptions) WithInput(input *SourceInput) *ValidateSourceOptions {
	o.Input = input

	return o
}

// WithAuthenticationID Universally unique identifier (UUID) of an authentication resource.
func (o *ValidateSourceOptions) WithAuthenticationID(authenticationID string) *ValidateSourceOptions {
	o.AuthenticationID = &authenticationID

	return o
}

// ValidateSource Validates a source payload to ensure it can be created and that the data source can be reached by Algolia.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - type_
//   - name - Descriptive name of the source.
//   - input  (in optionalParams)
//   - authenticationID - Universally unique identifier (UUID) of an authentication resource. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ValidateSource(
	ctx context.Context,
	type_ SourceType,
	name string,
	optionalParams *ValidateSourceOptions,
	opts ...RequestOption,
) (*WatchResponse, error) {
	var returnValue *WatchResponse

	res, resBody, err := c.ValidateSourceWithHTTPInfo(ctx, type_, name, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ValidateSourceWithHTTPInfo calls the API and returns the raw response from it.
// Validates a source payload to ensure it can be created and that the data source can be reached by Algolia.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - type_
//   - name - Descriptive name of the source.
//   - input  (in optionalParams)
//   - authenticationID - Universally unique identifier (UUID) of an authentication resource. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ValidateSourceWithHTTPInfo(
	ctx context.Context,
	type_ SourceType,
	name string,
	optionalParams *ValidateSourceOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/sources/validate"

	if name == "" {
		return nil, nil, reportError("Parameter `name` is required when calling `ValidateSource`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
		timeouts: transport.RequestConfiguration{
			ReadTimeout:    utils.ToPtr(180000 * time.Millisecond),
			WriteTimeout:   utils.ToPtr(180000 * time.Millisecond),
			ConnectTimeout: utils.ToPtr(180000 * time.Millisecond),
		},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Type             SourceType   `json:"type"`
		Name             string       `json:"name"`
		Input            *SourceInput `json:"input,omitempty"`
		AuthenticationID *string      `json:"authenticationID,omitempty"`
	}{
		Type: type_,
		Name: name,
	}
	if optionalParams != nil {
		postBody.Input = optionalParams.Input
		postBody.AuthenticationID = optionalParams.AuthenticationID
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// ValidateSourceBeforeUpdateOptions represents the optional params for the API call.
type ValidateSourceBeforeUpdateOptions struct {
	Name             *string
	Input            *SourceUpdateInput
	AuthenticationID *string
}

// NewValidateSourceBeforeUpdateOptions creates an instance of the ValidateSourceBeforeUpdateOptions used to add optional parameters to ValidateSourceBeforeUpdateWithOptions.
func NewValidateSourceBeforeUpdateOptions() *ValidateSourceBeforeUpdateOptions {
	return &ValidateSourceBeforeUpdateOptions{}
}

// WithName Descriptive name of the source.
func (o *ValidateSourceBeforeUpdateOptions) WithName(name string) *ValidateSourceBeforeUpdateOptions {
	o.Name = &name

	return o
}

// WithInput adds the input to the ApiValidateSourceBeforeUpdateRequest and returns the request for chaining.
func (o *ValidateSourceBeforeUpdateOptions) WithInput(input *SourceUpdateInput) *ValidateSourceBeforeUpdateOptions {
	o.Input = input

	return o
}

// WithAuthenticationID Universally unique identifier (UUID) of an authentication resource.
func (o *ValidateSourceBeforeUpdateOptions) WithAuthenticationID(authenticationID string) *ValidateSourceBeforeUpdateOptions {
	o.AuthenticationID = &authenticationID

	return o
}

// ValidateSourceBeforeUpdate Validates an update of a source payload to ensure it can be created and that the data source can be reached by Algolia.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - sourceID - Unique identifier of a source.
//   - name - Descriptive name of the source. (in optionalParams)
//   - input  (in optionalParams)
//   - authenticationID - Universally unique identifier (UUID) of an authentication resource. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ValidateSourceBeforeUpdate(
	ctx context.Context,
	sourceID string,
	optionalParams *ValidateSourceBeforeUpdateOptions,
	opts ...RequestOption,
) (*WatchResponse, error) {
	var returnValue *WatchResponse

	res, resBody, err := c.ValidateSourceBeforeUpdateWithHTTPInfo(ctx, sourceID, optionalParams, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// ValidateSourceBeforeUpdateWithHTTPInfo calls the API and returns the raw response from it.
// Validates an update of a source payload to ensure it can be created and that the data source can be reached by Algolia.
//
// Required API Key ACLs:
//   - addObject
//   - deleteIndex
//   - editSettings
//
// Parameters:
//   - sourceID - Unique identifier of a source.
//   - name - Descriptive name of the source. (in optionalParams)
//   - input  (in optionalParams)
//   - authenticationID - Universally unique identifier (UUID) of an authentication resource. (in optionalParams)
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ValidateSourceBeforeUpdateWithHTTPInfo(
	ctx context.Context,
	sourceID string,
	optionalParams *ValidateSourceBeforeUpdateOptions,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}/validate"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(sourceID)))

	if sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `ValidateSourceBeforeUpdate`.")
	}

	conf := config{
		queryParams:  url.Values{},
		headerParams: map[string]string{},
		timeouts: transport.RequestConfiguration{
			ReadTimeout:    utils.ToPtr(180000 * time.Millisecond),
			WriteTimeout:   utils.ToPtr(180000 * time.Millisecond),
			ConnectTimeout: utils.ToPtr(180000 * time.Millisecond),
		},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	// body params
	postBody := struct {
		Name             *string            `json:"name,omitempty"`
		Input            *SourceUpdateInput `json:"input,omitempty"`
		AuthenticationID *string            `json:"authenticationID,omitempty"`
	}{}
	if optionalParams != nil {
		postBody.Name = optionalParams.Name
		postBody.Input = optionalParams.Input
		postBody.AuthenticationID = optionalParams.AuthenticationID
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

// --------- ChunkedBatch options ---------

type ChunkedBatchOption interface {
	RequestOption
	chunkedBatch()
}

type chunkedBatchOption func(*config)

var (
	_ ChunkedBatchOption = (*chunkedBatchOption)(nil)
	_ ChunkedBatchOption = (*requestOption)(nil)
)

func (c chunkedBatchOption) apply(conf *config) {
	c(conf)
}

func (c chunkedBatchOption) chunkedBatch() {}

func (r requestOption) chunkedBatch() {}

// WithWaitForTasks whether or not we should wait until every `batch` tasks has been processed, this operation may slow the total execution time of this method but is more reliable.
func WithWaitForTasks(waitForTasks bool) chunkedBatchOption {
	return chunkedBatchOption(func(c *config) {
		c.waitForTasks = waitForTasks
	})
}

// WithBatchSize the size of the chunk of `objects`. The number of `batch` calls will be equal to `length(objects) / batchSize`. Defaults to 1000.
func WithBatchSize(batchSize int) chunkedBatchOption {
	return chunkedBatchOption(func(c *config) {
		c.batchSize = batchSize
	})
}

// --------- Iterable options ---------.

type IterableOption interface {
	RequestOption
	iterable()
}

type iterableOption func(*config)

var (
	_ IterableOption = (*iterableOption)(nil)
	_ IterableOption = (*requestOption)(nil)
)

func (i iterableOption) apply(c *config) {
	i(c)
}

func (r requestOption) iterable() {}

func (i iterableOption) iterable() {}

// WithMaxRetries the maximum number of retry. Default to 50.
func WithMaxRetries(maxRetries int) iterableOption {
	return iterableOption(func(c *config) {
		c.maxRetries = maxRetries
	})
}

// WithTimeout he function to decide how long to wait between retries. Default to min(retryCount * 200, 5000).
func WithTimeout(timeout func(int) time.Duration) iterableOption {
	return iterableOption(func(c *config) {
		c.timeout = timeout
	})
}

// WithAggregator the function to aggregate the results of the iterable.
func WithAggregator(aggregator func(any, error)) iterableOption {
	return iterableOption(func(c *config) {
		c.aggregator = aggregator
	})
}

func CreateIterable[T any](execute func(*T, error) (*T, error), validate func(*T, error) (bool, error), opts ...IterableOption) (*T, error) {
	conf := config{
		headerParams: map[string]string{},
		maxRetries:   -1,
		timeout: func(count int) time.Duration {
			return 0 * time.Millisecond
		},
	}

	for _, opt := range opts {
		opt.apply(&conf)
	}

	var executor func(*T, error) (*T, error)

	retryCount := 0

	executor = func(previousResponse *T, previousError error) (*T, error) {
		response, responseErr := execute(previousResponse, previousError)

		retryCount++

		if conf.aggregator != nil {
			conf.aggregator(response, responseErr)
		}

		canStop, err := validate(response, responseErr)
		if canStop || err != nil {
			return response, err
		}

		if conf.maxRetries >= 0 && retryCount >= conf.maxRetries {
			return nil, errs.NewWaitError(fmt.Sprintf("The maximum number of retries exceeded. (%d/%d)", retryCount, conf.maxRetries))
		}

		time.Sleep(conf.timeout(retryCount))

		return executor(response, responseErr)
	}

	return executor(nil, nil)
}

// ChunkedPush Chunks the given `objects` list in subset of 1000 elements max in order to make it fit in `push` requests by leveraging the Transformation pipeline setup in the Push connector (https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/connectors/push/).
//
// Parameters:
//   - transformationID - Unique identifier of a transformation.
//   - indexName string - the index name to save objects into.
//   - objects []map[string]any - List of objects to save.
//   - action Action - The action to perform on the objects.
//   - referenceIndexName *string - This is required when targeting an index that does not have a push connector setup (e.g. a tmp index), but you wish to attach another index's transformation to it (e.g. the source index name).
//   - opts - Optional parameters for the API call (e.g. WithHeaderParam, WithReadTimeout...)
func (c *APIClient) ChunkedPush(
	ctx context.Context,
	indexName string,
	objects []map[string]any,
	action Action,
	referenceIndexName *string,
	opts ...ChunkedBatchOption,
) ([]WatchResponse, error) {
	conf := config{
		headerParams: map[string]string{},
		waitForTasks: false,
		batchSize:    1000,
	}

	offset := 0

	waitBatchSize := conf.batchSize / 10
	if waitBatchSize < 1 {
		waitBatchSize = conf.batchSize
	}

	for _, opt := range opts {
		opt.apply(&conf)
	}

	records := make([]map[string]any, 0, len(objects)%conf.batchSize)
	responses := make([]WatchResponse, 0, len(objects)%conf.batchSize)

	for i, obj := range objects {
		records = append(records, obj)

		if len(records) == conf.batchSize || i == len(objects)-1 {
			pushRecords := make([]PushTaskRecords, 0, len(records))

			rawRecords, err := json.Marshal(records)
			if err != nil {
				return nil, reportError("unable to marshal the given `objects`: %w", err)
			}

			err = json.Unmarshal(rawRecords, &pushRecords)
			if err != nil {
				return nil, reportError("unable to unmarshal the given `objects` to an `[]PushTaskRecords` payload: %w", err)
			}

			opts := NewPushOptions()
			if referenceIndexName != nil {
				opts = opts.WithReferenceIndexName(*referenceIndexName)
			}

			resp, err := c.Push(ctx, indexName, action, pushRecords, opts)
			if err != nil {
				return nil, err
			}

			responses = append(responses, *resp)
			records = make([]map[string]any, 0, len(objects)%conf.batchSize)
		}

		if conf.waitForTasks && len(responses) > 0 && (len(responses)%waitBatchSize == 0 || i == len(objects)-1) {
			var waitableResponses []WatchResponse

			if len(responses) > offset+waitBatchSize {
				waitableResponses = responses[offset:waitBatchSize]
			} else {
				waitableResponses = responses[offset:]
			}

			for _, resp := range waitableResponses {
				_, err := CreateIterable(
					func(*Event, error) (*Event, error) {
						if resp.EventID == nil {
							return nil, reportError("received unexpected response from the push endpoint, eventID must not be undefined")
						}

						return c.GetEvent(ctx, resp.RunID, *resp.EventID)
					},
					func(response *Event, err error) (bool, error) {
						var apiErr *APIError
						if errors.As(err, &apiErr) {
							return apiErr.Status != 404, nil
						}

						return true, err
					},
					WithTimeout(func(count int) time.Duration { return time.Duration(min(500*count, 5000)) * time.Millisecond }), WithMaxRetries(50),
				)
				if err != nil {
					return nil, err
				}
			}

			offset += waitBatchSize
		}
	}

	return responses, nil
}
