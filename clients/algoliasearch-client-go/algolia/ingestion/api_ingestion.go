/*
Ingestion API

[Documentation](https://docs.google.com/document/d/13UnFi4Osfw4vOJr5iN4P4RJDZdslpFs4OgM4F1VBwQc/edit#heading=h.kp12qj1w1lig)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ingestion

import (
	"bytes"
	"context"
  "fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// 
//  @return AuthenticationCreateResponse
func (c *APIClient) CreateAuthentication(authenticationCreate *AuthenticationCreate) (*AuthenticationCreateResponse, error) {
	var (
		body     interface{}
		returnValue  *AuthenticationCreateResponse
	)

	path := fmt.Sprintf("%s/1/authentications", c.cfg.Host)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if authenticationCreate == nil {
	  return returnValue, reportError("authenticationCreate is required and must be specified")
	}

	// body params
	body = authenticationCreate
	req, err := c.prepareRequest(context.Background(), path, http.MethodPost, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return DestinationCreateResponse
func (c *APIClient) CreateDestination(destinationCreate *DestinationCreate) (*DestinationCreateResponse, error) {
	var (
		body     interface{}
		returnValue  *DestinationCreateResponse
	)

	path := fmt.Sprintf("%s/1/destinations", c.cfg.Host)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if destinationCreate == nil {
	  return returnValue, reportError("destinationCreate is required and must be specified")
	}

	// body params
	body = destinationCreate
	req, err := c.prepareRequest(context.Background(), path, http.MethodPost, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return SourceCreateResponse
func (c *APIClient) CreateSource(sourceCreate *SourceCreate) (*SourceCreateResponse, error) {
	var (
		body     interface{}
		returnValue  *SourceCreateResponse
	)

	path := fmt.Sprintf("%s/1/sources", c.cfg.Host)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if sourceCreate == nil {
	  return returnValue, reportError("sourceCreate is required and must be specified")
	}

	// body params
	body = sourceCreate
	req, err := c.prepareRequest(context.Background(), path, http.MethodPost, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return TaskCreateResponse
func (c *APIClient) CreateTask(taskCreate *TaskCreate) (*TaskCreateResponse, error) {
	var (
		body     interface{}
		returnValue  *TaskCreateResponse
	)

	path := fmt.Sprintf("%s/1/tasks", c.cfg.Host)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if taskCreate == nil {
	  return returnValue, reportError("taskCreate is required and must be specified")
	}

	// body params
	body = taskCreate
	req, err := c.prepareRequest(context.Background(), path, http.MethodPost, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
func (c *APIClient) DeleteAuthentication(authenticationID string) (error) {
	var (
		body     interface{}
	)

	path := fmt.Sprintf("%s/1/authentications/{authenticationID}", c.cfg.Host)
	path = strings.Replace(path, "{"+"authenticationID"+"}", url.PathEscape(parameterToString(authenticationID, "")), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), path, http.MethodDelete, body, headers, queryParams)
	if err != nil {
		return err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return err
	}
  if res == nil {
    return reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return newErr
			}
		}
		return newErr
	}

	return nil
}

// 
func (c *APIClient) DeleteDestination(destinationID string) (error) {
	var (
		body     interface{}
	)

	path := fmt.Sprintf("%s/1/destinations/{destinationID}", c.cfg.Host)
	path = strings.Replace(path, "{"+"destinationID"+"}", url.PathEscape(parameterToString(destinationID, "")), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), path, http.MethodDelete, body, headers, queryParams)
	if err != nil {
		return err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return err
	}
  if res == nil {
    return reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return newErr
			}
		}
		return newErr
	}

	return nil
}

// 
func (c *APIClient) DeleteSource(sourceID string) (error) {
	var (
		body     interface{}
	)

	path := fmt.Sprintf("%s/1/sources/{sourceID}", c.cfg.Host)
	path = strings.Replace(path, "{"+"sourceID"+"}", url.PathEscape(parameterToString(sourceID, "")), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), path, http.MethodDelete, body, headers, queryParams)
	if err != nil {
		return err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return err
	}
  if res == nil {
    return reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return newErr
			}
		}
		return newErr
	}

	return nil
}

// 
func (c *APIClient) DeleteTask(taskID string) (error) {
	var (
		body     interface{}
	)

	path := fmt.Sprintf("%s/1/tasks/{taskID}", c.cfg.Host)
	path = strings.Replace(path, "{"+"taskID"+"}", url.PathEscape(parameterToString(taskID, "")), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), path, http.MethodDelete, body, headers, queryParams)
	if err != nil {
		return err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return err
	}
  if res == nil {
    return reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return newErr
			}
		}
		return newErr
	}

	return nil
}

// 
//  @return TaskUpdateResponse
func (c *APIClient) DisableTask(taskID string) (*TaskUpdateResponse, error) {
	var (
		body     interface{}
		returnValue  *TaskUpdateResponse
	)

	path := fmt.Sprintf("%s/1/tasks/{taskID}/disable", c.cfg.Host)
	path = strings.Replace(path, "{"+"taskID"+"}", url.PathEscape(parameterToString(taskID, "")), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), path, http.MethodPost, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return TaskUpdateResponse
func (c *APIClient) EnableTask(taskID string) (*TaskUpdateResponse, error) {
	var (
		body     interface{}
		returnValue  *TaskUpdateResponse
	)

	path := fmt.Sprintf("%s/1/tasks/{taskID}/enable", c.cfg.Host)
	path = strings.Replace(path, "{"+"taskID"+"}", url.PathEscape(parameterToString(taskID, "")), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), path, http.MethodPost, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return Authentication
func (c *APIClient) GetAuthentication(authenticationID string) (*Authentication, error) {
	var (
		body     interface{}
		returnValue  *Authentication
	)

	path := fmt.Sprintf("%s/1/authentications/{authenticationID}", c.cfg.Host)
	path = strings.Replace(path, "{"+"authenticationID"+"}", url.PathEscape(parameterToString(authenticationID, "")), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), path, http.MethodGet, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return ListAuthenticationsResponse
func (c *APIClient) GetAuthentications() (*ListAuthenticationsResponse, error) {
	var (
		body     interface{}
		returnValue  *ListAuthenticationsResponse
	)

	path := fmt.Sprintf("%s/1/authentications", c.cfg.Host)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), path, http.MethodGet, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return Destination
func (c *APIClient) GetDestination(destinationID string) (*Destination, error) {
	var (
		body     interface{}
		returnValue  *Destination
	)

	path := fmt.Sprintf("%s/1/destinations/{destinationID}", c.cfg.Host)
	path = strings.Replace(path, "{"+"destinationID"+"}", url.PathEscape(parameterToString(destinationID, "")), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), path, http.MethodGet, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return ListDestinationsResponse
func (c *APIClient) GetDestinations() (*ListDestinationsResponse, error) {
	var (
		body     interface{}
		returnValue  *ListDestinationsResponse
	)

	path := fmt.Sprintf("%s/1/destinations", c.cfg.Host)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), path, http.MethodGet, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return Source
func (c *APIClient) GetSource(sourceID string) (*Source, error) {
	var (
		body     interface{}
		returnValue  *Source
	)

	path := fmt.Sprintf("%s/1/sources/{sourceID}", c.cfg.Host)
	path = strings.Replace(path, "{"+"sourceID"+"}", url.PathEscape(parameterToString(sourceID, "")), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), path, http.MethodGet, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return ListSourcesResponse
func (c *APIClient) GetSources() (*ListSourcesResponse, error) {
	var (
		body     interface{}
		returnValue  *ListSourcesResponse
	)

	path := fmt.Sprintf("%s/1/sources", c.cfg.Host)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), path, http.MethodGet, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return Task
func (c *APIClient) GetTask(taskID string) (*Task, error) {
	var (
		body     interface{}
		returnValue  *Task
	)

	path := fmt.Sprintf("%s/1/tasks/{taskID}", c.cfg.Host)
	path = strings.Replace(path, "{"+"taskID"+"}", url.PathEscape(parameterToString(taskID, "")), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), path, http.MethodGet, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return ListTasksResponse
func (c *APIClient) GetTasks() (*ListTasksResponse, error) {
	var (
		body     interface{}
		returnValue  *ListTasksResponse
	)

	path := fmt.Sprintf("%s/1/tasks", c.cfg.Host)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), path, http.MethodGet, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return RunResponse
func (c *APIClient) RunTask(taskID string) (*RunResponse, error) {
	var (
		body     interface{}
		returnValue  *RunResponse
	)

	path := fmt.Sprintf("%s/1/tasks/{taskID}/run", c.cfg.Host)
	path = strings.Replace(path, "{"+"taskID"+"}", url.PathEscape(parameterToString(taskID, "")), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), path, http.MethodPost, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return AuthenticationUpdateResponse
func (c *APIClient) UpdateAuthentication(authenticationID string,authenticationUpdate *AuthenticationUpdate) (*AuthenticationUpdateResponse, error) {
	var (
		body     interface{}
		returnValue  *AuthenticationUpdateResponse
	)

	path := fmt.Sprintf("%s/1/authentications/{authenticationID}", c.cfg.Host)
	path = strings.Replace(path, "{"+"authenticationID"+"}", url.PathEscape(parameterToString(authenticationID, "")), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if authenticationUpdate == nil {
	  return returnValue, reportError("authenticationUpdate is required and must be specified")
	}

	// body params
	body = authenticationUpdate
	req, err := c.prepareRequest(context.Background(), path, http.MethodPut, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return DestinationUpdateResponse
func (c *APIClient) UpdateDestination(destinationID string,destinationUpdate *DestinationUpdate) (*DestinationUpdateResponse, error) {
	var (
		body     interface{}
		returnValue  *DestinationUpdateResponse
	)

	path := fmt.Sprintf("%s/1/destinations/{destinationID}", c.cfg.Host)
	path = strings.Replace(path, "{"+"destinationID"+"}", url.PathEscape(parameterToString(destinationID, "")), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if destinationUpdate == nil {
	  return returnValue, reportError("destinationUpdate is required and must be specified")
	}

	// body params
	body = destinationUpdate
	req, err := c.prepareRequest(context.Background(), path, http.MethodPut, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return SourceUpdateResponse
func (c *APIClient) UpdateSource(sourceID string,sourceUpdate *SourceUpdate) (*SourceUpdateResponse, error) {
	var (
		body     interface{}
		returnValue  *SourceUpdateResponse
	)

	path := fmt.Sprintf("%s/1/sources/{sourceID}", c.cfg.Host)
	path = strings.Replace(path, "{"+"sourceID"+"}", url.PathEscape(parameterToString(sourceID, "")), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if sourceUpdate == nil {
	  return returnValue, reportError("sourceUpdate is required and must be specified")
	}

	// body params
	body = sourceUpdate
	req, err := c.prepareRequest(context.Background(), path, http.MethodPost, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// 
//  @return TaskUpdateResponse
func (c *APIClient) UpdateTask(taskID string,taskUpdate *TaskUpdate) (*TaskUpdateResponse, error) {
	var (
		body     interface{}
		returnValue  *TaskUpdateResponse
	)

	path := fmt.Sprintf("%s/1/tasks/{taskID}", c.cfg.Host)
	path = strings.Replace(path, "{"+"taskID"+"}", url.PathEscape(parameterToString(taskID, "")), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if taskUpdate == nil {
	  return returnValue, reportError("taskUpdate is required and must be specified")
	}

	// body params
	body = taskUpdate
	req, err := c.prepareRequest(context.Background(), path, http.MethodPut, body, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
  if res == nil {
    return returnValue, reportError("res is nil")
  }

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
      Message: string(resBody),
			Status: res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
