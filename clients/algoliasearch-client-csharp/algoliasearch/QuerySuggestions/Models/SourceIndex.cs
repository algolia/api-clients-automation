//
// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using FileParameter = Algolia.Search.QuerySuggestions.Client.FileParameter;
using OpenAPIDateConverter = Algolia.Search.QuerySuggestions.Client.OpenAPIDateConverter;

namespace Algolia.Search.QuerySuggestions.Models
{
  /// <summary>
  /// Configuration of an Algolia index for Query Suggestions.
  /// </summary>
  [DataContract(Name = "SourceIndex")]
  public partial class SourceIndex : IEquatable<SourceIndex>, IValidatableObject
  {
    /// <summary>
    /// Initializes a new instance of the <see cref="SourceIndex" /> class.
    /// </summary>
    [JsonConstructorAttribute]
    protected SourceIndex() { }
    /// <summary>
    /// Initializes a new instance of the <see cref="SourceIndex" /> class.
    /// </summary>
    /// <param name="indexName">Name of the Algolia index to use as source for query suggestions. (required).</param>
    /// <param name="replicas">If true, Query Suggestions uses all replicas of the primary index to find popular searches. If false, only the primary index is used.   (default to false).</param>
    /// <param name="analyticsTags">[Analytics tags](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) for filtering the popular searches. .</param>
    /// <param name="facets">Facets to use as top categories with your suggestions.  If provided, Query Suggestions adds the top facet values to each suggestion. .</param>
    /// <param name="minHits">Minimum number of hits required to be included as a suggestion.  A search query must at least generate &#x60;minHits&#x60; hits to be included in the Query Suggestions index.  (default to 5).</param>
    /// <param name="minLetters">Minimum letters required to be included as a suggestion.  A search query must be at least &#x60;minLetters&#x60; long to be included in the Query Suggestions index.  (default to 4).</param>
    /// <param name="generate">generate.</param>
    /// <param name="external">Algolia indices with popular searches to use as query suggestions.  Records of these indices must have these attributes:    - &#x60;query&#x60;: search query which will be added as a suggestion   - &#x60;count&#x60;: measure of popularity of that search query  For example, you can export popular searches from an external analytics tool, such as Google Analytics or Adobe Analytics, and feed this data into an external Algolia index. You can use this external index to generate query suggestions until your Algolia analytics has collected enough data. .</param>
    public SourceIndex(string indexName = default(string), bool replicas = false, List<string> analyticsTags = default(List<string>), List<Facet> facets = default(List<Facet>), int minHits = 5, int minLetters = 4, List<List<string>> generate = default(List<List<string>>), List<string> external = default(List<string>))
    {
      // to ensure "indexName" is required (not null)
      if (indexName == null)
      {
        throw new ArgumentNullException("indexName is a required property for SourceIndex and cannot be null");
      }
      this.IndexName = indexName;
      this.Replicas = replicas;
      this.AnalyticsTags = analyticsTags;
      this.Facets = facets;
      this.MinHits = minHits;
      this.MinLetters = minLetters;
      this.Generate = generate;
      this.External = external;
    }

    /// <summary>
    /// Name of the Algolia index to use as source for query suggestions.
    /// </summary>
    /// <value>Name of the Algolia index to use as source for query suggestions.</value>
    [DataMember(Name = "indexName", IsRequired = true, EmitDefaultValue = true)]
    public string IndexName { get; set; }

    /// <summary>
    /// If true, Query Suggestions uses all replicas of the primary index to find popular searches. If false, only the primary index is used.  
    /// </summary>
    /// <value>If true, Query Suggestions uses all replicas of the primary index to find popular searches. If false, only the primary index is used.  </value>
    [DataMember(Name = "replicas", EmitDefaultValue = true)]
    public bool Replicas { get; set; }

    /// <summary>
    /// [Analytics tags](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) for filtering the popular searches. 
    /// </summary>
    /// <value>[Analytics tags](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) for filtering the popular searches. </value>
    [DataMember(Name = "analyticsTags", EmitDefaultValue = true)]
    public List<string> AnalyticsTags { get; set; }

    /// <summary>
    /// Facets to use as top categories with your suggestions.  If provided, Query Suggestions adds the top facet values to each suggestion. 
    /// </summary>
    /// <value>Facets to use as top categories with your suggestions.  If provided, Query Suggestions adds the top facet values to each suggestion. </value>
    [DataMember(Name = "facets", EmitDefaultValue = true)]
    public List<Facet> Facets { get; set; }

    /// <summary>
    /// Minimum number of hits required to be included as a suggestion.  A search query must at least generate &#x60;minHits&#x60; hits to be included in the Query Suggestions index. 
    /// </summary>
    /// <value>Minimum number of hits required to be included as a suggestion.  A search query must at least generate &#x60;minHits&#x60; hits to be included in the Query Suggestions index. </value>
    [DataMember(Name = "minHits", EmitDefaultValue = false)]
    public int MinHits { get; set; }

    /// <summary>
    /// Minimum letters required to be included as a suggestion.  A search query must be at least &#x60;minLetters&#x60; long to be included in the Query Suggestions index. 
    /// </summary>
    /// <value>Minimum letters required to be included as a suggestion.  A search query must be at least &#x60;minLetters&#x60; long to be included in the Query Suggestions index. </value>
    [DataMember(Name = "minLetters", EmitDefaultValue = false)]
    public int MinLetters { get; set; }

    /// <summary>
    /// Gets or Sets Generate
    /// </summary>
    [DataMember(Name = "generate", EmitDefaultValue = false)]
    public List<List<string>> Generate { get; set; }

    /// <summary>
    /// Algolia indices with popular searches to use as query suggestions.  Records of these indices must have these attributes:    - &#x60;query&#x60;: search query which will be added as a suggestion   - &#x60;count&#x60;: measure of popularity of that search query  For example, you can export popular searches from an external analytics tool, such as Google Analytics or Adobe Analytics, and feed this data into an external Algolia index. You can use this external index to generate query suggestions until your Algolia analytics has collected enough data. 
    /// </summary>
    /// <value>Algolia indices with popular searches to use as query suggestions.  Records of these indices must have these attributes:    - &#x60;query&#x60;: search query which will be added as a suggestion   - &#x60;count&#x60;: measure of popularity of that search query  For example, you can export popular searches from an external analytics tool, such as Google Analytics or Adobe Analytics, and feed this data into an external Algolia index. You can use this external index to generate query suggestions until your Algolia analytics has collected enough data. </value>
    [DataMember(Name = "external", EmitDefaultValue = true)]
    public List<string> External { get; set; }

    /// <summary>
    /// Returns the string presentation of the object
    /// </summary>
    /// <returns>String presentation of the object</returns>
    public override string ToString()
    {
      StringBuilder sb = new StringBuilder();
      sb.Append("class SourceIndex {\n");
      sb.Append("  IndexName: ").Append(IndexName).Append("\n");
      sb.Append("  Replicas: ").Append(Replicas).Append("\n");
      sb.Append("  AnalyticsTags: ").Append(AnalyticsTags).Append("\n");
      sb.Append("  Facets: ").Append(Facets).Append("\n");
      sb.Append("  MinHits: ").Append(MinHits).Append("\n");
      sb.Append("  MinLetters: ").Append(MinLetters).Append("\n");
      sb.Append("  Generate: ").Append(Generate).Append("\n");
      sb.Append("  External: ").Append(External).Append("\n");
      sb.Append("}\n");
      return sb.ToString();
    }

    /// <summary>
    /// Returns the JSON string presentation of the object
    /// </summary>
    /// <returns>JSON string presentation of the object</returns>
    public virtual string ToJson()
    {
      return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
    }

    /// <summary>
    /// Returns true if objects are equal
    /// </summary>
    /// <param name="input">Object to be compared</param>
    /// <returns>Boolean</returns>
    public override bool Equals(object input)
    {
      return this.Equals(input as SourceIndex);
    }

    /// <summary>
    /// Returns true if SourceIndex instances are equal
    /// </summary>
    /// <param name="input">Instance of SourceIndex to be compared</param>
    /// <returns>Boolean</returns>
    public bool Equals(SourceIndex input)
    {
      if (input == null)
      {
        return false;
      }
      return
          (
              this.IndexName == input.IndexName ||
              (this.IndexName != null &&
              this.IndexName.Equals(input.IndexName))
          ) &&
          (
              this.Replicas == input.Replicas ||
              this.Replicas.Equals(input.Replicas)
          ) &&
          (
              this.AnalyticsTags == input.AnalyticsTags ||
              this.AnalyticsTags != null &&
              input.AnalyticsTags != null &&
              this.AnalyticsTags.SequenceEqual(input.AnalyticsTags)
          ) &&
          (
              this.Facets == input.Facets ||
              this.Facets != null &&
              input.Facets != null &&
              this.Facets.SequenceEqual(input.Facets)
          ) &&
          (
              this.MinHits == input.MinHits ||
              this.MinHits.Equals(input.MinHits)
          ) &&
          (
              this.MinLetters == input.MinLetters ||
              this.MinLetters.Equals(input.MinLetters)
          ) &&
          (
              this.Generate == input.Generate ||
              this.Generate != null &&
              input.Generate != null &&
              this.Generate.SequenceEqual(input.Generate)
          ) &&
          (
              this.External == input.External ||
              this.External != null &&
              input.External != null &&
              this.External.SequenceEqual(input.External)
          );
    }

    /// <summary>
    /// Gets the hash code
    /// </summary>
    /// <returns>Hash code</returns>
    public override int GetHashCode()
    {
      unchecked // Overflow is fine, just wrap
      {
        int hashCode = 41;
        if (this.IndexName != null)
        {
          hashCode = (hashCode * 59) + this.IndexName.GetHashCode();
        }
        hashCode = (hashCode * 59) + this.Replicas.GetHashCode();
        if (this.AnalyticsTags != null)
        {
          hashCode = (hashCode * 59) + this.AnalyticsTags.GetHashCode();
        }
        if (this.Facets != null)
        {
          hashCode = (hashCode * 59) + this.Facets.GetHashCode();
        }
        hashCode = (hashCode * 59) + this.MinHits.GetHashCode();
        hashCode = (hashCode * 59) + this.MinLetters.GetHashCode();
        if (this.Generate != null)
        {
          hashCode = (hashCode * 59) + this.Generate.GetHashCode();
        }
        if (this.External != null)
        {
          hashCode = (hashCode * 59) + this.External.GetHashCode();
        }
        return hashCode;
      }
    }

    /// <summary>
    /// To validate all properties of the instance
    /// </summary>
    /// <param name="validationContext">Validation context</param>
    /// <returns>Validation Result</returns>
    IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
    {
      // MinHits (int) minimum
      if (this.MinHits < (int)0)
      {
        yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for MinHits, must be a value greater than or equal to 0.", new[] { "MinHits" });
      }

      // MinLetters (int) minimum
      if (this.MinLetters < (int)0)
      {
        yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for MinLetters, must be a value greater than or equal to 0.", new[] { "MinLetters" });
      }

      yield break;
    }
  }

}
