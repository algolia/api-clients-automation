//
// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
//
using System;
using System.Text;
using System.Linq;
using System.Text.Json.Serialization;
using System.Collections.Generic;
using Algolia.Search.Serializer;
using System.Text.Json;

namespace Algolia.Search.Models.QuerySuggestions;

/// <summary>
/// Configuration of an Algolia index for Query Suggestions.
/// </summary>
public partial class SourceIndex
{
  /// <summary>
  /// Initializes a new instance of the SourceIndex class.
  /// </summary>
  [JsonConstructor]
  public SourceIndex() { }
  /// <summary>
  /// Initializes a new instance of the SourceIndex class.
  /// </summary>
  /// <param name="indexName">Name of the Algolia index to use as source for query suggestions. (required).</param>
  public SourceIndex(string indexName)
  {
    IndexName = indexName ?? throw new ArgumentNullException(nameof(indexName));
  }

  /// <summary>
  /// Name of the Algolia index to use as source for query suggestions.
  /// </summary>
  /// <value>Name of the Algolia index to use as source for query suggestions.</value>
  [JsonPropertyName("indexName")]
  public string IndexName { get; set; }

  /// <summary>
  /// If true, Query Suggestions uses all replicas of the primary index to find popular searches. If false, only the primary index is used.  
  /// </summary>
  /// <value>If true, Query Suggestions uses all replicas of the primary index to find popular searches. If false, only the primary index is used.  </value>
  [JsonPropertyName("replicas")]
  public bool? Replicas { get; set; }

  /// <summary>
  /// [Analytics tags](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) for filtering the popular searches. 
  /// </summary>
  /// <value>[Analytics tags](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) for filtering the popular searches. </value>
  [JsonPropertyName("analyticsTags")]
  public List<string> AnalyticsTags { get; set; }

  /// <summary>
  /// Facets to use as top categories with your suggestions.  If provided, Query Suggestions adds the top facet values to each suggestion. 
  /// </summary>
  /// <value>Facets to use as top categories with your suggestions.  If provided, Query Suggestions adds the top facet values to each suggestion. </value>
  [JsonPropertyName("facets")]
  public List<Facet> Facets { get; set; }

  /// <summary>
  /// Minimum number of hits required to be included as a suggestion.  A search query must at least generate `minHits` hits to be included in the Query Suggestions index. 
  /// </summary>
  /// <value>Minimum number of hits required to be included as a suggestion.  A search query must at least generate `minHits` hits to be included in the Query Suggestions index. </value>
  [JsonPropertyName("minHits")]
  public int? MinHits { get; set; }

  /// <summary>
  /// Minimum letters required to be included as a suggestion.  A search query must be at least `minLetters` long to be included in the Query Suggestions index. 
  /// </summary>
  /// <value>Minimum letters required to be included as a suggestion.  A search query must be at least `minLetters` long to be included in the Query Suggestions index. </value>
  [JsonPropertyName("minLetters")]
  public int? MinLetters { get; set; }

  /// <summary>
  /// Gets or Sets Generate
  /// </summary>
  [JsonPropertyName("generate")]
  public List<List<string>> Generate { get; set; }

  /// <summary>
  /// Algolia indices with popular searches to use as query suggestions.  Records of these indices must have these attributes:    - `query`: search query which will be added as a suggestion   - `count`: measure of popularity of that search query  For example, you can export popular searches from an external analytics tool, such as Google Analytics or Adobe Analytics, and feed this data into an external Algolia index. You can use this external index to generate query suggestions until your Algolia analytics has collected enough data. 
  /// </summary>
  /// <value>Algolia indices with popular searches to use as query suggestions.  Records of these indices must have these attributes:    - `query`: search query which will be added as a suggestion   - `count`: measure of popularity of that search query  For example, you can export popular searches from an external analytics tool, such as Google Analytics or Adobe Analytics, and feed this data into an external Algolia index. You can use this external index to generate query suggestions until your Algolia analytics has collected enough data. </value>
  [JsonPropertyName("external")]
  public List<string> External { get; set; }

  /// <summary>
  /// Returns the string presentation of the object
  /// </summary>
  /// <returns>String presentation of the object</returns>
  public override string ToString()
  {
    StringBuilder sb = new StringBuilder();
    sb.Append("class SourceIndex {\n");
    sb.Append("  IndexName: ").Append(IndexName).Append("\n");
    sb.Append("  Replicas: ").Append(Replicas).Append("\n");
    sb.Append("  AnalyticsTags: ").Append(AnalyticsTags).Append("\n");
    sb.Append("  Facets: ").Append(Facets).Append("\n");
    sb.Append("  MinHits: ").Append(MinHits).Append("\n");
    sb.Append("  MinLetters: ").Append(MinLetters).Append("\n");
    sb.Append("  Generate: ").Append(Generate).Append("\n");
    sb.Append("  External: ").Append(External).Append("\n");
    sb.Append("}\n");
    return sb.ToString();
  }

  /// <summary>
  /// Returns the JSON string presentation of the object
  /// </summary>
  /// <returns>JSON string presentation of the object</returns>
  public virtual string ToJson()
  {
    return JsonSerializer.Serialize(this, JsonConfig.Options);
  }

  /// <summary>
  /// Returns true if objects are equal
  /// </summary>
  /// <param name="obj">Object to be compared</param>
  /// <returns>Boolean</returns>
  public override bool Equals(object obj)
  {
    if (obj is not SourceIndex input)
    {
      return false;
    }

    return
        (IndexName == input.IndexName || (IndexName != null && IndexName.Equals(input.IndexName))) &&
        (Replicas == input.Replicas || Replicas.Equals(input.Replicas)) &&
        (AnalyticsTags == input.AnalyticsTags || AnalyticsTags != null && input.AnalyticsTags != null && AnalyticsTags.SequenceEqual(input.AnalyticsTags)) &&
        (Facets == input.Facets || Facets != null && input.Facets != null && Facets.SequenceEqual(input.Facets)) &&
        (MinHits == input.MinHits || MinHits.Equals(input.MinHits)) &&
        (MinLetters == input.MinLetters || MinLetters.Equals(input.MinLetters)) &&
        (Generate == input.Generate || Generate != null && input.Generate != null && Generate.SequenceEqual(input.Generate)) &&
        (External == input.External || External != null && input.External != null && External.SequenceEqual(input.External));
  }

  /// <summary>
  /// Gets the hash code
  /// </summary>
  /// <returns>Hash code</returns>
  public override int GetHashCode()
  {
    unchecked // Overflow is fine, just wrap
    {
      int hashCode = 41;
      if (IndexName != null)
      {
        hashCode = (hashCode * 59) + IndexName.GetHashCode();
      }
      hashCode = (hashCode * 59) + Replicas.GetHashCode();
      if (AnalyticsTags != null)
      {
        hashCode = (hashCode * 59) + AnalyticsTags.GetHashCode();
      }
      if (Facets != null)
      {
        hashCode = (hashCode * 59) + Facets.GetHashCode();
      }
      hashCode = (hashCode * 59) + MinHits.GetHashCode();
      hashCode = (hashCode * 59) + MinLetters.GetHashCode();
      if (Generate != null)
      {
        hashCode = (hashCode * 59) + Generate.GetHashCode();
      }
      if (External != null)
      {
        hashCode = (hashCode * 59) + External.GetHashCode();
      }
      return hashCode;
    }
  }

}

