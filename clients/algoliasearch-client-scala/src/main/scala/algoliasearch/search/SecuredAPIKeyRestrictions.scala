/** Search API Use the Search REST API to manage your data (indices and records), implement search, and improve
  * relevance (with Rules, synonyms, and language dictionaries). Although Algolia provides a REST API, you should use
  * the official open source API [clients, libraries, and
  * tools](https://www.algolia.com/doc/guides/getting-started/how-algolia-works/in-depth/ecosystem/) instead. There's no
  * [SLA](https://www.algolia.com/policies/sla/) if you use the REST API directly.
  *
  * The version of the OpenAPI document: 1.0.0
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech Do not edit the class manually.
  */
package algoliasearch.search

/** SecuredAPIKeyRestrictions
  *
  * @param filters
  *   Filters that apply to every search made with the secured API key. You can add extra filters at search time with
  *   the filters query parameter. For example, if you set the filter group:admin on your generated API key, and you add
  *   groups:press OR groups:visitors with the filters query parameter, your final search filter is equivalent to
  *   groups:admin AND (groups:press OR groups:visitors).
  * @param validUntil
  *   Unix timestamp used to set the expiration date of the API key.
  * @param restrictIndices
  *   Index names that can be queried.
  * @param restrictSources
  *   IPv4 network allowed to use the generated key. Use this to protect against API key leaking and reuse. You can only
  *   provide a single source, but you can specify a range of IPs (for example, 192.168.1.0/24).
  * @param userToken
  *   Unique user IP address. This can be useful when you want to impose a rate limit on specific users. By default,
  *   rate limits are set based on the IP address. This can become an issue when several users search from the same IP
  *   address. To avoid this, you can set a unique userToken for each user when generating their API key. This lets you
  *   restrict each user to a maximum number of API calls per hour, even if they share their IP with another user.
  *   Specifying the userToken in a secured API key is also a good security practice as it ensures users don't change
  *   it. Many features like Analytics, Personalization, and Dynamic Re-ranking rely on the authenticity of user
  *   identifiers. Setting the userToken at the API key level ensures that downstream services work as expected and
  *   prevents abuse.
  */
case class SecuredAPIKeyRestrictions(
    searchParams: Option[SearchParamsObject] = scala.None,
    filters: Option[String] = scala.None,
    validUntil: Option[Double] = scala.None,
    restrictIndices: Option[Seq[String]] = scala.None,
    restrictSources: Option[String] = scala.None,
    userToken: Option[String] = scala.None
)
