/** Search API Use the Search REST API to manage your data (indices and records), implement search, and improve
  * relevance (with Rules, synonyms, and language dictionaries). Although Algolia provides a REST API, you should use
  * the official open source API [clients, libraries, and
  * tools](https://www.algolia.com/doc/guides/getting-started/how-algolia-works/in-depth/ecosystem/) instead. There's no
  * [SLA](https://www.algolia.com/policies/sla/) if you use the REST API directly.
  *
  * The version of the OpenAPI document: 1.0.0
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech Do not edit the class manually.
  */
package algoliasearch.search

/** BaseIndexSettings
  *
  * @param replicas
  *   Creates [replicas](https://www.algolia.com/doc/guides/managing-results/refine-results/sorting/in-depth/replicas/),
  *   which are copies of a primary index with the same records but different settings.
  * @param paginationLimitedTo
  *   Maximum number of hits accessible through pagination.
  * @param unretrievableAttributes
  *   Attributes that can't be retrieved at query time.
  * @param disableTypoToleranceOnWords
  *   Words for which you want to turn off [typo
  *   tolerance](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/typo-tolerance/).
  * @param attributesToTransliterate
  *   Attributes in your index to which [Japanese
  *   transliteration](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/language-specific-configurations/#japanese-transliteration-and-type-ahead)
  *   applies. This will ensure that words indexed in Katakana or Kanji can also be searched in Hiragana.
  * @param camelCaseAttributes
  *   Attributes on which to split [camel case](https://wikipedia.org/wiki/Camel_case) words.
  * @param decompoundedAttributes
  *   Attributes in your index to which [word
  *   segmentation](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/)
  *   (decompounding) applies.
  * @param indexLanguages
  *   Set the languages of your index, for language-specific processing steps such as
  *   [tokenization](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/tokenization/)
  *   and
  *   [normalization](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/normalization/).
  * @param disablePrefixOnAttributes
  *   Attributes for which you want to turn off [prefix
  *   matching](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/override-search-engine-defaults/#adjusting-prefix-search).
  * @param allowCompressionOfIntegerArray
  *   Incidates whether the engine compresses arrays with exclusively non-negative integers. When enabled, the
  *   compressed arrays may be reordered.
  * @param numericAttributesForFiltering
  *   Numeric attributes that can be used as [numerical
  *   filters](https://www.algolia.com/doc/guides/managing-results/rules/detecting-intent/how-to/applying-a-custom-filter-for-a-specific-query/#numerical-filters).
  * @param separatorsToIndex
  *   Controls which separators are added to an Algolia index as part of
  *   [normalization](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/#what-does-normalization-mean).
  *   Separators are all non-letter characters except spaces and currency characters, such as $€£¥.
  * @param searchableAttributes
  *   [Attributes used for
  *   searching](https://www.algolia.com/doc/guides/managing-results/must-do/searchable-attributes/), including
  *   determining [if matches at the beginning of a word are important (ordered) or not
  *   (unordered)](https://www.algolia.com/doc/guides/managing-results/must-do/searchable-attributes/how-to/configuring-searchable-attributes-the-right-way/#understanding-word-position).
  * @param userData
  *   Lets you store custom data in your indices.
  * @param customNormalization
  *   A list of characters and their normalized replacements to override Algolia's default
  *   [normalization](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/normalization/).
  * @param attributeForDistinct
  *   Name of the deduplication attribute to be used with Algolia's [_distinct_
  *   feature](https://www.algolia.com/doc/guides/managing-results/refine-results/grouping/#introducing-algolias-distinct-feature).
  */
case class BaseIndexSettings(
    replicas: Option[Seq[String]] = scala.None,
    paginationLimitedTo: Option[Int] = scala.None,
    unretrievableAttributes: Option[Seq[String]] = scala.None,
    disableTypoToleranceOnWords: Option[Seq[String]] = scala.None,
    attributesToTransliterate: Option[Seq[String]] = scala.None,
    camelCaseAttributes: Option[Seq[String]] = scala.None,
    decompoundedAttributes: Option[Any] = scala.None,
    indexLanguages: Option[Seq[String]] = scala.None,
    disablePrefixOnAttributes: Option[Seq[String]] = scala.None,
    allowCompressionOfIntegerArray: Option[Boolean] = scala.None,
    numericAttributesForFiltering: Option[Seq[String]] = scala.None,
    separatorsToIndex: Option[String] = scala.None,
    searchableAttributes: Option[Seq[String]] = scala.None,
    userData: Option[Any] = scala.None,
    customNormalization: Option[Map[String, Map[String, String]]] = scala.None,
    attributeForDistinct: Option[String] = scala.None
)
