/** Algolia Monitoring API The Monitoring API lets you check the status of your Algolia infrastructure. ## Base URLs The
  * base URL for requests to the Monitoring API is: - `https://status.algolia.com` **All requests must use HTTPS.** ##
  * Availability and authentication Access to the [Infrastructure](#tag/infrastructure) endpoints is available as part
  * of the [Premium or Elevate plans](https://www.algolia.com/pricing). To authenticate requests to the Infrastructure
  * endpoints, add these headers: - `x-algolia-application-id`. Your Algolia application ID. - `x-algolia-api-key`. Your
  * Monitoring API key. You can find your application ID and API key in the [Algolia
  * dashboard](https://dashboard.algolia.com/account). Other endpoints don't require authentication. ## Response status
  * and errors The Monitoring API returns JSON responses. Since JSON doesn't guarantee any specific ordering, don't rely
  * on the order of attributes in the API response. Successful responses return a `2xx` status. Client errors return a
  * `4xx` status. Server errors are indicated by a `5xx` status. Error responses have a `message` property with more
  * information. ## Version The current version of the Monitoring API is version 1, as indicated by the `/1/` in each
  * endpoint's URL.
  *
  * The version of the OpenAPI document: 1.0.0
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech Do not edit the class manually.
  */
package algoliasearch.monitoring

import algoliasearch.monitoring.ModelType._
import algoliasearch.monitoring.Region._
import algoliasearch.monitoring.ServerStatus._

import org.json4s._

/** Server
  *
  * @param name
  *   Server name.
  * @param isSlave
  *   Included to support legacy applications. Use `is_replica` instead.
  * @param isReplica
  *   Whether this server is a replica of another server.
  * @param cluster
  *   Name of the cluster to which this server belongs.
  */
case class Server(
    name: Option[String] = scala.None,
    region: Option[Region] = scala.None,
    isSlave /* is_slave */: Option[Boolean] = scala.None,
    isReplica /* is_replica */: Option[Boolean] = scala.None,
    cluster: Option[String] = scala.None,
    status: Option[ServerStatus] = scala.None,
    `type`: Option[ModelType] = scala.None
)

class ServerSerializer extends Serializer[Server] {

  private val renamedFields = Map[String, String](
    "is_slave" -> "isSlave",
    "is_replica" -> "isReplica"
  )
  override def deserialize(implicit format: Formats): PartialFunction[(TypeInfo, JValue), Server] = {
    case (TypeInfo(clazz, _), json) if clazz == classOf[Server] =>
      json match {
        case jobject: JObject =>
          // Rename fields from JSON to Scala
          val renamedObject = JObject(
            jobject.obj.map { field =>
              renamedFields.get(field._1).map(JField(_, field._2)).getOrElse(field)
            }
          )
          val formats = format - this
          val mf = manifest[Server]
          Extraction.extract[Server](renamedObject)(formats, mf)

        case _ => throw new IllegalArgumentException(s"Can't deserialize $json as Server")
      }
  }

  override def serialize(implicit format: Formats): PartialFunction[Any, JValue] = { case value: Server =>
    val formats = format - this // remove current serializer from formats to avoid stackoverflow
    val baseObj = Extraction.decompose(value)(formats)
    baseObj transformField {
      case JField(name, value) if renamedFields.exists(_._2 == name) => (renamedFields.find(_._2 == name).get._1, value)
    }
  }
}
