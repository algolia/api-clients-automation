/** Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on
  * https://github.com/algolia/api-clients-automation. DO NOT EDIT.
  */
package algoliasearch.api

import algoliasearch.search.AddApiKeyResponse
import algoliasearch.search.ApiKey
import algoliasearch.search.AssignUserIdParams
import algoliasearch.search.AttributeToUpdate
import algoliasearch.search.BatchAssignUserIdsParams
import algoliasearch.search.BatchDictionaryEntriesParams
import algoliasearch.search.BatchParams
import algoliasearch.search.BatchResponse
import algoliasearch.search.BatchWriteParams
import algoliasearch.search.BrowseParams
import algoliasearch.search.BrowseResponse
import algoliasearch.search.CreatedAtResponse
import algoliasearch.search.DeleteApiKeyResponse
import algoliasearch.search.DeleteByParams
import algoliasearch.search.DeleteSourceResponse
import algoliasearch.search.DeletedAtResponse
import algoliasearch.search.DictionarySettingsParams
import algoliasearch.search.DictionaryType._
import algoliasearch.search.ErrorBase
import algoliasearch.search.GetApiKeyResponse
import algoliasearch.search.GetDictionarySettingsResponse
import algoliasearch.search.GetLogsResponse
import algoliasearch.search.GetObjectsParams
import algoliasearch.search.GetObjectsResponse
import algoliasearch.search.GetTaskResponse
import algoliasearch.search.GetTopUserIdsResponse
import algoliasearch.search.HasPendingMappingsResponse
import algoliasearch.search.IndexSettings
import algoliasearch.search.Languages
import algoliasearch.search.ListApiKeysResponse
import algoliasearch.search.ListClustersResponse
import algoliasearch.search.ListIndicesResponse
import algoliasearch.search.ListUserIdsResponse
import algoliasearch.search.LogType._
import algoliasearch.search.MultipleBatchResponse
import algoliasearch.search.OperationIndexParams
import algoliasearch.search.RemoveUserIdResponse
import algoliasearch.search.ReplaceSourceResponse
import algoliasearch.search.Rule
import algoliasearch.search.SaveObjectResponse
import algoliasearch.search.SaveSynonymResponse
import algoliasearch.search.SearchDictionaryEntriesParams
import algoliasearch.search.SearchForFacetValuesRequest
import algoliasearch.search.SearchForFacetValuesResponse
import algoliasearch.search.SearchMethodParams
import algoliasearch.search.SearchParams
import algoliasearch.search.SearchResponse
import algoliasearch.search.SearchResponses
import algoliasearch.search.SearchRulesParams
import algoliasearch.search.SearchRulesResponse
import algoliasearch.search.SearchSynonymsParams
import algoliasearch.search.SearchSynonymsResponse
import algoliasearch.search.SearchUserIdsParams
import algoliasearch.search.SearchUserIdsResponse
import algoliasearch.search.Source
import algoliasearch.search.SynonymHit
import algoliasearch.search.UpdateApiKeyResponse
import algoliasearch.search.UpdatedAtResponse
import algoliasearch.search.UpdatedAtWithObjectIdResponse
import algoliasearch.search.UpdatedRuleResponse
import algoliasearch.search.UserId
import algoliasearch.search._
import algoliasearch.ApiClient
import algoliasearch.api.SearchClient.hosts
import algoliasearch.config._
import algoliasearch.internal.util._

import scala.concurrent.{ExecutionContext, Future}
import scala.util.Random

object SearchClient {

  /** Creates a new SearchApi instance using default hosts.
    *
    * @param appId
    *   application ID
    * @param apiKey
    *   api key
    *
    * @param clientOptions
    *   client options
    */
  def apply(
      appId: String,
      apiKey: String,
      clientOptions: ClientOptions = ClientOptions()
  ) = new SearchClient(
    appId = appId,
    apiKey = apiKey,
    clientOptions = clientOptions
  )

  private def hosts(appId: String): Seq[Host] = {
    val commonHosts = Random.shuffle(
      List(
        Host(appId + "-1.algolianet.net", Set(CallType.Read, CallType.Write)),
        Host(appId + "-2.algolianet.net", Set(CallType.Read, CallType.Write)),
        Host(appId + "-3.algolianet.net", Set(CallType.Read, CallType.Write))
      )
    )
    List(
      Host(appId + "-dsn.algolia.net", Set(CallType.Read)),
      Host(appId + ".algolia.net", Set(CallType.Write))
    ) ++ commonHosts
  }
}

class SearchClient(
    appId: String,
    apiKey: String,
    clientOptions: ClientOptions = ClientOptions()
) extends ApiClient(
      appId = appId,
      apiKey = apiKey,
      clientName = "Search",
      defaultHosts = hosts(appId),
      formats = JsonSupport.format,
      options = clientOptions
    ) {

  /** Add a new API key with specific permissions and restrictions. The request must be authenticated with the admin API
    * key. The response returns an API key string.
    *
    * Required API Key ACLs:
    *   - admin
    */
  def addApiKey(apiKey: ApiKey, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[AddApiKeyResponse] = Future {
    requireNotNull(apiKey, "Parameter `apiKey` is required when calling `addApiKey`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/keys")
      .withBody(apiKey)
      .build()
    execute[AddApiKeyResponse](request, requestOptions)
  }

  /** If you use an existing `objectID`, the existing record will be replaced with the new one. To update only some
    * attributes of an existing record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject)
    * instead. To add multiple records to your index in a single API request, use the [`batch`
    * operation](#tag/Records/operation/batch).
    *
    * Required API Key ACLs:
    *   - addObject
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param objectID
    *   Unique record (object) identifier.
    * @param body
    *   Algolia record.
    */
  def addOrUpdateObject(indexName: String, objectID: String, body: Any, requestOptions: Option[RequestOptions] = None)(
      implicit ec: ExecutionContext
  ): Future[UpdatedAtWithObjectIdResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `addOrUpdateObject`.")
    requireNotNull(objectID, "Parameter `objectID` is required when calling `addOrUpdateObject`.")
    requireNotNull(body, "Parameter `body` is required when calling `addOrUpdateObject`.")

    val request = HttpRequest
      .builder()
      .withMethod("PUT")
      .withPath(s"/1/indexes/${escape(indexName)}/${escape(objectID)}")
      .withBody(body)
      .build()
    execute[UpdatedAtWithObjectIdResponse](request, requestOptions)
  }

  /** Add a source to the list of allowed sources.
    *
    * Required API Key ACLs:
    *   - admin
    *
    * @param source
    *   Source to add.
    */
  def appendSource(source: Source, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[CreatedAtResponse] = Future {
    requireNotNull(source, "Parameter `source` is required when calling `appendSource`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/security/sources/append")
      .withBody(source)
      .build()
    execute[CreatedAtResponse](request, requestOptions)
  }

  /** Assign or move a user ID to a cluster. The time it takes to move a user is proportional to the amount of data
    * linked to the user ID.
    *
    * Required API Key ACLs:
    *   - admin
    *
    * @param xAlgoliaUserID
    *   userID to assign.
    */
  def assignUserId(
      xAlgoliaUserID: String,
      assignUserIdParams: AssignUserIdParams,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[CreatedAtResponse] = Future {
    requireNotNull(xAlgoliaUserID, "Parameter `xAlgoliaUserID` is required when calling `assignUserId`.")
    requireNotNull(assignUserIdParams, "Parameter `assignUserIdParams` is required when calling `assignUserId`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/clusters/mapping")
      .withBody(assignUserIdParams)
      .withHeader("X-Algolia-User-ID", xAlgoliaUserID)
      .build()
    execute[CreatedAtResponse](request, requestOptions)
  }

  /** To reduce the time spent on network round trips, you can perform several write actions in a single API call.
    * Actions are applied in the order they are specified. The supported `action`s are equivalent to the individual
    * operations of the same name.
    *
    * @param indexName
    *   Index on which to perform the request.
    */
  def batch(indexName: String, batchWriteParams: BatchWriteParams, requestOptions: Option[RequestOptions] = None)(
      implicit ec: ExecutionContext
  ): Future[BatchResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `batch`.")
    requireNotNull(batchWriteParams, "Parameter `batchWriteParams` is required when calling `batch`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/${escape(indexName)}/batch")
      .withBody(batchWriteParams)
      .build()
    execute[BatchResponse](request, requestOptions)
  }

  /** Assign multiple user IDs to a cluster. **You can't _move_ users with this operation.**.
    *
    * Required API Key ACLs:
    *   - admin
    *
    * @param xAlgoliaUserID
    *   userID to assign.
    */
  def batchAssignUserIds(
      xAlgoliaUserID: String,
      batchAssignUserIdsParams: BatchAssignUserIdsParams,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[CreatedAtResponse] = Future {
    requireNotNull(xAlgoliaUserID, "Parameter `xAlgoliaUserID` is required when calling `batchAssignUserIds`.")
    requireNotNull(
      batchAssignUserIdsParams,
      "Parameter `batchAssignUserIdsParams` is required when calling `batchAssignUserIds`."
    )

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/clusters/mapping/batch")
      .withBody(batchAssignUserIdsParams)
      .withHeader("X-Algolia-User-ID", xAlgoliaUserID)
      .build()
    execute[CreatedAtResponse](request, requestOptions)
  }

  /** Add or remove a batch of dictionary entries.
    *
    * Required API Key ACLs:
    *   - editSettings
    *
    * @param dictionaryName
    *   Dictionary to search in.
    */
  def batchDictionaryEntries(
      dictionaryName: DictionaryType,
      batchDictionaryEntriesParams: BatchDictionaryEntriesParams,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[UpdatedAtResponse] = Future {
    requireNotNull(dictionaryName, "Parameter `dictionaryName` is required when calling `batchDictionaryEntries`.")
    requireNotNull(
      batchDictionaryEntriesParams,
      "Parameter `batchDictionaryEntriesParams` is required when calling `batchDictionaryEntries`."
    )

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/dictionaries/${escape(dictionaryName)}/batch")
      .withBody(batchDictionaryEntriesParams)
      .build()
    execute[UpdatedAtResponse](request, requestOptions)
  }

  /** Retrieve up to 1,000 records per call. Supports full-text search and filters. For better performance, it doesn't
    * support: - The `distinct` query parameter - Sorting by typos, proximity, words, or geographical distance.
    *
    * Required API Key ACLs:
    *   - browse
    *
    * @param indexName
    *   Index on which to perform the request.
    */
  def browse(
      indexName: String,
      browseParams: Option[BrowseParams] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[BrowseResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `browse`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/${escape(indexName)}/browse")
      .withBody(browseParams)
      .build()
    execute[BrowseResponse](request, requestOptions)
  }

  /** Delete the records but leave settings and index-specific API keys untouched.
    *
    * Required API Key ACLs:
    *   - deleteIndex
    *
    * @param indexName
    *   Index on which to perform the request.
    */
  def clearObjects(indexName: String, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[UpdatedAtResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `clearObjects`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/${escape(indexName)}/clear")
      .build()
    execute[UpdatedAtResponse](request, requestOptions)
  }

  /** Delete all rules in the index.
    *
    * Required API Key ACLs:
    *   - editSettings
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param forwardToReplicas
    *   Indicates whether changed index settings are forwarded to the replica indices.
    */
  def clearRules(
      indexName: String,
      forwardToReplicas: Option[Boolean] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[UpdatedAtResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `clearRules`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/${escape(indexName)}/rules/clear")
      .withQueryParameter("forwardToReplicas", forwardToReplicas)
      .build()
    execute[UpdatedAtResponse](request, requestOptions)
  }

  /** Delete all synonyms in the index.
    *
    * Required API Key ACLs:
    *   - editSettings
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param forwardToReplicas
    *   Indicates whether changed index settings are forwarded to the replica indices.
    */
  def clearSynonyms(
      indexName: String,
      forwardToReplicas: Option[Boolean] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[UpdatedAtResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `clearSynonyms`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/${escape(indexName)}/synonyms/clear")
      .withQueryParameter("forwardToReplicas", forwardToReplicas)
      .build()
    execute[UpdatedAtResponse](request, requestOptions)
  }

  /** This method allow you to send requests to the Algolia REST API.
    *
    * @param path
    *   Path of the endpoint, anything after \"/1\" must be specified.
    * @param parameters
    *   Query parameters to apply to the current query.
    */
  def customDelete[T: Manifest](
      path: String,
      parameters: Option[Map[String, Any]] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[T] = Future {
    requireNotNull(path, "Parameter `path` is required when calling `customDelete`.")

    val request = HttpRequest
      .builder()
      .withMethod("DELETE")
      .withPath(s"/1${path}")
      .withQueryParameters(parameters)
      .build()
    execute[T](request, requestOptions)
  }

  /** This method allow you to send requests to the Algolia REST API.
    *
    * @param path
    *   Path of the endpoint, anything after \"/1\" must be specified.
    * @param parameters
    *   Query parameters to apply to the current query.
    */
  def customGet[T: Manifest](
      path: String,
      parameters: Option[Map[String, Any]] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[T] = Future {
    requireNotNull(path, "Parameter `path` is required when calling `customGet`.")

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1${path}")
      .withQueryParameters(parameters)
      .build()
    execute[T](request, requestOptions)
  }

  /** This method allow you to send requests to the Algolia REST API.
    *
    * @param path
    *   Path of the endpoint, anything after \"/1\" must be specified.
    * @param parameters
    *   Query parameters to apply to the current query.
    * @param body
    *   Parameters to send with the custom request.
    */
  def customPost[T: Manifest](
      path: String,
      parameters: Option[Map[String, Any]] = None,
      body: Option[Any] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[T] = Future {
    requireNotNull(path, "Parameter `path` is required when calling `customPost`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1${path}")
      .withBody(body)
      .withQueryParameters(parameters)
      .build()
    execute[T](request, requestOptions)
  }

  /** This method allow you to send requests to the Algolia REST API.
    *
    * @param path
    *   Path of the endpoint, anything after \"/1\" must be specified.
    * @param parameters
    *   Query parameters to apply to the current query.
    * @param body
    *   Parameters to send with the custom request.
    */
  def customPut[T: Manifest](
      path: String,
      parameters: Option[Map[String, Any]] = None,
      body: Option[Any] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[T] = Future {
    requireNotNull(path, "Parameter `path` is required when calling `customPut`.")

    val request = HttpRequest
      .builder()
      .withMethod("PUT")
      .withPath(s"/1${path}")
      .withBody(body)
      .withQueryParameters(parameters)
      .build()
    execute[T](request, requestOptions)
  }

  /** Delete an existing API key. The request must be authenticated with the admin API key.
    *
    * Required API Key ACLs:
    *   - admin
    *
    * @param key
    *   API key.
    */
  def deleteApiKey(key: String, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[DeleteApiKeyResponse] = Future {
    requireNotNull(key, "Parameter `key` is required when calling `deleteApiKey`.")

    val request = HttpRequest
      .builder()
      .withMethod("DELETE")
      .withPath(s"/1/keys/${escape(key)}")
      .build()
    execute[DeleteApiKeyResponse](request, requestOptions)
  }

  /** This operation doesn't support all the query options, only its filters (numeric, facet, or tag) and geo queries.
    * It doesn't accept empty filters or queries.
    *
    * Required API Key ACLs:
    *   - deleteIndex
    *
    * @param indexName
    *   Index on which to perform the request.
    */
  def deleteBy(indexName: String, deleteByParams: DeleteByParams, requestOptions: Option[RequestOptions] = None)(
      implicit ec: ExecutionContext
  ): Future[DeletedAtResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `deleteBy`.")
    requireNotNull(deleteByParams, "Parameter `deleteByParams` is required when calling `deleteBy`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/${escape(indexName)}/deleteByQuery")
      .withBody(deleteByParams)
      .build()
    execute[DeletedAtResponse](request, requestOptions)
  }

  /** Delete an existing index.
    *
    * Required API Key ACLs:
    *   - deleteIndex
    *
    * @param indexName
    *   Index on which to perform the request.
    */
  def deleteIndex(indexName: String, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[DeletedAtResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `deleteIndex`.")

    val request = HttpRequest
      .builder()
      .withMethod("DELETE")
      .withPath(s"/1/indexes/${escape(indexName)}")
      .build()
    execute[DeletedAtResponse](request, requestOptions)
  }

  /** To delete a set of records matching a query, use the [`deleteByQuery` operation](#tag/Records/operation/deleteBy)
    * instead.
    *
    * Required API Key ACLs:
    *   - deleteObject
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param objectID
    *   Unique record (object) identifier.
    */
  def deleteObject(indexName: String, objectID: String, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[DeletedAtResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `deleteObject`.")
    requireNotNull(objectID, "Parameter `objectID` is required when calling `deleteObject`.")

    val request = HttpRequest
      .builder()
      .withMethod("DELETE")
      .withPath(s"/1/indexes/${escape(indexName)}/${escape(objectID)}")
      .build()
    execute[DeletedAtResponse](request, requestOptions)
  }

  /** Delete a rule by its `objectID`. To find the `objectID` for rules, use the [`search`
    * operation](#tag/Rules/operation/searchRules).
    *
    * Required API Key ACLs:
    *   - editSettings
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param objectID
    *   Unique identifier of a rule object.
    * @param forwardToReplicas
    *   Indicates whether changed index settings are forwarded to the replica indices.
    */
  def deleteRule(
      indexName: String,
      objectID: String,
      forwardToReplicas: Option[Boolean] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[UpdatedAtResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `deleteRule`.")
    requireNotNull(objectID, "Parameter `objectID` is required when calling `deleteRule`.")

    val request = HttpRequest
      .builder()
      .withMethod("DELETE")
      .withPath(s"/1/indexes/${escape(indexName)}/rules/${escape(objectID)}")
      .withQueryParameter("forwardToReplicas", forwardToReplicas)
      .build()
    execute[UpdatedAtResponse](request, requestOptions)
  }

  /** Remove a source from the list of allowed sources.
    *
    * Required API Key ACLs:
    *   - admin
    *
    * @param source
    *   IP address range of the source.
    */
  def deleteSource(source: String, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[DeleteSourceResponse] = Future {
    requireNotNull(source, "Parameter `source` is required when calling `deleteSource`.")

    val request = HttpRequest
      .builder()
      .withMethod("DELETE")
      .withPath(s"/1/security/sources/${escape(source)}")
      .build()
    execute[DeleteSourceResponse](request, requestOptions)
  }

  /** Delete a synonym by its `objectID`. To find the object IDs of your synonyms, use the [`search`
    * operation](#tag/Synonyms/operation/searchSynonyms).
    *
    * Required API Key ACLs:
    *   - editSettings
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param objectID
    *   Unique identifier of a synonym object.
    * @param forwardToReplicas
    *   Indicates whether changed index settings are forwarded to the replica indices.
    */
  def deleteSynonym(
      indexName: String,
      objectID: String,
      forwardToReplicas: Option[Boolean] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[DeletedAtResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `deleteSynonym`.")
    requireNotNull(objectID, "Parameter `objectID` is required when calling `deleteSynonym`.")

    val request = HttpRequest
      .builder()
      .withMethod("DELETE")
      .withPath(s"/1/indexes/${escape(indexName)}/synonyms/${escape(objectID)}")
      .withQueryParameter("forwardToReplicas", forwardToReplicas)
      .build()
    execute[DeletedAtResponse](request, requestOptions)
  }

  /** Get the permissions and restrictions of a specific API key. When authenticating with the admin API key, you can
    * request information for any of your application's keys. When authenticating with other API keys, you can only
    * retrieve information for that key.
    *
    * @param key
    *   API key.
    */
  def getApiKey(key: String, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[GetApiKeyResponse] = Future {
    requireNotNull(key, "Parameter `key` is required when calling `getApiKey`.")

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1/keys/${escape(key)}")
      .build()
    execute[GetApiKeyResponse](request, requestOptions)
  }

  /** Lists Algolia's [supported
    * languages](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/)
    * and any customizations applied to each language's [stop
    * word](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/),
    * [plural](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/),
    * and [segmentation
    * (compound)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/)
    * features.
    *
    * Required API Key ACLs:
    *   - settings
    */
  def getDictionaryLanguages(
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[Map[String, Languages]] = Future {

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1/dictionaries/*/languages")
      .build()
    execute[Map[String, Languages]](request, requestOptions)
  }

  /** Get the languages for which [stop words are turned off](#tag/Dictionaries/operation/setDictionarySettings).
    *
    * Required API Key ACLs:
    *   - settings
    */
  def getDictionarySettings(
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[GetDictionarySettingsResponse] = Future {

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1/dictionaries/*/settings")
      .build()
    execute[GetDictionarySettingsResponse](request, requestOptions)
  }

  /** The request must be authenticated by an API key with the [`logs`
    * ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl). Logs are held for the last
    * seven days. There's also a logging limit of 1,000 API calls per server. This request counts towards your
    * [operations
    * quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-)
    * but doesn't appear in the logs itself. > **Note**: To fetch the logs for a Distributed Search Network (DSN)
    * cluster, target the [DSN's
    * endpoint](https://www.algolia.com/doc/guides/scaling/distributed-search-network-dsn/#accessing-dsn-servers).
    *
    * Required API Key ACLs:
    *   - logs
    *
    * @param offset
    *   First log entry to retrieve. Sorted by decreasing date with 0 being the most recent.
    * @param length
    *   Maximum number of entries to retrieve.
    * @param indexName
    *   Index for which log entries should be retrieved. When omitted, log entries are retrieved for all indices.
    * @param `type`
    *   Type of log entries to retrieve. When omitted, all log entries are retrieved.
    */
  def getLogs(
      offset: Option[Int] = None,
      length: Option[Int] = None,
      indexName: Option[String] = None,
      `type`: Option[LogType] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[GetLogsResponse] = Future {

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1/logs")
      .withQueryParameter("offset", offset)
      .withQueryParameter("length", length)
      .withQueryParameter("indexName", indexName)
      .withQueryParameter("type", `type`)
      .build()
    execute[GetLogsResponse](request, requestOptions)
  }

  /** To get more than one record, use the [`objects` operation](#tag/Records/operation/getObjects).
    *
    * Required API Key ACLs:
    *   - search
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param objectID
    *   Unique record (object) identifier.
    * @param attributesToRetrieve
    *   Attributes to include with the records in the response. This is useful to reduce the size of the API response.
    *   By default, all retrievable attributes are returned. `objectID` is always retrieved, even when not specified.
    *   [`unretrievableAttributes`](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/)
    *   won't be retrieved unless the request is authenticated with the admin API key.
    */
  def getObject(
      indexName: String,
      objectID: String,
      attributesToRetrieve: Option[Seq[String]] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[Map[String, String]] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `getObject`.")
    requireNotNull(objectID, "Parameter `objectID` is required when calling `getObject`.")

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1/indexes/${escape(indexName)}/${escape(objectID)}")
      .withQueryParameter("attributesToRetrieve", attributesToRetrieve)
      .build()
    execute[Map[String, String]](request, requestOptions)
  }

  /** Retrieve one or more records, potentially from different indices, in a single API operation. Results will be
    * received in the same order as the requests.
    *
    * Required API Key ACLs:
    *   - search
    *
    * @param getObjectsParams
    *   Request object.
    */
  def getObjects(getObjectsParams: GetObjectsParams, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[GetObjectsResponse] = Future {
    requireNotNull(getObjectsParams, "Parameter `getObjectsParams` is required when calling `getObjects`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/*/objects")
      .withBody(getObjectsParams)
      .withRead(true)
      .build()
    execute[GetObjectsResponse](request, requestOptions)
  }

  /** Get a rule by its `objectID`. To find the `objectID` for rules, use the [`search`
    * operation](#tag/Rules/operation/searchRules).
    *
    * Required API Key ACLs:
    *   - settings
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param objectID
    *   Unique identifier of a rule object.
    */
  def getRule(indexName: String, objectID: String, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[Rule] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `getRule`.")
    requireNotNull(objectID, "Parameter `objectID` is required when calling `getRule`.")

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1/indexes/${escape(indexName)}/rules/${escape(objectID)}")
      .build()
    execute[Rule](request, requestOptions)
  }

  /** Return an object containing an index's [configuration
    * settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/).
    *
    * Required API Key ACLs:
    *   - search
    *
    * @param indexName
    *   Index on which to perform the request.
    */
  def getSettings(indexName: String, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[IndexSettings] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `getSettings`.")

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1/indexes/${escape(indexName)}/settings")
      .build()
    execute[IndexSettings](request, requestOptions)
  }

  /** Get all allowed sources (IP addresses).
    *
    * Required API Key ACLs:
    *   - admin
    */
  def getSources(requestOptions: Option[RequestOptions] = None)(implicit ec: ExecutionContext): Future[Seq[Source]] =
    Future {

      val request = HttpRequest
        .builder()
        .withMethod("GET")
        .withPath(s"/1/security/sources")
        .build()
      execute[Seq[Source]](request, requestOptions)
    }

  /** Get a syonym by its `objectID`. To find the object IDs for your synonyms, use the [`search`
    * operation](#tag/Synonyms/operation/searchSynonyms).
    *
    * Required API Key ACLs:
    *   - settings
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param objectID
    *   Unique identifier of a synonym object.
    */
  def getSynonym(indexName: String, objectID: String, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[SynonymHit] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `getSynonym`.")
    requireNotNull(objectID, "Parameter `objectID` is required when calling `getSynonym`.")

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1/indexes/${escape(indexName)}/synonyms/${escape(objectID)}")
      .build()
    execute[SynonymHit](request, requestOptions)
  }

  /** Some operations, such as copying an index, will respond with a `taskID` value. Use this value here to check the
    * status of that task.
    *
    * Required API Key ACLs:
    *   - addObject
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param taskID
    *   Unique task identifier.
    */
  def getTask(indexName: String, taskID: Long, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[GetTaskResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `getTask`.")
    requireNotNull(taskID, "Parameter `taskID` is required when calling `getTask`.")

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1/indexes/${escape(indexName)}/task/${escape(taskID)}")
      .build()
    execute[GetTaskResponse](request, requestOptions)
  }

  /** Get the IDs of the 10 users with the highest number of records per cluster. Since it can take up to a few seconds
    * to get the data from the different clusters, the response isn't real-time.
    *
    * Required API Key ACLs:
    *   - admin
    */
  def getTopUserIds(
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[GetTopUserIdsResponse] = Future {

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1/clusters/mapping/top")
      .build()
    execute[GetTopUserIdsResponse](request, requestOptions)
  }

  /** Returns the userID data stored in the mapping. Since it can take up to a few seconds to get the data from the
    * different clusters, the response isn't real-time.
    *
    * Required API Key ACLs:
    *   - admin
    *
    * @param userID
    *   userID to assign.
    */
  def getUserId(userID: String, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[UserId] = Future {
    requireNotNull(userID, "Parameter `userID` is required when calling `getUserId`.")

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1/clusters/mapping/${escape(userID)}")
      .build()
    execute[UserId](request, requestOptions)
  }

  /** To determine when the time-consuming process of creating a large batch of users or migrating users from one
    * cluster to another is complete, this operation retrieves the status of the process.
    *
    * Required API Key ACLs:
    *   - admin
    *
    * @param getClusters
    *   Indicates whether to include the cluster's pending mapping state in the response.
    */
  def hasPendingMappings(getClusters: Option[Boolean] = None, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[HasPendingMappingsResponse] = Future {

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1/clusters/mapping/pending")
      .withQueryParameter("getClusters", getClusters)
      .build()
    execute[HasPendingMappingsResponse](request, requestOptions)
  }

  /** List all API keys associated with your Algolia application, including their permissions and restrictions.
    *
    * Required API Key ACLs:
    *   - admin
    */
  def listApiKeys(
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[ListApiKeysResponse] = Future {

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1/keys")
      .build()
    execute[ListApiKeysResponse](request, requestOptions)
  }

  /** List the available clusters in a multi-cluster setup.
    *
    * Required API Key ACLs:
    *   - admin
    */
  def listClusters(
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[ListClustersResponse] = Future {

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1/clusters")
      .build()
    execute[ListClustersResponse](request, requestOptions)
  }

  /** List indices in an Algolia application.
    *
    * Required API Key ACLs:
    *   - listIndexes
    *
    * @param page
    *   Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the
    *   number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not
    *   paginated.
    * @param hitsPerPage
    *   Maximum number of hits per page.
    */
  def listIndices(
      page: Option[Int] = None,
      hitsPerPage: Option[Int] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[ListIndicesResponse] = Future {

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1/indexes")
      .withQueryParameter("page", page)
      .withQueryParameter("hitsPerPage", hitsPerPage)
      .build()
    execute[ListIndicesResponse](request, requestOptions)
  }

  /** List the userIDs assigned to a multi-cluster application. Since it can take up to a few seconds to get the data
    * from the different clusters, the response isn't real-time.
    *
    * Required API Key ACLs:
    *   - admin
    *
    * @param page
    *   Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the
    *   number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not
    *   paginated.
    * @param hitsPerPage
    *   Maximum number of hits per page.
    */
  def listUserIds(
      page: Option[Int] = None,
      hitsPerPage: Option[Int] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[ListUserIdsResponse] = Future {

    val request = HttpRequest
      .builder()
      .withMethod("GET")
      .withPath(s"/1/clusters/mapping")
      .withQueryParameter("page", page)
      .withQueryParameter("hitsPerPage", hitsPerPage)
      .build()
    execute[ListUserIdsResponse](request, requestOptions)
  }

  /** To reduce the time spent on network round trips, you can perform several write actions in a single request. It's a
    * multi-index version of the [`batch` operation](#tag/Records/operation/batch). Actions are applied in the order
    * they are specified. The supported actions are equivalent to the individual operations of the same name.
    */
  def multipleBatch(batchParams: BatchParams, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[MultipleBatchResponse] = Future {
    requireNotNull(batchParams, "Parameter `batchParams` is required when calling `multipleBatch`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/*/batch")
      .withBody(batchParams)
      .build()
    execute[MultipleBatchResponse](request, requestOptions)
  }

  /** This `operation`, _copy_ or _move_, will copy or move a source index's (`IndexName`) records, settings, synonyms,
    * and rules to a `destination` index. If the destination index exists, it will be replaced, except for
    * index-specific API keys and analytics data. If the destination index doesn't exist, it will be created. The choice
    * between moving or copying an index depends on your needs. Choose: - **Move** to rename an index. - **Copy** to
    * create a new index with the same records and configuration as an existing one. > **Note**: When considering
    * copying or moving, be aware of the [rate
    * limitations](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits)
    * on these processes and the [impact on your analytics
    * data](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/concepts/indices-analytics/).
    *
    * Required API Key ACLs:
    *   - addObject
    *
    * @param indexName
    *   Index on which to perform the request.
    */
  def operationIndex(
      indexName: String,
      operationIndexParams: OperationIndexParams,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[UpdatedAtResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `operationIndex`.")
    requireNotNull(operationIndexParams, "Parameter `operationIndexParams` is required when calling `operationIndex`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/${escape(indexName)}/operation")
      .withBody(operationIndexParams)
      .build()
    execute[UpdatedAtResponse](request, requestOptions)
  }

  /** Add new attributes or update current ones in an existing record. You can use any first-level attribute but not
    * nested attributes. If you specify a [nested
    * attribute](https://www.algolia.com/doc/guides/sending-and-managing-data/prepare-your-data/how-to/creating-and-using-nested-attributes/),
    * the engine treats it as a replacement for its first-level ancestor.
    *
    * Required API Key ACLs:
    *   - addObject
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param objectID
    *   Unique record (object) identifier.
    * @param attributesToUpdate
    *   Object with attributes to update.
    * @param createIfNotExists
    *   Indicates whether to create a new record if it doesn't exist yet.
    */
  def partialUpdateObject(
      indexName: String,
      objectID: String,
      attributesToUpdate: Map[String, AttributeToUpdate],
      createIfNotExists: Option[Boolean] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[UpdatedAtWithObjectIdResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `partialUpdateObject`.")
    requireNotNull(objectID, "Parameter `objectID` is required when calling `partialUpdateObject`.")
    requireNotNull(attributesToUpdate, "Parameter `attributesToUpdate` is required when calling `partialUpdateObject`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/${escape(indexName)}/${escape(objectID)}/partial")
      .withBody(attributesToUpdate)
      .withQueryParameter("createIfNotExists", createIfNotExists)
      .build()
    execute[UpdatedAtWithObjectIdResponse](request, requestOptions)
  }

  /** Remove a userID and its associated data from the multi-clusters.
    *
    * Required API Key ACLs:
    *   - admin
    *
    * @param userID
    *   userID to assign.
    */
  def removeUserId(userID: String, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[RemoveUserIdResponse] = Future {
    requireNotNull(userID, "Parameter `userID` is required when calling `removeUserId`.")

    val request = HttpRequest
      .builder()
      .withMethod("DELETE")
      .withPath(s"/1/clusters/mapping/${escape(userID)}")
      .build()
    execute[RemoveUserIdResponse](request, requestOptions)
  }

  /** Replace all allowed sources.
    *
    * Required API Key ACLs:
    *   - admin
    *
    * @param source
    *   Allowed sources.
    */
  def replaceSources(source: Seq[Source], requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[ReplaceSourceResponse] = Future {
    requireNotNull(source, "Parameter `source` is required when calling `replaceSources`.")

    val request = HttpRequest
      .builder()
      .withMethod("PUT")
      .withPath(s"/1/security/sources")
      .withBody(source)
      .build()
    execute[ReplaceSourceResponse](request, requestOptions)
  }

  /** Restore a deleted API key, along with its associated permissions. The request must be authenticated with the admin
    * API key.
    *
    * Required API Key ACLs:
    *   - admin
    *
    * @param key
    *   API key.
    */
  def restoreApiKey(key: String, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[AddApiKeyResponse] = Future {
    requireNotNull(key, "Parameter `key` is required when calling `restoreApiKey`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/keys/${escape(key)}/restore")
      .build()
    execute[AddApiKeyResponse](request, requestOptions)
  }

  /** Add a record (object) to an index or replace it. If the record doesn't contain an `objectID`, Algolia
    * automatically adds it. If you use an existing `objectID`, the existing record is replaced with the new one. To add
    * multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).
    *
    * Required API Key ACLs:
    *   - addObject
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param body
    *   The Algolia record.
    */
  def saveObject(indexName: String, body: Any, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[SaveObjectResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `saveObject`.")
    requireNotNull(body, "Parameter `body` is required when calling `saveObject`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/${escape(indexName)}")
      .withBody(body)
      .build()
    execute[SaveObjectResponse](request, requestOptions)
  }

  /** To create or update more than one rule, use the [`batch` operation](#tag/Rules/operation/saveRules).
    *
    * Required API Key ACLs:
    *   - editSettings
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param objectID
    *   Unique identifier of a rule object.
    * @param forwardToReplicas
    *   Indicates whether changed index settings are forwarded to the replica indices.
    */
  def saveRule(
      indexName: String,
      objectID: String,
      rule: Rule,
      forwardToReplicas: Option[Boolean] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[UpdatedRuleResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `saveRule`.")
    requireNotNull(objectID, "Parameter `objectID` is required when calling `saveRule`.")
    requireNotNull(rule, "Parameter `rule` is required when calling `saveRule`.")

    val request = HttpRequest
      .builder()
      .withMethod("PUT")
      .withPath(s"/1/indexes/${escape(indexName)}/rules/${escape(objectID)}")
      .withBody(rule)
      .withQueryParameter("forwardToReplicas", forwardToReplicas)
      .build()
    execute[UpdatedRuleResponse](request, requestOptions)
  }

  /** Create or update multiple rules.
    *
    * Required API Key ACLs:
    *   - editSettings
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param forwardToReplicas
    *   Indicates whether changed index settings are forwarded to the replica indices.
    * @param clearExistingRules
    *   Indicates whether existing rules should be deleted before adding this batch.
    */
  def saveRules(
      indexName: String,
      rules: Seq[Rule],
      forwardToReplicas: Option[Boolean] = None,
      clearExistingRules: Option[Boolean] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[UpdatedAtResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `saveRules`.")
    requireNotNull(rules, "Parameter `rules` is required when calling `saveRules`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/${escape(indexName)}/rules/batch")
      .withBody(rules)
      .withQueryParameter("forwardToReplicas", forwardToReplicas)
      .withQueryParameter("clearExistingRules", clearExistingRules)
      .build()
    execute[UpdatedAtResponse](request, requestOptions)
  }

  /** Add a
    * [synonym](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms)
    * to an index or replace it. If the synonym `objectID` doesn't exist, Algolia adds a new one. If you use an existing
    * synonym `objectID`, the existing synonym is replaced with the new one. To add multiple synonyms in a single API
    * request, use the [`batch` operation](#tag/Synonyms/operation/saveSynonyms).
    *
    * Required API Key ACLs:
    *   - editSettings
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param objectID
    *   Unique identifier of a synonym object.
    * @param forwardToReplicas
    *   Indicates whether changed index settings are forwarded to the replica indices.
    */
  def saveSynonym(
      indexName: String,
      objectID: String,
      synonymHit: SynonymHit,
      forwardToReplicas: Option[Boolean] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[SaveSynonymResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `saveSynonym`.")
    requireNotNull(objectID, "Parameter `objectID` is required when calling `saveSynonym`.")
    requireNotNull(synonymHit, "Parameter `synonymHit` is required when calling `saveSynonym`.")

    val request = HttpRequest
      .builder()
      .withMethod("PUT")
      .withPath(s"/1/indexes/${escape(indexName)}/synonyms/${escape(objectID)}")
      .withBody(synonymHit)
      .withQueryParameter("forwardToReplicas", forwardToReplicas)
      .build()
    execute[SaveSynonymResponse](request, requestOptions)
  }

  /** Create or update multiple synonyms.
    *
    * Required API Key ACLs:
    *   - editSettings
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param forwardToReplicas
    *   Indicates whether changed index settings are forwarded to the replica indices.
    * @param replaceExistingSynonyms
    *   Indicates whether to replace all synonyms in the index with the ones sent with this request.
    */
  def saveSynonyms(
      indexName: String,
      synonymHit: Seq[SynonymHit],
      forwardToReplicas: Option[Boolean] = None,
      replaceExistingSynonyms: Option[Boolean] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[UpdatedAtResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `saveSynonyms`.")
    requireNotNull(synonymHit, "Parameter `synonymHit` is required when calling `saveSynonyms`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/${escape(indexName)}/synonyms/batch")
      .withBody(synonymHit)
      .withQueryParameter("forwardToReplicas", forwardToReplicas)
      .withQueryParameter("replaceExistingSynonyms", replaceExistingSynonyms)
      .build()
    execute[UpdatedAtResponse](request, requestOptions)
  }

  /** Send multiple search queries to one or more indices.
    *
    * Required API Key ACLs:
    *   - search
    *
    * @param searchMethodParams
    *   Query requests and strategies. Results will be received in the same order as the queries.
    */
  def search(searchMethodParams: SearchMethodParams, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[SearchResponses] = Future {
    requireNotNull(searchMethodParams, "Parameter `searchMethodParams` is required when calling `search`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/*/queries")
      .withBody(searchMethodParams)
      .withRead(true)
      .build()
    execute[SearchResponses](request, requestOptions)
  }

  /** Search for standard and
    * [custom](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/)
    * entries in the [stop
    * words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/),
    * [plurals](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/),
    * or [segmentation
    * (compounds)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/)
    * dictionaries.
    *
    * Required API Key ACLs:
    *   - settings
    *
    * @param dictionaryName
    *   Dictionary to search in.
    */
  def searchDictionaryEntries(
      dictionaryName: DictionaryType,
      searchDictionaryEntriesParams: SearchDictionaryEntriesParams,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[UpdatedAtResponse] = Future {
    requireNotNull(dictionaryName, "Parameter `dictionaryName` is required when calling `searchDictionaryEntries`.")
    requireNotNull(
      searchDictionaryEntriesParams,
      "Parameter `searchDictionaryEntriesParams` is required when calling `searchDictionaryEntries`."
    )

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/dictionaries/${escape(dictionaryName)}/search")
      .withBody(searchDictionaryEntriesParams)
      .withRead(true)
      .build()
    execute[UpdatedAtResponse](request, requestOptions)
  }

  /** [Search for a facet's
    * values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values),
    * optionally restricting the returned values to those contained in records matching other search criteria. >
    * **Note**: Pagination isn't supported (`page` and `hitsPerPage` are ignored). By default, the engine returns a
    * maximum of 10 values but you can adjust this with `maxFacetHits`.
    *
    * Required API Key ACLs:
    *   - search
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param facetName
    *   Facet name.
    */
  def searchForFacetValues(
      indexName: String,
      facetName: String,
      searchForFacetValuesRequest: Option[SearchForFacetValuesRequest] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[SearchForFacetValuesResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `searchForFacetValues`.")
    requireNotNull(facetName, "Parameter `facetName` is required when calling `searchForFacetValues`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/${escape(indexName)}/facets/${escape(facetName)}/query")
      .withBody(searchForFacetValuesRequest)
      .withRead(true)
      .build()
    execute[SearchForFacetValuesResponse](request, requestOptions)
  }

  /** Search for rules in your index. You can control the search with parameters. To list all rules, send an empty
    * request body.
    *
    * Required API Key ACLs:
    *   - settings
    *
    * @param indexName
    *   Index on which to perform the request.
    */
  def searchRules(
      indexName: String,
      searchRulesParams: Option[SearchRulesParams] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[SearchRulesResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `searchRules`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/${escape(indexName)}/rules/search")
      .withBody(searchRulesParams)
      .withRead(true)
      .build()
    execute[SearchRulesResponse](request, requestOptions)
  }

  /** Return records that match the query.
    *
    * Required API Key ACLs:
    *   - search
    *
    * @param indexName
    *   Index on which to perform the request.
    */
  def searchSingleIndex(
      indexName: String,
      searchParams: Option[SearchParams] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[SearchResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `searchSingleIndex`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/${escape(indexName)}/query")
      .withBody(searchParams)
      .withRead(true)
      .build()
    execute[SearchResponse](request, requestOptions)
  }

  /** Search for synonyms in your index. You can control and filter the search with parameters. To get all synonyms,
    * send an empty request body.
    *
    * Required API Key ACLs:
    *   - settings
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param searchSynonymsParams
    *   Body of the `searchSynonyms` operation.
    */
  def searchSynonyms(
      indexName: String,
      searchSynonymsParams: Option[SearchSynonymsParams] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[SearchSynonymsResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `searchSynonyms`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/indexes/${escape(indexName)}/synonyms/search")
      .withBody(searchSynonymsParams)
      .withRead(true)
      .build()
    execute[SearchSynonymsResponse](request, requestOptions)
  }

  /** Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.
    * To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every
    * 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search
    * will show an old value until the next time the mapping is rebuilt (every 12 hours).
    *
    * Required API Key ACLs:
    *   - admin
    */
  def searchUserIds(searchUserIdsParams: SearchUserIdsParams, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[SearchUserIdsResponse] = Future {
    requireNotNull(searchUserIdsParams, "Parameter `searchUserIdsParams` is required when calling `searchUserIds`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/clusters/mapping/search")
      .withBody(searchUserIdsParams)
      .withRead(true)
      .build()
    execute[SearchUserIdsResponse](request, requestOptions)
  }

  /** Set stop word settings for a specific language.
    *
    * Required API Key ACLs:
    *   - editSettings
    */
  def setDictionarySettings(
      dictionarySettingsParams: DictionarySettingsParams,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[UpdatedAtResponse] = Future {
    requireNotNull(
      dictionarySettingsParams,
      "Parameter `dictionarySettingsParams` is required when calling `setDictionarySettings`."
    )

    val request = HttpRequest
      .builder()
      .withMethod("PUT")
      .withPath(s"/1/dictionaries/*/settings")
      .withBody(dictionarySettingsParams)
      .build()
    execute[UpdatedAtResponse](request, requestOptions)
  }

  /** Update the specified [index settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/).
    * Specifying null for a setting resets it to its default value.
    *
    * Required API Key ACLs:
    *   - editSettings
    *
    * @param indexName
    *   Index on which to perform the request.
    * @param forwardToReplicas
    *   Indicates whether changed index settings are forwarded to the replica indices.
    */
  def setSettings(
      indexName: String,
      indexSettings: IndexSettings,
      forwardToReplicas: Option[Boolean] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[UpdatedAtResponse] = Future {
    requireNotNull(indexName, "Parameter `indexName` is required when calling `setSettings`.")
    requireNotNull(indexSettings, "Parameter `indexSettings` is required when calling `setSettings`.")

    val request = HttpRequest
      .builder()
      .withMethod("PUT")
      .withPath(s"/1/indexes/${escape(indexName)}/settings")
      .withBody(indexSettings)
      .withQueryParameter("forwardToReplicas", forwardToReplicas)
      .build()
    execute[UpdatedAtResponse](request, requestOptions)
  }

  /** Replace the permissions of an existing API key. Any unspecified parameter resets that permission to its default
    * value. The request must be authenticated with the admin API key.
    *
    * Required API Key ACLs:
    *   - admin
    *
    * @param key
    *   API key.
    */
  def updateApiKey(key: String, apiKey: ApiKey, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[UpdateApiKeyResponse] = Future {
    requireNotNull(key, "Parameter `key` is required when calling `updateApiKey`.")
    requireNotNull(apiKey, "Parameter `apiKey` is required when calling `updateApiKey`.")

    val request = HttpRequest
      .builder()
      .withMethod("PUT")
      .withPath(s"/1/keys/${escape(key)}")
      .withBody(apiKey)
      .build()
    execute[UpdateApiKeyResponse](request, requestOptions)
  }

}
