/** Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on
  * https://github.com/algolia/api-clients-automation. DO NOT EDIT.
  */
package algoliasearch.api

import algoliasearch.composition.ErrorBase
import algoliasearch.composition.RequestBody
import algoliasearch.composition.SearchForFacetValuesRequest
import algoliasearch.composition.SearchForFacetValuesResponse
import algoliasearch.composition.SearchResponse
import algoliasearch.composition._
import algoliasearch.ApiClient
import algoliasearch.api.CompositionClient.hosts
import algoliasearch.api.CompositionClient.readTimeout
import algoliasearch.api.CompositionClient.writeTimeout
import algoliasearch.api.CompositionClient.connectTimeout
import algoliasearch.config._
import algoliasearch.internal.util._

import java.util.concurrent.TimeUnit
import scala.concurrent.duration.Duration
import scala.concurrent.{ExecutionContext, Future}
import scala.util.Random

object CompositionClient {

  /** Creates a new CompositionClient instance using default hosts.
    *
    * @param appId
    *   application ID
    * @param apiKey
    *   api key
    *
    * @param clientOptions
    *   client options
    */
  def apply(
      appId: String,
      apiKey: String,
      clientOptions: ClientOptions = ClientOptions()
  ) = new CompositionClient(
    appId = appId,
    apiKey = apiKey,
    clientOptions = clientOptions
  )

  private def readTimeout(): Duration = {
    Duration(5000, TimeUnit.MILLISECONDS)
  }

  private def connectTimeout(): Duration = {
    Duration(2000, TimeUnit.MILLISECONDS)
  }

  private def writeTimeout(): Duration = {
    Duration(30000, TimeUnit.MILLISECONDS)
  }

  private def hosts(appId: String): Seq[Host] = {
    val commonHosts = Random.shuffle(
      List(
        Host(appId + "-1.algolianet.com", Set(CallType.Read, CallType.Write)),
        Host(appId + "-2.algolianet.com", Set(CallType.Read, CallType.Write)),
        Host(appId + "-3.algolianet.com", Set(CallType.Read, CallType.Write))
      )
    )
    List(
      Host(appId + "-dsn.algolia.net", Set(CallType.Read)),
      Host(appId + ".algolia.net", Set(CallType.Write))
    ) ++ commonHosts
  }
}

class CompositionClient(
    appId: String,
    apiKey: String,
    clientOptions: ClientOptions = ClientOptions()
) extends ApiClient(
      appId = appId,
      apiKey = apiKey,
      clientName = "Composition",
      defaultHosts = hosts(appId),
      defaultReadTimeout = readTimeout(),
      defaultWriteTimeout = writeTimeout(),
      defaultConnectTimeout = connectTimeout(),
      formats = JsonSupport.format,
      options = clientOptions
    ) {

  /** Runs a query on a single composition and returns matching results.
    *
    * Required API Key ACLs:
    *   - search
    *
    * @param compositionID
    *   Unique Composition ObjectID.
    */
  def search(compositionID: String, requestBody: RequestBody, requestOptions: Option[RequestOptions] = None)(implicit
      ec: ExecutionContext
  ): Future[SearchResponse] = Future {
    requireNotNull(compositionID, "Parameter `compositionID` is required when calling `search`.")
    requireNotNull(requestBody, "Parameter `requestBody` is required when calling `search`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/compositions/${escape(compositionID)}/run")
      .withBody(requestBody)
      .withRead(true)
      .build()
    execute[SearchResponse](request, requestOptions)
  }

  /** Searches for values of a specified facet attribute on the composition's main source's index. - By default, facet
    * values are sorted by decreasing count. You can adjust this with the `sortFacetValueBy` parameter. - Searching for
    * facet values doesn't work if you have **more than 65 searchable facets and searchable attributes combined**.
    *
    * Required API Key ACLs:
    *   - search
    *
    * @param compositionID
    *   Unique Composition ObjectID.
    * @param facetName
    *   Facet attribute in which to search for values. This attribute must be included in the `attributesForFaceting`
    *   index setting with the `searchable()` modifier.
    */
  def searchForFacetValues(
      compositionID: String,
      facetName: String,
      searchForFacetValuesRequest: Option[SearchForFacetValuesRequest] = None,
      requestOptions: Option[RequestOptions] = None
  )(implicit ec: ExecutionContext): Future[SearchForFacetValuesResponse] = Future {
    requireNotNull(compositionID, "Parameter `compositionID` is required when calling `searchForFacetValues`.")
    requireNotNull(facetName, "Parameter `facetName` is required when calling `searchForFacetValues`.")

    val request = HttpRequest
      .builder()
      .withMethod("POST")
      .withPath(s"/1/compositions/${escape(compositionID)}/facets/${escape(facetName)}/query")
      .withBody(searchForFacetValuesRequest)
      .withRead(true)
      .build()
    execute[SearchForFacetValuesResponse](request, requestOptions)
  }

}
