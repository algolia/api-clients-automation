// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on
// https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import Foundation
#if canImport(Core)
    import Core
#endif

open class CompositionClient {
    private var configuration: CompositionClientConfiguration
    private var transporter: Transporter

    var appID: String {
        self.configuration.appID
    }

    public init(configuration: CompositionClientConfiguration, transporter: Transporter) {
        self.configuration = configuration
        self.transporter = transporter
    }

    public convenience init(configuration: CompositionClientConfiguration) {
        self.init(configuration: configuration, transporter: Transporter(configuration: configuration))
    }

    public convenience init(appID: String, apiKey: String) throws {
        try self.init(configuration: CompositionClientConfiguration(appID: appID, apiKey: apiKey))
    }

    open func setClientApiKey(apiKey: String) {
        self.configuration.apiKey = apiKey
        self.transporter.setClientApiKey(apiKey: apiKey)
    }

    /// - parameter compositionID: (path) Unique Composition ObjectID.
    /// - parameter requestBody: (body)
    /// - returns: CompositionSearchResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func search<T: Codable>(
        compositionID: String,
        requestBody: CompositionRequestBody,
        requestOptions: RequestOptions? = nil
    ) async throws -> CompositionSearchResponse<T> {
        let response: Response<CompositionSearchResponse<T>> = try await searchWithHTTPInfo(
            compositionID: compositionID,
            requestBody: requestBody,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Runs a query on a single composition and returns matching results.
    // Required API Key ACLs:
    //  - search
    //
    // - parameter compositionID: (path) Unique Composition ObjectID.
    //
    // - parameter requestBody: (body)
    // - returns: RequestBuilder<CompositionSearchResponse>

    open func searchWithHTTPInfo<T: Codable>(
        compositionID: String,
        requestBody: CompositionRequestBody,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<CompositionSearchResponse<T>> {
        guard !compositionID.isEmpty else {
            throw AlgoliaError.invalidArgument("compositionID", "search")
        }

        var resourcePath = "/1/compositions/{compositionID}/run"
        let compositionIDPreEscape = "\(APIHelper.mapValueToPathItem(compositionID))"
        let compositionIDPostEscape = compositionIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{compositionID}",
            with: compositionIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = requestBody
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter compositionID: (path) Unique Composition ObjectID.
    /// - parameter facetName: (path) Facet attribute in which to search for values.  This attribute must be included in
    /// the `attributesForFaceting` index setting with the `searchable()` modifier.
    /// - parameter searchForFacetValuesRequest: (body)  (optional)
    /// - returns: CompositionSearchForFacetValuesResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchForFacetValues(
        compositionID: String,
        facetName: String,
        searchForFacetValuesRequest: CompositionSearchForFacetValuesRequest? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> CompositionSearchForFacetValuesResponse {
        let response: Response<CompositionSearchForFacetValuesResponse> = try await searchForFacetValuesWithHTTPInfo(
            compositionID: compositionID,
            facetName: facetName,
            searchForFacetValuesRequest: searchForFacetValuesRequest,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Searches for values of a specified facet attribute on the composition's main source's index.  - By default, facet
    // values are sorted by decreasing count.   You can adjust this with the `sortFacetValueBy` parameter. - Searching
    // for facet values doesn't work if you have **more than 65 searchable facets and searchable attributes combined**.
    // Required API Key ACLs:
    //  - search
    //
    // - parameter compositionID: (path) Unique Composition ObjectID.
    //
    // - parameter facetName: (path) Facet attribute in which to search for values.  This attribute must be included in
    // the `attributesForFaceting` index setting with the `searchable()` modifier.
    //
    // - parameter searchForFacetValuesRequest: (body)  (optional)
    // - returns: RequestBuilder<CompositionSearchForFacetValuesResponse>

    open func searchForFacetValuesWithHTTPInfo(
        compositionID: String,
        facetName: String,
        searchForFacetValuesRequest: CompositionSearchForFacetValuesRequest? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<CompositionSearchForFacetValuesResponse> {
        guard !compositionID.isEmpty else {
            throw AlgoliaError.invalidArgument("compositionID", "searchForFacetValues")
        }

        guard !facetName.isEmpty else {
            throw AlgoliaError.invalidArgument("facetName", "searchForFacetValues")
        }

        var resourcePath = "/1/compositions/{compositionID}/facets/{facetName}/query"
        let compositionIDPreEscape = "\(APIHelper.mapValueToPathItem(compositionID))"
        let compositionIDPostEscape = compositionIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{compositionID}",
            with: compositionIDPostEscape,
            options: .literal,
            range: nil
        )
        let facetNamePreEscape = "\(APIHelper.mapValueToPathItem(facetName))"
        let facetNamePostEscape = facetNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{facetName}",
            with: facetNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = searchForFacetValuesRequest
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(
                headers: headers,
                queryParameters: queryParameters
            ) + userRequestOptions,
            useReadTransporter: true
        )
    }
}
