// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on
// https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import Foundation
#if canImport(Core)
    import Core
#endif

public struct MetricResult: Codable, JSONEncodable {
    public var name: String
    /// Date and time when the metric was last updated, in RFC 3339 format.
    public var updatedAt: String
    public var value: Double
    /// The upper bound of the 95% confidence interval for the metric value. The confidence interval is calculated using
    /// either the relative ratio or relative difference between the metric values for the control and the variant.
    /// Relative ratio is used for metrics that are ratios (e.g., click-through rate, conversion rate), while relative
    /// difference is used for continuous metrics (e.g., revenue).
    public var valueCIHigh: Double?
    /// The lower bound of the 95% confidence interval for the metric value. The confidence interval is calculated using
    /// either the relative ratio or relative difference between the metric values for the control and the variant.
    /// Relative ratio is used for metrics that are ratios (e.g., click-through rate, conversion rate), while relative
    /// difference is used for continuous metrics (e.g., revenue).
    public var valueCILow: Double?
    /// PValue for the first variant (control) will always be 0. For the other variants, pValue is calculated for the
    /// current variant based on the control.
    public var pValue: Double
    /// Dimension defined during test creation.
    public var dimension: String?
    public var metadata: MetricMetadata?
    /// The value that was computed during error correction. It is used to determine significance of the metric pValue.
    /// The critical value is calculated using Bonferroni or Benjamini-Hochberg corrections, based on the given
    /// configuration during the A/B test creation.
    public var criticalValue: Double?
    /// Whether the pValue is significant or not based on the critical value and the error correction algorithm used.
    public var significant: Bool?

    public init(
        name: String,
        updatedAt: String,
        value: Double,
        valueCIHigh: Double? = nil,
        valueCILow: Double? = nil,
        pValue: Double,
        dimension: String? = nil,
        metadata: MetricMetadata? = nil,
        criticalValue: Double? = nil,
        significant: Bool? = nil
    ) {
        self.name = name
        self.updatedAt = updatedAt
        self.value = value
        self.valueCIHigh = valueCIHigh
        self.valueCILow = valueCILow
        self.pValue = pValue
        self.dimension = dimension
        self.metadata = metadata
        self.criticalValue = criticalValue
        self.significant = significant
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case name
        case updatedAt
        case value
        case valueCIHigh
        case valueCILow
        case pValue
        case dimension
        case metadata
        case criticalValue
        case significant
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.name, forKey: .name)
        try container.encode(self.updatedAt, forKey: .updatedAt)
        try container.encode(self.value, forKey: .value)
        try container.encodeIfPresent(self.valueCIHigh, forKey: .valueCIHigh)
        try container.encodeIfPresent(self.valueCILow, forKey: .valueCILow)
        try container.encode(self.pValue, forKey: .pValue)
        try container.encodeIfPresent(self.dimension, forKey: .dimension)
        try container.encodeIfPresent(self.metadata, forKey: .metadata)
        try container.encodeIfPresent(self.criticalValue, forKey: .criticalValue)
        try container.encodeIfPresent(self.significant, forKey: .significant)
    }
}

extension MetricResult: Equatable {
    public static func ==(lhs: MetricResult, rhs: MetricResult) -> Bool {
        lhs.name == rhs.name &&
            lhs.updatedAt == rhs.updatedAt &&
            lhs.value == rhs.value &&
            lhs.valueCIHigh == rhs.valueCIHigh &&
            lhs.valueCILow == rhs.valueCILow &&
            lhs.pValue == rhs.pValue &&
            lhs.dimension == rhs.dimension &&
            lhs.metadata == rhs.metadata &&
            lhs.criticalValue == rhs.criticalValue &&
            lhs.significant == rhs.significant
    }
}

extension MetricResult: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(self.name.hashValue)
        hasher.combine(self.updatedAt.hashValue)
        hasher.combine(self.value.hashValue)
        hasher.combine(self.valueCIHigh?.hashValue)
        hasher.combine(self.valueCILow?.hashValue)
        hasher.combine(self.pValue.hashValue)
        hasher.combine(self.dimension?.hashValue)
        hasher.combine(self.metadata?.hashValue)
        hasher.combine(self.criticalValue?.hashValue)
        hasher.combine(self.significant?.hashValue)
    }
}
