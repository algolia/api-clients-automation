// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on
// https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import AnyCodable
import Core
import Foundation

public struct SecuredAPIKeyRestrictions: Codable, JSONEncodable, Hashable {
    public var searchParams: SearchParamsObject?
    /// Filters that apply to every search made with the secured API key. You can add extra filters at search time with
    /// the filters query parameter. For example, if you set the filter group:admin on your generated API key, and you
    /// add groups:press OR groups:visitors with the filters query parameter, your final search filter is equivalent to
    /// groups:admin AND (groups:press OR groups:visitors).
    public var filters: String?
    /// Unix timestamp used to set the expiration date of the API key.
    public var validUntil: Double?
    /// Index names that can be queried.
    public var restrictIndices: [String]?
    /// IPv4 network allowed to use the generated key. Use this to protect against API key leaking and reuse. You can
    /// only provide a single source, but you can specify a range of IPs (for example, 192.168.1.0/24).
    public var restrictSources: String?
    /// Unique user IP address. This can be useful when you want to impose a rate limit on specific users. By default,
    /// rate limits are set based on the IP address. This can become an issue when several users search from the same IP
    /// address. To avoid this, you can set a unique userToken for each user when generating their API key. This lets
    /// you restrict each user to a maximum number of API calls per hour, even if they share their IP with another user.
    /// Specifying the userToken in a secured API key is also a good security practice as it ensures users don't change
    /// it. Many features like Analytics, Personalization, and Dynamic Re-ranking rely on the authenticity of user
    /// identifiers. Setting the userToken at the API key level ensures that downstream services work as expected and
    /// prevents abuse.
    public var userToken: String?

    public init(
        searchParams: SearchParamsObject? = nil,
        filters: String? = nil,
        validUntil: Double? = nil,
        restrictIndices: [String]? = nil,
        restrictSources: String? = nil,
        userToken: String? = nil
    ) {
        self.searchParams = searchParams
        self.filters = filters
        self.validUntil = validUntil
        self.restrictIndices = restrictIndices
        self.restrictSources = restrictSources
        self.userToken = userToken
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case searchParams
        case filters
        case validUntil
        case restrictIndices
        case restrictSources
        case userToken
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(self.searchParams, forKey: .searchParams)
        try container.encodeIfPresent(self.filters, forKey: .filters)
        try container.encodeIfPresent(self.validUntil, forKey: .validUntil)
        try container.encodeIfPresent(self.restrictIndices, forKey: .restrictIndices)
        try container.encodeIfPresent(self.restrictSources, forKey: .restrictSources)
        try container.encodeIfPresent(self.userToken, forKey: .userToken)
    }
}
