// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on
// https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import AnyCodable
import Core
import Foundation

typealias Client = SearchClient

open class SearchClient {
    private var configuration: Configuration
    private var transporter: Transporter

    var appID: String {
        self.configuration.appID
    }

    public init(configuration: Configuration, transporter: Transporter) {
        self.configuration = configuration
        self.transporter = transporter
    }

    public convenience init(configuration: Configuration) {
        self.init(configuration: configuration, transporter: Transporter(configuration: configuration))
    }

    public convenience init(appID: String, apiKey: String) throws {
        try self.init(configuration: Configuration(appID: appID, apiKey: apiKey))
    }

    /// - parameter apiKey: (body)
    /// - returns: AddApiKeyResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func addApiKey(apiKey: ApiKey, requestOptions: RequestOptions? = nil) async throws -> AddApiKeyResponse {
        let response: Response<AddApiKeyResponse> = try await addApiKeyWithHTTPInfo(
            apiKey: apiKey,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Add a new API key with specific permissions and restrictions. The request must be authenticated with the admin
    // API key. The response returns an API key string.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter apiKey: (body)
    // - returns: RequestBuilder<AddApiKeyResponse>

    open func addApiKeyWithHTTPInfo(
        apiKey: ApiKey,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AddApiKeyResponse> {
        let resourcePath = "/1/keys"
        let body = apiKey
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter objectID: (path) Unique record (object) identifier.
    /// - parameter body: (body) Algolia record.
    /// - returns: UpdatedAtWithObjectIdResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func addOrUpdateObject(
        indexName: String,
        objectID: String,
        body: [String: AnyCodable],
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtWithObjectIdResponse {
        let response: Response<UpdatedAtWithObjectIdResponse> = try await addOrUpdateObjectWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            body: body,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // If you use an existing `objectID`, the existing record will be replaced with the new one.  To update only some
    // attributes of an existing record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject)
    // instead.  To add multiple records to your index in a single API request, use the [`batch`
    // operation](#tag/Records/operation/batch).
    // Required API Key ACLs:
    //  - addObject
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter objectID: (path) Unique record (object) identifier.
    //
    // - parameter body: (body) Algolia record.
    // - returns: RequestBuilder<UpdatedAtWithObjectIdResponse>

    open func addOrUpdateObjectWithHTTPInfo(
        indexName: String,
        objectID: String,
        body: [String: AnyCodable],
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtWithObjectIdResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "addOrUpdateObject")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "addOrUpdateObject")
        }

        guard !body.isEmpty else {
            throw AlgoliaError.invalidArgument("body", "addOrUpdateObject")
        }

        var resourcePath = "/1/indexes/{indexName}/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = body
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter source: (body) Source to add.
    /// - returns: CreatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func appendSource(source: Source, requestOptions: RequestOptions? = nil) async throws -> CreatedAtResponse {
        let response: Response<CreatedAtResponse> = try await appendSourceWithHTTPInfo(
            source: source,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Add a source to the list of allowed sources.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter source: (body) Source to add.
    // - returns: RequestBuilder<CreatedAtResponse>

    open func appendSourceWithHTTPInfo(
        source: Source,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<CreatedAtResponse> {
        let resourcePath = "/1/security/sources/append"
        let body = source
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter xAlgoliaUserID: (header) userID to assign.
    /// - parameter assignUserIdParams: (body)
    /// - returns: CreatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func assignUserId(
        xAlgoliaUserID: String,
        assignUserIdParams: AssignUserIdParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> CreatedAtResponse {
        let response: Response<CreatedAtResponse> = try await assignUserIdWithHTTPInfo(
            xAlgoliaUserID: xAlgoliaUserID,
            assignUserIdParams: assignUserIdParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Assign or move a user ID to a cluster. The time it takes to move a user is proportional to the amount of data
    // linked to the user ID.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter xAlgoliaUserID: (header) userID to assign.
    //
    // - parameter assignUserIdParams: (body)
    // - returns: RequestBuilder<CreatedAtResponse>

    open func assignUserIdWithHTTPInfo(
        xAlgoliaUserID: String,
        assignUserIdParams: AssignUserIdParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<CreatedAtResponse> {
        let resourcePath = "/1/clusters/mapping"
        let body = assignUserIdParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = [
            "X-Algolia-User-ID": xAlgoliaUserID.encodeToJSON(),
        ]

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter batchWriteParams: (body)
    /// - returns: BatchResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func batch(
        indexName: String,
        batchWriteParams: BatchWriteParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> BatchResponse {
        let response: Response<BatchResponse> = try await batchWithHTTPInfo(
            indexName: indexName,
            batchWriteParams: batchWriteParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // To reduce the time spent on network round trips, you can perform several write actions in a single API call.
    // Actions are applied in the order they are specified. The supported `action`s are equivalent to the individual
    // operations of the same name.
    //
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter batchWriteParams: (body)
    // - returns: RequestBuilder<BatchResponse>

    open func batchWithHTTPInfo(
        indexName: String,
        batchWriteParams: BatchWriteParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<BatchResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "batch")
        }

        var resourcePath = "/1/indexes/{indexName}/batch"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = batchWriteParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter xAlgoliaUserID: (header) userID to assign.
    /// - parameter batchAssignUserIdsParams: (body)
    /// - returns: CreatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func batchAssignUserIds(
        xAlgoliaUserID: String,
        batchAssignUserIdsParams: BatchAssignUserIdsParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> CreatedAtResponse {
        let response: Response<CreatedAtResponse> = try await batchAssignUserIdsWithHTTPInfo(
            xAlgoliaUserID: xAlgoliaUserID,
            batchAssignUserIdsParams: batchAssignUserIdsParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Assign multiple user IDs to a cluster. **You can't _move_ users with this operation.**.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter xAlgoliaUserID: (header) userID to assign.
    //
    // - parameter batchAssignUserIdsParams: (body)
    // - returns: RequestBuilder<CreatedAtResponse>

    open func batchAssignUserIdsWithHTTPInfo(
        xAlgoliaUserID: String,
        batchAssignUserIdsParams: BatchAssignUserIdsParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<CreatedAtResponse> {
        let resourcePath = "/1/clusters/mapping/batch"
        let body = batchAssignUserIdsParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = [
            "X-Algolia-User-ID": xAlgoliaUserID.encodeToJSON(),
        ]

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter dictionaryName: (path) Dictionary to search in.
    /// - parameter batchDictionaryEntriesParams: (body)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func batchDictionaryEntries(
        dictionaryName: DictionaryType,
        batchDictionaryEntriesParams: BatchDictionaryEntriesParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await batchDictionaryEntriesWithHTTPInfo(
            dictionaryName: dictionaryName,
            batchDictionaryEntriesParams: batchDictionaryEntriesParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Add or remove a batch of dictionary entries.
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter dictionaryName: (path) Dictionary to search in.
    //
    // - parameter batchDictionaryEntriesParams: (body)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func batchDictionaryEntriesWithHTTPInfo(
        dictionaryName: DictionaryType,
        batchDictionaryEntriesParams: BatchDictionaryEntriesParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        var resourcePath = "/1/dictionaries/{dictionaryName}/batch"
        let dictionaryNamePreEscape = "\(APIHelper.mapValueToPathItem(dictionaryName))"
        let dictionaryNamePostEscape = dictionaryNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{dictionaryName}",
            with: dictionaryNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = batchDictionaryEntriesParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter browseParams: (body)  (optional)
    /// - returns: BrowseResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func browse(
        indexName: String,
        browseParams: BrowseParams? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> BrowseResponse {
        let response: Response<BrowseResponse> = try await browseWithHTTPInfo(
            indexName: indexName,
            browseParams: browseParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieve up to 1,000 records per call. Supports full-text search and filters. For better performance, it doesn't
    // support: - The `distinct` query parameter - Sorting by typos, proximity, words, or geographical distance.
    // Required API Key ACLs:
    //  - browse
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter browseParams: (body)  (optional)
    // - returns: RequestBuilder<BrowseResponse>

    open func browseWithHTTPInfo(
        indexName: String,
        browseParams: BrowseParams? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<BrowseResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "browse")
        }

        var resourcePath = "/1/indexes/{indexName}/browse"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = browseParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func clearObjects(indexName: String, requestOptions: RequestOptions? = nil) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await clearObjectsWithHTTPInfo(
            indexName: indexName,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Delete the records but leave settings and index-specific API keys untouched.
    // Required API Key ACLs:
    //  - deleteIndex
    //
    // - parameter indexName: (path) Index on which to perform the request.
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func clearObjectsWithHTTPInfo(
        indexName: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "clearObjects")
        }

        var resourcePath = "/1/indexes/{indexName}/clear"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    /// indices. (optional)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func clearRules(
        indexName: String,
        forwardToReplicas: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await clearRulesWithHTTPInfo(
            indexName: indexName,
            forwardToReplicas: forwardToReplicas,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Delete all rules in the index.
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    // indices. (optional)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func clearRulesWithHTTPInfo(
        indexName: String,
        forwardToReplicas: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "clearRules")
        }

        var resourcePath = "/1/indexes/{indexName}/rules/clear"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    /// indices. (optional)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func clearSynonyms(
        indexName: String,
        forwardToReplicas: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await clearSynonymsWithHTTPInfo(
            indexName: indexName,
            forwardToReplicas: forwardToReplicas,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Delete all synonyms in the index.
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    // indices. (optional)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func clearSynonymsWithHTTPInfo(
        indexName: String,
        forwardToReplicas: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "clearSynonyms")
        }

        var resourcePath = "/1/indexes/{indexName}/synonyms/clear"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    /// - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func customDelete(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await customDeleteWithHTTPInfo(
            path: path,
            parameters: parameters,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This method allow you to send requests to the Algolia REST API.
    //
    //
    // - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    //
    // - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func customDeleteWithHTTPInfo(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !path.isEmpty else {
            throw AlgoliaError.invalidArgument("path", "customDelete")
        }

        var resourcePath = "/1{path}"
        let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
        resourcePath = resourcePath.replacingOccurrences(
            of: "{path}",
            with: pathPreEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters = parameters

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    /// - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func customGet(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await customGetWithHTTPInfo(
            path: path,
            parameters: parameters,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This method allow you to send requests to the Algolia REST API.
    //
    //
    // - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    //
    // - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func customGetWithHTTPInfo(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !path.isEmpty else {
            throw AlgoliaError.invalidArgument("path", "customGet")
        }

        var resourcePath = "/1{path}"
        let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
        resourcePath = resourcePath.replacingOccurrences(
            of: "{path}",
            with: pathPreEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters = parameters

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    /// - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    /// - parameter body: (body) Parameters to send with the custom request. (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func customPost(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        body: [String: AnyCodable]? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await customPostWithHTTPInfo(
            path: path,
            parameters: parameters,
            body: body,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This method allow you to send requests to the Algolia REST API.
    //
    //
    // - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    //
    // - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    //
    // - parameter body: (body) Parameters to send with the custom request. (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func customPostWithHTTPInfo(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        body: [String: AnyCodable]? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !path.isEmpty else {
            throw AlgoliaError.invalidArgument("path", "customPost")
        }

        var resourcePath = "/1{path}"
        let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
        resourcePath = resourcePath.replacingOccurrences(
            of: "{path}",
            with: pathPreEscape,
            options: .literal,
            range: nil
        )
        let body = body
        let queryParameters = parameters

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    /// - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    /// - parameter body: (body) Parameters to send with the custom request. (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func customPut(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        body: [String: AnyCodable]? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await customPutWithHTTPInfo(
            path: path,
            parameters: parameters,
            body: body,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This method allow you to send requests to the Algolia REST API.
    //
    //
    // - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    //
    // - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    //
    // - parameter body: (body) Parameters to send with the custom request. (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func customPutWithHTTPInfo(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        body: [String: AnyCodable]? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !path.isEmpty else {
            throw AlgoliaError.invalidArgument("path", "customPut")
        }

        var resourcePath = "/1{path}"
        let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
        resourcePath = resourcePath.replacingOccurrences(
            of: "{path}",
            with: pathPreEscape,
            options: .literal,
            range: nil
        )
        let body = body
        let queryParameters = parameters

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter key: (path) API key.
    /// - returns: DeleteApiKeyResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteApiKey(key: String, requestOptions: RequestOptions? = nil) async throws -> DeleteApiKeyResponse {
        let response: Response<DeleteApiKeyResponse> = try await deleteApiKeyWithHTTPInfo(
            key: key,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Delete an existing API key. The request must be authenticated with the admin API key.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter key: (path) API key.
    // - returns: RequestBuilder<DeleteApiKeyResponse>

    open func deleteApiKeyWithHTTPInfo(
        key: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeleteApiKeyResponse> {
        guard !key.isEmpty else {
            throw AlgoliaError.invalidArgument("key", "deleteApiKey")
        }

        var resourcePath = "/1/keys/{key}"
        let keyPreEscape = "\(APIHelper.mapValueToPathItem(key))"
        let keyPostEscape = keyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{key}",
            with: keyPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter deleteByParams: (body)
    /// - returns: DeletedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteBy(
        indexName: String,
        deleteByParams: DeleteByParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> DeletedAtResponse {
        let response: Response<DeletedAtResponse> = try await deleteByWithHTTPInfo(
            indexName: indexName,
            deleteByParams: deleteByParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This operation doesn't support all the query options, only its filters (numeric, facet, or tag) and geo queries.
    // It doesn't accept empty filters or queries.
    // Required API Key ACLs:
    //  - deleteIndex
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter deleteByParams: (body)
    // - returns: RequestBuilder<DeletedAtResponse>

    open func deleteByWithHTTPInfo(
        indexName: String,
        deleteByParams: DeleteByParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeletedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "deleteBy")
        }

        var resourcePath = "/1/indexes/{indexName}/deleteByQuery"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = deleteByParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - returns: DeletedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteIndex(indexName: String, requestOptions: RequestOptions? = nil) async throws -> DeletedAtResponse {
        let response: Response<DeletedAtResponse> = try await deleteIndexWithHTTPInfo(
            indexName: indexName,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Delete an existing index.
    // Required API Key ACLs:
    //  - deleteIndex
    //
    // - parameter indexName: (path) Index on which to perform the request.
    // - returns: RequestBuilder<DeletedAtResponse>

    open func deleteIndexWithHTTPInfo(
        indexName: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeletedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "deleteIndex")
        }

        var resourcePath = "/1/indexes/{indexName}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter objectID: (path) Unique record (object) identifier.
    /// - returns: DeletedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteObject(
        indexName: String,
        objectID: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> DeletedAtResponse {
        let response: Response<DeletedAtResponse> = try await deleteObjectWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // To delete a set of records matching a query, use the [`deleteByQuery` operation](#tag/Records/operation/deleteBy)
    // instead.
    // Required API Key ACLs:
    //  - deleteObject
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter objectID: (path) Unique record (object) identifier.
    // - returns: RequestBuilder<DeletedAtResponse>

    open func deleteObjectWithHTTPInfo(
        indexName: String,
        objectID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeletedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "deleteObject")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "deleteObject")
        }

        var resourcePath = "/1/indexes/{indexName}/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter objectID: (path) Unique identifier of a rule object.
    /// - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    /// indices. (optional)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteRule(
        indexName: String,
        objectID: String,
        forwardToReplicas: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await deleteRuleWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            forwardToReplicas: forwardToReplicas,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Delete a rule by its `objectID`. To find the `objectID` for rules, use the [`search`
    // operation](#tag/Rules/operation/searchRules).
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter objectID: (path) Unique identifier of a rule object.
    //
    // - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    // indices. (optional)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func deleteRuleWithHTTPInfo(
        indexName: String,
        objectID: String,
        forwardToReplicas: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "deleteRule")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "deleteRule")
        }

        var resourcePath = "/1/indexes/{indexName}/rules/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter source: (path) IP address range of the source.
    /// - returns: DeleteSourceResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteSource(source: String, requestOptions: RequestOptions? = nil) async throws -> DeleteSourceResponse {
        let response: Response<DeleteSourceResponse> = try await deleteSourceWithHTTPInfo(
            source: source,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Remove a source from the list of allowed sources.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter source: (path) IP address range of the source.
    // - returns: RequestBuilder<DeleteSourceResponse>

    open func deleteSourceWithHTTPInfo(
        source: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeleteSourceResponse> {
        guard !source.isEmpty else {
            throw AlgoliaError.invalidArgument("source", "deleteSource")
        }

        var resourcePath = "/1/security/sources/{source}"
        let sourcePreEscape = "\(APIHelper.mapValueToPathItem(source))"
        let sourcePostEscape = sourcePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{source}",
            with: sourcePostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter objectID: (path) Unique identifier of a synonym object.
    /// - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    /// indices. (optional)
    /// - returns: DeletedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteSynonym(
        indexName: String,
        objectID: String,
        forwardToReplicas: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> DeletedAtResponse {
        let response: Response<DeletedAtResponse> = try await deleteSynonymWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            forwardToReplicas: forwardToReplicas,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Delete a synonym by its `objectID`. To find the object IDs of your synonyms, use the [`search`
    // operation](#tag/Synonyms/operation/searchSynonyms).
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter objectID: (path) Unique identifier of a synonym object.
    //
    // - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    // indices. (optional)
    // - returns: RequestBuilder<DeletedAtResponse>

    open func deleteSynonymWithHTTPInfo(
        indexName: String,
        objectID: String,
        forwardToReplicas: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeletedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "deleteSynonym")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "deleteSynonym")
        }

        var resourcePath = "/1/indexes/{indexName}/synonyms/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter key: (path) API key.
    /// - returns: GetApiKeyResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getApiKey(key: String, requestOptions: RequestOptions? = nil) async throws -> GetApiKeyResponse {
        let response: Response<GetApiKeyResponse> = try await getApiKeyWithHTTPInfo(
            key: key,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Get the permissions and restrictions of a specific API key. When authenticating with the admin API key, you can
    // request information for any of your application's keys. When authenticating with other API keys, you can only
    // retrieve information for that key.
    //
    //
    // - parameter key: (path) API key.
    // - returns: RequestBuilder<GetApiKeyResponse>

    open func getApiKeyWithHTTPInfo(
        key: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<GetApiKeyResponse> {
        guard !key.isEmpty else {
            throw AlgoliaError.invalidArgument("key", "getApiKey")
        }

        var resourcePath = "/1/keys/{key}"
        let keyPreEscape = "\(APIHelper.mapValueToPathItem(key))"
        let keyPostEscape = keyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{key}",
            with: keyPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - returns: [String: Languages]
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getDictionaryLanguages(requestOptions: RequestOptions? = nil) async throws -> [String: Languages] {
        let response: Response<[String: Languages]> =
            try await getDictionaryLanguagesWithHTTPInfo(requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Lists Algolia's [supported languages](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/)
    // and any customizations applied to each language's [stop word](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/),
    // [plural](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/),
    // and [segmentation (compound)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/)
    // features.
    // Required API Key ACLs:
    //  - settings
    //     - returns: RequestBuilder<[String: Languages]>

    open func getDictionaryLanguagesWithHTTPInfo(requestOptions userRequestOptions: RequestOptions? = nil) async throws
    -> Response<[String: Languages]> {
        let resourcePath = "/1/dictionaries/*/languages"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - returns: GetDictionarySettingsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getDictionarySettings(requestOptions: RequestOptions? = nil) async throws
    -> GetDictionarySettingsResponse {
        let response: Response<GetDictionarySettingsResponse> =
            try await getDictionarySettingsWithHTTPInfo(requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Get the languages for which [stop words are turned off](#tag/Dictionaries/operation/setDictionarySettings).
    // Required API Key ACLs:
    //  - settings
    //     - returns: RequestBuilder<GetDictionarySettingsResponse>

    open func getDictionarySettingsWithHTTPInfo(requestOptions userRequestOptions: RequestOptions? = nil) async throws
    -> Response<GetDictionarySettingsResponse> {
        let resourcePath = "/1/dictionaries/*/settings"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter offset: (query) First log entry to retrieve. Sorted by decreasing date with 0 being the most recent.
    /// (optional, default to 0)
    /// - parameter length: (query) Maximum number of entries to retrieve. (optional, default to 10)
    /// - parameter indexName: (query) Index for which log entries should be retrieved. When omitted, log entries are
    /// retrieved for all indices. (optional)
    /// - parameter type: (query) Type of log entries to retrieve. When omitted, all log entries are retrieved.
    /// (optional)
    /// - returns: GetLogsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getLogs(
        offset: Int? = nil,
        length: Int? = nil,
        indexName: String? = nil,
        type: LogType? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> GetLogsResponse {
        let response: Response<GetLogsResponse> = try await getLogsWithHTTPInfo(
            offset: offset,
            length: length,
            indexName: indexName,
            type: type,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // The request must be authenticated by an API key with the [`logs`
    // ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl). Logs are held for the last
    // seven days. There's also a logging limit of 1,000 API calls per server. This request counts towards your
    // [operations
    // quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-)
    // but doesn't appear in the logs itself. > **Note**: To fetch the logs for a Distributed Search Network (DSN)
    // cluster, target the [DSN's
    // endpoint](https://www.algolia.com/doc/guides/scaling/distributed-search-network-dsn/#accessing-dsn-servers).
    // Required API Key ACLs:
    //  - logs
    //
    // - parameter offset: (query) First log entry to retrieve. Sorted by decreasing date with 0 being the most recent.
    // (optional, default to 0)
    //
    // - parameter length: (query) Maximum number of entries to retrieve. (optional, default to 10)
    //
    // - parameter indexName: (query) Index for which log entries should be retrieved. When omitted, log entries are
    // retrieved for all indices. (optional)
    //
    // - parameter type: (query) Type of log entries to retrieve. When omitted, all log entries are retrieved.
    // (optional)
    // - returns: RequestBuilder<GetLogsResponse>

    open func getLogsWithHTTPInfo(
        offset: Int? = nil,
        length: Int? = nil,
        indexName: String? = nil,
        type: LogType? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<GetLogsResponse> {
        let resourcePath = "/1/logs"
        let body: AnyCodable? = nil
        let queryParameters = [
            "offset": offset?.encodeToJSON(),
            "length": length?.encodeToJSON(),
            "indexName": indexName?.encodeToJSON(),
            "type": type?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter objectID: (path) Unique record (object) identifier.
    /// - parameter attributesToRetrieve: (query) Attributes to include with the records in the response. This is useful
    /// to reduce the size of the API response. By default, all retrievable attributes are returned.
    /// &#x60;objectID&#x60; is always retrieved, even when not specified. [&#x60;unretrievableAttributes&#x60;](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/)
    /// won&#39;t be retrieved unless the request is authenticated with the admin API key.  (optional)
    /// - returns: [String: String]
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getObject(
        indexName: String,
        objectID: String,
        attributesToRetrieve: [String]? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> [String: String] {
        let response: Response<[String: String]> = try await getObjectWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            attributesToRetrieve: attributesToRetrieve,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // To get more than one record, use the [`objects` operation](#tag/Records/operation/getObjects).
    // Required API Key ACLs:
    //  - search
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter objectID: (path) Unique record (object) identifier.
    //
    // - parameter attributesToRetrieve: (query) Attributes to include with the records in the response. This is useful
    // to reduce the size of the API response. By default, all retrievable attributes are returned. &#x60;objectID&#x60;
    // is always retrieved, even when not specified. [&#x60;unretrievableAttributes&#x60;](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/)
    // won&#39;t be retrieved unless the request is authenticated with the admin API key.  (optional)
    // - returns: RequestBuilder<[String: String]>

    open func getObjectWithHTTPInfo(
        indexName: String,
        objectID: String,
        attributesToRetrieve: [String]? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<[String: String]> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "getObject")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "getObject")
        }

        var resourcePath = "/1/indexes/{indexName}/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters = [
            "attributesToRetrieve": attributesToRetrieve?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter getObjectsParams: (body) Request object.
    /// - returns: GetObjectsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getObjects(
        getObjectsParams: GetObjectsParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> GetObjectsResponse {
        let response: Response<GetObjectsResponse> = try await getObjectsWithHTTPInfo(
            getObjectsParams: getObjectsParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieve one or more records, potentially from different indices, in a single API operation. Results will be
    // received in the same order as the requests.
    // Required API Key ACLs:
    //  - search
    //
    // - parameter getObjectsParams: (body) Request object.
    // - returns: RequestBuilder<GetObjectsResponse>

    open func getObjectsWithHTTPInfo(
        getObjectsParams: GetObjectsParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<GetObjectsResponse> {
        let resourcePath = "/1/indexes/*/objects"
        let body = getObjectsParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter objectID: (path) Unique identifier of a rule object.
    /// - returns: Rule
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getRule(indexName: String, objectID: String, requestOptions: RequestOptions? = nil) async throws -> Rule {
        let response: Response<Rule> = try await getRuleWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Get a rule by its `objectID`. To find the `objectID` for rules, use the [`search`
    // operation](#tag/Rules/operation/searchRules).
    // Required API Key ACLs:
    //  - settings
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter objectID: (path) Unique identifier of a rule object.
    // - returns: RequestBuilder<Rule>

    open func getRuleWithHTTPInfo(
        indexName: String,
        objectID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<Rule> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "getRule")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "getRule")
        }

        var resourcePath = "/1/indexes/{indexName}/rules/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - returns: IndexSettings
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getSettings(indexName: String, requestOptions: RequestOptions? = nil) async throws -> IndexSettings {
        let response: Response<IndexSettings> = try await getSettingsWithHTTPInfo(
            indexName: indexName,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Return an object containing an index's [configuration
    // settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/).
    // Required API Key ACLs:
    //  - search
    //
    // - parameter indexName: (path) Index on which to perform the request.
    // - returns: RequestBuilder<IndexSettings>

    open func getSettingsWithHTTPInfo(
        indexName: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<IndexSettings> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "getSettings")
        }

        var resourcePath = "/1/indexes/{indexName}/settings"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - returns: [Source]
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getSources(requestOptions: RequestOptions? = nil) async throws -> [Source] {
        let response: Response<[Source]> = try await getSourcesWithHTTPInfo(requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Get all allowed sources (IP addresses).
    // Required API Key ACLs:
    //  - admin
    //     - returns: RequestBuilder<[Source]>

    open func getSourcesWithHTTPInfo(requestOptions userRequestOptions: RequestOptions? = nil) async throws
    -> Response<[Source]> {
        let resourcePath = "/1/security/sources"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter objectID: (path) Unique identifier of a synonym object.
    /// - returns: SynonymHit
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getSynonym(
        indexName: String,
        objectID: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> SynonymHit {
        let response: Response<SynonymHit> = try await getSynonymWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Get a syonym by its `objectID`. To find the object IDs for your synonyms, use the [`search`
    // operation](#tag/Synonyms/operation/searchSynonyms).
    // Required API Key ACLs:
    //  - settings
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter objectID: (path) Unique identifier of a synonym object.
    // - returns: RequestBuilder<SynonymHit>

    open func getSynonymWithHTTPInfo(
        indexName: String,
        objectID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SynonymHit> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "getSynonym")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "getSynonym")
        }

        var resourcePath = "/1/indexes/{indexName}/synonyms/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter taskID: (path) Unique task identifier.
    /// - returns: GetTaskResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getTask(
        indexName: String,
        taskID: Int64,
        requestOptions: RequestOptions? = nil
    ) async throws -> GetTaskResponse {
        let response: Response<GetTaskResponse> = try await getTaskWithHTTPInfo(
            indexName: indexName,
            taskID: taskID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Some operations, such as copying an index, will respond with a `taskID` value. Use this value here to check the
    // status of that task.
    // Required API Key ACLs:
    //  - addObject
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter taskID: (path) Unique task identifier.
    // - returns: RequestBuilder<GetTaskResponse>

    open func getTaskWithHTTPInfo(
        indexName: String,
        taskID: Int64,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<GetTaskResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "getTask")
        }

        var resourcePath = "/1/indexes/{indexName}/task/{taskID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - returns: GetTopUserIdsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getTopUserIds(requestOptions: RequestOptions? = nil) async throws -> GetTopUserIdsResponse {
        let response: Response<GetTopUserIdsResponse> =
            try await getTopUserIdsWithHTTPInfo(requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Get the IDs of the 10 users with the highest number of records per cluster. Since it can take up to a few seconds
    // to get the data from the different clusters, the response isn't real-time.
    // Required API Key ACLs:
    //  - admin
    //     - returns: RequestBuilder<GetTopUserIdsResponse>

    open func getTopUserIdsWithHTTPInfo(requestOptions userRequestOptions: RequestOptions? = nil) async throws
    -> Response<GetTopUserIdsResponse> {
        let resourcePath = "/1/clusters/mapping/top"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter userID: (path) userID to assign.
    /// - returns: UserId
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getUserId(userID: String, requestOptions: RequestOptions? = nil) async throws -> UserId {
        let response: Response<UserId> = try await getUserIdWithHTTPInfo(userID: userID, requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Returns the userID data stored in the mapping. Since it can take up to a few seconds to get the data from the
    // different clusters, the response isn't real-time.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter userID: (path) userID to assign.
    // - returns: RequestBuilder<UserId>

    open func getUserIdWithHTTPInfo(
        userID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UserId> {
        guard !userID.isEmpty else {
            throw AlgoliaError.invalidArgument("userID", "getUserId")
        }

        var resourcePath = "/1/clusters/mapping/{userID}"
        let userIDPreEscape = "\(APIHelper.mapValueToPathItem(userID))"
        let userIDPostEscape = userIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{userID}",
            with: userIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter getClusters: (query) Indicates whether to include the cluster&#39;s pending mapping state in the
    /// response. (optional)
    /// - returns: HasPendingMappingsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func hasPendingMappings(
        getClusters: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> HasPendingMappingsResponse {
        let response: Response<HasPendingMappingsResponse> = try await hasPendingMappingsWithHTTPInfo(
            getClusters: getClusters,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // To determine when the time-consuming process of creating a large batch of users or migrating users from one
    // cluster to another is complete, this operation retrieves the status of the process.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter getClusters: (query) Indicates whether to include the cluster&#39;s pending mapping state in the
    // response. (optional)
    // - returns: RequestBuilder<HasPendingMappingsResponse>

    open func hasPendingMappingsWithHTTPInfo(
        getClusters: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<HasPendingMappingsResponse> {
        let resourcePath = "/1/clusters/mapping/pending"
        let body: AnyCodable? = nil
        let queryParameters = [
            "getClusters": getClusters?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - returns: ListApiKeysResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func listApiKeys(requestOptions: RequestOptions? = nil) async throws -> ListApiKeysResponse {
        let response: Response<ListApiKeysResponse> = try await listApiKeysWithHTTPInfo(requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // List all API keys associated with your Algolia application, including their permissions and restrictions.
    // Required API Key ACLs:
    //  - admin
    //     - returns: RequestBuilder<ListApiKeysResponse>

    open func listApiKeysWithHTTPInfo(requestOptions userRequestOptions: RequestOptions? = nil) async throws
    -> Response<ListApiKeysResponse> {
        let resourcePath = "/1/keys"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - returns: ListClustersResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func listClusters(requestOptions: RequestOptions? = nil) async throws -> ListClustersResponse {
        let response: Response<ListClustersResponse> =
            try await listClustersWithHTTPInfo(requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // List the available clusters in a multi-cluster setup.
    // Required API Key ACLs:
    //  - admin
    //     - returns: RequestBuilder<ListClustersResponse>

    open func listClustersWithHTTPInfo(requestOptions userRequestOptions: RequestOptions? = nil) async throws
    -> Response<ListClustersResponse> {
        let resourcePath = "/1/clusters"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter page: (query) Returns the requested page number. The page size is determined by the
    /// &#x60;hitsPerPage&#x60; parameter. You can see the number of available pages in the &#x60;nbPages&#x60; response
    /// attribute. When &#x60;page&#x60; is null, the API response is not paginated.  (optional)
    /// - parameter hitsPerPage: (query) Maximum number of hits per page. (optional, default to 100)
    /// - returns: ListIndicesResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func listIndices(
        page: Int? = nil,
        hitsPerPage: Int? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> ListIndicesResponse {
        let response: Response<ListIndicesResponse> = try await listIndicesWithHTTPInfo(
            page: page,
            hitsPerPage: hitsPerPage,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // List indices in an Algolia application.
    // Required API Key ACLs:
    //  - listIndexes
    //
    // - parameter page: (query) Returns the requested page number. The page size is determined by the
    // &#x60;hitsPerPage&#x60; parameter. You can see the number of available pages in the &#x60;nbPages&#x60; response
    // attribute. When &#x60;page&#x60; is null, the API response is not paginated.  (optional)
    //
    // - parameter hitsPerPage: (query) Maximum number of hits per page. (optional, default to 100)
    // - returns: RequestBuilder<ListIndicesResponse>

    open func listIndicesWithHTTPInfo(
        page: Int? = nil,
        hitsPerPage: Int? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ListIndicesResponse> {
        let resourcePath = "/1/indexes"
        let body: AnyCodable? = nil
        let queryParameters = [
            "page": page?.encodeToJSON(),
            "hitsPerPage": hitsPerPage?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter page: (query) Returns the requested page number. The page size is determined by the
    /// &#x60;hitsPerPage&#x60; parameter. You can see the number of available pages in the &#x60;nbPages&#x60; response
    /// attribute. When &#x60;page&#x60; is null, the API response is not paginated.  (optional)
    /// - parameter hitsPerPage: (query) Maximum number of hits per page. (optional, default to 100)
    /// - returns: ListUserIdsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func listUserIds(
        page: Int? = nil,
        hitsPerPage: Int? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> ListUserIdsResponse {
        let response: Response<ListUserIdsResponse> = try await listUserIdsWithHTTPInfo(
            page: page,
            hitsPerPage: hitsPerPage,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // List the userIDs assigned to a multi-cluster application. Since it can take up to a few seconds to get the data
    // from the different clusters, the response isn't real-time.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter page: (query) Returns the requested page number. The page size is determined by the
    // &#x60;hitsPerPage&#x60; parameter. You can see the number of available pages in the &#x60;nbPages&#x60; response
    // attribute. When &#x60;page&#x60; is null, the API response is not paginated.  (optional)
    //
    // - parameter hitsPerPage: (query) Maximum number of hits per page. (optional, default to 100)
    // - returns: RequestBuilder<ListUserIdsResponse>

    open func listUserIdsWithHTTPInfo(
        page: Int? = nil,
        hitsPerPage: Int? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ListUserIdsResponse> {
        let resourcePath = "/1/clusters/mapping"
        let body: AnyCodable? = nil
        let queryParameters = [
            "page": page?.encodeToJSON(),
            "hitsPerPage": hitsPerPage?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter batchParams: (body)
    /// - returns: MultipleBatchResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func multipleBatch(
        batchParams: BatchParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> MultipleBatchResponse {
        let response: Response<MultipleBatchResponse> = try await multipleBatchWithHTTPInfo(
            batchParams: batchParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // To reduce the time spent on network round trips, you can perform several write actions in a single request. It's
    // a multi-index version of the [`batch` operation](#tag/Records/operation/batch). Actions are applied in the order
    // they are specified. The supported actions are equivalent to the individual operations of the same name.
    //
    //
    // - parameter batchParams: (body)
    // - returns: RequestBuilder<MultipleBatchResponse>

    open func multipleBatchWithHTTPInfo(
        batchParams: BatchParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<MultipleBatchResponse> {
        let resourcePath = "/1/indexes/*/batch"
        let body = batchParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter operationIndexParams: (body)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func operationIndex(
        indexName: String,
        operationIndexParams: OperationIndexParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await operationIndexWithHTTPInfo(
            indexName: indexName,
            operationIndexParams: operationIndexParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This `operation`, _copy_ or _move_, will copy or move a source index's (`IndexName`) records, settings, synonyms,
    // and rules to a `destination` index. If the destination index exists, it will be replaced, except for
    // index-specific API keys and analytics data. If the destination index doesn't exist, it will be created.  The
    // choice between moving or copying an index depends on your needs. Choose:  - **Move** to rename an index. -
    // **Copy** to create a new index with the same records and configuration as an existing one.  > **Note**: When
    // considering copying or moving, be aware of the [rate limitations](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits)
    // on these processes and the [impact on your analytics data](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/concepts/indices-analytics/).
    // Required API Key ACLs:
    //  - addObject
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter operationIndexParams: (body)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func operationIndexWithHTTPInfo(
        indexName: String,
        operationIndexParams: OperationIndexParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "operationIndex")
        }

        var resourcePath = "/1/indexes/{indexName}/operation"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = operationIndexParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter objectID: (path) Unique record (object) identifier.
    /// - parameter attributesToUpdate: (body) Object with attributes to update.
    /// - parameter createIfNotExists: (query) Indicates whether to create a new record if it doesn&#39;t exist yet. 
    /// (optional, default to true)
    /// - returns: UpdatedAtWithObjectIdResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func partialUpdateObject(
        indexName: String,
        objectID: String,
        attributesToUpdate: [String: AttributeToUpdate],
        createIfNotExists: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtWithObjectIdResponse {
        let response: Response<UpdatedAtWithObjectIdResponse> = try await partialUpdateObjectWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            attributesToUpdate: attributesToUpdate,
            createIfNotExists: createIfNotExists,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Add new attributes or update current ones in an existing record. You can use any first-level attribute but not
    // nested attributes. If you specify a [nested attribute](https://www.algolia.com/doc/guides/sending-and-managing-data/prepare-your-data/how-to/creating-and-using-nested-attributes/),
    // the engine treats it as a replacement for its first-level ancestor.
    // Required API Key ACLs:
    //  - addObject
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter objectID: (path) Unique record (object) identifier.
    //
    // - parameter attributesToUpdate: (body) Object with attributes to update.
    //
    // - parameter createIfNotExists: (query) Indicates whether to create a new record if it doesn&#39;t exist yet. 
    // (optional, default to true)
    // - returns: RequestBuilder<UpdatedAtWithObjectIdResponse>

    open func partialUpdateObjectWithHTTPInfo(
        indexName: String,
        objectID: String,
        attributesToUpdate: [String: AttributeToUpdate],
        createIfNotExists: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtWithObjectIdResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "partialUpdateObject")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "partialUpdateObject")
        }

        var resourcePath = "/1/indexes/{indexName}/{objectID}/partial"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = attributesToUpdate
        let queryParameters = [
            "createIfNotExists": createIfNotExists?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter userID: (path) userID to assign.
    /// - returns: RemoveUserIdResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func removeUserId(userID: String, requestOptions: RequestOptions? = nil) async throws -> RemoveUserIdResponse {
        let response: Response<RemoveUserIdResponse> = try await removeUserIdWithHTTPInfo(
            userID: userID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Remove a userID and its associated data from the multi-clusters.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter userID: (path) userID to assign.
    // - returns: RequestBuilder<RemoveUserIdResponse>

    open func removeUserIdWithHTTPInfo(
        userID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<RemoveUserIdResponse> {
        guard !userID.isEmpty else {
            throw AlgoliaError.invalidArgument("userID", "removeUserId")
        }

        var resourcePath = "/1/clusters/mapping/{userID}"
        let userIDPreEscape = "\(APIHelper.mapValueToPathItem(userID))"
        let userIDPostEscape = userIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{userID}",
            with: userIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter source: (body) Allowed sources.
    /// - returns: ReplaceSourceResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func replaceSources(
        source: [Source],
        requestOptions: RequestOptions? = nil
    ) async throws -> ReplaceSourceResponse {
        let response: Response<ReplaceSourceResponse> = try await replaceSourcesWithHTTPInfo(
            source: source,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Replace all allowed sources.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter source: (body) Allowed sources.
    // - returns: RequestBuilder<ReplaceSourceResponse>

    open func replaceSourcesWithHTTPInfo(
        source: [Source],
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ReplaceSourceResponse> {
        let resourcePath = "/1/security/sources"
        let body = source
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter key: (path) API key.
    /// - returns: AddApiKeyResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func restoreApiKey(key: String, requestOptions: RequestOptions? = nil) async throws -> AddApiKeyResponse {
        let response: Response<AddApiKeyResponse> = try await restoreApiKeyWithHTTPInfo(
            key: key,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Restore a deleted API key, along with its associated permissions. The request must be authenticated with the
    // admin API key.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter key: (path) API key.
    // - returns: RequestBuilder<AddApiKeyResponse>

    open func restoreApiKeyWithHTTPInfo(
        key: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AddApiKeyResponse> {
        guard !key.isEmpty else {
            throw AlgoliaError.invalidArgument("key", "restoreApiKey")
        }

        var resourcePath = "/1/keys/{key}/restore"
        let keyPreEscape = "\(APIHelper.mapValueToPathItem(key))"
        let keyPostEscape = keyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{key}",
            with: keyPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter body: (body) The Algolia record.
    /// - returns: SaveObjectResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func saveObject(
        indexName: String,
        body: [String: AnyCodable],
        requestOptions: RequestOptions? = nil
    ) async throws -> SaveObjectResponse {
        let response: Response<SaveObjectResponse> = try await saveObjectWithHTTPInfo(
            indexName: indexName,
            body: body,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Add a record (object) to an index or replace it. If the record doesn't contain an `objectID`, Algolia
    // automatically adds it. If you use an existing `objectID`, the existing record is replaced with the new one. To
    // add
    // multiple records to your index in a single API request, use the [`batch`
    // operation](#tag/Records/operation/batch).
    // Required API Key ACLs:
    //  - addObject
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter body: (body) The Algolia record.
    // - returns: RequestBuilder<SaveObjectResponse>

    open func saveObjectWithHTTPInfo(
        indexName: String,
        body: [String: AnyCodable],
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SaveObjectResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "saveObject")
        }

        guard !body.isEmpty else {
            throw AlgoliaError.invalidArgument("body", "saveObject")
        }

        var resourcePath = "/1/indexes/{indexName}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = body
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter objectID: (path) Unique identifier of a rule object.
    /// - parameter rule: (body)
    /// - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    /// indices. (optional)
    /// - returns: UpdatedRuleResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func saveRule(
        indexName: String,
        objectID: String,
        rule: Rule,
        forwardToReplicas: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedRuleResponse {
        let response: Response<UpdatedRuleResponse> = try await saveRuleWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            rule: rule,
            forwardToReplicas: forwardToReplicas,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // To create or update more than one rule, use the [`batch` operation](#tag/Rules/operation/saveRules).
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter objectID: (path) Unique identifier of a rule object.
    //
    // - parameter rule: (body)
    //
    // - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    // indices. (optional)
    // - returns: RequestBuilder<UpdatedRuleResponse>

    open func saveRuleWithHTTPInfo(
        indexName: String,
        objectID: String,
        rule: Rule,
        forwardToReplicas: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedRuleResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "saveRule")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "saveRule")
        }

        var resourcePath = "/1/indexes/{indexName}/rules/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = rule
        let queryParameters = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter rules: (body)
    /// - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    /// indices. (optional)
    /// - parameter clearExistingRules: (query) Indicates whether existing rules should be deleted before adding this
    /// batch. (optional)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func saveRules(
        indexName: String,
        rules: [Rule],
        forwardToReplicas: Bool? = nil,
        clearExistingRules: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await saveRulesWithHTTPInfo(
            indexName: indexName,
            rules: rules,
            forwardToReplicas: forwardToReplicas,
            clearExistingRules: clearExistingRules,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Create or update multiple rules.
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter rules: (body)
    //
    // - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    // indices. (optional)
    //
    // - parameter clearExistingRules: (query) Indicates whether existing rules should be deleted before adding this
    // batch. (optional)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func saveRulesWithHTTPInfo(
        indexName: String,
        rules: [Rule],
        forwardToReplicas: Bool? = nil,
        clearExistingRules: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "saveRules")
        }

        var resourcePath = "/1/indexes/{indexName}/rules/batch"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = rules
        let queryParameters = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
            "clearExistingRules": clearExistingRules?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter objectID: (path) Unique identifier of a synonym object.
    /// - parameter synonymHit: (body)
    /// - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    /// indices. (optional)
    /// - returns: SaveSynonymResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func saveSynonym(
        indexName: String,
        objectID: String,
        synonymHit: SynonymHit,
        forwardToReplicas: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> SaveSynonymResponse {
        let response: Response<SaveSynonymResponse> = try await saveSynonymWithHTTPInfo(
            indexName: indexName,
            objectID: objectID,
            synonymHit: synonymHit,
            forwardToReplicas: forwardToReplicas,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Add a [synonym](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms)
    // to an index or replace it. If the synonym `objectID` doesn't exist, Algolia adds a new one. If you use an
    // existing
    // synonym `objectID`, the existing synonym is replaced with the new one. To add multiple synonyms in a single API
    // request, use the [`batch` operation](#tag/Synonyms/operation/saveSynonyms).
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter objectID: (path) Unique identifier of a synonym object.
    //
    // - parameter synonymHit: (body)
    //
    // - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    // indices. (optional)
    // - returns: RequestBuilder<SaveSynonymResponse>

    open func saveSynonymWithHTTPInfo(
        indexName: String,
        objectID: String,
        synonymHit: SynonymHit,
        forwardToReplicas: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SaveSynonymResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "saveSynonym")
        }

        guard !objectID.isEmpty else {
            throw AlgoliaError.invalidArgument("objectID", "saveSynonym")
        }

        var resourcePath = "/1/indexes/{indexName}/synonyms/{objectID}"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let objectIDPreEscape = "\(APIHelper.mapValueToPathItem(objectID))"
        let objectIDPostEscape = objectIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{objectID}",
            with: objectIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = synonymHit
        let queryParameters = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter synonymHit: (body)
    /// - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    /// indices. (optional)
    /// - parameter replaceExistingSynonyms: (query) Indicates whether to replace all synonyms in the index with the
    /// ones sent with this request. (optional)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func saveSynonyms(
        indexName: String,
        synonymHit: [SynonymHit],
        forwardToReplicas: Bool? = nil,
        replaceExistingSynonyms: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await saveSynonymsWithHTTPInfo(
            indexName: indexName,
            synonymHit: synonymHit,
            forwardToReplicas: forwardToReplicas,
            replaceExistingSynonyms: replaceExistingSynonyms,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Create or update multiple synonyms.
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter synonymHit: (body)
    //
    // - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    // indices. (optional)
    //
    // - parameter replaceExistingSynonyms: (query) Indicates whether to replace all synonyms in the index with the ones
    // sent with this request. (optional)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func saveSynonymsWithHTTPInfo(
        indexName: String,
        synonymHit: [SynonymHit],
        forwardToReplicas: Bool? = nil,
        replaceExistingSynonyms: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "saveSynonyms")
        }

        var resourcePath = "/1/indexes/{indexName}/synonyms/batch"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = synonymHit
        let queryParameters = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
            "replaceExistingSynonyms": replaceExistingSynonyms?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter searchMethodParams: (body) Query requests and strategies. Results will be received in the same order
    /// as the queries.
    /// - returns: SearchResponses
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func search(
        searchMethodParams: SearchMethodParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchResponses {
        let response: Response<SearchResponses> = try await searchWithHTTPInfo(
            searchMethodParams: searchMethodParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Send multiple search queries to one or more indices.
    // Required API Key ACLs:
    //  - search
    //
    // - parameter searchMethodParams: (body) Query requests and strategies. Results will be received in the same order
    // as the queries.
    // - returns: RequestBuilder<SearchResponses>

    open func searchWithHTTPInfo(
        searchMethodParams: SearchMethodParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SearchResponses> {
        let resourcePath = "/1/indexes/*/queries"
        let body = searchMethodParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter dictionaryName: (path) Dictionary to search in.
    /// - parameter searchDictionaryEntriesParams: (body)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchDictionaryEntries(
        dictionaryName: DictionaryType,
        searchDictionaryEntriesParams: SearchDictionaryEntriesParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await searchDictionaryEntriesWithHTTPInfo(
            dictionaryName: dictionaryName,
            searchDictionaryEntriesParams: searchDictionaryEntriesParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Search for standard and [custom](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/)
    // entries in the [stop words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/),
    // [plurals](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/),
    // or [segmentation (compounds)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/)
    // dictionaries.
    // Required API Key ACLs:
    //  - settings
    //
    // - parameter dictionaryName: (path) Dictionary to search in.
    //
    // - parameter searchDictionaryEntriesParams: (body)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func searchDictionaryEntriesWithHTTPInfo(
        dictionaryName: DictionaryType,
        searchDictionaryEntriesParams: SearchDictionaryEntriesParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        var resourcePath = "/1/dictionaries/{dictionaryName}/search"
        let dictionaryNamePreEscape = "\(APIHelper.mapValueToPathItem(dictionaryName))"
        let dictionaryNamePostEscape = dictionaryNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{dictionaryName}",
            with: dictionaryNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = searchDictionaryEntriesParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter facetName: (path) Facet name.
    /// - parameter searchForFacetValuesRequest: (body)  (optional)
    /// - returns: SearchForFacetValuesResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchForFacetValues(
        indexName: String,
        facetName: String,
        searchForFacetValuesRequest: SearchForFacetValuesRequest? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchForFacetValuesResponse {
        let response: Response<SearchForFacetValuesResponse> = try await searchForFacetValuesWithHTTPInfo(
            indexName: indexName,
            facetName: facetName,
            searchForFacetValuesRequest: searchForFacetValuesRequest,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // [Search for a facet's
    // values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values),
    // optionally restricting the returned values to those contained in records matching other search criteria. >
    // **Note**: Pagination isn't supported (`page` and `hitsPerPage` are ignored). By default, the engine returns a maximum of 10 values but you can adjust this with `maxFacetHits`.
    // Required API Key ACLs:
    //  - search
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter facetName: (path) Facet name.
    //
    // - parameter searchForFacetValuesRequest: (body)  (optional)
    // - returns: RequestBuilder<SearchForFacetValuesResponse>

    open func searchForFacetValuesWithHTTPInfo(
        indexName: String,
        facetName: String,
        searchForFacetValuesRequest: SearchForFacetValuesRequest? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SearchForFacetValuesResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "searchForFacetValues")
        }

        guard !facetName.isEmpty else {
            throw AlgoliaError.invalidArgument("facetName", "searchForFacetValues")
        }

        var resourcePath = "/1/indexes/{indexName}/facets/{facetName}/query"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let facetNamePreEscape = "\(APIHelper.mapValueToPathItem(facetName))"
        let facetNamePostEscape = facetNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{facetName}",
            with: facetNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = searchForFacetValuesRequest
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter searchRulesParams: (body)  (optional)
    /// - returns: SearchRulesResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchRules(
        indexName: String,
        searchRulesParams: SearchRulesParams? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchRulesResponse {
        let response: Response<SearchRulesResponse> = try await searchRulesWithHTTPInfo(
            indexName: indexName,
            searchRulesParams: searchRulesParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Search for rules in your index. You can control the search with parameters. To list all rules, send an empty
    // request body.
    // Required API Key ACLs:
    //  - settings
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter searchRulesParams: (body)  (optional)
    // - returns: RequestBuilder<SearchRulesResponse>

    open func searchRulesWithHTTPInfo(
        indexName: String,
        searchRulesParams: SearchRulesParams? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SearchRulesResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "searchRules")
        }

        var resourcePath = "/1/indexes/{indexName}/rules/search"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = searchRulesParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter searchParams: (body)  (optional)
    /// - returns: SearchResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchSingleIndex(
        indexName: String,
        searchParams: SearchParams? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchResponse {
        let response: Response<SearchResponse> = try await searchSingleIndexWithHTTPInfo(
            indexName: indexName,
            searchParams: searchParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Return records that match the query.
    // Required API Key ACLs:
    //  - search
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter searchParams: (body)  (optional)
    // - returns: RequestBuilder<SearchResponse>

    open func searchSingleIndexWithHTTPInfo(
        indexName: String,
        searchParams: SearchParams? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SearchResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "searchSingleIndex")
        }

        var resourcePath = "/1/indexes/{indexName}/query"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = searchParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter searchSynonymsParams: (body) Body of the &#x60;searchSynonyms&#x60; operation. (optional)
    /// - returns: SearchSynonymsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchSynonyms(
        indexName: String,
        searchSynonymsParams: SearchSynonymsParams? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchSynonymsResponse {
        let response: Response<SearchSynonymsResponse> = try await searchSynonymsWithHTTPInfo(
            indexName: indexName,
            searchSynonymsParams: searchSynonymsParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Search for synonyms in your index. You can control and filter the search with parameters. To get all synonyms,
    // send an empty request body.
    // Required API Key ACLs:
    //  - settings
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter searchSynonymsParams: (body) Body of the &#x60;searchSynonyms&#x60; operation. (optional)
    // - returns: RequestBuilder<SearchSynonymsResponse>

    open func searchSynonymsWithHTTPInfo(
        indexName: String,
        searchSynonymsParams: SearchSynonymsParams? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SearchSynonymsResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "searchSynonyms")
        }

        var resourcePath = "/1/indexes/{indexName}/synonyms/search"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = searchSynonymsParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter searchUserIdsParams: (body)
    /// - returns: SearchUserIdsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchUserIds(
        searchUserIdsParams: SearchUserIdsParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchUserIdsResponse {
        let response: Response<SearchUserIdsResponse> = try await searchUserIdsWithHTTPInfo(
            searchUserIdsParams: searchUserIdsParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.
    // To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built
    // every
    // 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search
    // will show an old value until the next time the mapping is rebuilt (every 12 hours).
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter searchUserIdsParams: (body)
    // - returns: RequestBuilder<SearchUserIdsResponse>

    open func searchUserIdsWithHTTPInfo(
        searchUserIdsParams: SearchUserIdsParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SearchUserIdsResponse> {
        let resourcePath = "/1/clusters/mapping/search"
        let body = searchUserIdsParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions,
            useReadTransporter: true
        )
    }

    /// - parameter dictionarySettingsParams: (body)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func setDictionarySettings(
        dictionarySettingsParams: DictionarySettingsParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await setDictionarySettingsWithHTTPInfo(
            dictionarySettingsParams: dictionarySettingsParams,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Set stop word settings for a specific language.
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter dictionarySettingsParams: (body)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func setDictionarySettingsWithHTTPInfo(
        dictionarySettingsParams: DictionarySettingsParams,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        let resourcePath = "/1/dictionaries/*/settings"
        let body = dictionarySettingsParams
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter indexName: (path) Index on which to perform the request.
    /// - parameter indexSettings: (body)
    /// - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    /// indices. (optional)
    /// - returns: UpdatedAtResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func setSettings(
        indexName: String,
        indexSettings: IndexSettings,
        forwardToReplicas: Bool? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdatedAtResponse {
        let response: Response<UpdatedAtResponse> = try await setSettingsWithHTTPInfo(
            indexName: indexName,
            indexSettings: indexSettings,
            forwardToReplicas: forwardToReplicas,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Update the specified [index settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/).
    // Specifying null for a setting resets it to its default value.
    // Required API Key ACLs:
    //  - editSettings
    //
    // - parameter indexName: (path) Index on which to perform the request.
    //
    // - parameter indexSettings: (body)
    //
    // - parameter forwardToReplicas: (query) Indicates whether changed index settings are forwarded to the replica
    // indices. (optional)
    // - returns: RequestBuilder<UpdatedAtResponse>

    open func setSettingsWithHTTPInfo(
        indexName: String,
        indexSettings: IndexSettings,
        forwardToReplicas: Bool? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdatedAtResponse> {
        guard !indexName.isEmpty else {
            throw AlgoliaError.invalidArgument("indexName", "setSettings")
        }

        var resourcePath = "/1/indexes/{indexName}/settings"
        let indexNamePreEscape = "\(APIHelper.mapValueToPathItem(indexName))"
        let indexNamePostEscape = indexNamePreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{indexName}",
            with: indexNamePostEscape,
            options: .literal,
            range: nil
        )
        let body = indexSettings
        let queryParameters = [
            "forwardToReplicas": forwardToReplicas?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter key: (path) API key.
    /// - parameter apiKey: (body)
    /// - returns: UpdateApiKeyResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func updateApiKey(
        key: String,
        apiKey: ApiKey,
        requestOptions: RequestOptions? = nil
    ) async throws -> UpdateApiKeyResponse {
        let response: Response<UpdateApiKeyResponse> = try await updateApiKeyWithHTTPInfo(
            key: key,
            apiKey: apiKey,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Replace the permissions of an existing API key. Any unspecified parameter resets that permission to its default
    // value. The request must be authenticated with the admin API key.
    // Required API Key ACLs:
    //  - admin
    //
    // - parameter key: (path) API key.
    //
    // - parameter apiKey: (body)
    // - returns: RequestBuilder<UpdateApiKeyResponse>

    open func updateApiKeyWithHTTPInfo(
        key: String,
        apiKey: ApiKey,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<UpdateApiKeyResponse> {
        guard !key.isEmpty else {
            throw AlgoliaError.invalidArgument("key", "updateApiKey")
        }

        var resourcePath = "/1/keys/{key}"
        let keyPreEscape = "\(APIHelper.mapValueToPathItem(key))"
        let keyPostEscape = keyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{key}",
            with: keyPostEscape,
            options: .literal,
            range: nil
        )
        let body = apiKey
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }
}
