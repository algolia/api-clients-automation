// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on
// https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import Foundation
#if canImport(Core)
    import Core
#endif

open class IngestionClient {
    private var configuration: IngestionClientConfiguration
    private var transporter: Transporter

    var appID: String {
        self.configuration.appID
    }

    public init(configuration: IngestionClientConfiguration, transporter: Transporter) {
        self.configuration = configuration
        self.transporter = transporter
    }

    public convenience init(configuration: IngestionClientConfiguration) {
        self.init(configuration: configuration, transporter: Transporter(configuration: configuration))
    }

    public convenience init(appID: String, apiKey: String, region: Region) throws {
        try self.init(configuration: IngestionClientConfiguration(appID: appID, apiKey: apiKey, region: region))
    }

    /// - parameter authenticationCreate: (body)
    /// - returns: AuthenticationCreateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func createAuthentication(
        authenticationCreate: AuthenticationCreate,
        requestOptions: RequestOptions? = nil
    ) async throws -> AuthenticationCreateResponse {
        let response: Response<AuthenticationCreateResponse> = try await createAuthenticationWithHTTPInfo(
            authenticationCreate: authenticationCreate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Creates a new authentication resource.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter authenticationCreate: (body)
    // - returns: RequestBuilder<AuthenticationCreateResponse>

    open func createAuthenticationWithHTTPInfo(
        authenticationCreate: AuthenticationCreate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AuthenticationCreateResponse> {
        let resourcePath = "/1/authentications"
        let body = authenticationCreate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter destinationCreate: (body)
    /// - returns: DestinationCreateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func createDestination(
        destinationCreate: DestinationCreate,
        requestOptions: RequestOptions? = nil
    ) async throws -> DestinationCreateResponse {
        let response: Response<DestinationCreateResponse> = try await createDestinationWithHTTPInfo(
            destinationCreate: destinationCreate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Creates a new destination.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter destinationCreate: (body)
    // - returns: RequestBuilder<DestinationCreateResponse>

    open func createDestinationWithHTTPInfo(
        destinationCreate: DestinationCreate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DestinationCreateResponse> {
        let resourcePath = "/1/destinations"
        let body = destinationCreate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter sourceCreate: (body)
    /// - returns: SourceCreateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func createSource(
        sourceCreate: SourceCreate,
        requestOptions: RequestOptions? = nil
    ) async throws -> SourceCreateResponse {
        let response: Response<SourceCreateResponse> = try await createSourceWithHTTPInfo(
            sourceCreate: sourceCreate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Creates a new source.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter sourceCreate: (body)
    // - returns: RequestBuilder<SourceCreateResponse>

    open func createSourceWithHTTPInfo(
        sourceCreate: SourceCreate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SourceCreateResponse> {
        let resourcePath = "/1/sources"
        let body = sourceCreate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter taskCreate: (body) Request body for creating a task.
    /// - returns: TaskCreateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func createTask(
        taskCreate: TaskCreate,
        requestOptions: RequestOptions? = nil
    ) async throws -> TaskCreateResponse {
        let response: Response<TaskCreateResponse> = try await createTaskWithHTTPInfo(
            taskCreate: taskCreate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Creates a new task.
    //
    //
    // - parameter taskCreate: (body) Request body for creating a task.
    // - returns: RequestBuilder<TaskCreateResponse>

    open func createTaskWithHTTPInfo(
        taskCreate: TaskCreate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TaskCreateResponse> {
        let resourcePath = "/1/tasks"
        let body = taskCreate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    /// - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func customDelete(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await customDeleteWithHTTPInfo(
            path: path,
            parameters: parameters,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This method allow you to send requests to the Algolia REST API.
    //
    //
    // - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    //
    // - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func customDeleteWithHTTPInfo(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !path.isEmpty else {
            throw AlgoliaError.invalidArgument("path", "customDelete")
        }

        var resourcePath = "/{path}"
        let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
        resourcePath = resourcePath.replacingOccurrences(
            of: "{path}",
            with: pathPreEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: AnyCodable]? = parameters

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    /// - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func customGet(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await customGetWithHTTPInfo(
            path: path,
            parameters: parameters,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This method allow you to send requests to the Algolia REST API.
    //
    //
    // - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    //
    // - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func customGetWithHTTPInfo(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !path.isEmpty else {
            throw AlgoliaError.invalidArgument("path", "customGet")
        }

        var resourcePath = "/{path}"
        let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
        resourcePath = resourcePath.replacingOccurrences(
            of: "{path}",
            with: pathPreEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: AnyCodable]? = parameters

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    /// - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    /// - parameter body: (body) Parameters to send with the custom request. (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func customPost(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        body: Codable? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await customPostWithHTTPInfo(
            path: path,
            parameters: parameters,
            body: body,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This method allow you to send requests to the Algolia REST API.
    //
    //
    // - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    //
    // - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    //
    // - parameter body: (body) Parameters to send with the custom request. (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func customPostWithHTTPInfo(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        body: Codable? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !path.isEmpty else {
            throw AlgoliaError.invalidArgument("path", "customPost")
        }

        var resourcePath = "/{path}"
        let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
        resourcePath = resourcePath.replacingOccurrences(
            of: "{path}",
            with: pathPreEscape,
            options: .literal,
            range: nil
        )
        let body = body
        let queryParameters: [String: AnyCodable]? = parameters

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    /// - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    /// - parameter body: (body) Parameters to send with the custom request. (optional)
    /// - returns: AnyCodable
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func customPut(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        body: Codable? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> AnyCodable {
        let response: Response<AnyCodable> = try await customPutWithHTTPInfo(
            path: path,
            parameters: parameters,
            body: body,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // This method allow you to send requests to the Algolia REST API.
    //
    //
    // - parameter path: (path) Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    //
    // - parameter parameters: (query) Query parameters to apply to the current query. (optional)
    //
    // - parameter body: (body) Parameters to send with the custom request. (optional)
    // - returns: RequestBuilder<AnyCodable>

    open func customPutWithHTTPInfo(
        path: String,
        parameters: [String: AnyCodable]? = nil,
        body: Codable? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AnyCodable> {
        guard !path.isEmpty else {
            throw AlgoliaError.invalidArgument("path", "customPut")
        }

        var resourcePath = "/{path}"
        let pathPreEscape = "\(APIHelper.mapValueToPathItem(path))"
        resourcePath = resourcePath.replacingOccurrences(
            of: "{path}",
            with: pathPreEscape,
            options: .literal,
            range: nil
        )
        let body = body
        let queryParameters: [String: AnyCodable]? = parameters

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body ?? AnyCodable(),
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter authenticationID: (path) Unique identifier of an authentication resource.
    /// - returns: DeleteResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteAuthentication(
        authenticationID: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> DeleteResponse {
        let response: Response<DeleteResponse> = try await deleteAuthenticationWithHTTPInfo(
            authenticationID: authenticationID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes an authentication resource. You can't delete authentication resources that are used by a source or a
    // destination.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter authenticationID: (path) Unique identifier of an authentication resource.
    // - returns: RequestBuilder<DeleteResponse>

    open func deleteAuthenticationWithHTTPInfo(
        authenticationID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeleteResponse> {
        guard !authenticationID.isEmpty else {
            throw AlgoliaError.invalidArgument("authenticationID", "deleteAuthentication")
        }

        var resourcePath = "/1/authentications/{authenticationID}"
        let authenticationIDPreEscape = "\(APIHelper.mapValueToPathItem(authenticationID))"
        let authenticationIDPostEscape = authenticationIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{authenticationID}",
            with: authenticationIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter destinationID: (path) Unique identifier of a destination.
    /// - returns: DeleteResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteDestination(
        destinationID: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> DeleteResponse {
        let response: Response<DeleteResponse> = try await deleteDestinationWithHTTPInfo(
            destinationID: destinationID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter destinationID: (path) Unique identifier of a destination.
    // - returns: RequestBuilder<DeleteResponse>

    open func deleteDestinationWithHTTPInfo(
        destinationID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeleteResponse> {
        guard !destinationID.isEmpty else {
            throw AlgoliaError.invalidArgument("destinationID", "deleteDestination")
        }

        var resourcePath = "/1/destinations/{destinationID}"
        let destinationIDPreEscape = "\(APIHelper.mapValueToPathItem(destinationID))"
        let destinationIDPostEscape = destinationIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{destinationID}",
            with: destinationIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter sourceID: (path) Unique identifier of a source.
    /// - returns: DeleteResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteSource(sourceID: String, requestOptions: RequestOptions? = nil) async throws -> DeleteResponse {
        let response: Response<DeleteResponse> = try await deleteSourceWithHTTPInfo(
            sourceID: sourceID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes a source by its ID. You can't delete sources that are referenced in tasks.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter sourceID: (path) Unique identifier of a source.
    // - returns: RequestBuilder<DeleteResponse>

    open func deleteSourceWithHTTPInfo(
        sourceID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeleteResponse> {
        guard !sourceID.isEmpty else {
            throw AlgoliaError.invalidArgument("sourceID", "deleteSource")
        }

        var resourcePath = "/1/sources/{sourceID}"
        let sourceIDPreEscape = "\(APIHelper.mapValueToPathItem(sourceID))"
        let sourceIDPostEscape = sourceIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{sourceID}",
            with: sourceIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: DeleteResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func deleteTask(taskID: String, requestOptions: RequestOptions? = nil) async throws -> DeleteResponse {
        let response: Response<DeleteResponse> = try await deleteTaskWithHTTPInfo(
            taskID: taskID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Deletes a task by its ID.
    //
    //
    // - parameter taskID: (path) Unique identifier of a task.
    // - returns: RequestBuilder<DeleteResponse>

    open func deleteTaskWithHTTPInfo(
        taskID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DeleteResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "deleteTask")
        }

        var resourcePath = "/1/tasks/{taskID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "DELETE",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: TaskUpdateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func disableTask(taskID: String, requestOptions: RequestOptions? = nil) async throws -> TaskUpdateResponse {
        let response: Response<TaskUpdateResponse> = try await disableTaskWithHTTPInfo(
            taskID: taskID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Disables a task.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter taskID: (path) Unique identifier of a task.
    // - returns: RequestBuilder<TaskUpdateResponse>

    open func disableTaskWithHTTPInfo(
        taskID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TaskUpdateResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "disableTask")
        }

        var resourcePath = "/1/tasks/{taskID}/disable"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: TaskUpdateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func enableTask(taskID: String, requestOptions: RequestOptions? = nil) async throws -> TaskUpdateResponse {
        let response: Response<TaskUpdateResponse> = try await enableTaskWithHTTPInfo(
            taskID: taskID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Enables a task.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter taskID: (path) Unique identifier of a task.
    // - returns: RequestBuilder<TaskUpdateResponse>

    open func enableTaskWithHTTPInfo(
        taskID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TaskUpdateResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "enableTask")
        }

        var resourcePath = "/1/tasks/{taskID}/enable"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PUT",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter authenticationID: (path) Unique identifier of an authentication resource.
    /// - returns: Authentication
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getAuthentication(
        authenticationID: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> Authentication {
        let response: Response<Authentication> = try await getAuthenticationWithHTTPInfo(
            authenticationID: authenticationID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves an authentication resource by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter authenticationID: (path) Unique identifier of an authentication resource.
    // - returns: RequestBuilder<Authentication>

    open func getAuthenticationWithHTTPInfo(
        authenticationID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<Authentication> {
        guard !authenticationID.isEmpty else {
            throw AlgoliaError.invalidArgument("authenticationID", "getAuthentication")
        }

        var resourcePath = "/1/authentications/{authenticationID}"
        let authenticationIDPreEscape = "\(APIHelper.mapValueToPathItem(authenticationID))"
        let authenticationIDPostEscape = authenticationIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{authenticationID}",
            with: authenticationIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    /// - parameter page: (query) Page number of the paginated API response. (optional)
    /// - parameter type: (query) Type of authentication resource to retrieve. (optional)
    /// - parameter platform: (query) Ecommerce platform for which to retrieve authentication resources. (optional)
    /// - parameter sort: (query) Property by which to sort the list of authentication resources. (optional)
    /// - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    /// - returns: ListAuthenticationsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getAuthentications(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        type: [AuthenticationType]? = nil,
        platform: [PlatformWithNone]? = nil,
        sort: AuthenticationSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> ListAuthenticationsResponse {
        let response: Response<ListAuthenticationsResponse> = try await getAuthenticationsWithHTTPInfo(
            itemsPerPage: itemsPerPage,
            page: page,
            type: type,
            platform: platform,
            sort: sort,
            order: order,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a list of all authentication resources.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    //
    // - parameter page: (query) Page number of the paginated API response. (optional)
    //
    // - parameter type: (query) Type of authentication resource to retrieve. (optional)
    //
    // - parameter platform: (query) Ecommerce platform for which to retrieve authentication resources. (optional)
    //
    // - parameter sort: (query) Property by which to sort the list of authentication resources. (optional)
    //
    // - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    // - returns: RequestBuilder<ListAuthenticationsResponse>

    open func getAuthenticationsWithHTTPInfo(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        type: [AuthenticationType]? = nil,
        platform: [PlatformWithNone]? = nil,
        sort: AuthenticationSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ListAuthenticationsResponse> {
        let resourcePath = "/1/authentications"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "itemsPerPage": itemsPerPage?.encodeToJSON(),
            "page": page?.encodeToJSON(),
            "type": type?.encodeToJSON(),
            "platform": platform?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "order": order?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter destinationID: (path) Unique identifier of a destination.
    /// - returns: Destination
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getDestination(destinationID: String, requestOptions: RequestOptions? = nil) async throws -> Destination {
        let response: Response<Destination> = try await getDestinationWithHTTPInfo(
            destinationID: destinationID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a destination by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter destinationID: (path) Unique identifier of a destination.
    // - returns: RequestBuilder<Destination>

    open func getDestinationWithHTTPInfo(
        destinationID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<Destination> {
        guard !destinationID.isEmpty else {
            throw AlgoliaError.invalidArgument("destinationID", "getDestination")
        }

        var resourcePath = "/1/destinations/{destinationID}"
        let destinationIDPreEscape = "\(APIHelper.mapValueToPathItem(destinationID))"
        let destinationIDPostEscape = destinationIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{destinationID}",
            with: destinationIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    /// - parameter page: (query) Page number of the paginated API response. (optional)
    /// - parameter type: (query) Destination type. (optional)
    /// - parameter authenticationID: (query) Authentication ID used by destinations. (optional)
    /// - parameter sort: (query) Property by which to sort the destinations. (optional)
    /// - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    /// - returns: ListDestinationsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getDestinations(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        type: [DestinationType]? = nil,
        authenticationID: [String]? = nil,
        sort: DestinationSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> ListDestinationsResponse {
        let response: Response<ListDestinationsResponse> = try await getDestinationsWithHTTPInfo(
            itemsPerPage: itemsPerPage,
            page: page,
            type: type,
            authenticationID: authenticationID,
            sort: sort,
            order: order,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a list of destinations.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    //
    // - parameter page: (query) Page number of the paginated API response. (optional)
    //
    // - parameter type: (query) Destination type. (optional)
    //
    // - parameter authenticationID: (query) Authentication ID used by destinations. (optional)
    //
    // - parameter sort: (query) Property by which to sort the destinations. (optional)
    //
    // - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    // - returns: RequestBuilder<ListDestinationsResponse>

    open func getDestinationsWithHTTPInfo(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        type: [DestinationType]? = nil,
        authenticationID: [String]? = nil,
        sort: DestinationSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ListDestinationsResponse> {
        let resourcePath = "/1/destinations"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "itemsPerPage": itemsPerPage?.encodeToJSON(),
            "page": page?.encodeToJSON(),
            "type": type?.encodeToJSON(),
            "authenticationID": authenticationID?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "order": order?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter sourceID: (path) Unique identifier of a source.
    /// - returns: DockerSourceStreams
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getDockerSourceStreams(
        sourceID: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> DockerSourceStreams {
        let response: Response<DockerSourceStreams> = try await getDockerSourceStreamsWithHTTPInfo(
            sourceID: sourceID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a stream listing for a source.  Listing streams only works with sources with `type: docker` and
    // `imageType: singer`.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter sourceID: (path) Unique identifier of a source.
    // - returns: RequestBuilder<DockerSourceStreams>

    open func getDockerSourceStreamsWithHTTPInfo(
        sourceID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DockerSourceStreams> {
        guard !sourceID.isEmpty else {
            throw AlgoliaError.invalidArgument("sourceID", "getDockerSourceStreams")
        }

        var resourcePath = "/1/sources/{sourceID}/discover"
        let sourceIDPreEscape = "\(APIHelper.mapValueToPathItem(sourceID))"
        let sourceIDPostEscape = sourceIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{sourceID}",
            with: sourceIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter runID: (path) Unique identifier of a task run.
    /// - parameter eventID: (path) Unique identifier of an event.
    /// - returns: Event
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getEvent(runID: String, eventID: String, requestOptions: RequestOptions? = nil) async throws -> Event {
        let response: Response<Event> = try await getEventWithHTTPInfo(
            runID: runID,
            eventID: eventID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a single task run event by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter runID: (path) Unique identifier of a task run.
    //
    // - parameter eventID: (path) Unique identifier of an event.
    // - returns: RequestBuilder<Event>

    open func getEventWithHTTPInfo(
        runID: String,
        eventID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<Event> {
        guard !runID.isEmpty else {
            throw AlgoliaError.invalidArgument("runID", "getEvent")
        }

        guard !eventID.isEmpty else {
            throw AlgoliaError.invalidArgument("eventID", "getEvent")
        }

        var resourcePath = "/1/runs/{runID}/events/{eventID}"
        let runIDPreEscape = "\(APIHelper.mapValueToPathItem(runID))"
        let runIDPostEscape = runIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{runID}",
            with: runIDPostEscape,
            options: .literal,
            range: nil
        )
        let eventIDPreEscape = "\(APIHelper.mapValueToPathItem(eventID))"
        let eventIDPostEscape = eventIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{eventID}",
            with: eventIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter runID: (path) Unique identifier of a task run.
    /// - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    /// - parameter page: (query) Page number of the paginated API response. (optional)
    /// - parameter status: (query) Event status for filtering the list of task runs. (optional)
    /// - parameter type: (query) Event type for filtering the list of task runs. (optional)
    /// - parameter sort: (query) Property by which to sort the list of task run events. (optional)
    /// - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    /// - parameter startDate: (query) Date and time in RFC3339 format for the earliest events to retrieve. By default,
    /// the current time minus three hours is used. (optional)
    /// - parameter endDate: (query) Date and time in RFC3339 format for the latest events to retrieve. By default, the
    /// current time is used. (optional)
    /// - returns: ListEventsResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getEvents(
        runID: String,
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        status: [EventStatus]? = nil,
        type: [EventType]? = nil,
        sort: EventSortKeys? = nil,
        order: OrderKeys? = nil,
        startDate: String? = nil,
        endDate: String? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> ListEventsResponse {
        let response: Response<ListEventsResponse> = try await getEventsWithHTTPInfo(
            runID: runID,
            itemsPerPage: itemsPerPage,
            page: page,
            status: status,
            type: type,
            sort: sort,
            order: order,
            startDate: startDate,
            endDate: endDate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a list of events for a task run, identified by it's ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter runID: (path) Unique identifier of a task run.
    //
    // - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    //
    // - parameter page: (query) Page number of the paginated API response. (optional)
    //
    // - parameter status: (query) Event status for filtering the list of task runs. (optional)
    //
    // - parameter type: (query) Event type for filtering the list of task runs. (optional)
    //
    // - parameter sort: (query) Property by which to sort the list of task run events. (optional)
    //
    // - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    //
    // - parameter startDate: (query) Date and time in RFC3339 format for the earliest events to retrieve. By default,
    // the current time minus three hours is used. (optional)
    //
    // - parameter endDate: (query) Date and time in RFC3339 format for the latest events to retrieve. By default, the
    // current time is used. (optional)
    // - returns: RequestBuilder<ListEventsResponse>

    open func getEventsWithHTTPInfo(
        runID: String,
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        status: [EventStatus]? = nil,
        type: [EventType]? = nil,
        sort: EventSortKeys? = nil,
        order: OrderKeys? = nil,
        startDate: String? = nil,
        endDate: String? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ListEventsResponse> {
        guard !runID.isEmpty else {
            throw AlgoliaError.invalidArgument("runID", "getEvents")
        }

        var resourcePath = "/1/runs/{runID}/events"
        let runIDPreEscape = "\(APIHelper.mapValueToPathItem(runID))"
        let runIDPostEscape = runIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{runID}",
            with: runIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "itemsPerPage": itemsPerPage?.encodeToJSON(),
            "page": page?.encodeToJSON(),
            "status": status?.encodeToJSON(),
            "type": type?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "order": order?.encodeToJSON(),
            "startDate": startDate?.encodeToJSON(),
            "endDate": endDate?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter runID: (path) Unique identifier of a task run.
    /// - returns: Run
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getRun(runID: String, requestOptions: RequestOptions? = nil) async throws -> Run {
        let response: Response<Run> = try await getRunWithHTTPInfo(runID: runID, requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieve a single task run by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter runID: (path) Unique identifier of a task run.
    // - returns: RequestBuilder<Run>

    open func getRunWithHTTPInfo(
        runID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<Run> {
        guard !runID.isEmpty else {
            throw AlgoliaError.invalidArgument("runID", "getRun")
        }

        var resourcePath = "/1/runs/{runID}"
        let runIDPreEscape = "\(APIHelper.mapValueToPathItem(runID))"
        let runIDPostEscape = runIDPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{runID}",
            with: runIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    /// - parameter page: (query) Page number of the paginated API response. (optional)
    /// - parameter status: (query) Run status for filtering the list of task runs. (optional)
    /// - parameter taskID: (query) Task ID for filtering the list of task runs. (optional)
    /// - parameter sort: (query) Property by which to sort the list of task runs. (optional)
    /// - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    /// - parameter startDate: (query) Date in RFC3339 format for the earliest run to retrieve. By default, the current
    /// day minus seven days is used. (optional)
    /// - parameter endDate: (query) Date in RFC3339 format for the latest run to retrieve. By default, the current day
    /// is used. (optional)
    /// - returns: RunListResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getRuns(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        status: [RunStatus]? = nil,
        taskID: String? = nil,
        sort: RunSortKeys? = nil,
        order: OrderKeys? = nil,
        startDate: String? = nil,
        endDate: String? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> RunListResponse {
        let response: Response<RunListResponse> = try await getRunsWithHTTPInfo(
            itemsPerPage: itemsPerPage,
            page: page,
            status: status,
            taskID: taskID,
            sort: sort,
            order: order,
            startDate: startDate,
            endDate: endDate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieve a list of task runs.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    //
    // - parameter page: (query) Page number of the paginated API response. (optional)
    //
    // - parameter status: (query) Run status for filtering the list of task runs. (optional)
    //
    // - parameter taskID: (query) Task ID for filtering the list of task runs. (optional)
    //
    // - parameter sort: (query) Property by which to sort the list of task runs. (optional)
    //
    // - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    //
    // - parameter startDate: (query) Date in RFC3339 format for the earliest run to retrieve. By default, the current
    // day minus seven days is used. (optional)
    //
    // - parameter endDate: (query) Date in RFC3339 format for the latest run to retrieve. By default, the current day
    // is used. (optional)
    // - returns: RequestBuilder<RunListResponse>

    open func getRunsWithHTTPInfo(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        status: [RunStatus]? = nil,
        taskID: String? = nil,
        sort: RunSortKeys? = nil,
        order: OrderKeys? = nil,
        startDate: String? = nil,
        endDate: String? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<RunListResponse> {
        let resourcePath = "/1/runs"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "itemsPerPage": itemsPerPage?.encodeToJSON(),
            "page": page?.encodeToJSON(),
            "status": status?.encodeToJSON(),
            "taskID": taskID?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "order": order?.encodeToJSON(),
            "startDate": startDate?.encodeToJSON(),
            "endDate": endDate?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter sourceID: (path) Unique identifier of a source.
    /// - returns: IngestionSource
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getSource(sourceID: String, requestOptions: RequestOptions? = nil) async throws -> IngestionSource {
        let response: Response<IngestionSource> = try await getSourceWithHTTPInfo(
            sourceID: sourceID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieve a source by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter sourceID: (path) Unique identifier of a source.
    // - returns: RequestBuilder<IngestionSource>

    open func getSourceWithHTTPInfo(
        sourceID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<IngestionSource> {
        guard !sourceID.isEmpty else {
            throw AlgoliaError.invalidArgument("sourceID", "getSource")
        }

        var resourcePath = "/1/sources/{sourceID}"
        let sourceIDPreEscape = "\(APIHelper.mapValueToPathItem(sourceID))"
        let sourceIDPostEscape = sourceIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{sourceID}",
            with: sourceIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    /// - parameter page: (query) Page number of the paginated API response. (optional)
    /// - parameter type: (query) Source type. Some sources require authentication. (optional)
    /// - parameter authenticationID: (query) Authentication IDs of the sources to retrieve. &#39;none&#39; returns
    /// sources that doesn&#39;t have an authentication resource.  (optional)
    /// - parameter sort: (query) Property by which to sort the list of sources. (optional)
    /// - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    /// - returns: ListSourcesResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getSources(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        type: [SourceType]? = nil,
        authenticationID: [String]? = nil,
        sort: SourceSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> ListSourcesResponse {
        let response: Response<ListSourcesResponse> = try await getSourcesWithHTTPInfo(
            itemsPerPage: itemsPerPage,
            page: page,
            type: type,
            authenticationID: authenticationID,
            sort: sort,
            order: order,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a list of sources.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    //
    // - parameter page: (query) Page number of the paginated API response. (optional)
    //
    // - parameter type: (query) Source type. Some sources require authentication. (optional)
    //
    // - parameter authenticationID: (query) Authentication IDs of the sources to retrieve. &#39;none&#39; returns
    // sources that doesn&#39;t have an authentication resource.  (optional)
    //
    // - parameter sort: (query) Property by which to sort the list of sources. (optional)
    //
    // - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    // - returns: RequestBuilder<ListSourcesResponse>

    open func getSourcesWithHTTPInfo(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        type: [SourceType]? = nil,
        authenticationID: [String]? = nil,
        sort: SourceSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ListSourcesResponse> {
        let resourcePath = "/1/sources"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "itemsPerPage": itemsPerPage?.encodeToJSON(),
            "page": page?.encodeToJSON(),
            "type": type?.encodeToJSON(),
            "authenticationID": authenticationID?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "order": order?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: Task
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getTask(taskID: String, requestOptions: RequestOptions? = nil) async throws -> Task {
        let response: Response<Task> = try await getTaskWithHTTPInfo(taskID: taskID, requestOptions: requestOptions)

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a task by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter taskID: (path) Unique identifier of a task.
    // - returns: RequestBuilder<Task>

    open func getTaskWithHTTPInfo(
        taskID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<Task> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "getTask")
        }

        var resourcePath = "/1/tasks/{taskID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    /// - parameter page: (query) Page number of the paginated API response. (optional)
    /// - parameter action: (query) Actions for filtering the list of tasks. (optional)
    /// - parameter enabled: (query) Whether to filter the list of tasks by the &#x60;enabled&#x60; status. (optional)
    /// - parameter sourceID: (query) Source IDs for filtering the list of tasks. (optional)
    /// - parameter destinationID: (query) Destination IDs for filtering the list of tasks. (optional)
    /// - parameter triggerType: (query) Type of task trigger for filtering the list of tasks. (optional)
    /// - parameter sort: (query) Property by which to sort the list of tasks. (optional)
    /// - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    /// - returns: ListTasksResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func getTasks(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        action: [ActionType]? = nil,
        enabled: Bool? = nil,
        sourceID: [String]? = nil,
        destinationID: [String]? = nil,
        triggerType: [TriggerType]? = nil,
        sort: TaskSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions: RequestOptions? = nil
    ) async throws -> ListTasksResponse {
        let response: Response<ListTasksResponse> = try await getTasksWithHTTPInfo(
            itemsPerPage: itemsPerPage,
            page: page,
            action: action,
            enabled: enabled,
            sourceID: sourceID,
            destinationID: destinationID,
            triggerType: triggerType,
            sort: sort,
            order: order,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Retrieves a list of tasks.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter itemsPerPage: (query) Number of items per page. (optional, default to 10)
    //
    // - parameter page: (query) Page number of the paginated API response. (optional)
    //
    // - parameter action: (query) Actions for filtering the list of tasks. (optional)
    //
    // - parameter enabled: (query) Whether to filter the list of tasks by the &#x60;enabled&#x60; status. (optional)
    //
    // - parameter sourceID: (query) Source IDs for filtering the list of tasks. (optional)
    //
    // - parameter destinationID: (query) Destination IDs for filtering the list of tasks. (optional)
    //
    // - parameter triggerType: (query) Type of task trigger for filtering the list of tasks. (optional)
    //
    // - parameter sort: (query) Property by which to sort the list of tasks. (optional)
    //
    // - parameter order: (query) Sort order of the response, ascending or descending. (optional)
    // - returns: RequestBuilder<ListTasksResponse>

    open func getTasksWithHTTPInfo(
        itemsPerPage: Int? = nil,
        page: Int? = nil,
        action: [ActionType]? = nil,
        enabled: Bool? = nil,
        sourceID: [String]? = nil,
        destinationID: [String]? = nil,
        triggerType: [TriggerType]? = nil,
        sort: TaskSortKeys? = nil,
        order: OrderKeys? = nil,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<ListTasksResponse> {
        let resourcePath = "/1/tasks"
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?] = [
            "itemsPerPage": itemsPerPage?.encodeToJSON(),
            "page": page?.encodeToJSON(),
            "action": action?.encodeToJSON(),
            "enabled": enabled?.encodeToJSON(),
            "sourceID": sourceID?.encodeToJSON(),
            "destinationID": destinationID?.encodeToJSON(),
            "triggerType": triggerType?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "order": order?.encodeToJSON(),
        ]

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "GET",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - returns: RunResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func runTask(taskID: String, requestOptions: RequestOptions? = nil) async throws -> RunResponse {
        let response: Response<RunResponse> = try await runTaskWithHTTPInfo(
            taskID: taskID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Runs a task. You can check the status of task runs with the observability endpoints.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter taskID: (path) Unique identifier of a task.
    // - returns: RequestBuilder<RunResponse>

    open func runTaskWithHTTPInfo(
        taskID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<RunResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "runTask")
        }

        var resourcePath = "/1/tasks/{taskID}/run"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter authenticationSearch: (body)
    /// - returns: [Authentication]
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchAuthentications(
        authenticationSearch: AuthenticationSearch,
        requestOptions: RequestOptions? = nil
    ) async throws -> [Authentication] {
        let response: Response<[Authentication]> = try await searchAuthenticationsWithHTTPInfo(
            authenticationSearch: authenticationSearch,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Searches for authentication resources.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter authenticationSearch: (body)
    // - returns: RequestBuilder<[Authentication]>

    open func searchAuthenticationsWithHTTPInfo(
        authenticationSearch: AuthenticationSearch,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<[Authentication]> {
        let resourcePath = "/1/authentications/search"
        let body = authenticationSearch
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter destinationSearch: (body)
    /// - returns: [Destination]
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchDestinations(
        destinationSearch: DestinationSearch,
        requestOptions: RequestOptions? = nil
    ) async throws -> [Destination] {
        let response: Response<[Destination]> = try await searchDestinationsWithHTTPInfo(
            destinationSearch: destinationSearch,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Searches for destinations.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter destinationSearch: (body)
    // - returns: RequestBuilder<[Destination]>

    open func searchDestinationsWithHTTPInfo(
        destinationSearch: DestinationSearch,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<[Destination]> {
        let resourcePath = "/1/destinations/search"
        let body = destinationSearch
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter sourceSearch: (body)
    /// - returns: [IngestionSource]
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchSources(
        sourceSearch: SourceSearch,
        requestOptions: RequestOptions? = nil
    ) async throws -> [IngestionSource] {
        let response: Response<[IngestionSource]> = try await searchSourcesWithHTTPInfo(
            sourceSearch: sourceSearch,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Searches for sources.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter sourceSearch: (body)
    // - returns: RequestBuilder<[IngestionSource]>

    open func searchSourcesWithHTTPInfo(
        sourceSearch: SourceSearch,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<[IngestionSource]> {
        let resourcePath = "/1/sources/search"
        let body = sourceSearch
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter taskSearch: (body)
    /// - returns: [Task]
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func searchTasks(taskSearch: TaskSearch, requestOptions: RequestOptions? = nil) async throws -> [Task] {
        let response: Response<[Task]> = try await searchTasksWithHTTPInfo(
            taskSearch: taskSearch,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Searches for tasks.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter taskSearch: (body)
    // - returns: RequestBuilder<[Task]>

    open func searchTasksWithHTTPInfo(
        taskSearch: TaskSearch,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<[Task]> {
        let resourcePath = "/1/tasks/search"
        let body = taskSearch
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter sourceID: (path) Unique identifier of a source.
    /// - returns: DockerSourceDiscover
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func triggerDockerSourceDiscover(
        sourceID: String,
        requestOptions: RequestOptions? = nil
    ) async throws -> DockerSourceDiscover {
        let response: Response<DockerSourceDiscover> = try await triggerDockerSourceDiscoverWithHTTPInfo(
            sourceID: sourceID,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Triggers a stream-listing request for a source. Triggering stream-listing requests only works with sources with
    // `type: docker` and `imageType: singer`.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter sourceID: (path) Unique identifier of a source.
    // - returns: RequestBuilder<DockerSourceDiscover>

    open func triggerDockerSourceDiscoverWithHTTPInfo(
        sourceID: String,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DockerSourceDiscover> {
        guard !sourceID.isEmpty else {
            throw AlgoliaError.invalidArgument("sourceID", "triggerDockerSourceDiscover")
        }

        var resourcePath = "/1/sources/{sourceID}/discover"
        let sourceIDPreEscape = "\(APIHelper.mapValueToPathItem(sourceID))"
        let sourceIDPostEscape = sourceIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{sourceID}",
            with: sourceIDPostEscape,
            options: .literal,
            range: nil
        )
        let body: AnyCodable? = nil
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "POST",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter authenticationID: (path) Unique identifier of an authentication resource.
    /// - parameter authenticationUpdate: (body)
    /// - returns: AuthenticationUpdateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func updateAuthentication(
        authenticationID: String,
        authenticationUpdate: AuthenticationUpdate,
        requestOptions: RequestOptions? = nil
    ) async throws -> AuthenticationUpdateResponse {
        let response: Response<AuthenticationUpdateResponse> = try await updateAuthenticationWithHTTPInfo(
            authenticationID: authenticationID,
            authenticationUpdate: authenticationUpdate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Updates an authentication resource.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter authenticationID: (path) Unique identifier of an authentication resource.
    //
    // - parameter authenticationUpdate: (body)
    // - returns: RequestBuilder<AuthenticationUpdateResponse>

    open func updateAuthenticationWithHTTPInfo(
        authenticationID: String,
        authenticationUpdate: AuthenticationUpdate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<AuthenticationUpdateResponse> {
        guard !authenticationID.isEmpty else {
            throw AlgoliaError.invalidArgument("authenticationID", "updateAuthentication")
        }

        var resourcePath = "/1/authentications/{authenticationID}"
        let authenticationIDPreEscape = "\(APIHelper.mapValueToPathItem(authenticationID))"
        let authenticationIDPostEscape = authenticationIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{authenticationID}",
            with: authenticationIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = authenticationUpdate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PATCH",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter destinationID: (path) Unique identifier of a destination.
    /// - parameter destinationUpdate: (body)
    /// - returns: DestinationUpdateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func updateDestination(
        destinationID: String,
        destinationUpdate: DestinationUpdate,
        requestOptions: RequestOptions? = nil
    ) async throws -> DestinationUpdateResponse {
        let response: Response<DestinationUpdateResponse> = try await updateDestinationWithHTTPInfo(
            destinationID: destinationID,
            destinationUpdate: destinationUpdate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Updates the destination by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter destinationID: (path) Unique identifier of a destination.
    //
    // - parameter destinationUpdate: (body)
    // - returns: RequestBuilder<DestinationUpdateResponse>

    open func updateDestinationWithHTTPInfo(
        destinationID: String,
        destinationUpdate: DestinationUpdate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<DestinationUpdateResponse> {
        guard !destinationID.isEmpty else {
            throw AlgoliaError.invalidArgument("destinationID", "updateDestination")
        }

        var resourcePath = "/1/destinations/{destinationID}"
        let destinationIDPreEscape = "\(APIHelper.mapValueToPathItem(destinationID))"
        let destinationIDPostEscape = destinationIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{destinationID}",
            with: destinationIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = destinationUpdate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PATCH",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter sourceID: (path) Unique identifier of a source.
    /// - parameter sourceUpdate: (body)
    /// - returns: SourceUpdateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func updateSource(
        sourceID: String,
        sourceUpdate: SourceUpdate,
        requestOptions: RequestOptions? = nil
    ) async throws -> SourceUpdateResponse {
        let response: Response<SourceUpdateResponse> = try await updateSourceWithHTTPInfo(
            sourceID: sourceID,
            sourceUpdate: sourceUpdate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Updates a source by its ID.
    // Required API Key ACLs:
    //  - addObject
    //  - deleteIndex
    //  - editSettings
    //
    // - parameter sourceID: (path) Unique identifier of a source.
    //
    // - parameter sourceUpdate: (body)
    // - returns: RequestBuilder<SourceUpdateResponse>

    open func updateSourceWithHTTPInfo(
        sourceID: String,
        sourceUpdate: SourceUpdate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<SourceUpdateResponse> {
        guard !sourceID.isEmpty else {
            throw AlgoliaError.invalidArgument("sourceID", "updateSource")
        }

        var resourcePath = "/1/sources/{sourceID}"
        let sourceIDPreEscape = "\(APIHelper.mapValueToPathItem(sourceID))"
        let sourceIDPostEscape = sourceIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{sourceID}",
            with: sourceIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = sourceUpdate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PATCH",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }

    /// - parameter taskID: (path) Unique identifier of a task.
    /// - parameter taskUpdate: (body)
    /// - returns: TaskUpdateResponse
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open func updateTask(
        taskID: String,
        taskUpdate: TaskUpdate,
        requestOptions: RequestOptions? = nil
    ) async throws -> TaskUpdateResponse {
        let response: Response<TaskUpdateResponse> = try await updateTaskWithHTTPInfo(
            taskID: taskID,
            taskUpdate: taskUpdate,
            requestOptions: requestOptions
        )

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

        return body
    }

    // Updates a task by its ID.
    //
    //
    // - parameter taskID: (path) Unique identifier of a task.
    //
    // - parameter taskUpdate: (body)
    // - returns: RequestBuilder<TaskUpdateResponse>

    open func updateTaskWithHTTPInfo(
        taskID: String,
        taskUpdate: TaskUpdate,
        requestOptions userRequestOptions: RequestOptions? = nil
    ) async throws -> Response<TaskUpdateResponse> {
        guard !taskID.isEmpty else {
            throw AlgoliaError.invalidArgument("taskID", "updateTask")
        }

        var resourcePath = "/1/tasks/{taskID}"
        let taskIDPreEscape = "\(APIHelper.mapValueToPathItem(taskID))"
        let taskIDPostEscape = taskIDPreEscape
            .addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""
        resourcePath = resourcePath.replacingOccurrences(
            of: "{taskID}",
            with: taskIDPostEscape,
            options: .literal,
            range: nil
        )
        let body = taskUpdate
        let queryParameters: [String: Any?]? = nil

        let nillableHeaders: [String: Any?]? = nil

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
            method: "PATCH",
            path: resourcePath,
            data: body,
            requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions
        )
    }
}
