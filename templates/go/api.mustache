{{{appDescription}}}
package {{packageName}}

// {{{generationBanner}}}

{{#operations}}
import (
	"context"
	"net/http"
	"net/url"
	"strings"
  {{#isSearchClient}}
  "github.com/algolia/algoliasearch-client-go/v4/algolia/errs"
  "cmp"
  "crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
  "errors"
  "slices"
  "sort"
  {{/isSearchClient}}
  "time"

  "github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type config struct {
	// -- Request options for API calls
	context      context.Context
	queryParams  url.Values
	headerParams map[string]string
  timeouts transport.RequestConfiguration

  {{#isSearchClient}}
  // -- ChunkedBatch options
	waitForTasks bool
	batchSize    int

  // -- Partial update options
  createIfNotExists bool

  // -- ReplaceAllObjects options
  scopes []ScopeType

	// -- Iterable options
	maxRetries    int
	timeout       func(int) time.Duration
	aggregator    func(any, error)

  // -- WaitForApiKey options
  apiKey *ApiKey
  {{/isSearchClient}}
}

type RequestOption interface {
	apply(*config)
}

type requestOption func(*config)

func (r requestOption) apply(c *config) {
	r(c)
}

func WithContext(ctx context.Context) requestOption {
	return requestOption(func(c *config) {
		c.context = ctx
	})
}

func WithHeaderParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.headerParams[key] = utils.ParameterToString(value)
	})
}

func WithQueryParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.queryParams.Set(utils.QueryParameterToString(key), utils.QueryParameterToString(value))
	})
}

func WithReadTimeout(timeout time.Duration) requestOption {
  return requestOption(func(c *config) {
    c.timeouts.ReadTimeout = &timeout
  })
}

func WithWriteTimeout(timeout time.Duration) requestOption {
  return requestOption(func(c *config) {
    c.timeouts.WriteTimeout = &timeout
  })
}

func WithConnectTimeout(timeout time.Duration) requestOption {
  return requestOption(func(c *config) {
    c.timeouts.ConnectTimeout = &timeout
  })
}

{{#isSearchClient}}

// --------- ChunkedBatch options ---------

type ChunkedBatchOption interface {
	RequestOption
	chunkedBatch()
}

type chunkedBatchOption func(*config)

var (
	_ ChunkedBatchOption = (*chunkedBatchOption)(nil)
	_ ChunkedBatchOption = (*requestOption)(nil)
)

func (c chunkedBatchOption) apply(conf *config) {
	c(conf)
}

func (c chunkedBatchOption) chunkedBatch() {}

func (r requestOption) chunkedBatch() {}

// WithWaitForTasks whether or not we should wait until every `batch` tasks has been processed, this operation may slow the total execution time of this method but is more reliable.
func WithWaitForTasks(waitForTasks bool) chunkedBatchOption {
	return chunkedBatchOption(func(c *config) {
		c.waitForTasks = waitForTasks
	})
}

// WithBatchSize the size of the chunk of `objects`. The number of `batch` calls will be equal to `length(objects) / batchSize`. Defaults to 1000.
func WithBatchSize(batchSize int) chunkedBatchOption {
	return chunkedBatchOption(func(c *config) {
		c.batchSize = batchSize
	})
}

// --------- PartialUpdateObjects options ---------

type PartialUpdateObjectsOption interface {
	ChunkedBatchOption
	partialUpdateObjects()
}

type partialUpdateObjectsOption func(*config)

var (
	_ PartialUpdateObjectsOption = (*partialUpdateObjectsOption)(nil)
  _ PartialUpdateObjectsOption = (*chunkedBatchOption)(nil)
	_ PartialUpdateObjectsOption = (*requestOption)(nil)
)

func (p partialUpdateObjectsOption) apply(c *config) {
	p(c)
}

func (p partialUpdateObjectsOption) partialUpdateObjects() {}

func (p partialUpdateObjectsOption) chunkedBatch() {}

func (c chunkedBatchOption) partialUpdateObjects() {}

func (r requestOption) partialUpdateObjects() {}

// WithCreateIfNotExists to be provided if non-existing objects are passed, otherwise, the call will fail.
func WithCreateIfNotExists(createIfNotExists bool) partialUpdateObjectsOption {
	return partialUpdateObjectsOption(func(c *config) {
		c.createIfNotExists = createIfNotExists
	})
}

// --------- ReplaceAllObjects options ---------

type ReplaceAllObjectsOption interface {
	ChunkedBatchOption
	replaceAllObjects()
}

type replaceAllObjectsOption func(*config)

var (
	_ ReplaceAllObjectsOption = (*replaceAllObjectsOption)(nil)
  _ ReplaceAllObjectsOption = (*chunkedBatchOption)(nil)
	_ ReplaceAllObjectsOption = (*requestOption)(nil)
)

func (p replaceAllObjectsOption) apply(c *config) {
	p(c)
}

func (p replaceAllObjectsOption) replaceAllObjects() {}

func (p replaceAllObjectsOption) chunkedBatch() {}

func (c chunkedBatchOption) replaceAllObjects() {}

func (r requestOption) replaceAllObjects() {}

// WithScopes the `scopes` to keep from the index. Defaults to ['settings', 'rules', 'synonyms'].
func WithScopes(scopes []ScopeType) replaceAllObjectsOption {
	return replaceAllObjectsOption(func(c *config) {
		c.scopes = scopes
	})
}

// --------- Iterable options ---------.

type IterableOption interface {
	RequestOption
	iterable()
}

type iterableOption func(*config)

var (
	_ IterableOption = (*iterableOption)(nil)
	_ IterableOption = (*requestOption)(nil)
)

func (i iterableOption) apply(c *config) {
	i(c)
}

func (r requestOption) iterable() {}

func (i iterableOption) iterable() {}

// WithMaxRetries the maximum number of retry. Default to 50.
func WithMaxRetries(maxRetries int) iterableOption {
	return iterableOption(func(c *config) {
		c.maxRetries = maxRetries
	})
}

// WithTimeout he function to decide how long to wait between retries. Default to min(retryCount * 200, 5000)
func WithTimeout(timeout func(int) time.Duration) iterableOption {
	return iterableOption(func(c *config) {
		c.timeout = timeout
	})
}

// WithAggregator the function to aggregate the results of the iterable.
func WithAggregator(aggregator func(any, error)) iterableOption {
	return iterableOption(func(c *config) {
		c.aggregator = aggregator
	})
}

// --------- WaitForKey options ---------.

type WaitForApiKeyOption interface {
	IterableOption
	waitForApiKey()
}

type waitForApiKeyOption func(*config)

var (
  _ WaitForApiKeyOption = (*waitForApiKeyOption)(nil)
	_ WaitForApiKeyOption = (*iterableOption)(nil)
	_ WaitForApiKeyOption = (*requestOption)(nil)
)

func (w waitForApiKeyOption) apply(c *config) {
	w(c)
}

func (w waitForApiKeyOption) waitForApiKey() {}

func (w waitForApiKeyOption) iterable() {}

func (r requestOption) waitForApiKey() {}

func (i iterableOption) waitForApiKey() {}

// WithApiKey necessary to know if an `update` operation has been processed, compare fields of the response with it. (optional - mandatory if operation is UPDATE)
func WithApiKey(apiKey *ApiKey) waitForApiKeyOption {
	return waitForApiKeyOption(func(c *config) {
		c.apiKey = apiKey
	})
}

// --------- Helper to convert options ---------

func toRequestOptions[T RequestOption](opts []T) []RequestOption {
	requestOpts := make([]RequestOption, 0, len(opts))

	for _, opt := range opts {
		requestOpts = append(requestOpts, opt)
	}

	return requestOpts
}

func toIterableOptions(opts []ChunkedBatchOption) []IterableOption {
	iterableOpts := make([]IterableOption, 0, len(opts))

	for _, opt := range opts {
		if opt, ok := opt.(IterableOption); ok {
			iterableOpts = append(iterableOpts, opt)
		}
	}

	return iterableOpts
}

func waitForApiKeyToIterableOptions(opts []WaitForApiKeyOption) []IterableOption {
	iterableOpts := make([]IterableOption, 0, len(opts))

	for _, opt := range opts {
		if opt, ok := opt.(IterableOption); ok {
			iterableOpts = append(iterableOpts, opt)
		}
	}

	return iterableOpts
}

func replaceAllObjectsToIterableOptions(opts []ReplaceAllObjectsOption) []IterableOption {
	iterableOpts := make([]IterableOption, 0, len(opts))

	for _, opt := range opts {
		if opt, ok := opt.(IterableOption); ok {
			iterableOpts = append(iterableOpts, opt)
		}
	}

	return iterableOpts
}

func partialUpdateObjectsToChunkedBatchOptions(opts []PartialUpdateObjectsOption) []ChunkedBatchOption {
	chunkedBatchOpts := make([]ChunkedBatchOption, 0, len(opts))

	for _, opt := range opts {
		if opt, ok := opt.(ChunkedBatchOption); ok {
			chunkedBatchOpts = append(chunkedBatchOpts, opt)
		}
	}

	return chunkedBatchOpts
}

func replaceAllObjectsToChunkBactchOptions(opts []ReplaceAllObjectsOption) []ChunkedBatchOption {
  chunkedBatchOpts := make([]ChunkedBatchOption, 0, len(opts))

  for _, opt := range opts {
    if opt, ok := opt.(ChunkedBatchOption); ok {
      chunkedBatchOpts = append(chunkedBatchOpts, opt)
    }
  }

  return chunkedBatchOpts
}
{{/isSearchClient}}

{{#operation}}
{{#hasOptionalParams}}
// {{operationId}}Options represents the optional params for the API call.
type {{operationId}}Options struct {
  {{#optionalParams}}
	{{nameInPascalCase}} {{^isPathParam}}{{^isFreeFormObject}}{{^isMap}}*{{/isMap}}{{/isFreeFormObject}}{{/isPathParam}}{{{dataType}}}
  {{/optionalParams}}
}

{{#isDeprecated}}
// Deprecated: {{operationId}}Options is deprecated
{{/isDeprecated}}
// New{{operationId}}Options creates an instance of the {{operationId}}Options used to add optional parameters to {{operationId}}WithOptions.
func New{{{operationId}}}Options() *{{operationId}}Options {
	return &{{operationId}}Options{}
}

{{#optionalParams}}
// With{{#lambda.titlecase}}{{baseName}}{{/lambda.titlecase}} {{#description}}{{{.}}}{{/description}}{{^description}}adds the {{paramName}} to the Api{{operationId}}Request and returns the request for chaining.{{/description}}
{{#isDeprecated}}
// Deprecated: With{{#lambda.titlecase}}{{baseName}}{{/lambda.titlecase}} is deprecated
{{/isDeprecated}}
func (o *{{operationId}}Options) With{{#lambda.titlecase}}{{baseName}}{{/lambda.titlecase}}({{paramName}} {{#isModel}}*{{/isModel}}{{{dataType}}}) *{{operationId}}Options {
	o.{{nameInPascalCase}} = {{^isModel}}{{^isMap}}&{{/isMap}}{{/isModel}}{{paramName}}
	return o
}
{{/optionalParams}}

{{/hasOptionalParams}}

// {{operationId}} {{{notes}}}
  {{#vendorExtensions}}
  {{#x-acl.0}}
//
// Required API Key ACLs:{{/x-acl.0}}
   {{#x-acl}}
//  - {{.}}
  {{/x-acl}}
  {{/vendorExtensions}}
  {{#hasParams}}
// Parameters:
  {{/hasParams}}
  {{#requiredParams}}
//  - {{paramName}} {{#description}} - {{{.}}}{{/description}}
  {{/requiredParams}}
  {{#optionalParams}}
//  - {{paramName}} {{#description}} - {{{.}}}{{/description}} (in optionalParams)
  {{/optionalParams}}
//  - opts - Optional parameters for the API call (e.g. WithContext, WithHeaderParam...)
  {{#isDeprecated}}
//
// Deprecated: {{operationId}} is deprecated
  {{/isDeprecated}}
func (c *APIClient) {{nickname}}({{#requiredParams}}{{paramName}} {{#required}}{{#isModel}}*{{/isModel}}{{/required}}{{^required}}*{{/required}}{{{dataType}}}, {{/requiredParams}}{{#hasOptionalParams}}optionalParams *{{operationId}}Options, {{/hasOptionalParams}}opts ...RequestOption) ({{#returnType}}{{^isArray}}{{^returnTypeIsPrimitive}}*{{/returnTypeIsPrimitive}}{{/isArray}}{{{.}}}, {{/returnType}}error) {
  {{#returnType}}
  var returnValue {{^isArray}}{{^returnTypeIsPrimitive}}*{{/returnTypeIsPrimitive}}{{/isArray}}{{{.}}}
  {{/returnType}}

  res, resBody, err := c.{{nickname}}WithHTTPInfo({{#requiredParams}}{{paramName}}, {{/requiredParams}}{{#hasOptionalParams}}optionalParams, {{/hasOptionalParams}}opts...)
  if err != nil {
		return {{#returnType}}returnValue, {{/returnType}}err
	}
  if res == nil {
    return {{#returnType}}returnValue, {{/returnType}}reportError("res is nil")
  }

	if res.StatusCode >= 300 {
			return {{#returnType}}returnValue, {{/returnType}}c.decodeError(res, resBody)
	}

	{{#returnType}}
	err = c.decode(&returnValue, resBody)
	if err != nil {
		return {{#returnType}}returnValue, {{/returnType}}reportError("cannot decode result: %w", err)
	}
	{{/returnType}}
	return {{#returnType}}returnValue, {{/returnType}}nil
}

// {{operationId}}WithHTTPInfo calls the API and returns the raw response from it.
// {{{notes}}}
  {{#vendorExtensions}}
  {{#x-acl.0}}
//
// Required API Key ACLs:{{/x-acl.0}}
   {{#x-acl}}
//  - {{.}}
  {{/x-acl}}
  {{/vendorExtensions}}
  {{#hasParams}}
//
// Parameters:
  {{/hasParams}}
  {{#requiredParams}}
//  - {{paramName}} {{#description}} - {{{.}}}{{/description}}
  {{/requiredParams}}
  {{#optionalParams}}
//  - {{paramName}} {{#description}} - {{{.}}}{{/description}} (in optionalParams)
  {{/optionalParams}}
//  - opts - Optional parameters for the API call (e.g. WithContext, WithHeaderParam...)
  {{#isDeprecated}}
//
// Deprecated: {{operationId}} is deprecated
  {{/isDeprecated}}
func (c *APIClient) {{nickname}}WithHTTPInfo({{#requiredParams}}{{paramName}} {{#required}}{{#isModel}}*{{/isModel}}{{/required}}{{^required}}*{{/required}}{{{dataType}}}, {{/requiredParams}}{{#hasOptionalParams}}optionalParams *{{operationId}}Options, {{/hasOptionalParams}}opts ...RequestOption) (*http.Response, []byte, error) {
  {{#vendorExtensions}}
  requestPath := "{{{path}}}"{{#pathParams}}
  requestPath = strings.ReplaceAll(requestPath, {{=<% %>=}}"{<%baseName%>}"<%={{ }}=%>, {{#x-is-custom-request}}utils.ParameterToString({{paramName}}){{/x-is-custom-request}}{{^x-is-custom-request}}url.PathEscape(utils.ParameterToString({{paramName}})){{/x-is-custom-request}}){{/pathParams}}
  {{/vendorExtensions}}

	{{#allParams}}
	{{#required}}
  {{#isString}}
	if {{paramName}} == "" { 
    return nil, nil, reportError("Parameter `{{paramName}}` is required when calling `{{operationId}}`.")
  }{{/isString}}{{#isContainer}}
  if len({{paramName}}) == 0 { 
    return nil, nil, reportError("Parameter `{{paramName}}` is required when calling `{{operationId}}`.")
  }{{/isContainer}}{{#isMap}}
  if len({{paramName}}) == 0 { 
    return nil, nil, reportError("Parameter `{{paramName}}` is required when calling `{{operationId}}`.")
  }{{/isMap}}{{^isPrimitiveType}}{{^isContainer}}{{^isMap}}{{^isEnumRef}}
  if {{paramName}} == nil {
	  return nil, nil, reportError("Parameter `{{paramName}}` is required when calling `{{operationId}}`.")
	}{{/isEnumRef}}{{/isMap}}{{/isContainer}}{{/isPrimitiveType}}
	{{/required}}
	{{/allParams}}

  conf := config{
    context:      context.Background(),
    queryParams:  url.Values{},
    headerParams: map[string]string{},
    {{#vendorExtensions.x-timeouts}}
    timeouts: transport.RequestConfiguration{
      ReadTimeout:  utils.ToPtr({{read}} * time.Millisecond),
      WriteTimeout: utils.ToPtr({{write}} * time.Millisecond),
      ConnectTimeout: utils.ToPtr({{connect}} * time.Millisecond),
    },
    {{/vendorExtensions.x-timeouts}}
  }

  {{#vendorExtensions.x-is-custom-request}}
    {{#queryParams}}
      {{^required}}if {{#hasOptionalParams}}optionalParams != nil && {{/hasOptionalParams}}!utils.IsNilOrEmpty({{> param_name}}) { {{/required}}
          for k, v := range {{> param_name}} {
           conf.queryParams.Set(k, utils.QueryParameterToString(v))
          }
      {{^required}} } {{/required}}
    {{/queryParams}}
  {{/vendorExtensions.x-is-custom-request}}
  {{^vendorExtensions.x-is-custom-request}}
	{{#queryParams}}
	{{#required}}
	conf.queryParams.Set("{{baseName}}", utils.QueryParameterToString({{^isFreeFormObject}}{{^isArray}}{{^isPrimitiveType}}{{^isEnumRef}}*{{/isEnumRef}}{{/isPrimitiveType}}{{/isArray}}{{/isFreeFormObject}}{{paramName}}))
	{{/required}}
  {{^required}}
  if {{#hasOptionalParams}}optionalParams != nil && {{/hasOptionalParams}}!utils.IsNilOrEmpty({{> param_name}}) {
    conf.queryParams.Set("{{baseName}}", utils.QueryParameterToString({{^isFreeFormObject}}{{^isArray}}{{^isEnumRef}}*{{/isEnumRef}}{{/isArray}}{{/isFreeFormObject}}{{> param_name}}))
  }
  {{/required}}
	{{/queryParams}}
  {{/vendorExtensions.x-is-custom-request}}
  {{#headerParams}}
	{{#required}}
	conf.headerParams["{{baseName}}"] = utils.ParameterToString({{^isFreeFormObject}}{{^isArray}}{{^isPrimitiveType}}{{^isEnumRef}}*{{/isEnumRef}}{{/isPrimitiveType}}{{/isArray}}{{/isFreeFormObject}}{{paramName}})
	{{/required}}
  {{^required}}
  if {{#hasOptionalParams}}optionalParams != nil && {{/hasOptionalParams}}!utils.IsNilOrEmpty({{> param_name}}) {
    conf.headerParams["{{baseName}}"] = utils.ParameterToString({{^isFreeFormObject}}{{^isArray}}{{^isEnumRef}}*{{/isEnumRef}}{{/isArray}}{{/isFreeFormObject}}{{> param_name}})
  }
  {{/required}}
{{/headerParams}}

  // optional params if any
  for _, opt := range opts {
    opt.apply(&conf)
  }

{{#bodyParams}}
  // body params
  {{#required}}
  {{#vendorExtensions.x-flat-body}}
  postBody := struct{
    {{#vars}}
    {{name}} {{^required}}{{^isFreeFormObject}}*{{/isFreeFormObject}}{{/required}}{{#required}}{{#isModel}}*{{/isModel}}{{/required}}{{{dataType}}} `json:"{{baseName}}{{^required}},omitempty{{/required}}"`
    {{/vars}}
  }{
    {{#vars}}
    {{#required}}
    {{name}}: {{nameInLowerCase}},
    {{/required}}
    {{/vars}}
  }
  {{#hasOptionalParams}}
  if optionalParams != nil {
    {{#vars}}
    {{^required}}
    postBody.{{name}} = optionalParams.{{nameInPascalCase}}
    {{/required}}
    {{/vars}}
  }
  {{/hasOptionalParams}}
  {{/vendorExtensions.x-flat-body}}
  {{^vendorExtensions.x-flat-body}}
  postBody := {{^required}}{{#hasOptionalParams}}optionalParams.{{/hasOptionalParams}}{{/required}}{{paramName}}
  {{/vendorExtensions.x-flat-body}}
  {{/required}}
  {{^required}}
  {{#vendorExtensions.x-flat-body}}
  {{#hasOptionalParams}}
  postBody := optionalParams
  {{/hasOptionalParams}}
  {{^hasOptionalParams}}
  postBody := struct{
    {{#vars}}
    {{name}} {{^required}}{{^isFreeFormObject}}*{{/isFreeFormObject}}{{/required}}{{#required}}{{#isModel}}*{{/isModel}}{{/required}}{{{dataType}}} `json:"{{baseName}}{{^required}},omitempty{{/required}}"`
    {{/vars}}
  }{
    {{#vars}}
    {{name}}: {{nameInLowerCase}},
    {{/vars}}
  }
  {{/hasOptionalParams}}
  {{/vendorExtensions.x-flat-body}}
  {{^vendorExtensions.x-flat-body}}
  {{#hasOptionalParams}}
  var postBody any
  if optionalParams != nil {
    postBody = optionalParams.{{nameInPascalCase}}
  }
  {{/hasOptionalParams}}
  {{^hasOptionalParams}}
  postBody := {{paramName}}
  {{/hasOptionalParams}}
  {{/vendorExtensions.x-flat-body}}
  {{/required}}
{{/bodyParams}}
	req, err := c.prepareRequest(conf.context, requestPath, http.Method{{httpMethod}}, {{^bodyParams}}nil{{/bodyParams}}{{#bodyParams}}postBody{{/bodyParams}}, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, {{#vendorExtensions}}{{#x-use-read-transporter}}true{{/x-use-read-transporter}}{{^x-use-read-transporter}}false{{/x-use-read-transporter}},{{/vendorExtensions}}conf.timeouts)
}

{{/operation}}
{{/operations}}

{{#isSearchClient}}
{{> search_helpers}}
{{/isSearchClient}}