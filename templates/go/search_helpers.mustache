/*
SearchForHits calls the `search` method but with certainty that we will only request Algolia records (hits) and not facets.
Disclaimer: We don't assert that the parameters you pass to this method only contains `hits` requests to prevent impacting search performances, this helper is purely for typing purposes.

  @param ctx context.Context - The context that will be drilled down to the actual request.
  @param r ApiSearchRequest - Body of the `search` operation.
  @param opts ...Option - Optional parameters for the request.
  @return []SearchResponse - List of hits.
  @return error - Error if any.
 */
func (c *APIClient) SearchForHits(ctx context.Context, r ApiSearchRequest, opts ...Option) ([]SearchResponse, error) {
  res, err := c.SearchWithContext(ctx, r, opts...)
  if err != nil {
    return nil, err
  }

  hits := make([]SearchResponse, 0, len(res.GetResults()))

  for _, hit := range res.GetResults() {
    if hit.SearchResponse != nil {
      hits = append(hits, *hit.SearchResponse)
    }
  }

  return slices.Clip(hits), nil
}

/*
SearchForFacets calls the `search` method but with certainty that we will only request Algolia facets and not records (hits).
Disclaimer: We don't assert that the parameters you pass to this method only contains `facets` requests to prevent impacting search performances, this helper is purely for typing purposes.

  @param ctx context.Context - The context that will be drilled down to the actual request.
  @param r ApiSearchRequest - Body of the `search` operation.
  @param opts ...Option - Optional parameters for the request.
  @return []SearchForFacetValuesResponse - List of facet hits.
  @return error - Error if any.
 */
func (c *APIClient) SearchForFacets(ctx context.Context, r ApiSearchRequest, opts ...Option) ([]SearchForFacetValuesResponse, error) {
  res, err := c.SearchWithContext(ctx, r, opts...)
  if err != nil {
    return nil, err
  }

  facetHits := make([]SearchForFacetValuesResponse, 0, len(res.GetResults()))

  for _, hit := range res.GetResults() {
      if hit.SearchForFacetValuesResponse != nil {
        facetHits = append(facetHits, *hit.SearchForFacetValuesResponse)
      }
  }

  return slices.Clip(facetHits), nil
}

/*
WaitForTask waits for a task to be published.
Wraps WaitForTaskWithContext with context.Background().
It returns the task response if the operation was successful.
It returns an error if the operation failed.

		@param indexName string - Index name.
		@param taskID int64 - Task ID.
		@param maxRetries *float64 - Maximum number of retries.
	  @param timeout func(float64) time.Duration - Timeout function.
		@param opts ...Option - Optional parameters for the request.
		@return *GetTaskResponse - Task response.
		@return error - Error if any.
*/
func (c *APIClient) WaitForTask(
	indexName string,
	taskID int64,
	maxRetries *float64,
	timeout func(float64) time.Duration,
	opts ...Option,
) (*GetTaskResponse, error) {
	return c.WaitForTaskWithContext(
		context.Background(),
		indexName,
		taskID,
		maxRetries,
		timeout,
		opts...,
	)
}

/*
WaitForTaskWithContext waits for a task to be published.
It returns the task response if the operation was successful.
It returns an error if the operation failed.

	@param ctx context.Context - The context that will be drilled down to the actual request.
	@param indexName string - Index name.
	@param taskID int64 - Task ID.
	@param maxRetries *float64 - Maximum number of retries.
	@param timeout func(float64) time.Duration - Timeout function.
	@param opts ...Option - Optional parameters for the request.
	@return *GetTaskResponse - Task response.
	@return error - Error if any.
*/
func (c *APIClient) WaitForTaskWithContext(
	ctx context.Context,
	indexName string,
	taskID int64,
	maxRetries *float64,
	timeout func(float64) time.Duration,
	opts ...Option,
) (*GetTaskResponse, error) {
	retryCount := float64(0)

	if maxRetries == nil {
		maxRetries = new(float64)
		*maxRetries = 50
	}

	if timeout == nil {
		timeout = func(count float64) time.Duration {
			return time.Duration(min(count*0.2, 5)) * time.Second
		}
	}

	return utils.CreateIterable( //nolint:wrapcheck
		func(*GetTaskResponse, error) (*GetTaskResponse, error) {
			return c.GetTaskWithContext(ctx, c.NewApiGetTaskRequest(indexName, taskID), opts...)
		},
		func(response *GetTaskResponse, err error) bool {
			if err != nil || response == nil {
				return false
			}

			return response.Status == TASK_STATUS_PUBLISHED
		},
		func(*GetTaskResponse, error) {
			retryCount++
		},
		func() time.Duration {
			return timeout(retryCount)
		},
		&utils.IterableError[GetTaskResponse]{
			Validate: func(*GetTaskResponse, error) bool {
				return retryCount >= *maxRetries
			},
			Message: func(*GetTaskResponse, error) string {
				return fmt.Sprintf("The maximum number of retries exceeded. (%f/%f)", retryCount, *maxRetries)
			},
		},
	)
}

/*
WaitForAppTask waits for an application-level task to be published.
Wraps WaitForAppTask with context.Background().
It returns the task response if the operation was successful.
It returns an error if the operation failed.

	@param taskID int64 - Task ID.
	@param maxRetries *float64 - Maximum number of retries.
	@param timeout func(float64) time.Duration - Timeout function.
	@param opts ...Option - Optional parameters for the request.
	@return *GetTaskResponse - Task response.
	@return error - Error if any.
*/
func (c *APIClient) WaitForAppTask(
	taskID int64,
	maxRetries *float64,
	timeout func(float64) time.Duration,
	opts ...Option,
) (*GetTaskResponse, error) {
	return c.WaitForAppTaskWithContext(
		context.Background(),
		taskID,
		maxRetries,
		timeout,
		opts...,
	)
}

/*
WaitForAppTaskWithContext waits for an application-level task to be published.
It returns the task response if the operation was successful.
It returns an error if the operation failed.

	@param ctx context.Context - The context that will be drilled down to the actual request.
	@param taskID int64 - Task ID.
	@param maxRetries *float64 - Maximum number of retries.
	@param timeout func(float64) time.Duration - Timeout function.
	@param opts ...Option - Optional parameters for the request.
	@return *GetTaskResponse - Task response.
	@return error - Error if any.
*/
func (c *APIClient) WaitForAppTaskWithContext(
	ctx context.Context,
	taskID int64,
	maxRetries *float64,
	timeout func(float64) time.Duration,
	opts ...Option,
) (*GetTaskResponse, error) {
	retryCount := float64(0)

	if maxRetries == nil {
		maxRetries = new(float64)
		*maxRetries = 50
	}

	if timeout == nil {
		timeout = func(count float64) time.Duration {
			return time.Duration(min(count*0.2, 5)) * time.Second
		}
	}

	return utils.CreateIterable( //nolint:wrapcheck
		func(*GetTaskResponse, error) (*GetTaskResponse, error) {
			return c.GetAppTaskWithContext(ctx, c.NewApiGetAppTaskRequest(taskID), opts...)
		},
		func(response *GetTaskResponse, err error) bool {
			if err != nil || response == nil {
				return false
			}

			return response.Status == TASK_STATUS_PUBLISHED
		},
		func(*GetTaskResponse, error) {
			retryCount++
		},
		func() time.Duration {
			return timeout(retryCount)
		},
		&utils.IterableError[GetTaskResponse]{
			Validate: func(*GetTaskResponse, error) bool {
				return retryCount >= *maxRetries
			},
			Message: func(*GetTaskResponse, error) string {
				return fmt.Sprintf("The maximum number of retries exceeded. (%f/%f)", retryCount, *maxRetries)
			},
		},
	)
}

/*
WaitForApiKey waits for an API key to be created, deleted or updated.
It returns the API key response if the operation was successful.
It returns an error if the operation failed.

The operation can be one of the following:
  - "add": wait for the API key to be created
  - "delete": wait for the API key to be deleted
  - "update": wait for the API key to be updated

If the operation is "update", the apiKey parameter must be set.
If the operation is "delete" or "add", the apiKey parameter is not used.

	@param operation ApiKeyOperation - Operation type - add, delete or update.
	@param key string - API key.
	@param apiKey *ApiKey - API key structure - required for update operation.
	@param opts ...Option - Optional parameters for the request.
	@return *GetApiKeyResponse - API key response.
	@return error - Error if any.
*/
func (c *APIClient) WaitForApiKey(
	operation ApiKeyOperation,
	key string,
	apiKey *ApiKey,
	opts ...Option,
) (*GetApiKeyResponse, error) {
	return c.WaitForApiKeyWithContext(
		context.Background(),
		operation,
		key,
		apiKey,
		nil,
		nil,
		opts...,
	)
}

/*
WaitForApiKey waits for an API key to be created, deleted or updated.
Wraps WaitForApiKeyWithContext with context.Background().
It returns the API key response if the operation was successful.
It returns an error if the operation failed.

The operation can be one of the following:
  - "add": wait for the API key to be created
  - "delete": wait for the API key to be deleted
  - "update": wait for the API key to be updated

If the operation is "update", the apiKey parameter must be set.
If the operation is "delete" or "add", the apiKey parameter is not used.

	@param operation ApiKeyOperation - Operation type - add, delete or update.
	@param key string - API key.
	@param apiKey *ApiKey - API key structure - required for update operation.
	@param maxRetries *float64 - Maximum number of retries.
	@param timeout func(float64) time.Duration - Timeout function.
	@param opts ...Option - Optional parameters for the request.
	@return *GetApiKeyResponse - API key response.
	@return error - Error if any.
*/
func (c *APIClient) WaitForApiKeyWithOptions(
	operation ApiKeyOperation,
	key string,
	apiKey *ApiKey,
	maxRetries *float64,
	timeout func(float64) time.Duration,
	opts ...Option,
) (*GetApiKeyResponse, error) {
	return c.WaitForApiKeyWithContext(
		context.Background(),
		operation,
		key,
		apiKey,
		maxRetries,
		timeout,
		opts...,
	)
}

/*
WaitForApiKeyWithContext waits for an API key to be created, deleted or updated.
It returns the API key response if the operation was successful.
It returns an error if the operation failed.

The operation can be one of the following:
  - "add": wait for the API key to be created
  - "delete": wait for the API key to be deleted
  - "update": wait for the API key to be updated

If the operation is "update", the apiKey parameter must be set.
If the operation is "delete" or "add", the apiKey parameter is not used.

	@param ctx context.Context - The context that will be drilled down to the actual request.
	@param operation ApiKeyOperation - Operation type - add, delete or update.
	@param key string - API key.
	@param apiKey *ApiKey - API key structure - required for update operation.
	@param maxRetries *float64 - Maximum number of retries.
	@param timeout func(float64) time.Duration - Timeout function.
	@param opts ...Option - Optional parameters for the request.
	@return *GetApiKeyResponse - API key response.
	@return error - Error if any.
*/
func (c *APIClient) WaitForApiKeyWithContext(
	ctx context.Context,
	operation ApiKeyOperation,
	key string,
	apiKey *ApiKey,
	maxRetries *float64,
	timeout func(float64) time.Duration,
	opts ...Option,
) (*GetApiKeyResponse, error) {
	if operation != API_KEY_OPERATION_ADD && operation != API_KEY_OPERATION_DELETE && operation != API_KEY_OPERATION_UPDATE {
		return nil, &errs.WaitKeyOperationError{}
	}

	retryCount := float64(0)

	if maxRetries == nil {
		maxRetries = new(float64)
		*maxRetries = 50
	}

	if timeout == nil {
		timeout = func(count float64) time.Duration {
			return time.Duration(min(count*0.2, 5)) * time.Second
		}
	}

	var validateFunc func(*GetApiKeyResponse, error) bool

	if operation == API_KEY_OPERATION_UPDATE {
		if apiKey == nil {
			return nil, &errs.WaitKeyUpdateError{}
		}

		validateFunc = func(response *GetApiKeyResponse, err error) bool {
			if err != nil || response == nil {
				return false
			}

			if apiKey.GetDescription() != response.GetDescription() {
				return false
			}

			if apiKey.GetQueryParameters() != response.GetQueryParameters() {
				return false
			}

			if apiKey.GetMaxHitsPerQuery() != response.GetMaxHitsPerQuery() {
				return false
			}

			if apiKey.GetMaxQueriesPerIPPerHour() != response.GetMaxQueriesPerIPPerHour() {
				return false
			}

			if apiKey.GetValidity() != response.GetValidity() {
				return false
			}

			slices.Sort(apiKey.Acl)
			slices.Sort(response.Acl)

			if !slices.Equal(apiKey.Acl, response.Acl) {
				return false
			}

			slices.Sort(apiKey.Indexes)
			slices.Sort(response.Indexes)

			if !slices.Equal(apiKey.Indexes, response.Indexes) {
				return false
			}

			slices.Sort(apiKey.Referers)
			slices.Sort(response.Referers)

			return slices.Equal(apiKey.Referers, response.Referers)
		}
	} else {
		validateFunc = func(response *GetApiKeyResponse, err error) bool {
			switch operation {
			case API_KEY_OPERATION_ADD:
        if _, ok := err.(*APIError); ok {
					apiErr := err.(*APIError)

					return apiErr.Status != 404
				}

				return true
			case API_KEY_OPERATION_DELETE:
				if _, ok := err.(*APIError); ok {
					apiErr := err.(*APIError)

					return apiErr.Status == 404
				}

				return false
			}
			return false
		}
	}

	return utils.CreateIterable( //nolint:wrapcheck
		func(*GetApiKeyResponse, error) (*GetApiKeyResponse, error) {
			return c.GetApiKeyWithContext(ctx, c.NewApiGetApiKeyRequest(key), opts...)
		},
		validateFunc,
		func(*GetApiKeyResponse, error) {
			retryCount += 1
		},
		func() time.Duration {
			return timeout(retryCount)
		},
		&utils.IterableError[GetApiKeyResponse]{
			Validate: func(*GetApiKeyResponse, error) bool {
				return retryCount >= *maxRetries
			},
			Message: func(*GetApiKeyResponse, error) string {
				return fmt.Sprintf("The maximum number of retries exceeded. (%f/%f)", retryCount, *maxRetries)
			},
		},
	)
}

/*
BrowseObjects allows to aggregate all the hits returned by the API calls.
Wraps BrowseObjectsWithContext using context.Background.

		@param indexName string - Index name.
	  @param browseParams BrowseParamsObject - Browse parameters.
	  @param validate func(*BrowseResponse, error) bool - Validator function.
	  @param aggregator func(*BrowseResponse) - Aggregator function.
		@param opts ...Option - Optional parameters for the request.
		@return *BrowseResponse - Browse response.
		@return error - Error if any.
*/
func (c *APIClient) BrowseObjects(
	indexName string,
	browseParams BrowseParamsObject,
	validate func(*BrowseResponse, error) bool,
	aggregator func(*BrowseResponse, error),
	opts ...Option,
) (*BrowseResponse, error) {
	return c.BrowseObjectsWithContext(context.Background(), indexName, browseParams, validate, aggregator, opts...)
}

/*
BrowseObjectsWithContext allows to aggregate all the hits returned by the API calls.

		@param ctx context.Context - The context that will be drilled down to the actual request.
	  @param indexName string - Index name.
	  @param browseParams BrowseParamsObject - Browse parameters.
	  @param validate func(*BrowseResponse, error) bool - Validator function.
	  @param aggregator func(*BrowseResponse) - Aggregator function.
		@param opts ...Option - Optional parameters for the request.
		@return *BrowseResponse - Browse response.
		@return error - Error if any.
*/
func (c *APIClient) BrowseObjectsWithContext(
	ctx context.Context,
	indexName string,
	browseParams BrowseParamsObject,
	validate func(*BrowseResponse, error) bool,
	aggregator func(*BrowseResponse, error),
	opts ...Option,
) (*BrowseResponse, error) {
	if validate == nil {
		validate = func(response *BrowseResponse, responseErr error) bool {
			return responseErr != nil || response != nil && response.Cursor == nil
		}
	}

	return utils.CreateIterable( //nolint:wrapcheck
		func(previousResponse *BrowseResponse, previousErr error) (*BrowseResponse, error) {
			if previousResponse != nil {
				browseParams.Cursor = previousResponse.Cursor
			}

			return c.BrowseWithContext(
				ctx,
				c.NewApiBrowseRequest(indexName).WithBrowseParams(BrowseParamsObjectAsBrowseParams(&browseParams)),
				opts...,
			)
		},
		validate,
		aggregator,
		nil,
		nil,
	)
}

/*
BrowseRules allows to aggregate all the rules returned by the API calls.
Wraps BrowseRulesWithContext using context.Background.

	@param indexName string - Index name.
	@param searchRulesParams SearchRulesParams - Search rules parameters.
	@param validate func(*SearchRulesResponse, error) bool - Validator function.
	@param aggregator func(*SearchRulesResponse) - Aggregator function.
	@param opts ...Option - Optional parameters for the request.
	@return *SearchRulesResponse - Search rules response.
	@return error - Error if any.
*/
func (c *APIClient) BrowseRules(
	indexName string,
	searchRulesParams SearchRulesParams,
	validate func(*SearchRulesResponse, error) bool,
	aggregator func(*SearchRulesResponse, error),
	opts ...Option,
) (*SearchRulesResponse, error) {
	return c.BrowseRulesWithContext(context.Background(), indexName, searchRulesParams, validate, aggregator, opts...)
}

/*
BrowseRulesWithContext allows to aggregate all the rules returned by the API calls.

	@param ctx context.Context - The context that will be drilled down to the actual request.
	@param indexName string - Index name.
	@param searchRulesParams SearchRulesParams - Search rules parameters.
	@param validate func(*SearchRulesResponse, error) bool - Validator function.
	@param aggregator func(*SearchRulesResponse) - Aggregator function.
	@param opts ...Option - Optional parameters for the request.
	@return *SearchRulesResponse - Search rules response.
	@return error - Error if any.
*/
func (c *APIClient) BrowseRulesWithContext(
	ctx context.Context,
	indexName string,
	searchRulesParams SearchRulesParams,
	validate func(*SearchRulesResponse, error) bool,
	aggregator func(*SearchRulesResponse, error),
	opts ...Option,
) (*SearchRulesResponse, error) {
	hitsPerPage := int32(1000)
	if searchRulesParams.HitsPerPage != nil {
		hitsPerPage = *searchRulesParams.HitsPerPage
	}

	if validate == nil {
		validate = func(response *SearchRulesResponse, responseErr error) bool {
			return responseErr != nil || (response != nil && response.NbHits < hitsPerPage)
		}
	}

	return utils.CreateIterable( //nolint:wrapcheck
		func(previousResponse *SearchRulesResponse, previousErr error) (*SearchRulesResponse, error) {
			searchRulesParams.HitsPerPage = &hitsPerPage

			if previousResponse != nil {
				searchRulesParams.Page = utils.ToPtr(previousResponse.Page + 1)
			}

			if searchRulesParams.Page == nil {
				searchRulesParams.Page = utils.ToPtr(int32(0))
			}

			return c.SearchRulesWithContext(
				ctx,
				c.NewApiSearchRulesRequest(indexName).WithSearchRulesParams(&searchRulesParams),
				opts...,
			)
		},
		validate,
		aggregator,
		nil,
		nil,
	)
}

/*
BrowseSynonyms allows to aggregate all the synonyms returned by the API calls.
Wraps BrowseSynonymsWithContext using context.Background.

	@param indexName string - Index name.
	@param searchSynonymsParams SearchSynonymsParams - Search synonyms parameters.
	@param validate func(*SearchSynonymsResponse, error) bool - Validator function.
	@param aggregator func(*SearchSynonymsResponse) - Aggregator function.
	@param opts ...Option - Optional parameters for the request.
	@return *SearchSynonymsResponse - Search synonyms response.
	@return error - Error if any.
*/
func (c *APIClient) BrowseSynonyms(
	indexName string,
	searchSynonymsParams SearchSynonymsParams,
	validate func(*SearchSynonymsResponse, error) bool,
	aggregator func(*SearchSynonymsResponse, error),
	opts ...Option,
) (*SearchSynonymsResponse, error) {
	return c.BrowseSynonymsWithContext(context.Background(), indexName, searchSynonymsParams, validate, aggregator, opts...)
}

/*
BrowseSynonymsWithContext allows to aggregate all the synonyms returned by the API calls.

	@param ctx context.Context - The context that will be drilled down to the actual request.
	@param indexName string - Index name.
	@param searchSynonymsParams SearchSynonymsParams - Search synonyms parameters.
	@param validate func(*SearchSynonymsResponse, error) bool - Validator function.
	@param aggregator func(*SearchSynonymsResponse) - Aggregator function.
	@param opts ...Option - Optional parameters for the request.
	@return *SearchSynonymsResponse - Search synonyms response.
	@return error - Error if any.
*/
func (c *APIClient) BrowseSynonymsWithContext(
	ctx context.Context,
	indexName string,
	searchSynonymsParams SearchSynonymsParams,
	validate func(*SearchSynonymsResponse, error) bool,
	aggregator func(*SearchSynonymsResponse, error),
	opts ...Option,
) (*SearchSynonymsResponse, error) {
	hitsPerPage := int32(1000)
	if searchSynonymsParams.HitsPerPage != nil {
		hitsPerPage = *searchSynonymsParams.HitsPerPage
	}

	if searchSynonymsParams.Page == nil {
		searchSynonymsParams.Page = utils.ToPtr(int32(0))
	}

	if validate == nil {
		validate = func(response *SearchSynonymsResponse, responseErr error) bool {
			return responseErr != nil || (response != nil && response.NbHits < hitsPerPage)
		}
	}

	return utils.CreateIterable( //nolint:wrapcheck
		func(previousResponse *SearchSynonymsResponse, previousErr error) (*SearchSynonymsResponse, error) {
			searchSynonymsParams.HitsPerPage = &hitsPerPage

			defer func() {
				searchSynonymsParams.Page = utils.ToPtr(*searchSynonymsParams.Page + 1)
			}()

			return c.SearchSynonymsWithContext(
				ctx,
				c.NewApiSearchSynonymsRequest(indexName).WithSearchSynonymsParams(&searchSynonymsParams),
				opts...,
			)
		},
		validate,
		aggregator,
		nil,
		nil,
	)
}

func encodeRestrictions(restrictions *SecuredApiKeyRestrictions) (string, error) {
	if restrictions == nil {
		return "", nil
	}

	toSerialize := map[string]any{}
	if restrictions.Filters != nil {
		toSerialize["filters"] = *restrictions.Filters
	}
	if restrictions.ValidUntil != nil {
		toSerialize["validUntil"] = *restrictions.ValidUntil
	}
	if restrictions.RestrictIndices != nil {
		toSerialize["restrictIndices"] = restrictions.RestrictIndices
	}
	if restrictions.RestrictSources != nil {
		toSerialize["restrictSources"] = *restrictions.RestrictSources
	}
	if restrictions.UserToken != nil {
		toSerialize["userToken"] = *restrictions.UserToken
	}
	if restrictions.SearchParams != nil {
		// merge with searchParams
		serializedParams, err := restrictions.SearchParams.MarshalJSON()
		if err != nil {
			return "", fmt.Errorf("failed to marshal SearchParams: %w", err)
		}
		err = json.Unmarshal(serializedParams, &toSerialize)
		if err != nil {
			return "", fmt.Errorf("failed to unmarshal SearchParams: %w", err)
		}
	}

	// sort the keys to ensure consistent encoding
	keys := make([]string, 0, len(toSerialize))
	for k := range toSerialize {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	queryString := make([]string, 0, len(toSerialize))
	for _, k := range keys {
		queryString = append(queryString, k+"="+queryParameterToString(toSerialize[k]))
	}

	return strings.Join(queryString, "&"), nil
}

// GenerateSecuredApiKey generates a public API key intended to restrict access
// to certain records. This new key is built upon the existing key named
// `parentApiKey` and the following options.
func (c *APIClient) GenerateSecuredApiKey(parentApiKey string, restrictions *SecuredApiKeyRestrictions) (string, error) {
	h := hmac.New(sha256.New, []byte(parentApiKey))

	message, err := encodeRestrictions(restrictions)
	if err != nil {
		return "", err
	}
	_, err = h.Write([]byte(message))
	if err != nil {
		return "", fmt.Errorf("failed to compute HMAC: %w", err)
	}

	checksum := hex.EncodeToString(h.Sum(nil))
	key := base64.StdEncoding.EncodeToString([]byte(checksum + message))

	return key, nil
}

// GetSecuredApiKeyRemainingValidity retrieves the remaining validity of the previously generated `securedApiKey`, the `ValidUntil` parameter must have been provided.
func (c *APIClient) GetSecuredApiKeyRemainingValidity(securedApiKey string) (time.Duration, error) {
	if len(securedApiKey) == 0 {
		return 0, fmt.Errorf("given secured API key is empty: %s", securedApiKey)
	}

	decoded, err := base64.StdEncoding.DecodeString(securedApiKey)
	if err != nil {
		return 0, fmt.Errorf("unable to decode given secured API key: %s", err)
	}

	submatch := regexp.MustCompile(`validUntil=(\d{1,10})`).FindSubmatch(decoded)

	if len(submatch) != 2 {
		return 0, fmt.Errorf("unable to find `validUntil` parameter in the given secured API key: %s", string(decoded))
	}

	ts, err := strconv.Atoi(string(submatch[1]))
	if err != nil {
		return 0, fmt.Errorf("invalid format for the received `validUntil` value: %s", string(submatch[1]))
	}

	return time.Until(time.Unix(int64(ts), 0)), nil
}

// Helper: Saves the given array of objects in the given index. The `chunkedBatch` helper is used under the hood, which creates a `batch` requests with at most 1000 objects in it.
func (c *APIClient) SaveObjects(indexName string, objects []map[string]any) ([]BatchResponse, error) {
  return c.ChunkedBatch(indexName, objects, utils.ToPtr(ACTION_ADD_OBJECT), nil, nil)
}

// Helper: Deletes every records for the given objectIDs. The `chunkedBatch` helper is used under the hood, which creates a `batch` requests with at most 1000 objectIDs in it.
func (c *APIClient) DeleteObjects(indexName string, objectIDs []string) ([]BatchResponse, error) {
  objects := make([]map[string]any, 0, len(objectIDs))

  for _, id := range objectIDs {
    objects = append(objects, map[string]any{"objectID":id})
  }

  return c.ChunkedBatch(indexName, objects, utils.ToPtr(ACTION_DELETE_OBJECT), nil, nil)
}

// Helper: Replaces object content of all the given objects according to their respective `objectID` field. The `chunkedBatch` helper is used under the hood, which creates a `batch` requests with at most 1000 objects in it.
func (c *APIClient) PartialUpdateObjects(indexName string, objects []map[string]any, createIfNotExists bool) ([]BatchResponse, error) {
  var action Action

  if createIfNotExists {
    action = ACTION_PARTIAL_UPDATE_OBJECT
  } else {
    action = ACTION_PARTIAL_UPDATE_OBJECT_NO_CREATE
  }

  return c.ChunkedBatch(indexName, objects, utils.ToPtr(action), nil, nil)
}

// ChunkedBatch chunks the given `objects` list in subset of 1000 elements max in order to make it fit in `batch` requests.
func (c *APIClient) ChunkedBatch(indexName string, objects []map[string]any, action *Action, waitForTasks *bool, batchSize *int) ([]BatchResponse, error) {
	var (
		defaultBatchSize   = 1000
		defaultAction      = ACTION_ADD_OBJECT
		defaultWaitForTask = false
	)

	if batchSize == nil {
		batchSize = &defaultBatchSize
	}

	if action == nil {
		action = &defaultAction
	}

	if waitForTasks == nil {
		waitForTasks = &defaultWaitForTask
	}

	requests := make([]BatchRequest, 0, len(objects)%*batchSize)
	responses := make([]BatchResponse, 0, len(objects)%*batchSize)

	for i, obj := range objects {
		requests = append(requests, *NewBatchRequest(*action, obj))

		if len(requests) == *batchSize || i == len(objects)-1 {
			resp, err := c.Batch(c.NewApiBatchRequest(indexName, NewBatchWriteParams(requests)))
			if err != nil {
				return nil, err
			}

			responses = append(responses, *resp)
			requests = make([]BatchRequest, 0, len(objects)%*batchSize)
		}
	}

	if *waitForTasks {
		for _, resp := range responses {
			_, err := c.WaitForTask(indexName, resp.TaskID, nil, nil)
			if err != nil {
				return nil, err
			}
		}
	}

	return responses, nil
}

// ReplaceAllObjects replaces all objects (records) in the given `indexName` with the given `objects`. A temporary index is created during this process in order to backup your data.
// See https://api-clients-automation.netlify.app/docs/contributing/add-new-api-client#5-helpers for implementation details.
func (c *APIClient) ReplaceAllObjects(indexName string, objects []map[string]any, batchSize *int) (*ReplaceAllObjectsResponse, error) {
	tmpIndexName := fmt.Sprintf("%s_tmp_%d", indexName, time.Now().UnixNano())

	copyResp, err := c.OperationIndex(c.NewApiOperationIndexRequest(indexName, NewOperationIndexParams(OPERATION_TYPE_COPY, tmpIndexName, WithOperationIndexParamsScope([]ScopeType{SCOPE_TYPE_RULES, SCOPE_TYPE_SETTINGS, SCOPE_TYPE_SYNONYMS}))))
	if err != nil {
		return nil, err
	}

	waitForTask := true

	batchResp, err := c.ChunkedBatch(tmpIndexName, objects, nil, &waitForTask, batchSize)
	if err != nil {
		return nil, err
	}

	_, err = c.WaitForTask(tmpIndexName, copyResp.TaskID, nil, nil)
	if err != nil {
		return nil, err
	}

	copyResp, err = c.OperationIndex(c.NewApiOperationIndexRequest(indexName, NewOperationIndexParams(OPERATION_TYPE_COPY, tmpIndexName, WithOperationIndexParamsScope([]ScopeType{SCOPE_TYPE_RULES, SCOPE_TYPE_SETTINGS, SCOPE_TYPE_SYNONYMS}))))
	if err != nil {
		return nil, err
	}

	_, err = c.WaitForTask(tmpIndexName, copyResp.TaskID, nil, nil)
	if err != nil {
		return nil, err
	}

	moveResp, err := c.OperationIndex(c.NewApiOperationIndexRequest(tmpIndexName, NewOperationIndexParams(OPERATION_TYPE_MOVE, indexName)))
	if err != nil {
		return nil, err
	}

	_, err = c.WaitForTask(tmpIndexName, moveResp.TaskID, nil, nil)
	if err != nil {
		return nil, err
	}

	return &ReplaceAllObjectsResponse{
		CopyOperationResponse: *copyResp,
		BatchResponses:        batchResp,
		MoveOperationResponse: *moveResp,
	}, nil
}