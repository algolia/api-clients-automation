{{#operations}}// {{{generationBanner}}}

import AnyCodable
import Foundation
import Core

typealias Client = {{classname}}

{{#description}}
/**
{{{.}}}
*/{{/description}}
{{#objcCompatible}}@objcMembers {{/objcCompatible}}open class {{classname}}{{#objcCompatible}} : NSObject{{/objcCompatible}} {

    private var configuration: Configuration
    private var transporter: Transporter

    var appID: String {
        self.configuration.appID
    }

    public init(configuration: Configuration, transporter: Transporter) {
        self.configuration = configuration
        self.transporter = transporter
    }

    public convenience init(configuration: Configuration) {
        self.init(configuration: configuration, transporter: Transporter(configuration: configuration))
    }

    public convenience init(appID: String, apiKey: String{{#hasRegionalHost}}, region: Region{{#fallbackToAliasHost}}?{{/fallbackToAliasHost}}{{/hasRegionalHost}}) throws {
        self.init(configuration: try Configuration(appID: appID, apiKey: apiKey{{#hasRegionalHost}}, region: region{{/hasRegionalHost}}))
    }

{{#operation}}
    {{#allParams}}
    {{#isEnum}}

    /**
     * enum for parameter {{paramName}}
     */
    public enum {{enumName}}_{{operationId}}: {{^isContainer}}{{{dataType}}}{{/isContainer}}{{#isContainer}}String{{/isContainer}}, CaseIterable {
        {{^enumUnknownDefaultCase}}
        {{#allowableValues}}
        {{#enumVars}}
        case {{name}} = {{{value}}}
        {{/enumVars}}
        {{/allowableValues}}
        {{/enumUnknownDefaultCase}}
        {{#enumUnknownDefaultCase}}
        {{#allowableValues}}
        {{#enumVars}}
        {{^-last}}
        case {{name}} = {{{value}}}
        {{/-last}}
        {{/enumVars}}
        {{/allowableValues}}
        {{/enumUnknownDefaultCase}}
    }
    {{/isEnum}}
    {{/allParams}}

    /**
     {{#allParams}}
     - parameter {{paramName}}: ({{#isFormParam}}form{{/isFormParam}}{{#isQueryParam}}query{{/isQueryParam}}{{#isPathParam}}path{{/isPathParam}}{{#isHeaderParam}}header{{/isHeaderParam}}{{#isBodyParam}}body{{/isBodyParam}}) {{description}} {{^required}}(optional{{#defaultValue}}, default to {{{.}}}{{/defaultValue}}){{/required}}
     {{/allParams}}
     - returns: {{{returnType}}}{{#returnType}}{{#isResponseOptional}}?{{/isResponseOptional}}{{/returnType}}{{^returnType}}Void{{/returnType}}
     */
    {{#isDeprecated}}
    @available(*, deprecated, message: "This operation is deprecated.")
    {{/isDeprecated}}
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    {{#nonPublicApi}}internal{{/nonPublicApi}}{{^nonPublicApi}}open{{/nonPublicApi}} func {{operationId}}({{#allParams}}{{paramName}}: {{#isEnum}}{{#isContainer}}[{{enumName}}_{{operationId}}]{{/isContainer}}{{^isContainer}}{{enumName}}_{{operationId}}{{/isContainer}}{{/isEnum}}{{^isEnum}}{{#lambda.to-codable}}{{{dataType}}}{{/lambda.to-codable}}{{/isEnum}}{{^required}}? = nil{{/required}}, {{/allParams}}requestOptions: RequestOptions? = nil) async throws{{#returnType}} -> {{{returnType}}}{{#returnType}}{{#isResponseOptional}}?{{/isResponseOptional}}{{/returnType}}{{/returnType}} {
    {{#returnType}}let response: Response<{{{returnType}}}> = {{/returnType}}try await {{operationId}}WithHTTPInfo({{#allParams}}{{paramName}}: {{paramName}}, {{/allParams}}requestOptions: requestOptions)
    {{#returnType}}

        guard let body = response.body else {
            throw AlgoliaError.missingData
        }

      return body{{/returnType}}
    }

    /**
     {{#notes}}{{{.}}}{{/notes}}
     {{#vendorExtensions}}
     {{#x-acl.0}}
     Required API Key ACLs:{{/x-acl.0}}
     {{#x-acl}}
       - {{.}}
     {{/x-acl}}
     {{/vendorExtensions}}{{#allParams}}
     - parameter {{paramName}}: ({{#isFormParam}}form{{/isFormParam}}{{#isQueryParam}}query{{/isQueryParam}}{{#isPathParam}}path{{/isPathParam}}{{#isHeaderParam}}header{{/isHeaderParam}}{{#isBodyParam}}body{{/isBodyParam}}) {{description}} {{^required}}(optional{{#defaultValue}}, default to {{{.}}}{{/defaultValue}}){{/required}}
     {{/allParams}}
     - returns: RequestBuilder<{{{returnType}}}{{#returnType}}{{#isResponseOptional}}?{{/isResponseOptional}}{{/returnType}}{{^returnType}}Void{{/returnType}}> {{description}}
     */
    {{#isDeprecated}}
    @available(*, deprecated, message: "This operation is deprecated.")
    {{/isDeprecated}}
    {{^returnType}}@discardableResult{{/returnType}}
    {{#vendorExtensions}}{{#nonPublicApi}}internal{{/nonPublicApi}}{{^nonPublicApi}}open{{/nonPublicApi}} func {{operationId}}WithHTTPInfo({{#allParams}}{{paramName}}: {{#isEnum}}{{#isContainer}}[{{enumName}}_{{operationId}}]{{/isContainer}}{{^isContainer}}{{enumName}}_{{operationId}}{{/isContainer}}{{/isEnum}}{{^isEnum}}{{#lambda.to-codable}}{{{dataType}}}{{/lambda.to-codable}}{{/isEnum}}{{^required}}? = nil{{/required}}, {{/allParams}}requestOptions userRequestOptions: RequestOptions? = nil) async throws -> Response<{{{returnType}}}{{#returnType}}{{#isResponseOptional}}?{{/isResponseOptional}}{{/returnType}}{{^returnType}}AnyCodable{{/returnType}}> {
        {{#pathParams}}{{#isString}}{{#required}}guard !{{{paramName}}}.isEmpty else {
          throw AlgoliaError.invalidArgument("{{{paramName}}}", "{{{operationId}}}")
        }

        {{/required}}{{/isString}}{{/pathParams}}{{#queryParams}}{{#isString}}{{#required}}guard !{{{paramName}}}.isEmpty else {
          throw AlgoliaError.invalidArgument("{{{paramName}}}", "{{{operationId}}}")
        }

        {{/required}}{{/isString}}{{/queryParams}}{{#bodyParam}}{{#isFreeFormObject}}{{#required}}guard !{{{paramName}}}.isEmpty else {
          throw AlgoliaError.invalidArgument("{{{paramName}}}", "{{{operationId}}}")
        }

        {{/required}}{{/isFreeFormObject}}{{/bodyParam}}
        {{^pathParams}}let{{/pathParams}}{{#pathParams}}{{#-first}}var{{/-first}}{{/pathParams}} resourcePath = "{{{path}}}"{{#pathParams}}
        let {{paramName}}PreEscape = "\({{#isEnum}}{{paramName}}{{#isContainer}}{{{dataType}}}{{/isContainer}}{{^isContainer}}.rawValue{{/isContainer}}{{/isEnum}}{{^isEnum}}APIHelper.mapValueToPathItem({{paramName}}){{/isEnum}})"{{^x-is-custom-request}}
        let {{paramName}}PostEscape = {{paramName}}PreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAlgoliaAllowed) ?? ""{{/x-is-custom-request}}
        resourcePath = resourcePath.replacingOccurrences(of: "{{=<% %>=}}{<%baseName%>}<%={{ }}=%>", with: {{^x-is-custom-request}}{{paramName}}PostEscape{{/x-is-custom-request}}{{#x-is-custom-request}}{{paramName}}PreEscape{{/x-is-custom-request}}, options: .literal, range: nil){{/pathParams}}
        {{#bodyParam}}
        let body = {{paramName}}
        {{/bodyParam}}
        {{^bodyParam}}
          let body: AnyCodable? = nil
        {{/bodyParam}}
        {{#hasQueryParams}}
        let queryParameters = {{#x-is-custom-request}}parameters{{/x-is-custom-request}}{{^x-is-custom-request}}[{{^queryParams}}:{{/queryParams}}
            {{#queryParams}}
            {{> _param}},
            {{/queryParams}}
        ]{{/x-is-custom-request}}
        {{/hasQueryParams}}
        {{^hasQueryParams}}
          let queryParameters: [String: Any?]? = nil
        {{/hasQueryParams}}

        let nillableHeaders: [String: Any?]? = {{^headerParams}}nil{{/headerParams}}{{#headerParams}}{{#-first}}[{{/-first}}
            {{> _param}},
        {{#-last}}]{{/-last}}{{/headerParams}}

        let headers = APIHelper.rejectNilHeaders(nillableHeaders)

        return try await self.transporter.send(
          method: "{{httpMethod}}",
          path: resourcePath,
          data: body{{#bodyParam}}{{^required}} ?? AnyCodable(){{/required}}{{/bodyParam}},
          requestOptions: RequestOptions(headers: headers, queryParameters: queryParameters) + userRequestOptions{{#vendorExtensions.x-use-read-transporter}},
          useReadTransporter: true{{/vendorExtensions.x-use-read-transporter}}
        )
    }{{/vendorExtensions}}
{{/operation}}{{#isSearchClient}}

    public enum ApiKeyOperation: String {
        case add
        case update
        case delete
    }

    /// Wait for a task to complete
    /// - parameter taskID: The id of the task to wait for
    /// - parameter indexName: The name of the index to wait for
    /// - parameter maxRetries: The maximum number of retries
    /// - parameter initialDelay: The initial delay between retries
    /// - parameter maxDelay: The maximum delay between retries
    /// - returns: GetTaskResponse
    open func waitForTask(
        with taskID: Int64,
        for indexName: String,
        maxRetries: Int = 50,
        timeout: (Int) -> TimeInterval = { count in
            min(TimeInterval(count) * 0.2, 5)
        },
        requestOptions: RequestOptions? = nil
    ) async throws -> GetTaskResponse {
        var retryCount = 0

        return try await createIterable(
            execute: { _ in
                try await self.getTask(indexName: indexName, taskID: taskID, requestOptions: requestOptions)
            },
            validate: { response in
                response.status == TaskStatus.published
            },
            aggregator: { _ in
                retryCount += 1
            },
            timeout: {
                timeout(retryCount)
            },
            error: IterableError(
                validate: { _ in
                    retryCount >= maxRetries
                },
                message: { _ in
                    "The maximum number of retries exceeded. (\(retryCount)/\(maxRetries))"
                }
            )
        )
    }

    /// Wait for an API key to be available
    /// - parameter key: The key to wait for
    /// - parameter operation: The type of operation
    /// - parameter apiKey: The original API key
    /// - parameter maxRetries: The maximum number of retries
    /// - parameter timeout: A closure that computes the timeout in seconds for the next retry
    /// - parameter requestOptions: The request options
    /// - returns: GetApiKeyResponse?
    open func waitForApiKey(
        with key: String,
        operation: ApiKeyOperation,
        apiKey: ApiKey? = nil,
        maxRetries: Int = 50,
        timeout: (Int) -> TimeInterval = { retryCount in
            min(TimeInterval(retryCount) * 0.2, 5)
        },
        requestOptions: RequestOptions? = nil
    ) async throws -> GetApiKeyResponse? {
        var retryCount = 0

        if operation == .update {
            guard let apiKey else {
                throw AlgoliaError.runtimeError("Missing API key optimistic value")
            }

            return try await createIterable(
                execute: { _ in
                    try await self.getApiKey(key: key, requestOptions: requestOptions)
                },
                validate: { response in
                    if apiKey.description != response.description {
                        return false
                    }

                    if apiKey.queryParameters != response.queryParameters {
                        return false
                    }

                    if apiKey.maxHitsPerQuery != response.maxHitsPerQuery {
                        return false
                    }

                    if apiKey.maxQueriesPerIPPerHour != response.maxQueriesPerIPPerHour {
                        return false
                    }

                    if apiKey.validity != response.validity {
                        return false
                    }

                    let expectedACLs = apiKey.acl.sorted { $0.rawValue > $1.rawValue }
                    let responseACLs = response.acl.sorted { $0.rawValue > $1.rawValue }
                    if expectedACLs != responseACLs {
                        return false
                    }

                    let expectedIndexes = apiKey.indexes?.sorted { $0 > $1 }
                    let responseIndexes = response.indexes?.sorted { $0 > $1 }
                    if expectedIndexes != responseIndexes {
                        return false
                    }

                    let expectedReferers = apiKey.referers?.sorted { $0 > $1 }
                    let responseReferers = response.referers?.sorted { $0 > $1 }
                    if expectedReferers != responseReferers {
                        return false
                    }

                    return true
                },
                aggregator: { _ in
                    retryCount += 1
                },
                timeout: {
                    timeout(retryCount)
                },
                error: IterableError(
                    validate: { _ in
                        retryCount >= maxRetries
                    },
                    message: { _ in
                        "The maximum number of retries exceeded. (\(retryCount)/\(maxRetries))"
                    }
                )
            )
        }

        return try await createIterable(
            execute: { _ in
                let response = try await self.getApiKeyWithHTTPInfo(key: key, requestOptions: requestOptions)
                if response.statusCode == 404 {
                    return nil
                }

                return response.body
            },
            validate: { response in
                switch operation {
                case .add:
                    guard let response else {
                        return false
                    }

                    return response.createdAt > 0
                case .delete:
                    return response == nil
                default:
                    return false
                }
            },
            aggregator: { _ in
                retryCount += 1
            },
            timeout: {
                timeout(retryCount)
            },
            error: IterableError(
                validate: { _ in
                    retryCount >= maxRetries
                },
                message: { _ in
                    "The maximum number of retries exceeded. (\(retryCount)/\(maxRetries))"
                }
            )
        )
    }

    /// Allows to aggregate all the hits returned by the API calls
    /// - parameter indexName: The name of the index to browse
    /// - parameter browseParams: The browse request parameters
    /// - parameter validate: A closure that validates the response
    /// - parameter aggregator: A closure that aggregates the response
    /// - parameter requestOptions: The request options
    /// - returns: BrowseResponse
    @discardableResult
    open func browseObjects(
        indexName: String,
        browseParams: BrowseParamsObject,
        validate: (BrowseResponse) -> Bool = { response in
            response.cursor == nil
        },
        aggregator: @escaping (BrowseResponse) -> Void,
        requestOptions: RequestOptions? = nil
    ) async throws -> BrowseResponse {
        return try await createIterable(
            execute: { previousResponse in
                var updatedBrowseParams = browseParams
                if let previousResponse {
                    updatedBrowseParams.cursor = previousResponse.cursor
                }

                return try await self.browse(
                    indexName: indexName,
                    browseParams: .browseParamsObject(updatedBrowseParams),
                    requestOptions: requestOptions
                )
            },
            validate: validate,
            aggregator: aggregator
        )
    }

    /// Allows to aggregate all the rules returned by the API calls
    /// - parameter indexName: The name of the index to browse
    /// - parameter searchRulesParams: The search rules request parameters
    /// - parameter validate: A closure that validates the response
    /// - parameter aggregator: A closure that aggregates the response
    /// - parameter requestOptions: The request options
    /// - returns: SearchRulesResponse
    @discardableResult
    open func browseRules(
        indexName: String,
        searchRulesParams: SearchRulesParams,
        validate: ((SearchRulesResponse) -> Bool)? = nil,
        aggregator: @escaping (SearchRulesResponse) -> Void,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchRulesResponse {
        let hitsPerPage = searchRulesParams.hitsPerPage ?? 1000

        return try await createIterable(
            execute: { previousResponse in
                var updatedSearchRulesParams = searchRulesParams

                updatedSearchRulesParams.hitsPerPage = hitsPerPage

                if let previousResponse {
                    updatedSearchRulesParams.page = previousResponse.page + 1
                }
                if updatedSearchRulesParams.page == nil {
                    updatedSearchRulesParams.page = 0
                }

                return try await self.searchRules(
                    indexName: indexName,
                    searchRulesParams: updatedSearchRulesParams,
                    requestOptions: requestOptions
                )
            },
            validate: validate ?? { response in
                response.nbHits < hitsPerPage
            },
            aggregator: aggregator
        )
    }

    /// Allows to aggregate all the synonyms returned by the API calls
    /// - parameter indexName: The name of the index to browse
    /// - parameter searchSynonymsParams: The search synonyms request parameters
    /// - parameter validate: A closure that validates the response
    /// - parameter aggregator: A closure that aggregates the response
    /// - parameter requestOptions: The request options
    /// - returns: SearchSynonymsResponse
    @discardableResult
    open func browseSynonyms(
        indexName: String,
        searchSynonymsParams: SearchSynonymsParams,
        validate: ((SearchSynonymsResponse) -> Bool)? = nil,
        aggregator: @escaping (SearchSynonymsResponse) -> Void,
        requestOptions: RequestOptions? = nil
    ) async throws -> SearchSynonymsResponse {
        let hitsPerPage = searchSynonymsParams.hitsPerPage ?? 1000

        var updatedSearchSynonymsParams = searchSynonymsParams
        if updatedSearchSynonymsParams.page == nil {
            updatedSearchSynonymsParams.page = 0
        }

        return try await createIterable(
            execute: { previousResponse in
                updatedSearchSynonymsParams.hitsPerPage = hitsPerPage

                defer {
                    updatedSearchSynonymsParams.page! += 1
                }

                return try await self.searchSynonyms(
                    indexName: indexName,
                    searchSynonymsParams: updatedSearchSynonymsParams,
                    requestOptions: requestOptions
                )
            },
            validate: validate ?? { response in
                response.nbHits < hitsPerPage
            },
            aggregator: aggregator
        )
    }

    /// Helper: calls the `search` method but with certainty that we will only request Algolia records (hits) and not
    /// facets.
    /// Disclaimer: We don't assert that the parameters you pass to this method only contains `hits` requests to prevent
    /// impacting search performances, this helper is purely for typing purposes.
    open func searchForHits(
        searchMethodParams: SearchMethodParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> [SearchResponse] {
        try await self.search(searchMethodParams: searchMethodParams, requestOptions: requestOptions).results
            .reduce(into: [SearchResponse]()) { acc, cur in
                switch cur {
                case let .searchResponse(searchResponse):
                    acc.append(searchResponse)
                case .searchForFacetValuesResponse(_):
                    break
                }
            }
    }

    /// Helper: calls the `search` method but with certainty that we will only request Algolia facets and not records
    /// (hits).
    /// Disclaimer: We don't assert that the parameters you pass to this method only contains `facets` requests to
    /// prevent impacting search performances, this helper is purely for typing purposes.
    open func searchForFacets(
        searchMethodParams: SearchMethodParams,
        requestOptions: RequestOptions? = nil
    ) async throws -> [SearchForFacetValuesResponse] {
        try await self.search(searchMethodParams: searchMethodParams, requestOptions: requestOptions).results
            .reduce(into: [SearchForFacetValuesResponse]()) { acc, cur in
                switch cur {
                case .searchResponse(_):
                    break
                case let .searchForFacetValuesResponse(searchForFacet):
                    acc.append(searchForFacet)
                }
            }
    }
{{/isSearchClient}}
}
{{/operations}}
