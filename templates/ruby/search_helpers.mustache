def wait_for_task(index_name, task_id, max_retries = 50, timeout = -> (retry_count) { [retry_count * 200, 5000].min }, request_options = {})
  retries = 0
  while retries < max_retries
    res = get_task(index_name, task_id, request_options)
    if res.status == 'published'
      return res
    end
    retries += 1
    sleep(timeout.call(retries) / 1000.0)
  end
  raise ApiError, "The maximum number of retries exceeded. (#{max_retries})"
end

def wait_for_api_key(operation, key, api_key = {}, max_retries = 50, timeout = -> (retry_count) { [retry_count * 200, 5000].min }, request_options = {})
  retries = 0
  if operation == 'update'
    raise ArgumentError, '`api_key` is required when waiting for an `update` operation.' if api_key.nil?
    while retries < max_retries
      begin
        updatad_key = get_api_key(key, request_options)
        updated_key_hash = updatad_key.to_hash
        equals = true
        api_key.to_hash.each do |k, v|
          equals &&= updated_key_hash[k] == v
        end
      
        return updatad_key if equals
      rescue AlgoliaError => e
        raise e unless e.code == 404
      end

      retries += 1
      sleep(timeout.call(retries) / 1000.0)
    end
  
    raise ApiError, "The maximum number of retries exceeded. (#{max_retries})"
  end

  while retries < max_retries
    begin
      res = get_api_key(key, request_options)
      return res if operation == 'add'
    rescue AlgoliaError => e
      return res if operation == 'delete' && e.code == 404
    end
    retries += 1
    sleep(timeout.call(retries) / 1000.0)
  end
  raise ApiError, "The maximum number of retries exceeded. (#{max_retries})"
end
