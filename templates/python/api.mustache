{{>partial_header}}
{{>imports}}

from algoliasearch.{{packageName}}.models import ({{#operations}}{{#operation}}{{#imports}}{{{.}}},{{/imports}}{{/operation}}{{/operations}})

try:
    from typing import Self
except ImportError:
    from typing_extensions import Self


{{#operations}}
class {{classname}}:
    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
    NATIVE_TYPES_MAPPING = {
        "int": int,
        "float": float,
        "str": str,
        "bool": bool,
        "object": object,
    }

    def app_id(self) -> str:
        return self._config.app_id

    def __init__(self, transporter: Transporter, config: Config) -> None:
        self._transporter = transporter
        self._config = config

    def create_with_config(config: Config) -> Self:
        transporter = Transporter(config)

        return {{classname}}(transporter, config)

    def create(app_id: Optional[str] = None, api_key: Optional[str] = None) -> Self:
        return {{classname}}.create_with_config(Config(app_id, api_key))

    async def close(self) -> None:
        return await self._transporter.close()

    def __deserialize(self, data: Optional[dict], klass: any = None) -> dict:
        """Deserializes dict, list, str into an object.

        :param data: dict, list or str.
        :param klass: class literal, or string of class name.

        :return: object.
        """
        if data is None:
            return None

        if isinstance(klass, str):
            if klass.startswith("List["):
                sub_kls = match(r"List\[(.*)]", klass).group(1)
                return [self.__deserialize(sub_data, sub_kls) for sub_data in data]

            if klass.startswith("Dict["):
                sub_kls = match(r"Dict\[([^,]*), (.*)]", klass).group(2)
                return {k: self.__deserialize(v, sub_kls) for k, v in data.items()}

            if klass in self.NATIVE_TYPES_MAPPING:
                klass = self.NATIVE_TYPES_MAPPING[klass]

        if klass in self.PRIMITIVE_TYPES:
            try:
                return klass(data)
            except UnicodeEncodeError:
                return str(data)
            except TypeError:
                return data
        elif klass == object:
            return data
        else:
            return klass.from_json(data)

    {{#operation}}

    async def {{operationId}}_with_http_info{{>partial_api_args}} -> ApiResponse[str]:
        """
        {{#isDeprecated}}(Deprecated) {{/isDeprecated}}{{{summary}}}{{^summary}}{{operationId}}{{/summary}}

        {{#notes}}
        {{{.}}}
        {{/notes}}

        {{#allParams}}
        :param {{paramName}}:{{#description}} {{{.}}}{{/description}}{{#required}} (required){{/required}}{{#optional}}(optional){{/optional}}
        :type {{paramName}}: {{dataType}}{{#optional}}, optional{{/optional}}
        {{/allParams}}
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        :return: Returns the raw algoliasearch 'APIResponse' object.
        """

        {{#isDeprecated}}warnings.warn("{{{httpMethod}}} {{{path}}} is deprecated.", DeprecationWarning){{/isDeprecated}}

        {{#allParams}}
        {{#required}}
        if {{paramName}} is None:
            raise ValueError("'{{paramName}}' is required when calling '{{nickname}}'")

        {{/required}}
        {{/allParams}}

        _query_params: List[Tuple[str, str]] = []
        _body: Optional[bytes] = None
        {{#vendorExtensions}}
        _path = '{{{path}}}'{{#pathParams}}.replace({{=<% %>=}}'{<%baseName%>}'<%={{ }}=%>, {{#x-is-custom-request}}{{paramName}}{{/x-is-custom-request}}{{^x-is-custom-request}}quote(str({{paramName}})){{/x-is-custom-request}}){{/pathParams}}
        {{/vendorExtensions}}

        {{#queryParams}}
        if {{paramName}} is not None:
            _query_params.append(('{{baseName}}', {{paramName}}{{#isEnumRef}}.value{{/isEnumRef}}))
        {{/queryParams}}

        {{#bodyParam}}
        if {{paramName}} is not None:
            _body = {{paramName}}
        {{/bodyParam}}

        _param = self._transporter.param_serialize(
            query_params=_query_params,
            body=_body,
            request_options=request_options,
        )

        response = await self._transporter.request(
            verb=Verb.{{httpMethod}},
            path=_path,
            data=_param[0],
            request_options=_param[1],
            {{#vendorExtensions}}
              {{#x-use-read-transporter}}
            use_read_transporter=True,
              {{/x-use-read-transporter}}
            {{/vendorExtensions}}
        )

        response.data = response.raw_data

        return response

    async def {{operationId}}{{>partial_api_args}} -> {{{returnType}}}{{^returnType}}None{{/returnType}}:
        """
        {{#isDeprecated}}(Deprecated) {{/isDeprecated}}{{{summary}}}{{^summary}}{{operationId}}{{/summary}}

        {{#notes}}
        {{{.}}}
        {{/notes}}

        {{#allParams}}
        :param {{paramName}}:{{#description}} {{{.}}}{{/description}}{{#required}} (required){{/required}}{{#optional}}(optional){{/optional}}
        :type {{paramName}}: {{dataType}}{{#optional}}, optional{{/optional}}
        {{/allParams}}
        :param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
        {{#returnType}}
        :return: Returns the deserialized response in a '{{{returnType}}}' result object.
        {{/returnType}}
        """

        response = await self.{{operationId}}_with_http_info({{#allParams}}{{paramName}},{{/allParams}}request_options)

        return {{^returnType}}None{{/returnType}}{{#returnType}}self.__deserialize(response.raw_data, {{{returnType}}}){{/returnType}}
{{/operation}}
{{/operations}}