class {{classname}}({{#parent}}{{{.}}}{{/parent}}{{^parent}}BaseModel{{/parent}}):
{{>model_description}}

    @staticmethod
    def model_discriminator(v: Any) -> Optional[str]:
        {{#composedSchemas.oneOf}}
        {{#isContainer}}
        first_item = next(iter(v.values()))
        {{/isContainer}}
        if isinstance({{^isContainer}}v{{/isContainer}}{{#isContainer}}first_item{{/isContainer}}, {{#isArray}}list{{/isArray}}{{^isArray}}dict{{/isArray}}){{#isContainer}}{{#items}}{{#vendorExtensions.x-discriminator-fields}} and '{{{.}}}' in first_item{{/vendorExtensions.x-discriminator-fields}}{{/items}}{{/isContainer}}{{^isContainer}}{{#vendorExtensions.x-discriminator-fields}} and '{{{.}}}' in v{{/vendorExtensions.x-discriminator-fields}}{{/isContainer}}{{^isContainer}} or isinstance(v, {{{dataType}}}){{/isContainer}}:
            return '{{{dataType}}}'
        {{/composedSchemas.oneOf}}
        return getattr(v, 'value', None)

    value: Optional[Annotated[Union[
        {{#composedSchemas.oneOf}}
        Annotated[{{{dataType}}}, Tag('{{{dataType}}}')],
        {{/composedSchemas.oneOf}}
        ],
        Discriminator(model_discriminator),
    ]] = None

    model_config = ConfigDict(
        use_enum_values=True,
        validate_assignment=True,
        protected_namespaces=(),
    )
  
    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set `value`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(value=args[0])
        else:
            super().__init__(**kwargs)

    @classmethod
    def from_dict(cls, obj: Union[str, Dict[str, Any]]) -> Self:
        if isinstance(obj, dict):
            return cls.from_json(json.dumps(obj))
        else:
            return cls.from_json(obj)

    @classmethod
    def from_json(cls, json_str: {{#isNullable}}Optional[{{/isNullable}}str{{#isNullable}}]{{/isNullable}}) -> Self:
        instance = cls.model_construct()
        error_messages = []
        {{#composedSchemas.oneOf}}
        {{#isContainer}}
        try:
            instance.value = json.loads(json_str)
            return instance
        except ValidationError as e:
            error_messages.append(str(e))
        {{/isContainer}}
        {{^isContainer}}
        {{#isPrimitiveType}}
        try:
            instance.value = json.loads(json_str)
            return instance
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        {{/isPrimitiveType}}
        {{^isPrimitiveType}}
        try:
            instance.value = {{{dataType}}}.from_json(json_str)
            return instance
        except ValidationError as e:
            error_messages.append(str(e))
        {{/isPrimitiveType}}
        {{/isContainer}}
        {{/composedSchemas.oneOf}}
        raise ValueError("No match found when deserializing the JSON string into {{{classname}}} with oneOf schemas: {{#oneOf}}{{{.}}}{{^-last}}, {{/-last}}{{/oneOf}}. Details: " + ", ".join(error_messages))

    def to_json(self) -> str:
        """Returns the JSON representation of the one_of value"""
        if self.value is None:
            return "null"
        if hasattr(self.value, "to_json") and callable(self.value.to_json):
            return self.value.to_json()  # type: ignore
        else:
            return json.dumps(self.value)

    def to_dict(self) -> Optional[Union[Dict[str, Any], {{#oneOf}}{{{.}}}{{^-last}}, {{/-last}}{{/oneOf}}]]:
        """Returns the dict representation of the one_of value"""
        if self.value is None:
            return None
        if hasattr(self.value, "to_dict") and callable(self.value.to_dict):
            return self.value.to_dict()  # type: ignore
        else:
            return self.value

    def to_str(self) -> str:
        """Returns the string representation of the one_of value"""
        return pprint.pformat(self.model_dump(by_alias=True, exclude_unset=True, exclude_defaults=True))