import com.algolia.utils.CompoundType;
import com.algolia.utils.JSON;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import java.io.IOException;
import java.util.List;

/**
 * {{{description}}}{{^description}}{{classname}}{{/description}}{{#isDeprecated}}
 * @deprecated{{/isDeprecated}}
 */{{#isDeprecated}}
@Deprecated{{/isDeprecated}}
@JsonDeserialize(using = {{classname}}.{{classname}}Deserializer.class)
@JsonSerialize(using = {{classname}}.{{classname}}Serializer.class)
{{>additionalModelTypeAnnotations}}
public abstract class {{classname}} implements CompoundType {
    {{#vendorExtensions.x-one-of-list}}
    public static {{classname}} of{{#vendorExtensions.x-one-of-explicit-name}}{{{name}}}{{/vendorExtensions.x-one-of-explicit-name}}({{{type}}} inside) {
        return new {{classname}}{{name}}(inside);
    }

    {{/vendorExtensions.x-one-of-list}}

    public static class {{classname}}Serializer extends StdSerializer<{{classname}}> {
        public {{classname}}Serializer(Class<{{classname}}> t) {
            super(t);
        }

        public {{classname}}Serializer() {
            this(null);
        }

        @Override
        public void serialize({{classname}} value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
            jgen.writeObject(value.getInsideValue());
        }
    }

    public static class {{classname}}Deserializer extends StdDeserializer<{{classname}}> {
        public {{classname}}Deserializer() {
            this({{classname}}.class);
        }

        public {{classname}}Deserializer(Class<?> vc) {
            super(vc);
        }

         @Override
        public {{classname}} deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JsonNode tree = jp.readValueAsTree();
            {{{classname}}} deserialized = null;
           
            boolean typeCoercion = ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS);
            int match = 0;
            JsonToken token = tree.traverse(jp.getCodec()).nextToken();
            {{#vendorExtensions.x-one-of-list}}
            // deserialize {{{type}}}
            try {
                boolean attemptParsing = true;
                String currentType = new TypeReference<{{{type}}}>() {}.getType().getTypeName();
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (currentType.equals("Integer") || currentType.equals("Long") || currentType.equals("Float") || currentType.equals("Double") || currentType.equals("Boolean") || currentType.equals("String")) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((currentType.equals("Integer") || currentType.equals("Long")) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((currentType.equals("Float") || currentType.equals("Double")) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (currentType.equals("Boolean") && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (currentType.equals("String") && token == JsonToken.VALUE_STRING);
                        {{#isNullable}}
                        attemptParsing |= (token == JsonToken.VALUE_NULL);
                        {{/isNullable}}
                    }
                }
                if (attemptParsing) {
                    deserialized = {{{classname}}}.of{{#vendorExtensions.x-one-of-explicit-name}}{{{name}}}{{/vendorExtensions.x-one-of-explicit-name}}(({{{type}}}) tree.traverse(jp.getCodec()).readValueAs(new TypeReference<{{{type}}}>() {}));
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                }
            } catch (Exception e) {
                // deserialization failed, continue
                System.err.println("Failed to deserialize oneOf {{{type}}}");
            }

            {{/vendorExtensions.x-one-of-list}}
            if (match == 1) {
                return deserialized;
            }
            throw new IOException(String.format("Failed deserialization for {{classname}}: %d classes match result, expected 1", match));
        }

        /**
         * Handle deserialization of the 'null' value.
         */
        @Override
        public {{classname}} getNullValue(DeserializationContext ctxt) throws JsonMappingException {
        {{#isNullable}}
            return null;
        {{/isNullable}}
        {{^isNullable}}
            throw new JsonMappingException(ctxt.getParser(), "{{classname}} cannot be null");
        {{/isNullable}}
        }
    }
}

{{#vendorExtensions.x-one-of-list}}
class {{classname}}{{name}} extends {{classname}} {
    private final {{{type}}} insideValue;

    {{classname}}{{name}}({{{type}}} insideValue) {
        this.insideValue = insideValue;
    }

    @Override
    public {{{type}}} getInsideValue() {
        return insideValue;
    }
}
{{/vendorExtensions.x-one-of-list}}
