if (operation == ApiKeyOperation.UPDATE) {
  if (apiKey == null) {
    throw new AlgoliaRuntimeException("`apiKey` is required when waiting for an `update` operation.");
  }

  // when updating an api key, we poll the api until we receive a different key
  return TaskUtils.retryUntil(
    () -> this.getApiKey(key, requestOptions),
    (GetApiKeyResponse respKey) -> {
      // we need to convert to an ApiKey object to use the `equals` method
      ApiKey sameType = new ApiKey()
        .setAcl(respKey.getAcl())
        .setDescription(respKey.getDescription())
        .setIndexes(respKey.getIndexes())
        .setMaxHitsPerQuery(respKey.getMaxHitsPerQuery())
        .setMaxQueriesPerIPPerHour(respKey.getMaxQueriesPerIPPerHour())
        .setQueryParameters(respKey.getQueryParameters())
        .setReferers(respKey.getReferers())
        .setValidity(respKey.getValidity());

      return apiKey.equals(sameType);
    },
    maxRetries,
    timeout
  );
}

// bypass lambda restriction to modify final object
final GetApiKeyResponse[] addedKey = new GetApiKeyResponse[] { null };

// check the status of the getApiKey method
TaskUtils.retryUntil(
  () -> {
    try {
      addedKey[0] = this.getApiKey(key, requestOptions);
      // magic number to signify we found the key
      return -2;
    } catch (AlgoliaApiException e) {
      return e.getStatusCode();
    }
  },
  (Integer status) -> {
    switch (operation) {
      case ADD:
        // stop either when the key is created or when we don't receive 404
        return status == -2 || status != 404;
      case DELETE:
        // stop when the key is not found
        return status == 404;
      default:
        // continue
        return false;
    }
  },
  maxRetries,
  timeout
);

return addedKey[0];