/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.algolia.client.api

import com.algolia.client.model.search.AddApiKeyResponse
import com.algolia.client.model.search.Any
import com.algolia.client.model.search.ApiKey
import com.algolia.client.model.search.AssignUserIdParams
import com.algolia.client.model.search.AttributeToUpdate
import com.algolia.client.model.search.BatchAssignUserIdsParams
import com.algolia.client.model.search.BatchDictionaryEntriesParams
import com.algolia.client.model.search.BatchParams
import com.algolia.client.model.search.BatchResponse
import com.algolia.client.model.search.BatchWriteParams
import com.algolia.client.model.search.BrowseParams
import com.algolia.client.model.search.BrowseResponse
import com.algolia.client.model.search.CreatedAtResponse
import com.algolia.client.model.search.DeleteApiKeyResponse
import com.algolia.client.model.search.DeleteByParams
import com.algolia.client.model.search.DeleteSourceResponse
import com.algolia.client.model.search.DeletedAtResponse
import com.algolia.client.model.search.DictionarySettingsParams
import com.algolia.client.model.search.DictionaryType
import com.algolia.client.model.search.ErrorBase
import com.algolia.client.model.search.GetApiKeyResponse
import com.algolia.client.model.search.GetDictionarySettingsResponse
import com.algolia.client.model.search.GetLogsResponse
import com.algolia.client.model.search.GetObjectsParams
import com.algolia.client.model.search.GetObjectsResponse
import com.algolia.client.model.search.GetTaskResponse
import com.algolia.client.model.search.GetTopUserIdsResponse
import com.algolia.client.model.search.HasPendingMappingsResponse
import com.algolia.client.model.search.IndexSettings
import com.algolia.client.model.search.JsonObject
import com.algolia.client.model.search.Languages
import com.algolia.client.model.search.ListApiKeysResponse
import com.algolia.client.model.search.ListClustersResponse
import com.algolia.client.model.search.ListIndicesResponse
import com.algolia.client.model.search.ListUserIdsResponse
import com.algolia.client.model.search.LogType
import com.algolia.client.model.search.MultipleBatchResponse
import com.algolia.client.model.search.OperationIndexParams
import com.algolia.client.model.search.RemoveUserIdResponse
import com.algolia.client.model.search.ReplaceSourceResponse
import com.algolia.client.model.search.Rule
import com.algolia.client.model.search.SaveObjectResponse
import com.algolia.client.model.search.SaveSynonymResponse
import com.algolia.client.model.search.SearchDictionaryEntriesParams
import com.algolia.client.model.search.SearchForFacetValuesRequest
import com.algolia.client.model.search.SearchForFacetValuesResponse
import com.algolia.client.model.search.SearchMethodParams
import com.algolia.client.model.search.SearchParams
import com.algolia.client.model.search.SearchResponse
import com.algolia.client.model.search.SearchResponses
import com.algolia.client.model.search.SearchRulesParams
import com.algolia.client.model.search.SearchRulesResponse
import com.algolia.client.model.search.SearchSynonymsParams
import com.algolia.client.model.search.SearchSynonymsResponse
import com.algolia.client.model.search.SearchUserIdsParams
import com.algolia.client.model.search.SearchUserIdsResponse
import com.algolia.client.model.search.Source
import com.algolia.client.model.search.SynonymHit
import com.algolia.client.model.search.SynonymType
import com.algolia.client.model.search.UpdateApiKeyResponse
import com.algolia.client.model.search.UpdatedAtResponse
import com.algolia.client.model.search.UpdatedAtWithObjectIdResponse
import com.algolia.client.model.search.UpdatedRuleResponse
import com.algolia.client.model.search.UserId

import com.algolia.client.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class SearchClient : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * Add API key.
     * Add a new API key with specific permissions and restrictions. The request must be authenticated with the admin API key. The response returns an API key string. 
     * @param apiKey 
     * @return AddApiKeyResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun addApiKey(apiKey: ApiKey): HttpResponse<AddApiKeyResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = apiKey

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/keys",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Add or update a record (using objectID).
     * If you use an existing &#x60;objectID&#x60;, the existing record will be replaced with the new one.  To update only some attributes of an existing record, use the [&#x60;partial&#x60; operation](#tag/Records/operation/partialUpdateObject) instead.  To add multiple records to your index in a single API request, use the [&#x60;batch&#x60; operation](#tag/Records/operation/batch). 
     * @param indexName Index on which to perform the request.
     * @param objectID Unique record (object) identifier.
     * @param body Algolia record.
     * @return UpdatedAtWithObjectIdResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun addOrUpdateObject(indexName: String, objectID: String, body: JsonObject): HttpResponse<UpdatedAtWithObjectIdResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = AddOrUpdateObjectRequest(body)

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/1/indexes/{indexName}/{objectID}".replace("{" + "indexName" + "}", "$indexName").replace("{" + "objectID" + "}", "$objectID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    @Serializable
    private class AddOrUpdateObjectRequest(val value: Map<kotlin.String, JsonObject>) {
        @Serializer(AddOrUpdateObjectRequest::class)
        companion object : KSerializer<AddOrUpdateObjectRequest> {
            private val serializer: KSerializer<Map<kotlin.String, JsonObject>> = serializer<Map<String, JsonObject>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: AddOrUpdateObjectRequest) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = AddOrUpdateObjectRequest(serializer.deserialize(decoder))
        }
    }

    /**
     * Add a source.
     * Add a source to the list of allowed sources.
     * @param source Source to add.
     * @return CreatedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun appendSource(source: Source): HttpResponse<CreatedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = source

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/security/sources/append",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Assign or move a user ID.
     * Assign or move a user ID to a cluster. The time it takes to move a user is proportional to the amount of data linked to the user ID. 
     * @param xAlgoliaUserID userID to assign.
     * @param assignUserIdParams 
     * @return CreatedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun assignUserId(xAlgoliaUserID: String, assignUserIdParams: AssignUserIdParams): HttpResponse<CreatedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = assignUserIdParams

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xAlgoliaUserID?.apply { localVariableHeaders["X-Algolia-User-ID"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/clusters/mapping",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Batch write operations on one index.
     * To reduce the time spent on network round trips, you can perform several write actions in a single API call. Actions are applied in the order they are specified. The supported &#x60;action&#x60;s are equivalent to the individual operations of the same name. 
     * @param indexName Index on which to perform the request.
     * @param batchWriteParams 
     * @return BatchResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun batch(indexName: String, batchWriteParams: BatchWriteParams): HttpResponse<BatchResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = batchWriteParams

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/{indexName}/batch".replace("{" + "indexName" + "}", "$indexName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Batch assign userIDs.
     * Assign multiple user IDs to a cluster. **You can&#39;t _move_ users with this operation.**. 
     * @param xAlgoliaUserID userID to assign.
     * @param batchAssignUserIdsParams 
     * @return CreatedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun batchAssignUserIds(xAlgoliaUserID: String, batchAssignUserIdsParams: BatchAssignUserIdsParams): HttpResponse<CreatedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = batchAssignUserIdsParams

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xAlgoliaUserID?.apply { localVariableHeaders["X-Algolia-User-ID"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/clusters/mapping/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Batch dictionary entries.
     * Add or remove a batch of dictionary entries.
     * @param dictionaryName Dictionary to search in.
     * @param batchDictionaryEntriesParams 
     * @return UpdatedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun batchDictionaryEntries(dictionaryName: DictionaryType, batchDictionaryEntriesParams: BatchDictionaryEntriesParams): HttpResponse<UpdatedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = batchDictionaryEntriesParams

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/dictionaries/{dictionaryName}/batch".replace("{" + "dictionaryName" + "}", "$dictionaryName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Get all records from an index.
     * Retrieve up to 1,000 records per call. Supports full-text search and filters. For better performance, it doesn&#39;t support: - The &#x60;distinct&#x60; query parameter - Sorting by typos, proximity, words, or geographical distance. 
     * @param indexName Index on which to perform the request.
     * @param browseParams  (optional)
     * @return BrowseResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun browse(indexName: String, browseParams: BrowseParams? = null): HttpResponse<BrowseResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = browseParams

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/{indexName}/browse".replace("{" + "indexName" + "}", "$indexName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Delete all synonyms.
     * Delete all synonyms in the index.
     * @param indexName Index on which to perform the request.
     * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices. (optional)
     * @return UpdatedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun clearAllSynonyms(indexName: String, forwardToReplicas: Boolean? = null): HttpResponse<UpdatedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        forwardToReplicas?.apply { localVariableQuery["forwardToReplicas"] = listOf("$forwardToReplicas") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/{indexName}/synonyms/clear".replace("{" + "indexName" + "}", "$indexName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete all records from an index.
     * Delete the records but leave settings and index-specific API keys untouched.
     * @param indexName Index on which to perform the request.
     * @return UpdatedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun clearObjects(indexName: String): HttpResponse<UpdatedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/{indexName}/clear".replace("{" + "indexName" + "}", "$indexName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete all rules.
     * Delete all rules in the index.
     * @param indexName Index on which to perform the request.
     * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices. (optional)
     * @return UpdatedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun clearRules(indexName: String, forwardToReplicas: Boolean? = null): HttpResponse<UpdatedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        forwardToReplicas?.apply { localVariableQuery["forwardToReplicas"] = listOf("$forwardToReplicas") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/{indexName}/rules/clear".replace("{" + "indexName" + "}", "$indexName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Send requests to the Algolia REST API.
     * This method allow you to send requests to the Algolia REST API.
     * @param path Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
     * @param parameters Query parameters to apply to the current query. (optional)
     * @return JsonObject
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun del(path: String, parameters: Map<kotlin.String, Any>? = null): HttpResponse<JsonObject> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        parameters?.apply { localVariableQuery["parameters"] = toMultiValue(this, "") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/1{path}".replace("{" + "path" + "}", "$path"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete API key.
     * Delete an existing API key. The request must be authenticated with the admin API key. 
     * @param key API key.
     * @return DeleteApiKeyResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deleteApiKey(key: String): HttpResponse<DeleteApiKeyResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/1/keys/{key}".replace("{" + "key" + "}", "$key"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete all records matching a query.
     * This operation doesn&#39;t support all the query options, only its filters (numeric, facet, or tag) and geo queries. It doesn&#39;t accept empty filters or queries. 
     * @param indexName Index on which to perform the request.
     * @param deleteByParams 
     * @return DeletedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deleteBy(indexName: String, deleteByParams: DeleteByParams): HttpResponse<DeletedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = deleteByParams

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/{indexName}/deleteByQuery".replace("{" + "indexName" + "}", "$indexName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Delete index.
     * Delete an existing index.
     * @param indexName Index on which to perform the request.
     * @return DeletedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deleteIndex(indexName: String): HttpResponse<DeletedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/1/indexes/{indexName}".replace("{" + "indexName" + "}", "$indexName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete a record.
     * To delete a set of records matching a query, use the [&#x60;deleteByQuery&#x60; operation](#tag/Records/operation/deleteBy) instead.
     * @param indexName Index on which to perform the request.
     * @param objectID Unique record (object) identifier.
     * @return DeletedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deleteObject(indexName: String, objectID: String): HttpResponse<DeletedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/1/indexes/{indexName}/{objectID}".replace("{" + "indexName" + "}", "$indexName").replace("{" + "objectID" + "}", "$objectID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete a rule.
     * Delete a rule by its &#x60;objectID&#x60;. To find the &#x60;objectID&#x60; for rules, use the [&#x60;search&#x60; operation](#tag/Rules/operation/searchRules).
     * @param indexName Index on which to perform the request.
     * @param objectID Unique identifier of a rule object.
     * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices. (optional)
     * @return UpdatedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deleteRule(indexName: String, objectID: String, forwardToReplicas: Boolean? = null): HttpResponse<UpdatedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        forwardToReplicas?.apply { localVariableQuery["forwardToReplicas"] = listOf("$forwardToReplicas") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/1/indexes/{indexName}/rules/{objectID}".replace("{" + "indexName" + "}", "$indexName").replace("{" + "objectID" + "}", "$objectID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Remove a source.
     * Remove a source from the list of allowed sources.
     * @param source IP address range of the source.
     * @return DeleteSourceResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deleteSource(source: String): HttpResponse<DeleteSourceResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/1/security/sources/{source}".replace("{" + "source" + "}", "$source"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete a synonym.
     * Delete a synonym by its &#x60;objectID&#x60;. To find the object IDs of your synonyms, use the [&#x60;search&#x60; operation](#tag/Synonyms/operation/searchSynonyms).
     * @param indexName Index on which to perform the request.
     * @param objectID Unique identifier of a synonym object.
     * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices. (optional)
     * @return DeletedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deleteSynonym(indexName: String, objectID: String, forwardToReplicas: Boolean? = null): HttpResponse<DeletedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        forwardToReplicas?.apply { localVariableQuery["forwardToReplicas"] = listOf("$forwardToReplicas") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/1/indexes/{indexName}/synonyms/{objectID}".replace("{" + "indexName" + "}", "$indexName").replace("{" + "objectID" + "}", "$objectID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Send requests to the Algolia REST API.
     * This method allow you to send requests to the Algolia REST API.
     * @param path Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
     * @param parameters Query parameters to apply to the current query. (optional)
     * @return JsonObject
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun get(path: String, parameters: Map<kotlin.String, Any>? = null): HttpResponse<JsonObject> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        parameters?.apply { localVariableQuery["parameters"] = toMultiValue(this, "") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1{path}".replace("{" + "path" + "}", "$path"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get API key permissions.
     * Get the permissions and restrictions of a specific API key. When authenticating with the admin API key, you can request information for any of your application&#39;s keys. When authenticating with other API keys, you can only retrieve information for that key. 
     * @param key API key.
     * @return GetApiKeyResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getApiKey(key: String): HttpResponse<GetApiKeyResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/keys/{key}".replace("{" + "key" + "}", "$key"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List available languages.
     * Lists Algolia&#39;s [supported languages](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/) and any customizations applied to each language&#39;s [stop word](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plural](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), and [segmentation (compound)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) features.
     * @return Map<kotlin.String, Languages>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getDictionaryLanguages(): HttpResponse<Map<kotlin.String, Languages>> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/dictionaries/*/languages",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetDictionaryLanguagesResponse>().map { value }
    }

    @Serializable
    private class GetDictionaryLanguagesResponse(val value: Map<kotlin.String, Languages>) {
        @Serializer(GetDictionaryLanguagesResponse::class)
        companion object : KSerializer<GetDictionaryLanguagesResponse> {
            private val serializer: KSerializer<Map<kotlin.String, Languages>> = serializer<Map<String, Languages>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetDictionaryLanguagesResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetDictionaryLanguagesResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Get stop word settings.
     * Get the languages for which [stop words are turned off](#tag/Dictionaries/operation/setDictionarySettings).
     * @return GetDictionarySettingsResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getDictionarySettings(): HttpResponse<GetDictionarySettingsResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/dictionaries/*/settings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Return the latest log entries.
     * The request must be authenticated by an API key with the [&#x60;logs&#x60; ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl). Logs are held for the last seven days. There&#39;s also a logging limit of 1,000 API calls per server. This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn&#39;t appear in the logs itself. &gt; **Note**: To fetch the logs for a Distributed Search Network (DSN) cluster, target the [DSN&#39;s endpoint](https://www.algolia.com/doc/guides/scaling/distributed-search-network-dsn/#accessing-dsn-servers). 
     * @param offset First log entry to retrieve. Sorted by decreasing date with 0 being the most recent. (optional, default to 0)
     * @param length Maximum number of entries to retrieve. (optional, default to 10)
     * @param indexName Index for which log entries should be retrieved. When omitted, log entries are retrieved for all indices. (optional)
     * @param type Type of log entries to retrieve. When omitted, all log entries are retrieved. (optional, default to all)
     * @return GetLogsResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getLogs(offset: Int? = 0, length: Int? = 10, indexName: String? = null, type: LogType? = all): HttpResponse<GetLogsResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        offset?.apply { localVariableQuery["offset"] = listOf("$offset") }
        length?.apply { localVariableQuery["length"] = listOf("$length") }
        indexName?.apply { localVariableQuery["indexName"] = listOf("$indexName") }
        type?.apply { localVariableQuery["type"] = listOf("$type") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/logs",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get a record.
     * To get more than one record, use the [&#x60;objects&#x60; operation](#tag/Records/operation/getObjects).
     * @param indexName Index on which to perform the request.
     * @param objectID Unique record (object) identifier.
     * @param attributesToRetrieve Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned. &#x60;objectID&#x60; is always retrieved, even when not specified. [&#x60;unretrievableAttributes&#x60;](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/) won&#39;t be retrieved unless the request is authenticated with the admin API key.  (optional)
     * @return Map<kotlin.String, String>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getObject(indexName: String, objectID: String, attributesToRetrieve: List<String>? = null): HttpResponse<Map<kotlin.String, String>> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        attributesToRetrieve?.apply { localVariableQuery["attributesToRetrieve"] = toMultiValue(this, "multi") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/indexes/{indexName}/{objectID}".replace("{" + "indexName" + "}", "$indexName").replace("{" + "objectID" + "}", "$objectID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetObjectResponse>().map { value }
    }

    @Serializable
    private class GetObjectResponse(val value: Map<kotlin.String, String>) {
        @Serializer(GetObjectResponse::class)
        companion object : KSerializer<GetObjectResponse> {
            private val serializer: KSerializer<Map<kotlin.String, String>> = serializer<Map<String, String>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetObjectResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetObjectResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Get multiple records.
     * Retrieve one or more records, potentially from different indices, in a single API operation. Results will be received in the same order as the requests. 
     * @param getObjectsParams Request object.
     * @return GetObjectsResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getObjects(getObjectsParams: GetObjectsParams): HttpResponse<GetObjectsResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = getObjectsParams

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/*/objects",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Get a rule.
     * Get a rule by its &#x60;objectID&#x60;. To find the &#x60;objectID&#x60; for rules, use the [&#x60;search&#x60; operation](#tag/Rules/operation/searchRules).
     * @param indexName Index on which to perform the request.
     * @param objectID Unique identifier of a rule object.
     * @return Rule
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getRule(indexName: String, objectID: String): HttpResponse<Rule> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/indexes/{indexName}/rules/{objectID}".replace("{" + "indexName" + "}", "$indexName").replace("{" + "objectID" + "}", "$objectID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get index settings.
     * Return an object containing an index&#39;s [configuration settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/).
     * @param indexName Index on which to perform the request.
     * @return IndexSettings
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSettings(indexName: String): HttpResponse<IndexSettings> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/indexes/{indexName}/settings".replace("{" + "indexName" + "}", "$indexName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get all allowed IP addresses.
     * Get all allowed sources (IP addresses).
     * @return List<Source>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSources(): HttpResponse<List<Source>> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/security/sources",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetSourcesResponse>().map { value }
    }

    @Serializable
    private class GetSourcesResponse(val value: List<Source>) {
        @Serializer(GetSourcesResponse::class)
        companion object : KSerializer<GetSourcesResponse> {
            private val serializer: KSerializer<List<Source>> = serializer<List<Source>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetSourcesResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetSourcesResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Get a synonym object.
     * Get a syonym by its &#x60;objectID&#x60;. To find the object IDs for your synonyms, use the [&#x60;search&#x60; operation](#tag/Synonyms/operation/searchSynonyms).
     * @param indexName Index on which to perform the request.
     * @param objectID Unique identifier of a synonym object.
     * @return SynonymHit
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSynonym(indexName: String, objectID: String): HttpResponse<SynonymHit> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/indexes/{indexName}/synonyms/{objectID}".replace("{" + "indexName" + "}", "$indexName").replace("{" + "objectID" + "}", "$objectID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Check a task&#39;s status.
     * Some operations, such as copying an index, will respond with a &#x60;taskID&#x60; value. Use this value here to check the status of that task.
     * @param indexName Index on which to perform the request.
     * @param taskID Unique task identifier.
     * @return GetTaskResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getTask(indexName: String, taskID: Long): HttpResponse<GetTaskResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/indexes/{indexName}/task/{taskID}".replace("{" + "indexName" + "}", "$indexName").replace("{" + "taskID" + "}", "$taskID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get top userID.
     * Get the IDs of the 10 users with the highest number of records per cluster. Since it can take up to a few seconds to get the data from the different clusters, the response isn&#39;t real-time. 
     * @return GetTopUserIdsResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getTopUserIds(): HttpResponse<GetTopUserIdsResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/clusters/mapping/top",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get userID.
     * Returns the userID data stored in the mapping. Since it can take up to a few seconds to get the data from the different clusters, the response isn&#39;t real-time. 
     * @param userID userID to assign.
     * @return UserId
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getUserId(userID: String): HttpResponse<UserId> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/clusters/mapping/{userID}".replace("{" + "userID" + "}", "$userID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get migration and user mapping status.
     * To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process. 
     * @param getClusters Indicates whether to include the cluster&#39;s pending mapping state in the response. (optional)
     * @return HasPendingMappingsResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun hasPendingMappings(getClusters: Boolean? = null): HttpResponse<HasPendingMappingsResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        getClusters?.apply { localVariableQuery["getClusters"] = listOf("$getClusters") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/clusters/mapping/pending",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List API keys.
     * List all API keys associated with your Algolia application, including their permissions and restrictions.
     * @return ListApiKeysResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listApiKeys(): HttpResponse<ListApiKeysResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/keys",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List clusters.
     * List the available clusters in a multi-cluster setup.
     * @return ListClustersResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listClusters(): HttpResponse<ListClustersResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/clusters",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List indices.
     * List indices in an Algolia application.
     * @param page Returns the requested page number. The page size is determined by the &#x60;hitsPerPage&#x60; parameter. You can see the number of available pages in the &#x60;nbPages&#x60; response attribute. When &#x60;page&#x60; is null, the API response is not paginated.  (optional)
     * @param hitsPerPage Maximum number of hits per page. (optional, default to 100)
     * @return ListIndicesResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listIndices(page: Int? = null, hitsPerPage: Int? = 100): HttpResponse<ListIndicesResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        hitsPerPage?.apply { localVariableQuery["hitsPerPage"] = listOf("$hitsPerPage") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/indexes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List userIDs.
     * List the userIDs assigned to a multi-cluster application. Since it can take up to a few seconds to get the data from the different clusters, the response isn&#39;t real-time. 
     * @param page Returns the requested page number. The page size is determined by the &#x60;hitsPerPage&#x60; parameter. You can see the number of available pages in the &#x60;nbPages&#x60; response attribute. When &#x60;page&#x60; is null, the API response is not paginated.  (optional)
     * @param hitsPerPage Maximum number of hits per page. (optional, default to 100)
     * @return ListUserIdsResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listUserIds(page: Int? = null, hitsPerPage: Int? = 100): HttpResponse<ListUserIdsResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        hitsPerPage?.apply { localVariableQuery["hitsPerPage"] = listOf("$hitsPerPage") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/1/clusters/mapping",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Batch write operations on multiple indices.
     * To reduce the time spent on network round trips, you can perform several write actions in a single request. It&#39;s a multi-index version of the [&#x60;batch&#x60; operation](#tag/Records/operation/batch). Actions are applied in the order they are specified. The supported actions are equivalent to the individual operations of the same name. 
     * @param batchParams 
     * @return MultipleBatchResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun multipleBatch(batchParams: BatchParams): HttpResponse<MultipleBatchResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = batchParams

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/*/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Copy, move, or rename an index.
     * This &#x60;operation&#x60;, _copy_ or _move_, will copy or move a source index&#39;s (&#x60;IndexName&#x60;) records, settings, synonyms, and rules to a &#x60;destination&#x60; index. If the destination index exists, it will be replaced, except for index-specific API keys and analytics data. If the destination index doesn&#39;t exist, it will be created.  The choice between moving or copying an index depends on your needs. Choose:  - **Move** to rename an index. - **Copy** to create a new index with the same records and configuration as an existing one.  &gt; **Note**: When considering copying or moving, be aware of the [rate limitations](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits) on these processes and the [impact on your analytics data](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/concepts/indices-analytics/).
     * @param indexName Index on which to perform the request.
     * @param operationIndexParams 
     * @return UpdatedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun operationIndex(indexName: String, operationIndexParams: OperationIndexParams): HttpResponse<UpdatedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = operationIndexParams

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/{indexName}/operation".replace("{" + "indexName" + "}", "$indexName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Update record attributes.
     * Add new attributes or update current ones in an existing record. You can use any first-level attribute but not nested attributes. If you specify a [nested attribute](https://www.algolia.com/doc/guides/sending-and-managing-data/prepare-your-data/how-to/creating-and-using-nested-attributes/), the engine treats it as a replacement for its first-level ancestor. 
     * @param indexName Index on which to perform the request.
     * @param objectID Unique record (object) identifier.
     * @param attributesToUpdate Object with attributes to update.
     * @param createIfNotExists Indicates whether to create a new record if it doesn&#39;t exist yet.  (optional, default to true)
     * @return UpdatedAtWithObjectIdResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun partialUpdateObject(indexName: String, objectID: String, attributesToUpdate: Map<kotlin.String, AttributeToUpdate>, createIfNotExists: Boolean? = true): HttpResponse<UpdatedAtWithObjectIdResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = PartialUpdateObjectRequest(attributesToUpdate)

        val localVariableQuery = mutableMapOf<String, List<String>>()
        createIfNotExists?.apply { localVariableQuery["createIfNotExists"] = listOf("$createIfNotExists") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/{indexName}/{objectID}/partial".replace("{" + "indexName" + "}", "$indexName").replace("{" + "objectID" + "}", "$objectID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    @Serializable
    private class PartialUpdateObjectRequest(val value: Map<kotlin.String, AttributeToUpdate>) {
        @Serializer(PartialUpdateObjectRequest::class)
        companion object : KSerializer<PartialUpdateObjectRequest> {
            private val serializer: KSerializer<Map<kotlin.String, AttributeToUpdate>> = serializer<Map<String, AttributeToUpdate>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: PartialUpdateObjectRequest) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = PartialUpdateObjectRequest(serializer.deserialize(decoder))
        }
    }

    /**
     * Send requests to the Algolia REST API.
     * This method allow you to send requests to the Algolia REST API.
     * @param path Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
     * @param parameters Query parameters to apply to the current query. (optional)
     * @param body Parameters to send with the custom request. (optional)
     * @return JsonObject
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun post(path: String, parameters: Map<kotlin.String, Any>? = null, body: JsonObject? = null): HttpResponse<JsonObject> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = PostRequest(body)

        val localVariableQuery = mutableMapOf<String, List<String>>()
        parameters?.apply { localVariableQuery["parameters"] = toMultiValue(this, "") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1{path}".replace("{" + "path" + "}", "$path"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    @Serializable
    private class PostRequest(val value: Map<kotlin.String, JsonObject>) {
        @Serializer(PostRequest::class)
        companion object : KSerializer<PostRequest> {
            private val serializer: KSerializer<Map<kotlin.String, JsonObject>> = serializer<Map<String, JsonObject>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: PostRequest) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = PostRequest(serializer.deserialize(decoder))
        }
    }

    /**
     * Send requests to the Algolia REST API.
     * This method allow you to send requests to the Algolia REST API.
     * @param path Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
     * @param parameters Query parameters to apply to the current query. (optional)
     * @param body Parameters to send with the custom request. (optional)
     * @return JsonObject
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun put(path: String, parameters: Map<kotlin.String, Any>? = null, body: JsonObject? = null): HttpResponse<JsonObject> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = PutRequest(body)

        val localVariableQuery = mutableMapOf<String, List<String>>()
        parameters?.apply { localVariableQuery["parameters"] = toMultiValue(this, "") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/1{path}".replace("{" + "path" + "}", "$path"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    @Serializable
    private class PutRequest(val value: Map<kotlin.String, JsonObject>) {
        @Serializer(PutRequest::class)
        companion object : KSerializer<PutRequest> {
            private val serializer: KSerializer<Map<kotlin.String, JsonObject>> = serializer<Map<String, JsonObject>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: PutRequest) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = PutRequest(serializer.deserialize(decoder))
        }
    }

    /**
     * Remove userID.
     * Remove a userID and its associated data from the multi-clusters.
     * @param userID userID to assign.
     * @return RemoveUserIdResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun removeUserId(userID: String): HttpResponse<RemoveUserIdResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/1/clusters/mapping/{userID}".replace("{" + "userID" + "}", "$userID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Replace all sources.
     * Replace all allowed sources.
     * @param source Allowed sources.
     * @return ReplaceSourceResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun replaceSources(source: List<Source>): HttpResponse<ReplaceSourceResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = ReplaceSourcesRequest(source)

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/1/security/sources",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    @Serializable
    private class ReplaceSourcesRequest(val value: List<Source>) {
        @Serializer(ReplaceSourcesRequest::class)
        companion object : KSerializer<ReplaceSourcesRequest> {
            private val serializer: KSerializer<List<Source>> = serializer<List<Source>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: ReplaceSourcesRequest) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = ReplaceSourcesRequest(serializer.deserialize(decoder))
        }
    }

    /**
     * Restore API key.
     * Restore a deleted API key, along with its associated permissions. The request must be authenticated with the admin API key. 
     * @param key API key.
     * @return AddApiKeyResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun restoreApiKey(key: String): HttpResponse<AddApiKeyResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/keys/{key}/restore".replace("{" + "key" + "}", "$key"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Add or update a record.
     * Add a record (object) to an index or replace it. If the record doesn&#39;t contain an &#x60;objectID&#x60;, Algolia automatically adds it. If you use an existing &#x60;objectID&#x60;, the existing record is replaced with the new one. To add multiple records to your index in a single API request, use the [&#x60;batch&#x60; operation](#tag/Records/operation/batch). 
     * @param indexName Index on which to perform the request.
     * @param body The Algolia record.
     * @return SaveObjectResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun saveObject(indexName: String, body: JsonObject): HttpResponse<SaveObjectResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = SaveObjectRequest(body)

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/{indexName}".replace("{" + "indexName" + "}", "$indexName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    @Serializable
    private class SaveObjectRequest(val value: Map<kotlin.String, JsonObject>) {
        @Serializer(SaveObjectRequest::class)
        companion object : KSerializer<SaveObjectRequest> {
            private val serializer: KSerializer<Map<kotlin.String, JsonObject>> = serializer<Map<String, JsonObject>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: SaveObjectRequest) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = SaveObjectRequest(serializer.deserialize(decoder))
        }
    }

    /**
     * Create or update a rule.
     * To create or update more than one rule, use the [&#x60;batch&#x60; operation](#tag/Rules/operation/saveRules).
     * @param indexName Index on which to perform the request.
     * @param objectID Unique identifier of a rule object.
     * @param rule 
     * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices. (optional)
     * @return UpdatedRuleResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun saveRule(indexName: String, objectID: String, rule: Rule, forwardToReplicas: Boolean? = null): HttpResponse<UpdatedRuleResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = rule

        val localVariableQuery = mutableMapOf<String, List<String>>()
        forwardToReplicas?.apply { localVariableQuery["forwardToReplicas"] = listOf("$forwardToReplicas") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/1/indexes/{indexName}/rules/{objectID}".replace("{" + "indexName" + "}", "$indexName").replace("{" + "objectID" + "}", "$objectID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Save a batch of rules.
     * Create or update multiple rules.
     * @param indexName Index on which to perform the request.
     * @param rules 
     * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices. (optional)
     * @param clearExistingRules Indicates whether existing rules should be deleted before adding this batch. (optional)
     * @return UpdatedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun saveRules(indexName: String, rules: List<Rule>, forwardToReplicas: Boolean? = null, clearExistingRules: Boolean? = null): HttpResponse<UpdatedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = SaveRulesRequest(rules)

        val localVariableQuery = mutableMapOf<String, List<String>>()
        forwardToReplicas?.apply { localVariableQuery["forwardToReplicas"] = listOf("$forwardToReplicas") }
        clearExistingRules?.apply { localVariableQuery["clearExistingRules"] = listOf("$clearExistingRules") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/{indexName}/rules/batch".replace("{" + "indexName" + "}", "$indexName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    @Serializable
    private class SaveRulesRequest(val value: List<Rule>) {
        @Serializer(SaveRulesRequest::class)
        companion object : KSerializer<SaveRulesRequest> {
            private val serializer: KSerializer<List<Rule>> = serializer<List<Rule>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: SaveRulesRequest) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = SaveRulesRequest(serializer.deserialize(decoder))
        }
    }

    /**
     * Save a synonym.
     * Add a [synonym](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms) to an index or replace it. If the synonym &#x60;objectID&#x60; doesn&#39;t exist, Algolia adds a new one. If you use an existing synonym &#x60;objectID&#x60;, the existing synonym is replaced with the new one. To add multiple synonyms in a single API request, use the [&#x60;batch&#x60; operation](#tag/Synonyms/operation/saveSynonyms). 
     * @param indexName Index on which to perform the request.
     * @param objectID Unique identifier of a synonym object.
     * @param synonymHit 
     * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices. (optional)
     * @return SaveSynonymResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun saveSynonym(indexName: String, objectID: String, synonymHit: SynonymHit, forwardToReplicas: Boolean? = null): HttpResponse<SaveSynonymResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = synonymHit

        val localVariableQuery = mutableMapOf<String, List<String>>()
        forwardToReplicas?.apply { localVariableQuery["forwardToReplicas"] = listOf("$forwardToReplicas") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/1/indexes/{indexName}/synonyms/{objectID}".replace("{" + "indexName" + "}", "$indexName").replace("{" + "objectID" + "}", "$objectID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Save a batch of synonyms.
     * Create or update multiple synonyms.
     * @param indexName Index on which to perform the request.
     * @param synonymHit 
     * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices. (optional)
     * @param replaceExistingSynonyms Indicates whether to replace all synonyms in the index with the ones sent with this request. (optional)
     * @return UpdatedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun saveSynonyms(indexName: String, synonymHit: List<SynonymHit>, forwardToReplicas: Boolean? = null, replaceExistingSynonyms: Boolean? = null): HttpResponse<UpdatedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = SaveSynonymsRequest(synonymHit)

        val localVariableQuery = mutableMapOf<String, List<String>>()
        forwardToReplicas?.apply { localVariableQuery["forwardToReplicas"] = listOf("$forwardToReplicas") }
        replaceExistingSynonyms?.apply { localVariableQuery["replaceExistingSynonyms"] = listOf("$replaceExistingSynonyms") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/{indexName}/synonyms/batch".replace("{" + "indexName" + "}", "$indexName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    @Serializable
    private class SaveSynonymsRequest(val value: List<SynonymHit>) {
        @Serializer(SaveSynonymsRequest::class)
        companion object : KSerializer<SaveSynonymsRequest> {
            private val serializer: KSerializer<List<SynonymHit>> = serializer<List<SynonymHit>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: SaveSynonymsRequest) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = SaveSynonymsRequest(serializer.deserialize(decoder))
        }
    }

    /**
     * Search multiple indices.
     * Send multiple search queries to one or more indices.
     * @param searchMethodParams Query requests and strategies. Results will be received in the same order as the queries.
     * @return SearchResponses
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun search(searchMethodParams: SearchMethodParams): HttpResponse<SearchResponses> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = searchMethodParams

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/*/queries",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Search dictionary entries.
     * Search for standard and [custom](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/) entries in the [stop words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plurals](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), or [segmentation (compounds)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) dictionaries.
     * @param dictionaryName Dictionary to search in.
     * @param searchDictionaryEntriesParams 
     * @return UpdatedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun searchDictionaryEntries(dictionaryName: DictionaryType, searchDictionaryEntriesParams: SearchDictionaryEntriesParams): HttpResponse<UpdatedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = searchDictionaryEntriesParams

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/dictionaries/{dictionaryName}/search".replace("{" + "dictionaryName" + "}", "$dictionaryName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Search for facet values.
     * [Search for a facet&#39;s values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values), optionally restricting the returned values to those contained in records matching other search criteria. &gt; **Note**: Pagination isn&#39;t supported (&#x60;page&#x60; and &#x60;hitsPerPage&#x60; are ignored). By default, the engine returns a maximum of 10 values but you can adjust this with &#x60;maxFacetHits&#x60;. 
     * @param indexName Index on which to perform the request.
     * @param facetName Facet name.
     * @param searchForFacetValuesRequest  (optional)
     * @return SearchForFacetValuesResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun searchForFacetValues(indexName: String, facetName: String, searchForFacetValuesRequest: SearchForFacetValuesRequest? = null): HttpResponse<SearchForFacetValuesResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = searchForFacetValuesRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/{indexName}/facets/{facetName}/query".replace("{" + "indexName" + "}", "$indexName").replace("{" + "facetName" + "}", "$facetName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Search for rules.
     * Search for rules in your index. You can control the search with parameters. To list all rules, send an empty request body.
     * @param indexName Index on which to perform the request.
     * @param searchRulesParams  (optional)
     * @return SearchRulesResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun searchRules(indexName: String, searchRulesParams: SearchRulesParams? = null): HttpResponse<SearchRulesResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = searchRulesParams

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/{indexName}/rules/search".replace("{" + "indexName" + "}", "$indexName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Search an index.
     * Return records that match the query.
     * @param indexName Index on which to perform the request.
     * @param searchParams  (optional)
     * @return SearchResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun searchSingleIndex(indexName: String, searchParams: SearchParams? = null): HttpResponse<SearchResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = searchParams

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/{indexName}/query".replace("{" + "indexName" + "}", "$indexName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Search for synonyms.
     * Search for synonyms in your index. You can control and filter the search with parameters. To get all synonyms, send an empty request body.
     * @param indexName Index on which to perform the request.
     * @param type Search for specific [types of synonyms](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms). (optional)
     * @param page Returns the requested page number (the first page is 0). Page size is set by &#x60;hitsPerPage&#x60;. When null, there&#39;s no pagination.  (optional, default to 0)
     * @param hitsPerPage Maximum number of hits per page. (optional, default to 100)
     * @param searchSynonymsParams Body of the &#x60;searchSynonyms&#x60; operation. (optional)
     * @return SearchSynonymsResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun searchSynonyms(indexName: String, type: SynonymType? = null, page: Int? = 0, hitsPerPage: Int? = 100, searchSynonymsParams: SearchSynonymsParams? = null): HttpResponse<SearchSynonymsResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = searchSynonymsParams

        val localVariableQuery = mutableMapOf<String, List<String>>()
        type?.apply { localVariableQuery["type"] = listOf("$type") }
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        hitsPerPage?.apply { localVariableQuery["hitsPerPage"] = listOf("$hitsPerPage") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/indexes/{indexName}/synonyms/search".replace("{" + "indexName" + "}", "$indexName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Search for a user ID.
     * Since it can take up to a few seconds to get the data from the different clusters, the response isn&#39;t real-time. To ensure rapid updates, the user IDs index isn&#39;t built at the same time as the mapping. Instead, it&#39;s built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).  
     * @param searchUserIdsParams 
     * @return SearchUserIdsResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun searchUserIds(searchUserIdsParams: SearchUserIdsParams): HttpResponse<SearchUserIdsResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = searchUserIdsParams

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/1/clusters/mapping/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Set stop word settings.
     * Set stop word settings for a specific language.
     * @param dictionarySettingsParams 
     * @return UpdatedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun setDictionarySettings(dictionarySettingsParams: DictionarySettingsParams): HttpResponse<UpdatedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = dictionarySettingsParams

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/1/dictionaries/*/settings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Update index settings.
     * Update the specified [index settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/). Specifying null for a setting resets it to its default value.
     * @param indexName Index on which to perform the request.
     * @param indexSettings 
     * @param forwardToReplicas Indicates whether changed index settings are forwarded to the replica indices. (optional)
     * @return UpdatedAtResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun setSettings(indexName: String, indexSettings: IndexSettings, forwardToReplicas: Boolean? = null): HttpResponse<UpdatedAtResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = indexSettings

        val localVariableQuery = mutableMapOf<String, List<String>>()
        forwardToReplicas?.apply { localVariableQuery["forwardToReplicas"] = listOf("$forwardToReplicas") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/1/indexes/{indexName}/settings".replace("{" + "indexName" + "}", "$indexName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Update an API key.
     * Replace the permissions of an existing API key. Any unspecified parameter resets that permission to its default value. The request must be authenticated with the admin API key. 
     * @param key API key.
     * @param apiKey 
     * @return UpdateApiKeyResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updateApiKey(key: String, apiKey: ApiKey): HttpResponse<UpdateApiKeyResponse> {

        val localVariableAuthNames = listOf<String>("apiKey", "appId")

        val localVariableBody = apiKey

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/1/keys/{key}".replace("{" + "key" + "}", "$key"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



}
