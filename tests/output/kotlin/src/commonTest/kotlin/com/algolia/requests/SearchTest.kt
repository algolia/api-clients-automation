// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package com.algolia.requests

import com.algolia.client.api.SearchClient
import com.algolia.client.configuration.*
import com.algolia.client.model.search.*
import com.algolia.client.transport.*
import com.algolia.utils.*
import io.ktor.http.*
import kotlinx.coroutines.test.*
import kotlinx.serialization.json.*
import kotlin.test.*

class SearchTest {

  val client = SearchClient(
    appId = "appId",
    apiKey = "apiKey",
  )

  // addApiKey

  @Test
  fun `addApiKey`() = runTest {
    client.runTest(
      call = {
        addApiKey(
          apiKey = ApiKey(
            acl = listOf(Acl.entries.first { it.value == "search" }, Acl.entries.first { it.value == "addObject" }),
            description = "my new api key",
            validity = 300,
            maxQueriesPerIPPerHour = 100,
            maxHitsPerQuery = 20,
          ),
        )
      },
      intercept = {
        assertEquals("/1/keys".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"acl":["search","addObject"],"description":"my new api key","validity":300,"maxQueriesPerIPPerHour":100,"maxHitsPerQuery":20}""", it.body)
      },
    )
  }

  // addOrUpdateObject

  @Test
  fun `addOrUpdateObject`() = runTest {
    client.runTest(
      call = {
        addOrUpdateObject(
          indexName = "indexName",
          objectID = "uniqueID",
          body = buildJsonObject {
            put(
              "key",
              JsonPrimitive("value"),
            )
          },
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/uniqueID".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertJsonBody("""{"key":"value"}""", it.body)
      },
    )
  }

  // appendSource

  @Test
  fun `appendSource`() = runTest {
    client.runTest(
      call = {
        appendSource(
          source = Source(
            source = "theSource",
            description = "theDescription",
          ),
        )
      },
      intercept = {
        assertEquals("/1/security/sources/append".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"source":"theSource","description":"theDescription"}""", it.body)
      },
    )
  }

  // assignUserId

  @Test
  fun `assignUserId`() = runTest {
    client.runTest(
      call = {
        assignUserId(
          xAlgoliaUserID = "userID",
          assignUserIdParams = AssignUserIdParams(
            cluster = "theCluster",
          ),
        )
      },
      intercept = {
        assertEquals("/1/clusters/mapping".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertContainsAll("""{"x-algolia-user-id":"userID"}""", it.headers)
        assertJsonBody("""{"cluster":"theCluster"}""", it.body)
      },
    )
  }

  @Test
  fun `it should not encode the userID1`() = runTest {
    client.runTest(
      call = {
        assignUserId(
          xAlgoliaUserID = "user id with spaces",
          assignUserIdParams = AssignUserIdParams(
            cluster = "cluster with spaces",
          ),
        )
      },
      intercept = {
        assertEquals("/1/clusters/mapping".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertContainsAll("""{"x-algolia-user-id":"user id with spaces"}""", it.headers)
        assertJsonBody("""{"cluster":"cluster with spaces"}""", it.body)
      },
    )
  }

  // batch

  @Test
  fun `addObject`() = runTest {
    client.runTest(
      call = {
        batch(
          indexName = "<YOUR_INDEX_NAME>",
          batchWriteParams = BatchWriteParams(
            requests = listOf(
              BatchRequest(
                action = Action.entries.first { it.value == "addObject" },
                body = buildJsonObject {
                  put(
                    "key",
                    JsonPrimitive("bar"),
                  )
                  put(
                    "foo",
                    JsonPrimitive("1"),
                  )
                },
              ),
              BatchRequest(
                action = Action.entries.first { it.value == "addObject" },
                body = buildJsonObject {
                  put(
                    "key",
                    JsonPrimitive("baz"),
                  )
                  put(
                    "foo",
                    JsonPrimitive("2"),
                  )
                },
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"action":"addObject","body":{"key":"bar","foo":"1"}},{"action":"addObject","body":{"key":"baz","foo":"2"}}]}""", it.body)
      },
    )
  }

  @Test
  fun `clear1`() = runTest {
    client.runTest(
      call = {
        batch(
          indexName = "<YOUR_INDEX_NAME>",
          batchWriteParams = BatchWriteParams(
            requests = listOf(
              BatchRequest(
                action = Action.entries.first { it.value == "clear" },
                body = buildJsonObject {
                  put(
                    "key",
                    JsonPrimitive("value"),
                  )
                },
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"action":"clear","body":{"key":"value"}}]}""", it.body)
      },
    )
  }

  @Test
  fun `delete2`() = runTest {
    client.runTest(
      call = {
        batch(
          indexName = "<YOUR_INDEX_NAME>",
          batchWriteParams = BatchWriteParams(
            requests = listOf(
              BatchRequest(
                action = Action.entries.first { it.value == "delete" },
                body = buildJsonObject {
                  put(
                    "key",
                    JsonPrimitive("value"),
                  )
                },
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"action":"delete","body":{"key":"value"}}]}""", it.body)
      },
    )
  }

  @Test
  fun `deleteObject3`() = runTest {
    client.runTest(
      call = {
        batch(
          indexName = "<YOUR_INDEX_NAME>",
          batchWriteParams = BatchWriteParams(
            requests = listOf(
              BatchRequest(
                action = Action.entries.first { it.value == "deleteObject" },
                body = buildJsonObject {
                  put(
                    "key",
                    JsonPrimitive("value"),
                  )
                },
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"action":"deleteObject","body":{"key":"value"}}]}""", it.body)
      },
    )
  }

  @Test
  fun `partialUpdateObject4`() = runTest {
    client.runTest(
      call = {
        batch(
          indexName = "<YOUR_INDEX_NAME>",
          batchWriteParams = BatchWriteParams(
            requests = listOf(
              BatchRequest(
                action = Action.entries.first { it.value == "partialUpdateObject" },
                body = buildJsonObject {
                  put(
                    "key",
                    JsonPrimitive("value"),
                  )
                },
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"action":"partialUpdateObject","body":{"key":"value"}}]}""", it.body)
      },
    )
  }

  @Test
  fun `partialUpdateObjectNoCreate5`() = runTest {
    client.runTest(
      call = {
        batch(
          indexName = "<YOUR_INDEX_NAME>",
          batchWriteParams = BatchWriteParams(
            requests = listOf(
              BatchRequest(
                action = Action.entries.first { it.value == "partialUpdateObjectNoCreate" },
                body = buildJsonObject {
                  put(
                    "key",
                    JsonPrimitive("value"),
                  )
                },
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"action":"partialUpdateObjectNoCreate","body":{"key":"value"}}]}""", it.body)
      },
    )
  }

  @Test
  fun `updateObject6`() = runTest {
    client.runTest(
      call = {
        batch(
          indexName = "<YOUR_INDEX_NAME>",
          batchWriteParams = BatchWriteParams(
            requests = listOf(
              BatchRequest(
                action = Action.entries.first { it.value == "updateObject" },
                body = buildJsonObject {
                  put(
                    "key",
                    JsonPrimitive("value"),
                  )
                },
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"action":"updateObject","body":{"key":"value"}}]}""", it.body)
      },
    )
  }

  // batchAssignUserIds

  @Test
  fun `batchAssignUserIds`() = runTest {
    client.runTest(
      call = {
        batchAssignUserIds(
          xAlgoliaUserID = "userID",
          batchAssignUserIdsParams = BatchAssignUserIdsParams(
            cluster = "theCluster",
            users = listOf("user1", "user2"),
          ),
        )
      },
      intercept = {
        assertEquals("/1/clusters/mapping/batch".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertContainsAll("""{"x-algolia-user-id":"userID"}""", it.headers)
        assertJsonBody("""{"cluster":"theCluster","users":["user1","user2"]}""", it.body)
      },
    )
  }

  // batchDictionaryEntries

  @Test
  fun `replace`() = runTest {
    client.runTest(
      call = {
        batchDictionaryEntries(
          dictionaryName = DictionaryType.entries.first { it.value == "plurals" },
          batchDictionaryEntriesParams = BatchDictionaryEntriesParams(
            clearExistingDictionaryEntries = true,
            requests = listOf(
              BatchDictionaryEntriesRequest(
                action = DictionaryAction.entries.first { it.value == "addEntry" },
                body = DictionaryEntry(
                  objectID = "1",
                  language = SupportedLanguage.entries.first { it.value == "en" },
                  word = "fancy",
                  words = listOf("believe", "algolia"),
                  decomposition = listOf("trust", "algolia"),
                  state = DictionaryEntryState.entries.first { it.value == "enabled" },
                ),
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/dictionaries/plurals/batch".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"clearExistingDictionaryEntries":true,"requests":[{"action":"addEntry","body":{"objectID":"1","language":"en","word":"fancy","words":["believe","algolia"],"decomposition":["trust","algolia"],"state":"enabled"}}]}""", it.body)
      },
    )
  }

  @Test
  fun `delete1`() = runTest {
    client.runTest(
      call = {
        batchDictionaryEntries(
          dictionaryName = DictionaryType.entries.first { it.value == "plurals" },
          batchDictionaryEntriesParams = BatchDictionaryEntriesParams(
            clearExistingDictionaryEntries = true,
            requests = listOf(
              BatchDictionaryEntriesRequest(
                action = DictionaryAction.entries.first { it.value == "deleteEntry" },
                body = DictionaryEntry(
                  objectID = "1",
                ),
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/dictionaries/plurals/batch".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"clearExistingDictionaryEntries":true,"requests":[{"action":"deleteEntry","body":{"objectID":"1"}}]}""", it.body)
      },
    )
  }

  @Test
  fun `append2`() = runTest {
    client.runTest(
      call = {
        batchDictionaryEntries(
          dictionaryName = DictionaryType.entries.first { it.value == "stopwords" },
          batchDictionaryEntriesParams = BatchDictionaryEntriesParams(
            requests = listOf(
              BatchDictionaryEntriesRequest(
                action = DictionaryAction.entries.first { it.value == "addEntry" },
                body = DictionaryEntry(
                  objectID = "1",
                  language = SupportedLanguage.entries.first { it.value == "en" },
                  additionalProperties = mapOf(
                    "additional" to JsonPrimitive("try me"),
                  ),
                ),
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/dictionaries/stopwords/batch".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"action":"addEntry","body":{"objectID":"1","language":"en","additional":"try me"}}]}""", it.body)
      },
    )
  }

  // browse

  @Test
  fun `browse with minimal parameters`() = runTest {
    client.runTest(
      call = {
        browse(
          indexName = "cts_e2e_browse",
        )
      },
      intercept = {
        assertEquals("/1/indexes/cts_e2e_browse/browse".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{}""", it.body)
      },
    )
  }

  @Test
  fun `browse with search parameters1`() = runTest {
    client.runTest(
      call = {
        browse(
          indexName = "indexName",
          browseParams = BrowseParamsObject(
            query = "myQuery",
            facetFilters = FacetFilters.of(listOf(FacetFilters.of("tags:algolia"))),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/browse".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"query":"myQuery","facetFilters":["tags:algolia"]}""", it.body)
      },
    )
  }

  @Test
  fun `browse allow a cursor in parameters2`() = runTest {
    client.runTest(
      call = {
        browse(
          indexName = "indexName",
          browseParams = BrowseParamsObject(
            cursor = "test",
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/browse".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"cursor":"test"}""", it.body)
      },
    )
  }

  // clearObjects

  @Test
  fun `clearObjects`() = runTest {
    client.runTest(
      call = {
        clearObjects(
          indexName = "theIndexName",
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/clear".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertEmptyBody(it.body)
      },
    )
  }

  // clearRules

  @Test
  fun `clearRules`() = runTest {
    client.runTest(
      call = {
        clearRules(
          indexName = "indexName",
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/rules/clear".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertEmptyBody(it.body)
      },
    )
  }

  // clearSynonyms

  @Test
  fun `clearSynonyms`() = runTest {
    client.runTest(
      call = {
        clearSynonyms(
          indexName = "indexName",
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/synonyms/clear".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertEmptyBody(it.body)
      },
    )
  }

  // customDelete

  @Test
  fun `allow del method for a custom path with minimal parameters`() = runTest {
    client.runTest(
      call = {
        customDelete(
          path = "test/minimal",
        )
      },
      intercept = {
        assertEquals("/test/minimal".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("DELETE"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  @Test
  fun `allow del method for a custom path with all parameters1`() = runTest {
    client.runTest(
      call = {
        customDelete(
          path = "test/all",
          parameters = mapOf("query" to "parameters"),
        )
      },
      intercept = {
        assertEquals("/test/all".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("DELETE"), it.method)
        assertQueryParams("""{"query":"parameters"}""", it.url.encodedParameters)
        assertNoBody(it.body)
      },
    )
  }

  // customGet

  @Test
  fun `allow get method for a custom path with minimal parameters`() = runTest {
    client.runTest(
      call = {
        customGet(
          path = "test/minimal",
        )
      },
      intercept = {
        assertEquals("/test/minimal".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  @Test
  fun `allow get method for a custom path with all parameters1`() = runTest {
    client.runTest(
      call = {
        customGet(
          path = "test/all",
          parameters = mapOf("query" to "parameters with space"),
        )
      },
      intercept = {
        assertEquals("/test/all".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertQueryParams("""{"query":"parameters%20with%20space"}""", it.url.encodedParameters)
        assertNoBody(it.body)
      },
    )
  }

  @Test
  fun `requestOptions should be escaped too2`() = runTest {
    client.runTest(
      call = {
        customGet(
          path = "test/all",
          parameters = mapOf("query" to "to be overriden"),
          requestOptions = RequestOptions(
            urlParameters = buildMap {
              put("query", "parameters with space")
              put("and an array", listOf("array", "with spaces"))
            },
            headers = buildMap {
              put("x-header-1", "spaces are left alone")
            },
          ),
        )
      },
      intercept = {
        assertEquals("/test/all".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertContainsAll("""{"x-header-1":"spaces are left alone"}""", it.headers)
        assertQueryParams("""{"query":"parameters%20with%20space","and%20an%20array":"array%2Cwith%20spaces"}""", it.url.encodedParameters)
        assertNoBody(it.body)
      },
    )
  }

  // customPost

  @Test
  fun `allow post method for a custom path with minimal parameters`() = runTest {
    client.runTest(
      call = {
        customPost(
          path = "test/minimal",
        )
      },
      intercept = {
        assertEquals("/test/minimal".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{}""", it.body)
      },
    )
  }

  @Test
  fun `allow post method for a custom path with all parameters1`() = runTest {
    client.runTest(
      call = {
        customPost(
          path = "test/all",
          parameters = mapOf("query" to "parameters"),
          body = buildJsonObject {
            put(
              "body",
              JsonPrimitive("parameters"),
            )
          },
        )
      },
      intercept = {
        assertEquals("/test/all".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertQueryParams("""{"query":"parameters"}""", it.url.encodedParameters)
        assertJsonBody("""{"body":"parameters"}""", it.body)
      },
    )
  }

  @Test
  fun `requestOptions can override default query parameters2`() = runTest {
    client.runTest(
      call = {
        customPost(
          path = "test/requestOptions",
          parameters = mapOf("query" to "parameters"),
          body = buildJsonObject {
            put(
              "facet",
              JsonPrimitive("filters"),
            )
          },
          requestOptions = RequestOptions(
            urlParameters = buildMap {
              put("query", "myQueryParameter")
            },
          ),
        )
      },
      intercept = {
        assertEquals("/test/requestOptions".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertQueryParams("""{"query":"myQueryParameter"}""", it.url.encodedParameters)
        assertJsonBody("""{"facet":"filters"}""", it.body)
      },
    )
  }

  @Test
  fun `requestOptions merges query parameters with default ones3`() = runTest {
    client.runTest(
      call = {
        customPost(
          path = "test/requestOptions",
          parameters = mapOf("query" to "parameters"),
          body = buildJsonObject {
            put(
              "facet",
              JsonPrimitive("filters"),
            )
          },
          requestOptions = RequestOptions(
            urlParameters = buildMap {
              put("query2", "myQueryParameter")
            },
          ),
        )
      },
      intercept = {
        assertEquals("/test/requestOptions".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertQueryParams("""{"query":"parameters","query2":"myQueryParameter"}""", it.url.encodedParameters)
        assertJsonBody("""{"facet":"filters"}""", it.body)
      },
    )
  }

  @Test
  fun `requestOptions can override default headers4`() = runTest {
    client.runTest(
      call = {
        customPost(
          path = "test/requestOptions",
          parameters = mapOf("query" to "parameters"),
          body = buildJsonObject {
            put(
              "facet",
              JsonPrimitive("filters"),
            )
          },
          requestOptions = RequestOptions(
            headers = buildMap {
              put("x-algolia-api-key", "ALGOLIA_API_KEY")
            },
          ),
        )
      },
      intercept = {
        assertEquals("/test/requestOptions".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertContainsAll("""{"x-algolia-api-key":"ALGOLIA_API_KEY"}""", it.headers)
        assertQueryParams("""{"query":"parameters"}""", it.url.encodedParameters)
        assertJsonBody("""{"facet":"filters"}""", it.body)
      },
    )
  }

  @Test
  fun `requestOptions merges headers with default ones5`() = runTest {
    client.runTest(
      call = {
        customPost(
          path = "test/requestOptions",
          parameters = mapOf("query" to "parameters"),
          body = buildJsonObject {
            put(
              "facet",
              JsonPrimitive("filters"),
            )
          },
          requestOptions = RequestOptions(
            headers = buildMap {
              put("x-algolia-api-key", "ALGOLIA_API_KEY")
            },
          ),
        )
      },
      intercept = {
        assertEquals("/test/requestOptions".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertContainsAll("""{"x-algolia-api-key":"ALGOLIA_API_KEY"}""", it.headers)
        assertQueryParams("""{"query":"parameters"}""", it.url.encodedParameters)
        assertJsonBody("""{"facet":"filters"}""", it.body)
      },
    )
  }

  @Test
  fun `requestOptions queryParameters accepts booleans6`() = runTest {
    client.runTest(
      call = {
        customPost(
          path = "test/requestOptions",
          parameters = mapOf("query" to "parameters"),
          body = buildJsonObject {
            put(
              "facet",
              JsonPrimitive("filters"),
            )
          },
          requestOptions = RequestOptions(
            urlParameters = buildMap {
              put("isItWorking", true)
            },
          ),
        )
      },
      intercept = {
        assertEquals("/test/requestOptions".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertQueryParams("""{"query":"parameters","isItWorking":"true"}""", it.url.encodedParameters)
        assertJsonBody("""{"facet":"filters"}""", it.body)
      },
    )
  }

  @Test
  fun `requestOptions queryParameters accepts integers7`() = runTest {
    client.runTest(
      call = {
        customPost(
          path = "test/requestOptions",
          parameters = mapOf("query" to "parameters"),
          body = buildJsonObject {
            put(
              "facet",
              JsonPrimitive("filters"),
            )
          },
          requestOptions = RequestOptions(
            urlParameters = buildMap {
              put("myParam", 2)
            },
          ),
        )
      },
      intercept = {
        assertEquals("/test/requestOptions".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertQueryParams("""{"query":"parameters","myParam":"2"}""", it.url.encodedParameters)
        assertJsonBody("""{"facet":"filters"}""", it.body)
      },
    )
  }

  @Test
  fun `requestOptions queryParameters accepts list of string8`() = runTest {
    client.runTest(
      call = {
        customPost(
          path = "test/requestOptions",
          parameters = mapOf("query" to "parameters"),
          body = buildJsonObject {
            put(
              "facet",
              JsonPrimitive("filters"),
            )
          },
          requestOptions = RequestOptions(
            urlParameters = buildMap {
              put("myParam", listOf("b and c", "d"))
            },
          ),
        )
      },
      intercept = {
        assertEquals("/test/requestOptions".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertQueryParams("""{"query":"parameters","myParam":"b%20and%20c%2Cd"}""", it.url.encodedParameters)
        assertJsonBody("""{"facet":"filters"}""", it.body)
      },
    )
  }

  @Test
  fun `requestOptions queryParameters accepts list of booleans9`() = runTest {
    client.runTest(
      call = {
        customPost(
          path = "test/requestOptions",
          parameters = mapOf("query" to "parameters"),
          body = buildJsonObject {
            put(
              "facet",
              JsonPrimitive("filters"),
            )
          },
          requestOptions = RequestOptions(
            urlParameters = buildMap {
              put("myParam", listOf(true, true, false))
            },
          ),
        )
      },
      intercept = {
        assertEquals("/test/requestOptions".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertQueryParams("""{"query":"parameters","myParam":"true%2Ctrue%2Cfalse"}""", it.url.encodedParameters)
        assertJsonBody("""{"facet":"filters"}""", it.body)
      },
    )
  }

  @Test
  fun `requestOptions queryParameters accepts list of integers10`() = runTest {
    client.runTest(
      call = {
        customPost(
          path = "test/requestOptions",
          parameters = mapOf("query" to "parameters"),
          body = buildJsonObject {
            put(
              "facet",
              JsonPrimitive("filters"),
            )
          },
          requestOptions = RequestOptions(
            urlParameters = buildMap {
              put("myParam", listOf(1, 2))
            },
          ),
        )
      },
      intercept = {
        assertEquals("/test/requestOptions".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertQueryParams("""{"query":"parameters","myParam":"1%2C2"}""", it.url.encodedParameters)
        assertJsonBody("""{"facet":"filters"}""", it.body)
      },
    )
  }

  // customPut

  @Test
  fun `allow put method for a custom path with minimal parameters`() = runTest {
    client.runTest(
      call = {
        customPut(
          path = "test/minimal",
        )
      },
      intercept = {
        assertEquals("/test/minimal".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertJsonBody("""{}""", it.body)
      },
    )
  }

  @Test
  fun `allow put method for a custom path with all parameters1`() = runTest {
    client.runTest(
      call = {
        customPut(
          path = "test/all",
          parameters = mapOf("query" to "parameters"),
          body = buildJsonObject {
            put(
              "body",
              JsonPrimitive("parameters"),
            )
          },
        )
      },
      intercept = {
        assertEquals("/test/all".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertQueryParams("""{"query":"parameters"}""", it.url.encodedParameters)
        assertJsonBody("""{"body":"parameters"}""", it.body)
      },
    )
  }

  // deleteApiKey

  @Test
  fun `deleteApiKey`() = runTest {
    client.runTest(
      call = {
        deleteApiKey(
          key = "myTestApiKey",
        )
      },
      intercept = {
        assertEquals("/1/keys/myTestApiKey".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("DELETE"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // deleteBy

  @Test
  fun `deleteBy`() = runTest {
    client.runTest(
      call = {
        deleteBy(
          indexName = "theIndexName",
          deleteByParams = DeleteByParams(
            filters = "brand:brandName",
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/deleteByQuery".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"filters":"brand:brandName"}""", it.body)
      },
    )
  }

  // deleteIndex

  @Test
  fun `deleteIndex`() = runTest {
    client.runTest(
      call = {
        deleteIndex(
          indexName = "theIndexName",
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("DELETE"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // deleteObject

  @Test
  fun `deleteObject`() = runTest {
    client.runTest(
      call = {
        deleteObject(
          indexName = "<YOUR_INDEX_NAME>",
          objectID = "uniqueID",
        )
      },
      intercept = {
        assertEquals("/1/indexes/%3CYOUR_INDEX_NAME%3E/uniqueID".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("DELETE"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // deleteRule

  @Test
  fun `delete rule simple case`() = runTest {
    client.runTest(
      call = {
        deleteRule(
          indexName = "indexName",
          objectID = "id1",
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/rules/id1".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("DELETE"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  @Test
  fun `delete rule with simple characters to encode in objectID1`() = runTest {
    client.runTest(
      call = {
        deleteRule(
          indexName = "indexName",
          objectID = "test/with/slash",
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/rules/test%2Fwith%2Fslash".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("DELETE"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // deleteSource

  @Test
  fun `deleteSource`() = runTest {
    client.runTest(
      call = {
        deleteSource(
          source = "theSource",
        )
      },
      intercept = {
        assertEquals("/1/security/sources/theSource".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("DELETE"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // deleteSynonym

  @Test
  fun `deleteSynonym`() = runTest {
    client.runTest(
      call = {
        deleteSynonym(
          indexName = "indexName",
          objectID = "id1",
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/synonyms/id1".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("DELETE"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // getApiKey

  @Test
  fun `getApiKey`() = runTest {
    client.runTest(
      call = {
        getApiKey(
          key = "myTestApiKey",
        )
      },
      intercept = {
        assertEquals("/1/keys/myTestApiKey".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // getAppTask

  @Test
  fun `getAppTask`() = runTest {
    client.runTest(
      call = {
        getAppTask(
          taskID = 123L,
        )
      },
      intercept = {
        assertEquals("/1/task/123".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // getDictionaryLanguages

  @Test
  fun `get getDictionaryLanguages`() = runTest {
    client.runTest(
      call = {
        getDictionaryLanguages()
      },
      intercept = {
        assertEquals("/1/dictionaries/*/languages".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // getDictionarySettings

  @Test
  fun `get getDictionarySettings results`() = runTest {
    client.runTest(
      call = {
        getDictionarySettings()
      },
      intercept = {
        assertEquals("/1/dictionaries/*/settings".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // getLogs

  @Test
  fun `getLogs with minimal parameters`() = runTest {
    client.runTest(
      call = {
        getLogs()
      },
      intercept = {
        assertEquals("/1/logs".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  @Test
  fun `getLogs with parameters1`() = runTest {
    client.runTest(
      call = {
        getLogs(
          offset = 5,
          length = 10,
          indexName = "theIndexName",
          type = LogType.entries.first { it.value == "all" },
        )
      },
      intercept = {
        assertEquals("/1/logs".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertQueryParams("""{"offset":"5","length":"10","indexName":"theIndexName","type":"all"}""", it.url.encodedParameters)
        assertNoBody(it.body)
      },
    )
  }

  // getObject

  @Test
  fun `getObject`() = runTest {
    client.runTest(
      call = {
        getObject(
          indexName = "theIndexName",
          objectID = "uniqueID",
          attributesToRetrieve = listOf("attr1", "attr2"),
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/uniqueID".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertQueryParams("""{"attributesToRetrieve":"attr1%2Cattr2"}""", it.url.encodedParameters)
        assertNoBody(it.body)
      },
    )
  }

  @Test
  fun `search with a real object1`() = runTest {
    client.runTest(
      call = {
        getObject(
          indexName = "cts_e2e_browse",
          objectID = "Batman and Robin",
        )
      },
      intercept = {
        assertEquals("/1/indexes/cts_e2e_browse/Batman%20and%20Robin".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // getObjects

  @Test
  fun `getObjects`() = runTest {
    client.runTest(
      call = {
        getObjects(
          getObjectsParams = GetObjectsParams(
            requests = listOf(
              GetObjectsRequest(
                attributesToRetrieve = listOf("attr1", "attr2"),
                objectID = "uniqueID",
                indexName = "theIndexName",
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/objects".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"attributesToRetrieve":["attr1","attr2"],"objectID":"uniqueID","indexName":"theIndexName"}]}""", it.body)
      },
    )
  }

  // getRule

  @Test
  fun `getRule`() = runTest {
    client.runTest(
      call = {
        getRule(
          indexName = "cts_e2e_browse",
          objectID = "qr-1725004648916",
        )
      },
      intercept = {
        assertEquals("/1/indexes/cts_e2e_browse/rules/qr-1725004648916".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // getSettings

  @Test
  fun `getSettings`() = runTest {
    client.runTest(
      call = {
        getSettings(
          indexName = "cts_e2e_settings",
        )
      },
      intercept = {
        assertEquals("/1/indexes/cts_e2e_settings/settings".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // getSources

  @Test
  fun `getSources`() = runTest {
    client.runTest(
      call = {
        getSources()
      },
      intercept = {
        assertEquals("/1/security/sources".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // getSynonym

  @Test
  fun `getSynonym`() = runTest {
    client.runTest(
      call = {
        getSynonym(
          indexName = "indexName",
          objectID = "id1",
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/synonyms/id1".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // getTask

  @Test
  fun `getTask`() = runTest {
    client.runTest(
      call = {
        getTask(
          indexName = "theIndexName",
          taskID = 123L,
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/task/123".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // getTopUserIds

  @Test
  fun `getTopUserIds`() = runTest {
    client.runTest(
      call = {
        getTopUserIds()
      },
      intercept = {
        assertEquals("/1/clusters/mapping/top".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // getUserId

  @Test
  fun `getUserId`() = runTest {
    client.runTest(
      call = {
        getUserId(
          userID = "uniqueID",
        )
      },
      intercept = {
        assertEquals("/1/clusters/mapping/uniqueID".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // hasPendingMappings

  @Test
  fun `hasPendingMappings with minimal parameters`() = runTest {
    client.runTest(
      call = {
        hasPendingMappings()
      },
      intercept = {
        assertEquals("/1/clusters/mapping/pending".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  @Test
  fun `hasPendingMappings with parameters1`() = runTest {
    client.runTest(
      call = {
        hasPendingMappings(
          getClusters = true,
        )
      },
      intercept = {
        assertEquals("/1/clusters/mapping/pending".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertQueryParams("""{"getClusters":"true"}""", it.url.encodedParameters)
        assertNoBody(it.body)
      },
    )
  }

  // listApiKeys

  @Test
  fun `listApiKeys`() = runTest {
    client.runTest(
      call = {
        listApiKeys()
      },
      intercept = {
        assertEquals("/1/keys".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // listClusters

  @Test
  fun `listClusters`() = runTest {
    client.runTest(
      call = {
        listClusters()
      },
      intercept = {
        assertEquals("/1/clusters".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // listIndices

  @Test
  fun `listIndices with minimal parameters`() = runTest {
    client.runTest(
      call = {
        listIndices()
      },
      intercept = {
        assertEquals("/1/indexes".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  @Test
  fun `listIndices with parameters1`() = runTest {
    client.runTest(
      call = {
        listIndices(
          page = 8,
          hitsPerPage = 3,
        )
      },
      intercept = {
        assertEquals("/1/indexes".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertQueryParams("""{"page":"8","hitsPerPage":"3"}""", it.url.encodedParameters)
        assertNoBody(it.body)
      },
    )
  }

  // listUserIds

  @Test
  fun `listUserIds with minimal parameters`() = runTest {
    client.runTest(
      call = {
        listUserIds()
      },
      intercept = {
        assertEquals("/1/clusters/mapping".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  @Test
  fun `listUserIds with parameters1`() = runTest {
    client.runTest(
      call = {
        listUserIds(
          page = 8,
          hitsPerPage = 100,
        )
      },
      intercept = {
        assertEquals("/1/clusters/mapping".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("GET"), it.method)
        assertQueryParams("""{"page":"8","hitsPerPage":"100"}""", it.url.encodedParameters)
        assertNoBody(it.body)
      },
    )
  }

  // multipleBatch

  @Test
  fun `multipleBatch`() = runTest {
    client.runTest(
      call = {
        multipleBatch(
          batchParams = BatchParams(
            requests = listOf(
              MultipleBatchRequest(
                action = Action.entries.first { it.value == "addObject" },
                body = buildJsonObject {
                  put(
                    "key",
                    JsonPrimitive("value"),
                  )
                },
                indexName = "theIndexName",
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/batch".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"action":"addObject","body":{"key":"value"},"indexName":"theIndexName"}]}""", it.body)
      },
    )
  }

  // operationIndex

  @Test
  fun `scopes`() = runTest {
    client.runTest(
      call = {
        operationIndex(
          indexName = "<SOURCE_INDEX_NAME>",
          operationIndexParams = OperationIndexParams(
            operation = OperationType.entries.first { it.value == "move" },
            destination = "<DESTINATION_INDEX_NAME>",
            scope = listOf(ScopeType.entries.first { it.value == "rules" }, ScopeType.entries.first { it.value == "settings" }),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"operation":"move","destination":"<DESTINATION_INDEX_NAME>","scope":["rules","settings"]}""", it.body)
      },
    )
  }

  @Test
  fun `copy1`() = runTest {
    client.runTest(
      call = {
        operationIndex(
          indexName = "<SOURCE_INDEX_NAME>",
          operationIndexParams = OperationIndexParams(
            operation = OperationType.entries.first { it.value == "copy" },
            destination = "<DESTINATION_INDEX_NAME>",
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"operation":"copy","destination":"<DESTINATION_INDEX_NAME>"}""", it.body)
      },
    )
  }

  @Test
  fun `move2`() = runTest {
    client.runTest(
      call = {
        operationIndex(
          indexName = "<SOURCE_INDEX_NAME>",
          operationIndexParams = OperationIndexParams(
            operation = OperationType.entries.first { it.value == "move" },
            destination = "<DESTINATION_INDEX_NAME>",
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"operation":"move","destination":"<DESTINATION_INDEX_NAME>"}""", it.body)
      },
    )
  }

  // partialUpdateObject

  @Test
  fun `Partial update with a new value for a string attribute`() = runTest {
    client.runTest(
      call = {
        partialUpdateObject(
          indexName = "theIndexName",
          objectID = "uniqueID",
          attributesToUpdate = buildJsonObject {
            put(
              "attributeId",
              JsonPrimitive("new value"),
            )
          },
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/uniqueID/partial".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"attributeId":"new value"}""", it.body)
      },
    )
  }

  @Test
  fun `Partial update with a new value for an integer attribute1`() = runTest {
    client.runTest(
      call = {
        partialUpdateObject(
          indexName = "theIndexName",
          objectID = "uniqueID",
          attributesToUpdate = buildJsonObject {
            put(
              "attributeId",
              JsonPrimitive(1),
            )
          },
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/uniqueID/partial".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"attributeId":1}""", it.body)
      },
    )
  }

  @Test
  fun `Partial update with a new value for a boolean attribute2`() = runTest {
    client.runTest(
      call = {
        partialUpdateObject(
          indexName = "theIndexName",
          objectID = "uniqueID",
          attributesToUpdate = buildJsonObject {
            put(
              "attributeId",
              JsonPrimitive(true),
            )
          },
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/uniqueID/partial".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"attributeId":true}""", it.body)
      },
    )
  }

  @Test
  fun `Partial update with a new value for an array attribute3`() = runTest {
    client.runTest(
      call = {
        partialUpdateObject(
          indexName = "theIndexName",
          objectID = "uniqueID",
          attributesToUpdate = buildJsonObject {
            put(
              "attributeId",
              JsonArray(
                listOf(
                  JsonPrimitive("one"),
                  JsonPrimitive("two"),
                  JsonPrimitive("three"),
                ),
              ),
            )
          },
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/uniqueID/partial".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"attributeId":["one","two","three"]}""", it.body)
      },
    )
  }

  @Test
  fun `Partial update with a new value for an object attribute4`() = runTest {
    client.runTest(
      call = {
        partialUpdateObject(
          indexName = "theIndexName",
          objectID = "uniqueID",
          attributesToUpdate = buildJsonObject {
            put(
              "attributeId",
              buildJsonObject {
                put(
                  "nested",
                  JsonPrimitive("value"),
                )
              },
            )
          },
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/uniqueID/partial".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"attributeId":{"nested":"value"}}""", it.body)
      },
    )
  }

  // removeUserId

  @Test
  fun `removeUserId`() = runTest {
    client.runTest(
      call = {
        removeUserId(
          userID = "uniqueID",
        )
      },
      intercept = {
        assertEquals("/1/clusters/mapping/uniqueID".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("DELETE"), it.method)
        assertNoBody(it.body)
      },
    )
  }

  // replaceSources

  @Test
  fun `replaceSources`() = runTest {
    client.runTest(
      call = {
        replaceSources(
          source = listOf(
            Source(
              source = "theSource",
              description = "theDescription",
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/security/sources".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertJsonBody("""[{"source":"theSource","description":"theDescription"}]""", it.body)
      },
    )
  }

  // restoreApiKey

  @Test
  fun `restoreApiKey`() = runTest {
    client.runTest(
      call = {
        restoreApiKey(
          key = "ALGOLIA_API_KEY",
        )
      },
      intercept = {
        assertEquals("/1/keys/ALGOLIA_API_KEY/restore".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertEmptyBody(it.body)
      },
    )
  }

  // saveObject

  @Test
  fun `saveObject`() = runTest {
    client.runTest(
      call = {
        saveObject(
          indexName = "<YOUR_INDEX_NAME>",
          body = buildJsonObject {
            put(
              "objectID",
              JsonPrimitive("id"),
            )
            put(
              "test",
              JsonPrimitive("val"),
            )
          },
        )
      },
      intercept = {
        assertEquals("/1/indexes/%3CYOUR_INDEX_NAME%3E".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"objectID":"id","test":"val"}""", it.body)
      },
    )
  }

  // saveRule

  @Test
  fun `saveRule with minimal parameters`() = runTest {
    client.runTest(
      call = {
        saveRule(
          indexName = "indexName",
          objectID = "id1",
          rule = Rule(
            objectID = "id1",
            conditions = listOf(
              Condition(
                pattern = "apple",
                anchoring = Anchoring.entries.first { it.value == "contains" },
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/rules/id1".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertJsonBody("""{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains"}]}""", it.body)
      },
    )
  }

  @Test
  fun `saveRule with all parameters1`() = runTest {
    client.runTest(
      call = {
        saveRule(
          indexName = "indexName",
          objectID = "id1",
          rule = Rule(
            objectID = "id1",
            conditions = listOf(
              Condition(
                pattern = "apple",
                anchoring = Anchoring.entries.first { it.value == "contains" },
                alternatives = false,
                context = "search",
              ),
            ),
            consequence = Consequence(
              params = ConsequenceParams(
                filters = "brand:apple",
                query = ConsequenceQueryObject(
                  remove = listOf("algolia"),
                  edits = listOf(
                    Edit(
                      type = EditType.entries.first { it.value == "remove" },
                      delete = "abc",
                      insert = "cde",
                    ),
                    Edit(
                      type = EditType.entries.first { it.value == "replace" },
                      delete = "abc",
                      insert = "cde",
                    ),
                  ),
                ),
              ),
              hide = listOf(
                ConsequenceHide(
                  objectID = "321",
                ),
              ),
              filterPromotes = false,
              userData = buildJsonObject {
                put("algolia", "aloglia")
              },
              promote = listOf(
                PromoteObjectID(
                  objectID = "abc",
                  position = 3,
                ),
                PromoteObjectIDs(
                  objectIDs = listOf("abc", "def"),
                  position = 1,
                ),
              ),
            ),
            description = "test",
            enabled = true,
            validity = listOf(
              TimeRange(
                from = 1656670273L,
                until = 1656670277L,
              ),
            ),
          ),
          forwardToReplicas = true,
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/rules/id1".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertQueryParams("""{"forwardToReplicas":"true"}""", it.url.encodedParameters)
        assertJsonBody("""{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains","alternatives":false,"context":"search"}],"consequence":{"params":{"filters":"brand:apple","query":{"remove":["algolia"],"edits":[{"type":"remove","delete":"abc","insert":"cde"},{"type":"replace","delete":"abc","insert":"cde"}]}},"hide":[{"objectID":"321"}],"filterPromotes":false,"userData":{"algolia":"aloglia"},"promote":[{"objectID":"abc","position":3},{"objectIDs":["abc","def"],"position":1}]},"description":"test","enabled":true,"validity":[{"from":1656670273,"until":1656670277}]}""", it.body)
      },
    )
  }

  // saveRules

  @Test
  fun `saveRules with minimal parameters`() = runTest {
    client.runTest(
      call = {
        saveRules(
          indexName = "<YOUR_INDEX_NAME>",
          rules = listOf(
            Rule(
              objectID = "a-rule-id",
              conditions = listOf(
                Condition(
                  pattern = "smartphone",
                  anchoring = Anchoring.entries.first { it.value == "contains" },
                ),
              ),
            ),
            Rule(
              objectID = "a-second-rule-id",
              conditions = listOf(
                Condition(
                  pattern = "apple",
                  anchoring = Anchoring.entries.first { it.value == "contains" },
                ),
              ),
            ),
          ),
          forwardToReplicas = false,
          clearExistingRules = true,
        )
      },
      intercept = {
        assertEquals("/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertQueryParams("""{"forwardToReplicas":"false","clearExistingRules":"true"}""", it.url.encodedParameters)
        assertJsonBody("""[{"objectID":"a-rule-id","conditions":[{"pattern":"smartphone","anchoring":"contains"}]},{"objectID":"a-second-rule-id","conditions":[{"pattern":"apple","anchoring":"contains"}]}]""", it.body)
      },
    )
  }

  @Test
  fun `saveRules with all parameters1`() = runTest {
    client.runTest(
      call = {
        saveRules(
          indexName = "<YOUR_INDEX_NAME>",
          rules = listOf(
            Rule(
              objectID = "id1",
              conditions = listOf(
                Condition(
                  pattern = "apple",
                  anchoring = Anchoring.entries.first { it.value == "contains" },
                  alternatives = false,
                  context = "search",
                ),
              ),
              consequence = Consequence(
                params = ConsequenceParams(
                  filters = "brand:apple",
                  query = ConsequenceQueryObject(
                    remove = listOf("algolia"),
                    edits = listOf(
                      Edit(
                        type = EditType.entries.first { it.value == "remove" },
                        delete = "abc",
                        insert = "cde",
                      ),
                      Edit(
                        type = EditType.entries.first { it.value == "replace" },
                        delete = "abc",
                        insert = "cde",
                      ),
                    ),
                  ),
                ),
                hide = listOf(
                  ConsequenceHide(
                    objectID = "321",
                  ),
                ),
                filterPromotes = false,
                userData = buildJsonObject {
                  put("algolia", "aloglia")
                },
                promote = listOf(
                  PromoteObjectID(
                    objectID = "abc",
                    position = 3,
                  ),
                  PromoteObjectIDs(
                    objectIDs = listOf("abc", "def"),
                    position = 1,
                  ),
                ),
              ),
              description = "test",
              enabled = true,
              validity = listOf(
                TimeRange(
                  from = 1656670273L,
                  until = 1656670277L,
                ),
              ),
            ),
          ),
          forwardToReplicas = true,
          clearExistingRules = true,
        )
      },
      intercept = {
        assertEquals("/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertQueryParams("""{"forwardToReplicas":"true","clearExistingRules":"true"}""", it.url.encodedParameters)
        assertJsonBody("""[{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains","alternatives":false,"context":"search"}],"consequence":{"params":{"filters":"brand:apple","query":{"remove":["algolia"],"edits":[{"type":"remove","delete":"abc","insert":"cde"},{"type":"replace","delete":"abc","insert":"cde"}]}},"hide":[{"objectID":"321"}],"filterPromotes":false,"userData":{"algolia":"aloglia"},"promote":[{"objectID":"abc","position":3},{"objectIDs":["abc","def"],"position":1}]},"description":"test","enabled":true,"validity":[{"from":1656670273,"until":1656670277}]}]""", it.body)
      },
    )
  }

  // saveSynonym

  @Test
  fun `saveSynonym`() = runTest {
    client.runTest(
      call = {
        saveSynonym(
          indexName = "indexName",
          objectID = "id1",
          synonymHit = SynonymHit(
            objectID = "id1",
            type = SynonymType.entries.first { it.value == "synonym" },
            synonyms = listOf("car", "vehicule", "auto"),
          ),
          forwardToReplicas = true,
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/synonyms/id1".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertQueryParams("""{"forwardToReplicas":"true"}""", it.url.encodedParameters)
        assertJsonBody("""{"objectID":"id1","type":"synonym","synonyms":["car","vehicule","auto"]}""", it.body)
      },
    )
  }

  // saveSynonyms

  @Test
  fun `saveSynonyms`() = runTest {
    client.runTest(
      call = {
        saveSynonyms(
          indexName = "<YOUR_INDEX_NAME>",
          synonymHit = listOf(
            SynonymHit(
              objectID = "id1",
              type = SynonymType.entries.first { it.value == "synonym" },
              synonyms = listOf("car", "vehicule", "auto"),
            ),
            SynonymHit(
              objectID = "id2",
              type = SynonymType.entries.first { it.value == "onewaysynonym" },
              input = "iphone",
              synonyms = listOf("ephone", "aphone", "yphone"),
            ),
          ),
          forwardToReplicas = true,
          replaceExistingSynonyms = true,
        )
      },
      intercept = {
        assertEquals("/1/indexes/%3CYOUR_INDEX_NAME%3E/synonyms/batch".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertQueryParams("""{"forwardToReplicas":"true","replaceExistingSynonyms":"true"}""", it.url.encodedParameters)
        assertJsonBody("""[{"objectID":"id1","type":"synonym","synonyms":["car","vehicule","auto"]},{"objectID":"id2","type":"onewaysynonym","input":"iphone","synonyms":["ephone","aphone","yphone"]}]""", it.body)
      },
    )
  }

  // search

  @Test
  fun `withHitsPerPage`() = runTest {
    client.runTest(
      call = {
        search(
          searchMethodParams = SearchMethodParams(
            requests = listOf(
              SearchForHits(
                indexName = "<YOUR_INDEX_NAME>",
                query = "<YOUR_QUERY>",
                hitsPerPage = 50,
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/queries".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","hitsPerPage":50}]}""", it.body)
      },
    )
  }

  @Test
  fun `filterOnly1`() = runTest {
    client.runTest(
      call = {
        search(
          searchMethodParams = SearchMethodParams(
            requests = listOf(
              SearchForHits(
                indexName = "<YOUR_INDEX_NAME>",
                query = "<YOUR_QUERY>",
                filters = "actor:Scarlett Johansson",
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/queries".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"actor:Scarlett Johansson"}]}""", it.body)
      },
    )
  }

  @Test
  fun `filterOr2`() = runTest {
    client.runTest(
      call = {
        search(
          searchMethodParams = SearchMethodParams(
            requests = listOf(
              SearchForHits(
                indexName = "<YOUR_INDEX_NAME>",
                query = "<YOUR_QUERY>",
                filters = "actor:Tom Cruise OR actor:Scarlett Johansson",
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/queries".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"actor:Tom Cruise OR actor:Scarlett Johansson"}]}""", it.body)
      },
    )
  }

  @Test
  fun `filterNot3`() = runTest {
    client.runTest(
      call = {
        search(
          searchMethodParams = SearchMethodParams(
            requests = listOf(
              SearchForHits(
                indexName = "<YOUR_INDEX_NAME>",
                query = "<YOUR_QUERY>",
                filters = "NOT actor:Nicolas Cage",
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/queries".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"NOT actor:Nicolas Cage"}]}""", it.body)
      },
    )
  }

  @Test
  fun `search for a single hits request with minimal parameters4`() = runTest {
    client.runTest(
      call = {
        search(
          searchMethodParams = SearchMethodParams(
            requests = listOf(
              SearchForHits(
                indexName = "cts_e2e_search_empty_index",
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/queries".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"indexName":"cts_e2e_search_empty_index"}]}""", it.body)
      },
    )
  }

  @Test
  fun `search with highlight and snippet results5`() = runTest {
    client.runTest(
      call = {
        search(
          searchMethodParams = SearchMethodParams(
            requests = listOf(
              SearchForHits(
                indexName = "cts_e2e_highlight_snippet_results",
                query = "vim",
                attributesToSnippet = listOf("*:20"),
                attributesToHighlight = listOf("*"),
                attributesToRetrieve = listOf("*"),
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/queries".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"indexName":"cts_e2e_highlight_snippet_results","query":"vim","attributesToSnippet":["*:20"],"attributesToHighlight":["*"],"attributesToRetrieve":["*"]}]}""", it.body)
      },
    )
  }

  @Test
  fun `retrieveFacets6`() = runTest {
    client.runTest(
      call = {
        search(
          searchMethodParams = SearchMethodParams(
            requests = listOf(
              SearchForHits(
                indexName = "<YOUR_INDEX_NAME>",
                query = "<YOUR_QUERY>",
                facets = listOf("author", "genre"),
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/queries".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","facets":["author","genre"]}]}""", it.body)
      },
    )
  }

  @Test
  fun `retrieveFacetsWildcard7`() = runTest {
    client.runTest(
      call = {
        search(
          searchMethodParams = SearchMethodParams(
            requests = listOf(
              SearchForHits(
                indexName = "<YOUR_INDEX_NAME>",
                query = "<YOUR_QUERY>",
                facets = listOf("*"),
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/queries".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","facets":["*"]}]}""", it.body)
      },
    )
  }

  @Test
  fun `search for a single facet request with minimal parameters8`() = runTest {
    client.runTest(
      call = {
        search(
          searchMethodParams = SearchMethodParams(
            requests = listOf(
              SearchForFacets(
                indexName = "cts_e2e_search_facet",
                type = SearchTypeFacet.entries.first { it.value == "facet" },
                facet = "editor",
              ),
            ),
            strategy = SearchStrategy.entries.first { it.value == "stopIfEnoughMatches" },
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/queries".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"indexName":"cts_e2e_search_facet","type":"facet","facet":"editor"}],"strategy":"stopIfEnoughMatches"}""", it.body)
      },
    )
  }

  @Test
  fun `search for a single hits request with all parameters9`() = runTest {
    client.runTest(
      call = {
        search(
          searchMethodParams = SearchMethodParams(
            requests = listOf(
              SearchForHits(
                indexName = "theIndexName",
                query = "myQuery",
                hitsPerPage = 50,
                type = SearchTypeDefault.entries.first { it.value == "default" },
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/queries".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"indexName":"theIndexName","query":"myQuery","hitsPerPage":50,"type":"default"}]}""", it.body)
      },
    )
  }

  @Test
  fun `search for a single facet request with all parameters10`() = runTest {
    client.runTest(
      call = {
        search(
          searchMethodParams = SearchMethodParams(
            requests = listOf(
              SearchForFacets(
                indexName = "theIndexName",
                type = SearchTypeFacet.entries.first { it.value == "facet" },
                facet = "theFacet",
                facetQuery = "theFacetQuery",
                query = "theQuery",
                maxFacetHits = 50,
              ),
            ),
            strategy = SearchStrategy.entries.first { it.value == "stopIfEnoughMatches" },
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/queries".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"indexName":"theIndexName","type":"facet","facet":"theFacet","facetQuery":"theFacetQuery","query":"theQuery","maxFacetHits":50}],"strategy":"stopIfEnoughMatches"}""", it.body)
      },
    )
  }

  @Test
  fun `search for multiple mixed requests in multiple indices with minimal parameters11`() = runTest {
    client.runTest(
      call = {
        search(
          searchMethodParams = SearchMethodParams(
            requests = listOf(
              SearchForHits(
                indexName = "theIndexName",
              ),
              SearchForFacets(
                indexName = "theIndexName2",
                type = SearchTypeFacet.entries.first { it.value == "facet" },
                facet = "theFacet",
              ),
              SearchForHits(
                indexName = "theIndexName",
                type = SearchTypeDefault.entries.first { it.value == "default" },
              ),
            ),
            strategy = SearchStrategy.entries.first { it.value == "stopIfEnoughMatches" },
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/queries".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"indexName":"theIndexName"},{"indexName":"theIndexName2","type":"facet","facet":"theFacet"},{"indexName":"theIndexName","type":"default"}],"strategy":"stopIfEnoughMatches"}""", it.body)
      },
    )
  }

  @Test
  fun `search for multiple mixed requests in multiple indices with all parameters12`() = runTest {
    client.runTest(
      call = {
        search(
          searchMethodParams = SearchMethodParams(
            requests = listOf(
              SearchForFacets(
                indexName = "theIndexName",
                type = SearchTypeFacet.entries.first { it.value == "facet" },
                facet = "theFacet",
                facetQuery = "theFacetQuery",
                query = "theQuery",
                maxFacetHits = 50,
              ),
              SearchForHits(
                indexName = "theIndexName",
                query = "myQuery",
                hitsPerPage = 50,
                type = SearchTypeDefault.entries.first { it.value == "default" },
              ),
            ),
            strategy = SearchStrategy.entries.first { it.value == "stopIfEnoughMatches" },
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/queries".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"indexName":"theIndexName","type":"facet","facet":"theFacet","facetQuery":"theFacetQuery","query":"theQuery","maxFacetHits":50},{"indexName":"theIndexName","query":"myQuery","hitsPerPage":50,"type":"default"}],"strategy":"stopIfEnoughMatches"}""", it.body)
      },
    )
  }

  @Test
  fun `search filters accept all of the possible shapes13`() = runTest {
    client.runTest(
      call = {
        search(
          searchMethodParams = SearchMethodParams(
            requests = listOf(
              SearchForHits(
                indexName = "theIndexName",
                facetFilters = FacetFilters.of("mySearch:filters"),
                reRankingApplyFilter = ReRankingApplyFilter.of("mySearch:filters"),
                tagFilters = TagFilters.of("mySearch:filters"),
                numericFilters = NumericFilters.of("mySearch:filters"),
                optionalFilters = OptionalFilters.of("mySearch:filters"),
              ),
              SearchForHits(
                indexName = "theIndexName",
                facetFilters = FacetFilters.of(listOf(FacetFilters.of("mySearch:filters"), FacetFilters.of(listOf(FacetFilters.of("mySearch:filters"), FacetFilters.of(listOf(FacetFilters.of("mySearch:filters"))))))),
                reRankingApplyFilter = ReRankingApplyFilter.of(listOf(ReRankingApplyFilter.of("mySearch:filters"), ReRankingApplyFilter.of(listOf(ReRankingApplyFilter.of("mySearch:filters"))))),
                tagFilters = TagFilters.of(listOf(TagFilters.of("mySearch:filters"), TagFilters.of(listOf(TagFilters.of("mySearch:filters"))))),
                numericFilters = NumericFilters.of(listOf(NumericFilters.of("mySearch:filters"), NumericFilters.of(listOf(NumericFilters.of("mySearch:filters"))))),
                optionalFilters = OptionalFilters.of(listOf(OptionalFilters.of("mySearch:filters"), OptionalFilters.of(listOf(OptionalFilters.of("mySearch:filters"))))),
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/queries".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"indexName":"theIndexName","facetFilters":"mySearch:filters","reRankingApplyFilter":"mySearch:filters","tagFilters":"mySearch:filters","numericFilters":"mySearch:filters","optionalFilters":"mySearch:filters"},{"indexName":"theIndexName","facetFilters":["mySearch:filters",["mySearch:filters",["mySearch:filters"]]],"reRankingApplyFilter":["mySearch:filters",["mySearch:filters"]],"tagFilters":["mySearch:filters",["mySearch:filters"]],"numericFilters":["mySearch:filters",["mySearch:filters"]],"optionalFilters":["mySearch:filters",["mySearch:filters"]]}]}""", it.body)
      },
    )
  }

  @Test
  fun `search filters end to end14`() = runTest {
    client.runTest(
      call = {
        search(
          searchMethodParams = SearchMethodParams(
            requests = listOf(
              SearchForHits(
                indexName = "cts_e2e_search_facet",
                filters = "editor:'visual studio' OR editor:neovim",
              ),
              SearchForHits(
                indexName = "cts_e2e_search_facet",
                facetFilters = FacetFilters.of(listOf(FacetFilters.of("editor:'visual studio'"), FacetFilters.of("editor:neovim"))),
              ),
              SearchForHits(
                indexName = "cts_e2e_search_facet",
                facetFilters = FacetFilters.of(listOf(FacetFilters.of("editor:'visual studio'"), FacetFilters.of(listOf(FacetFilters.of("editor:neovim"))))),
              ),
              SearchForHits(
                indexName = "cts_e2e_search_facet",
                facetFilters = FacetFilters.of(listOf(FacetFilters.of("editor:'visual studio'"), FacetFilters.of(listOf(FacetFilters.of("editor:neovim"), FacetFilters.of(listOf(FacetFilters.of("editor:goland"))))))),
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/queries".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"indexName":"cts_e2e_search_facet","filters":"editor:'visual studio' OR editor:neovim"},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'","editor:neovim"]},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'",["editor:neovim"]]},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'",["editor:neovim",["editor:goland"]]]}]}""", it.body)
      },
    )
  }

  @Test
  fun `search with all search parameters15`() = runTest {
    client.runTest(
      call = {
        search(
          searchMethodParams = SearchMethodParams(
            requests = listOf(
              SearchForHits(
                advancedSyntax = true,
                advancedSyntaxFeatures = listOf(AdvancedSyntaxFeatures.entries.first { it.value == "exactPhrase" }),
                allowTyposOnNumericTokens = true,
                alternativesAsExact = listOf(AlternativesAsExact.entries.first { it.value == "multiWordsSynonym" }),
                analytics = true,
                analyticsTags = listOf(""),
                aroundLatLng = "",
                aroundLatLngViaIP = true,
                aroundPrecision = AroundPrecision.of(0),
                aroundRadius = AroundRadiusAll.entries.first { it.value == "all" },
                attributeCriteriaComputedByMinProximity = true,
                attributesToHighlight = listOf(""),
                attributesToRetrieve = listOf(""),
                attributesToSnippet = listOf(""),
                clickAnalytics = true,
                customRanking = listOf(""),
                decompoundQuery = true,
                disableExactOnAttributes = listOf(""),
                disableTypoToleranceOnAttributes = listOf(""),
                distinct = Distinct.of(0),
                enableABTest = true,
                enablePersonalization = true,
                enableReRanking = true,
                enableRules = true,
                exactOnSingleWordQuery = ExactOnSingleWordQuery.entries.first { it.value == "attribute" },
                facetFilters = FacetFilters.of(listOf(FacetFilters.of(""))),
                facetingAfterDistinct = true,
                facets = listOf(""),
                filters = "",
                getRankingInfo = true,
                highlightPostTag = "",
                highlightPreTag = "",
                hitsPerPage = 1,
                ignorePlurals = IgnorePlurals.of(false),
                indexName = "theIndexName",
                insideBoundingBox = listOf(listOf(47.3165, 4.9665, 47.3424, 5.0201), listOf(40.9234, 2.1185, 38.643, 1.9916)),
                insidePolygon = listOf(listOf(47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9), listOf(40.9234, 2.1185, 38.643, 1.9916, 39.2587, 2.0104)),
                keepDiacriticsOnCharacters = "",
                length = 1,
                maxValuesPerFacet = 0,
                minProximity = 1,
                minWordSizefor1Typo = 0,
                minWordSizefor2Typos = 0,
                minimumAroundRadius = 1,
                naturalLanguages = listOf(SupportedLanguage.entries.first { it.value == "fr" }),
                numericFilters = NumericFilters.of(listOf(NumericFilters.of(""))),
                offset = 0,
                optionalFilters = OptionalFilters.of(listOf(OptionalFilters.of(""))),
                optionalWords = listOf(""),
                page = 0,
                percentileComputation = true,
                personalizationImpact = 0,
                query = "",
                queryLanguages = listOf(SupportedLanguage.entries.first { it.value == "fr" }),
                queryType = QueryType.entries.first { it.value == "prefixAll" },
                ranking = listOf(""),
                reRankingApplyFilter = ReRankingApplyFilter.of(listOf(ReRankingApplyFilter.of(""))),
                relevancyStrictness = 0,
                removeStopWords = RemoveStopWords.of(true),
                removeWordsIfNoResults = RemoveWordsIfNoResults.entries.first { it.value == "allOptional" },
                renderingContent = RenderingContent(
                  facetOrdering = FacetOrdering(
                    facets = Facets(
                      order = listOf("a", "b"),
                    ),
                    values = mapOf(
                      "a" to Value(
                        order = listOf("b"),
                        sortRemainingBy = SortRemainingBy.entries.first { it.value == "count" },
                      ),
                    ),
                  ),
                ),
                replaceSynonymsInHighlight = true,
                responseFields = listOf(""),
                restrictHighlightAndSnippetArrays = true,
                restrictSearchableAttributes = listOf(""),
                ruleContexts = listOf(""),
                similarQuery = "",
                snippetEllipsisText = "",
                sortFacetValuesBy = "",
                sumOrFiltersScores = true,
                synonyms = true,
                tagFilters = TagFilters.of(listOf(TagFilters.of(""))),
                type = SearchTypeDefault.entries.first { it.value == "default" },
                typoTolerance = TypoToleranceEnum.entries.first { it.value == "min" },
                userToken = "",
              ),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/*/queries".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"requests":[{"advancedSyntax":true,"advancedSyntaxFeatures":["exactPhrase"],"allowTyposOnNumericTokens":true,"alternativesAsExact":["multiWordsSynonym"],"analytics":true,"analyticsTags":[""],"aroundLatLng":"","aroundLatLngViaIP":true,"aroundPrecision":0,"aroundRadius":"all","attributeCriteriaComputedByMinProximity":true,"attributesToHighlight":[""],"attributesToRetrieve":[""],"attributesToSnippet":[""],"clickAnalytics":true,"customRanking":[""],"decompoundQuery":true,"disableExactOnAttributes":[""],"disableTypoToleranceOnAttributes":[""],"distinct":0,"enableABTest":true,"enablePersonalization":true,"enableReRanking":true,"enableRules":true,"exactOnSingleWordQuery":"attribute","facetFilters":[""],"facetingAfterDistinct":true,"facets":[""],"filters":"","getRankingInfo":true,"highlightPostTag":"","highlightPreTag":"","hitsPerPage":1,"ignorePlurals":false,"indexName":"theIndexName","insideBoundingBox":[[47.3165,4.9665,47.3424,5.0201],[40.9234,2.1185,38.643,1.9916]],"insidePolygon":[[47.3165,4.9665,47.3424,5.0201,47.32,4.9],[40.9234,2.1185,38.643,1.9916,39.2587,2.0104]],"keepDiacriticsOnCharacters":"","length":1,"maxValuesPerFacet":0,"minProximity":1,"minWordSizefor1Typo":0,"minWordSizefor2Typos":0,"minimumAroundRadius":1,"naturalLanguages":["fr"],"numericFilters":[""],"offset":0,"optionalFilters":[""],"optionalWords":[""],"page":0,"percentileComputation":true,"personalizationImpact":0,"query":"","queryLanguages":["fr"],"queryType":"prefixAll","ranking":[""],"reRankingApplyFilter":[""],"relevancyStrictness":0,"removeStopWords":true,"removeWordsIfNoResults":"allOptional","renderingContent":{"facetOrdering":{"facets":{"order":["a","b"]},"values":{"a":{"order":["b"],"sortRemainingBy":"count"}}}},"replaceSynonymsInHighlight":true,"responseFields":[""],"restrictHighlightAndSnippetArrays":true,"restrictSearchableAttributes":[""],"ruleContexts":[""],"similarQuery":"","snippetEllipsisText":"","sortFacetValuesBy":"","sumOrFiltersScores":true,"synonyms":true,"tagFilters":[""],"type":"default","typoTolerance":"min","userToken":""}]}""", it.body)
      },
    )
  }

  // searchDictionaryEntries

  @Test
  fun `get searchDictionaryEntries results with minimal parameters`() = runTest {
    client.runTest(
      call = {
        searchDictionaryEntries(
          dictionaryName = DictionaryType.entries.first { it.value == "stopwords" },
          searchDictionaryEntriesParams = SearchDictionaryEntriesParams(
            query = "about",
          ),
        )
      },
      intercept = {
        assertEquals("/1/dictionaries/stopwords/search".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"query":"about"}""", it.body)
      },
    )
  }

  @Test
  fun `get searchDictionaryEntries results with all parameters1`() = runTest {
    client.runTest(
      call = {
        searchDictionaryEntries(
          dictionaryName = DictionaryType.entries.first { it.value == "compounds" },
          searchDictionaryEntriesParams = SearchDictionaryEntriesParams(
            query = "foo",
            page = 4,
            hitsPerPage = 2,
            language = SupportedLanguage.entries.first { it.value == "fr" },
          ),
        )
      },
      intercept = {
        assertEquals("/1/dictionaries/compounds/search".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"query":"foo","page":4,"hitsPerPage":2,"language":"fr"}""", it.body)
      },
    )
  }

  // searchForFacetValues

  @Test
  fun `get searchForFacetValues results with minimal parameters`() = runTest {
    client.runTest(
      call = {
        searchForFacetValues(
          indexName = "indexName",
          facetName = "facetName",
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/facets/facetName/query".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{}""", it.body)
      },
    )
  }

  @Test
  fun `get searchForFacetValues results with all parameters1`() = runTest {
    client.runTest(
      call = {
        searchForFacetValues(
          indexName = "indexName",
          facetName = "facetName",
          searchForFacetValuesRequest = SearchForFacetValuesRequest(
            params = "query=foo&facetFilters=['bar']",
            facetQuery = "foo",
            maxFacetHits = 42,
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/facets/facetName/query".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"params":"query=foo&facetFilters=['bar']","facetQuery":"foo","maxFacetHits":42}""", it.body)
      },
    )
  }

  // searchRules

  @Test
  fun `searchRules`() = runTest {
    client.runTest(
      call = {
        searchRules(
          indexName = "cts_e2e_browse",
          searchRulesParams = SearchRulesParams(
            query = "zorro",
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/cts_e2e_browse/rules/search".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"query":"zorro"}""", it.body)
      },
    )
  }

  // searchSingleIndex

  @Test
  fun `search with minimal parameters`() = runTest {
    client.runTest(
      call = {
        searchSingleIndex(
          indexName = "indexName",
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/query".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{}""", it.body)
      },
    )
  }

  @Test
  fun `search with special characters in indexName1`() = runTest {
    client.runTest(
      call = {
        searchSingleIndex(
          indexName = "cts_e2e_space in index",
        )
      },
      intercept = {
        assertEquals("/1/indexes/cts_e2e_space%20in%20index/query".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{}""", it.body)
      },
    )
  }

  @Test
  fun `search with searchParams2`() = runTest {
    client.runTest(
      call = {
        searchSingleIndex(
          indexName = "indexName",
          searchParams = SearchParamsObject(
            query = "myQuery",
            facetFilters = FacetFilters.of(listOf(FacetFilters.of("tags:algolia"))),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/query".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"query":"myQuery","facetFilters":["tags:algolia"]}""", it.body)
      },
    )
  }

  @Test
  fun `single search retrieve snippets3`() = runTest {
    client.runTest(
      call = {
        searchSingleIndex(
          indexName = "cts_e2e_browse",
          searchParams = SearchParamsObject(
            query = "batman mask of the phantasm",
            attributesToRetrieve = listOf("*"),
            attributesToSnippet = listOf("*:20"),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/cts_e2e_browse/query".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"query":"batman mask of the phantasm","attributesToRetrieve":["*"],"attributesToSnippet":["*:20"]}""", it.body)
      },
    )
  }

  // searchSynonyms

  @Test
  fun `searchSynonyms with minimal parameters`() = runTest {
    client.runTest(
      call = {
        searchSynonyms(
          indexName = "indexName",
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/synonyms/search".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{}""", it.body)
      },
    )
  }

  @Test
  fun `searchSynonyms with all parameters1`() = runTest {
    client.runTest(
      call = {
        searchSynonyms(
          indexName = "indexName",
          searchSynonymsParams = SearchSynonymsParams(
            query = "myQuery",
            type = SynonymType.entries.first { it.value == "altcorrection1" },
            page = 10,
            hitsPerPage = 10,
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/indexName/synonyms/search".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"query":"myQuery","type":"altcorrection1","page":10,"hitsPerPage":10}""", it.body)
      },
    )
  }

  // searchUserIds

  @Test
  fun `searchUserIds`() = runTest {
    client.runTest(
      call = {
        searchUserIds(
          searchUserIdsParams = SearchUserIdsParams(
            query = "test",
            clusterName = "theClusterName",
            page = 5,
            hitsPerPage = 10,
          ),
        )
      },
      intercept = {
        assertEquals("/1/clusters/mapping/search".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("POST"), it.method)
        assertJsonBody("""{"query":"test","clusterName":"theClusterName","page":5,"hitsPerPage":10}""", it.body)
      },
    )
  }

  // setDictionarySettings

  @Test
  fun `get setDictionarySettings results with minimal parameters`() = runTest {
    client.runTest(
      call = {
        setDictionarySettings(
          dictionarySettingsParams = DictionarySettingsParams(
            disableStandardEntries = StandardEntries(
              plurals = mapOf("fr" to false, "en" to false, "ru" to true),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/dictionaries/*/settings".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertJsonBody("""{"disableStandardEntries":{"plurals":{"fr":false,"en":false,"ru":true}}}""", it.body)
      },
    )
  }

  @Test
  fun `get setDictionarySettings results with all parameters1`() = runTest {
    client.runTest(
      call = {
        setDictionarySettings(
          dictionarySettingsParams = DictionarySettingsParams(
            disableStandardEntries = StandardEntries(
              plurals = mapOf("fr" to false, "en" to false, "ru" to true),
              stopwords = mapOf("fr" to false),
              compounds = mapOf("ru" to true),
            ),
          ),
        )
      },
      intercept = {
        assertEquals("/1/dictionaries/*/settings".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertJsonBody("""{"disableStandardEntries":{"plurals":{"fr":false,"en":false,"ru":true},"stopwords":{"fr":false},"compounds":{"ru":true}}}""", it.body)
      },
    )
  }

  // setSettings

  @Test
  fun `setSettingsAttributesForFaceting`() = runTest {
    client.runTest(
      call = {
        setSettings(
          indexName = "<YOUR_INDEX_NAME>",
          indexSettings = IndexSettings(
            attributesForFaceting = listOf("actor", "filterOnly(category)", "searchable(publisher)"),
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertJsonBody("""{"attributesForFaceting":["actor","filterOnly(category)","searchable(publisher)"]}""", it.body)
      },
    )
  }

  @Test
  fun `setSettings with minimal parameters1`() = runTest {
    client.runTest(
      call = {
        setSettings(
          indexName = "cts_e2e_settings",
          indexSettings = IndexSettings(
            paginationLimitedTo = 10,
          ),
          forwardToReplicas = true,
        )
      },
      intercept = {
        assertEquals("/1/indexes/cts_e2e_settings/settings".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertQueryParams("""{"forwardToReplicas":"true"}""", it.url.encodedParameters)
        assertJsonBody("""{"paginationLimitedTo":10}""", it.body)
      },
    )
  }

  @Test
  fun `setSettings allow boolean 'typoTolerance'2`() = runTest {
    client.runTest(
      call = {
        setSettings(
          indexName = "theIndexName",
          indexSettings = IndexSettings(
            typoTolerance = TypoTolerance.of(true),
          ),
          forwardToReplicas = true,
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/settings".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertQueryParams("""{"forwardToReplicas":"true"}""", it.url.encodedParameters)
        assertJsonBody("""{"typoTolerance":true}""", it.body)
      },
    )
  }

  @Test
  fun `setSettings allow enum 'typoTolerance'3`() = runTest {
    client.runTest(
      call = {
        setSettings(
          indexName = "theIndexName",
          indexSettings = IndexSettings(
            typoTolerance = TypoToleranceEnum.entries.first { it.value == "min" },
          ),
          forwardToReplicas = true,
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/settings".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertQueryParams("""{"forwardToReplicas":"true"}""", it.url.encodedParameters)
        assertJsonBody("""{"typoTolerance":"min"}""", it.body)
      },
    )
  }

  @Test
  fun `setSettings allow boolean 'ignorePlurals'4`() = runTest {
    client.runTest(
      call = {
        setSettings(
          indexName = "theIndexName",
          indexSettings = IndexSettings(
            ignorePlurals = IgnorePlurals.of(true),
          ),
          forwardToReplicas = true,
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/settings".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertQueryParams("""{"forwardToReplicas":"true"}""", it.url.encodedParameters)
        assertJsonBody("""{"ignorePlurals":true}""", it.body)
      },
    )
  }

  @Test
  fun `setSettings allow list of string 'ignorePlurals'5`() = runTest {
    client.runTest(
      call = {
        setSettings(
          indexName = "theIndexName",
          indexSettings = IndexSettings(
            ignorePlurals = IgnorePlurals.of(listOf(SupportedLanguage.entries.first { it.value == "fr" })),
          ),
          forwardToReplicas = true,
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/settings".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertQueryParams("""{"forwardToReplicas":"true"}""", it.url.encodedParameters)
        assertJsonBody("""{"ignorePlurals":["fr"]}""", it.body)
      },
    )
  }

  @Test
  fun `setSettings allow boolean 'removeStopWords'6`() = runTest {
    client.runTest(
      call = {
        setSettings(
          indexName = "theIndexName",
          indexSettings = IndexSettings(
            removeStopWords = RemoveStopWords.of(true),
          ),
          forwardToReplicas = true,
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/settings".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertQueryParams("""{"forwardToReplicas":"true"}""", it.url.encodedParameters)
        assertJsonBody("""{"removeStopWords":true}""", it.body)
      },
    )
  }

  @Test
  fun `setSettings allow list of string 'removeStopWords'7`() = runTest {
    client.runTest(
      call = {
        setSettings(
          indexName = "theIndexName",
          indexSettings = IndexSettings(
            removeStopWords = RemoveStopWords.of(listOf(SupportedLanguage.entries.first { it.value == "fr" })),
          ),
          forwardToReplicas = true,
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/settings".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertQueryParams("""{"forwardToReplicas":"true"}""", it.url.encodedParameters)
        assertJsonBody("""{"removeStopWords":["fr"]}""", it.body)
      },
    )
  }

  @Test
  fun `setSettings allow boolean 'distinct'8`() = runTest {
    client.runTest(
      call = {
        setSettings(
          indexName = "theIndexName",
          indexSettings = IndexSettings(
            distinct = Distinct.of(true),
          ),
          forwardToReplicas = true,
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/settings".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertQueryParams("""{"forwardToReplicas":"true"}""", it.url.encodedParameters)
        assertJsonBody("""{"distinct":true}""", it.body)
      },
    )
  }

  @Test
  fun `setSettings allow integers for 'distinct'9`() = runTest {
    client.runTest(
      call = {
        setSettings(
          indexName = "theIndexName",
          indexSettings = IndexSettings(
            distinct = Distinct.of(1),
          ),
          forwardToReplicas = true,
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/settings".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertQueryParams("""{"forwardToReplicas":"true"}""", it.url.encodedParameters)
        assertJsonBody("""{"distinct":1}""", it.body)
      },
    )
  }

  @Test
  fun `setSettings allow all 'indexSettings'10`() = runTest {
    client.runTest(
      call = {
        setSettings(
          indexName = "theIndexName",
          indexSettings = IndexSettings(
            advancedSyntax = true,
            advancedSyntaxFeatures = listOf(AdvancedSyntaxFeatures.entries.first { it.value == "exactPhrase" }),
            allowCompressionOfIntegerArray = true,
            allowTyposOnNumericTokens = true,
            alternativesAsExact = listOf(AlternativesAsExact.entries.first { it.value == "singleWordSynonym" }),
            attributeCriteriaComputedByMinProximity = true,
            attributeForDistinct = "test",
            attributesForFaceting = listOf("algolia"),
            attributesToHighlight = listOf("algolia"),
            attributesToRetrieve = listOf("algolia"),
            attributesToSnippet = listOf("algolia"),
            attributesToTransliterate = listOf("algolia"),
            camelCaseAttributes = listOf("algolia"),
            customNormalization = mapOf("algolia" to mapOf("aloglia" to "aglolia")),
            customRanking = listOf("algolia"),
            decompoundQuery = false,
            decompoundedAttributes = buildJsonObject {
              put(
                "algolia",
                JsonPrimitive("aloglia"),
              )
            },
            disableExactOnAttributes = listOf("algolia"),
            disablePrefixOnAttributes = listOf("algolia"),
            disableTypoToleranceOnAttributes = listOf("algolia"),
            disableTypoToleranceOnWords = listOf("algolia"),
            distinct = Distinct.of(3),
            enablePersonalization = true,
            enableReRanking = false,
            enableRules = true,
            exactOnSingleWordQuery = ExactOnSingleWordQuery.entries.first { it.value == "attribute" },
            highlightPreTag = "<span>",
            highlightPostTag = "</span>",
            hitsPerPage = 10,
            ignorePlurals = IgnorePlurals.of(false),
            indexLanguages = listOf(SupportedLanguage.entries.first { it.value == "fr" }),
            keepDiacriticsOnCharacters = "abc",
            maxFacetHits = 20,
            maxValuesPerFacet = 30,
            minProximity = 6,
            minWordSizefor1Typo = 5,
            minWordSizefor2Typos = 11,
            mode = Mode.entries.first { it.value == "neuralSearch" },
            numericAttributesForFiltering = listOf("algolia"),
            optionalWords = listOf("myspace"),
            paginationLimitedTo = 0,
            queryLanguages = listOf(SupportedLanguage.entries.first { it.value == "fr" }),
            queryType = QueryType.entries.first { it.value == "prefixLast" },
            ranking = listOf("geo"),
            reRankingApplyFilter = ReRankingApplyFilter.of("mySearch:filters"),
            relevancyStrictness = 10,
            removeStopWords = RemoveStopWords.of(false),
            removeWordsIfNoResults = RemoveWordsIfNoResults.entries.first { it.value == "lastWords" },
            renderingContent = RenderingContent(
              facetOrdering = FacetOrdering(
                facets = Facets(
                  order = listOf("a", "b"),
                ),
                values = mapOf(
                  "a" to Value(
                    order = listOf("b"),
                    sortRemainingBy = SortRemainingBy.entries.first { it.value == "count" },
                  ),
                ),
              ),
            ),
            replaceSynonymsInHighlight = true,
            replicas = listOf(""),
            responseFields = listOf("algolia"),
            restrictHighlightAndSnippetArrays = true,
            searchableAttributes = listOf("foo"),
            semanticSearch = SemanticSearch(
              eventSources = listOf("foo"),
            ),
            separatorsToIndex = "bar",
            snippetEllipsisText = "---",
            sortFacetValuesBy = "date",
            typoTolerance = TypoTolerance.of(false),
            unretrievableAttributes = listOf("foo"),
            userData = buildJsonObject {
              put(
                "user",
                JsonPrimitive("data"),
              )
            },
          ),
        )
      },
      intercept = {
        assertEquals("/1/indexes/theIndexName/settings".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertJsonBody("""{"advancedSyntax":true,"advancedSyntaxFeatures":["exactPhrase"],"allowCompressionOfIntegerArray":true,"allowTyposOnNumericTokens":true,"alternativesAsExact":["singleWordSynonym"],"attributeCriteriaComputedByMinProximity":true,"attributeForDistinct":"test","attributesForFaceting":["algolia"],"attributesToHighlight":["algolia"],"attributesToRetrieve":["algolia"],"attributesToSnippet":["algolia"],"attributesToTransliterate":["algolia"],"camelCaseAttributes":["algolia"],"customNormalization":{"algolia":{"aloglia":"aglolia"}},"customRanking":["algolia"],"decompoundQuery":false,"decompoundedAttributes":{"algolia":"aloglia"},"disableExactOnAttributes":["algolia"],"disablePrefixOnAttributes":["algolia"],"disableTypoToleranceOnAttributes":["algolia"],"disableTypoToleranceOnWords":["algolia"],"distinct":3,"enablePersonalization":true,"enableReRanking":false,"enableRules":true,"exactOnSingleWordQuery":"attribute","highlightPreTag":"<span>","highlightPostTag":"</span>","hitsPerPage":10,"ignorePlurals":false,"indexLanguages":["fr"],"keepDiacriticsOnCharacters":"abc","maxFacetHits":20,"maxValuesPerFacet":30,"minProximity":6,"minWordSizefor1Typo":5,"minWordSizefor2Typos":11,"mode":"neuralSearch","numericAttributesForFiltering":["algolia"],"optionalWords":["myspace"],"paginationLimitedTo":0,"queryLanguages":["fr"],"queryType":"prefixLast","ranking":["geo"],"reRankingApplyFilter":"mySearch:filters","relevancyStrictness":10,"removeStopWords":false,"removeWordsIfNoResults":"lastWords","renderingContent":{"facetOrdering":{"facets":{"order":["a","b"]},"values":{"a":{"order":["b"],"sortRemainingBy":"count"}}}},"replaceSynonymsInHighlight":true,"replicas":[""],"responseFields":["algolia"],"restrictHighlightAndSnippetArrays":true,"searchableAttributes":["foo"],"semanticSearch":{"eventSources":["foo"]},"separatorsToIndex":"bar","snippetEllipsisText":"---","sortFacetValuesBy":"date","typoTolerance":false,"unretrievableAttributes":["foo"],"userData":{"user":"data"}}""", it.body)
      },
    )
  }

  // updateApiKey

  @Test
  fun `updateApiKey`() = runTest {
    client.runTest(
      call = {
        updateApiKey(
          key = "ALGOLIA_API_KEY",
          apiKey = ApiKey(
            acl = listOf(Acl.entries.first { it.value == "search" }, Acl.entries.first { it.value == "addObject" }),
            validity = 300,
            maxQueriesPerIPPerHour = 100,
            maxHitsPerQuery = 20,
          ),
        )
      },
      intercept = {
        assertEquals("/1/keys/ALGOLIA_API_KEY".toPathSegments(), it.url.pathSegments)
        assertEquals(HttpMethod.parse("PUT"), it.method)
        assertJsonBody("""{"acl":["search","addObject"],"validity":300,"maxQueriesPerIPPerHour":100,"maxHitsPerQuery":20}""", it.body)
      },
    )
  }
}
