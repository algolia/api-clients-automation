# Code generated by OpenAPI Generator (https://openapi-generator.tech),
# manual changes will be lost - read more on
# https://github.com/algolia/api-clients-automation. DO NOT EDIT.
from json import loads
from os import environ
from time import time
from unittest.mock import AsyncMock

from algoliasearch.http.transporter import EchoTransporter
from algoliasearch.search.client import SearchClient
from algoliasearch.search.config import SearchConfig
from algoliasearch.search.models.batch_response import BatchResponse
from algoliasearch.search.models.get_task_response import GetTaskResponse
from algoliasearch.search.models.secured_api_key_restrictions import (
    SecuredAPIKeyRestrictions,
)
from algoliasearch.search.models.updated_at_response import UpdatedAtResponse
from dotenv import load_dotenv

from ..helpers import Helpers

load_dotenv("../../.env")


class TestSearchClient:
    _config = SearchConfig("test_app_id", "test_api_key")
    _client = SearchClient.create_with_config(
        config=_config, transporter=EchoTransporter(_config)
    )

    _helpers = Helpers()
    _e2e_app_id = environ.get("ALGOLIA_APPLICATION_ID")
    if _e2e_app_id is None:
        raise Exception(
            "please provide an `ALGOLIA_APPLICATION_ID` env var for e2e tests"
        )

    _e2e_api_key = environ.get("ALGOLIA_ADMIN_KEY")
    if _e2e_api_key is None:
        raise Exception("please provide an `ALGOLIA_ADMIN_KEY` env var for e2e tests")

    async def test_add_api_key_(self):
        """
        addApiKey
        """
        _req = await self._client.add_api_key_with_http_info(
            api_key={
                "acl": [
                    "search",
                    "addObject",
                ],
                "description": "my new api key",
                "validity": 300,
                "maxQueriesPerIPPerHour": 100,
                "maxHitsPerQuery": 20,
            },
        )

        assert _req.path == "/1/keys"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"acl":["search","addObject"],"description":"my new api key","validity":300,"maxQueriesPerIPPerHour":100,"maxHitsPerQuery":20}"""
        )

    async def test_add_or_update_object_(self):
        """
        addOrUpdateObject
        """
        _req = await self._client.add_or_update_object_with_http_info(
            index_name="indexName",
            object_id="uniqueID",
            body={
                "key": "value",
            },
        )

        assert _req.path == "/1/indexes/indexName/uniqueID"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"key":"value"}""")

    async def test_append_source_(self):
        """
        appendSource
        """
        _req = await self._client.append_source_with_http_info(
            source={
                "source": "theSource",
                "description": "theDescription",
            },
        )

        assert _req.path == "/1/security/sources/append"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"source":"theSource","description":"theDescription"}"""
        )

    async def test_assign_user_id_(self):
        """
        assignUserId
        """
        _req = await self._client.assign_user_id_with_http_info(
            x_algolia_user_id="userID",
            assign_user_id_params={
                "cluster": "theCluster",
            },
        )

        assert _req.path == "/1/clusters/mapping"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {"x-algolia-user-id": "userID"}.items()
        assert loads(_req.data) == loads("""{"cluster":"theCluster"}""")

    async def test_assign_user_id_1(self):
        """
        it should not encode the userID
        """
        _req = await self._client.assign_user_id_with_http_info(
            x_algolia_user_id="user id with spaces",
            assign_user_id_params={
                "cluster": "cluster with spaces",
            },
        )

        assert _req.path == "/1/clusters/mapping"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert (
            _req.headers.items() >= {"x-algolia-user-id": "user id with spaces"}.items()
        )
        assert loads(_req.data) == loads("""{"cluster":"cluster with spaces"}""")

    async def test_batch_(self):
        """
        addObject
        """
        _req = await self._client.batch_with_http_info(
            index_name="<YOUR_INDEX_NAME>",
            batch_write_params={
                "requests": [
                    {
                        "action": "addObject",
                        "body": {
                            "key": "bar",
                            "foo": "1",
                        },
                    },
                    {
                        "action": "addObject",
                        "body": {
                            "key": "baz",
                            "foo": "2",
                        },
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"action":"addObject","body":{"key":"bar","foo":"1"}},{"action":"addObject","body":{"key":"baz","foo":"2"}}]}"""
        )

    async def test_batch_1(self):
        """
        clear
        """
        _req = await self._client.batch_with_http_info(
            index_name="<YOUR_INDEX_NAME>",
            batch_write_params={
                "requests": [
                    {
                        "action": "clear",
                        "body": {
                            "key": "value",
                        },
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"action":"clear","body":{"key":"value"}}]}"""
        )

    async def test_batch_2(self):
        """
        delete
        """
        _req = await self._client.batch_with_http_info(
            index_name="<YOUR_INDEX_NAME>",
            batch_write_params={
                "requests": [
                    {
                        "action": "delete",
                        "body": {
                            "key": "value",
                        },
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"action":"delete","body":{"key":"value"}}]}"""
        )

    async def test_batch_3(self):
        """
        deleteObject
        """
        _req = await self._client.batch_with_http_info(
            index_name="<YOUR_INDEX_NAME>",
            batch_write_params={
                "requests": [
                    {
                        "action": "deleteObject",
                        "body": {
                            "key": "value",
                        },
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"action":"deleteObject","body":{"key":"value"}}]}"""
        )

    async def test_batch_4(self):
        """
        partialUpdateObject
        """
        _req = await self._client.batch_with_http_info(
            index_name="<YOUR_INDEX_NAME>",
            batch_write_params={
                "requests": [
                    {
                        "action": "partialUpdateObject",
                        "body": {
                            "key": "value",
                        },
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"action":"partialUpdateObject","body":{"key":"value"}}]}"""
        )

    async def test_batch_5(self):
        """
        partialUpdateObjectNoCreate
        """
        _req = await self._client.batch_with_http_info(
            index_name="<YOUR_INDEX_NAME>",
            batch_write_params={
                "requests": [
                    {
                        "action": "partialUpdateObjectNoCreate",
                        "body": {
                            "key": "value",
                        },
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"action":"partialUpdateObjectNoCreate","body":{"key":"value"}}]}"""
        )

    async def test_batch_6(self):
        """
        updateObject
        """
        _req = await self._client.batch_with_http_info(
            index_name="<YOUR_INDEX_NAME>",
            batch_write_params={
                "requests": [
                    {
                        "action": "updateObject",
                        "body": {
                            "key": "value",
                        },
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"action":"updateObject","body":{"key":"value"}}]}"""
        )

    async def test_batch_assign_user_ids_(self):
        """
        batchAssignUserIds
        """
        _req = await self._client.batch_assign_user_ids_with_http_info(
            x_algolia_user_id="userID",
            batch_assign_user_ids_params={
                "cluster": "theCluster",
                "users": [
                    "user1",
                    "user2",
                ],
            },
        )

        assert _req.path == "/1/clusters/mapping/batch"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {"x-algolia-user-id": "userID"}.items()
        assert loads(_req.data) == loads(
            """{"cluster":"theCluster","users":["user1","user2"]}"""
        )

    async def test_batch_dictionary_entries_(self):
        """
        replace
        """
        _req = await self._client.batch_dictionary_entries_with_http_info(
            dictionary_name="plurals",
            batch_dictionary_entries_params={
                "clearExistingDictionaryEntries": True,
                "requests": [
                    {
                        "action": "addEntry",
                        "body": {
                            "objectID": "1",
                            "language": "en",
                            "word": "fancy",
                            "words": [
                                "believe",
                                "algolia",
                            ],
                            "decomposition": [
                                "trust",
                                "algolia",
                            ],
                            "state": "enabled",
                        },
                    },
                ],
            },
        )

        assert _req.path == "/1/dictionaries/plurals/batch"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"clearExistingDictionaryEntries":true,"requests":[{"action":"addEntry","body":{"objectID":"1","language":"en","word":"fancy","words":["believe","algolia"],"decomposition":["trust","algolia"],"state":"enabled"}}]}"""
        )

    async def test_batch_dictionary_entries_1(self):
        """
        delete
        """
        _req = await self._client.batch_dictionary_entries_with_http_info(
            dictionary_name="plurals",
            batch_dictionary_entries_params={
                "clearExistingDictionaryEntries": True,
                "requests": [
                    {
                        "action": "deleteEntry",
                        "body": {
                            "objectID": "1",
                            "language": "en",
                            "word": "fancy",
                            "words": [
                                "believe",
                                "algolia",
                            ],
                            "decomposition": [
                                "trust",
                                "algolia",
                            ],
                            "state": "enabled",
                        },
                    },
                ],
            },
        )

        assert _req.path == "/1/dictionaries/plurals/batch"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"clearExistingDictionaryEntries":true,"requests":[{"action":"deleteEntry","body":{"objectID":"1","language":"en","word":"fancy","words":["believe","algolia"],"decomposition":["trust","algolia"],"state":"enabled"}}]}"""
        )

    async def test_batch_dictionary_entries_2(self):
        """
        append
        """
        _req = await self._client.batch_dictionary_entries_with_http_info(
            dictionary_name="stopwords",
            batch_dictionary_entries_params={
                "requests": [
                    {
                        "action": "addEntry",
                        "body": {
                            "objectID": "1",
                            "language": "en",
                            "additional": "try me",
                        },
                    },
                ],
            },
        )

        assert _req.path == "/1/dictionaries/stopwords/batch"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"action":"addEntry","body":{"objectID":"1","language":"en","additional":"try me"}}]}"""
        )

    async def test_browse_(self):
        """
        browse with minimal parameters
        """
        _req = await self._client.browse_with_http_info(
            index_name="cts_e2e_browse",
        )

        assert _req.path == "/1/indexes/cts_e2e_browse/browse"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{}""")

        raw_resp = await SearchClient(
            self._e2e_app_id, self._e2e_api_key
        ).browse_with_http_info(
            index_name="cts_e2e_browse",
        )
        assert raw_resp.status_code == 200

        resp = await SearchClient(self._e2e_app_id, self._e2e_api_key).browse(
            index_name="cts_e2e_browse",
        )
        _expected_body = loads(
            """{"page":0,"nbHits":33191,"nbPages":34,"hitsPerPage":1000,"query":"","params":""}"""
        )
        assert self._helpers.union(_expected_body, resp) == _expected_body

    async def test_browse_1(self):
        """
        browse with search parameters
        """
        _req = await self._client.browse_with_http_info(
            index_name="indexName",
            browse_params={
                "query": "myQuery",
                "facetFilters": [
                    "tags:algolia",
                ],
            },
        )

        assert _req.path == "/1/indexes/indexName/browse"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"query":"myQuery","facetFilters":["tags:algolia"]}"""
        )

    async def test_browse_2(self):
        """
        browse allow a cursor in parameters
        """
        _req = await self._client.browse_with_http_info(
            index_name="indexName",
            browse_params={
                "cursor": "test",
            },
        )

        assert _req.path == "/1/indexes/indexName/browse"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"cursor":"test"}""")

    async def test_clear_objects_(self):
        """
        clearObjects
        """
        _req = await self._client.clear_objects_with_http_info(
            index_name="theIndexName",
        )

        assert _req.path == "/1/indexes/theIndexName/clear"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()

    async def test_clear_rules_(self):
        """
        clearRules
        """
        _req = await self._client.clear_rules_with_http_info(
            index_name="indexName",
        )

        assert _req.path == "/1/indexes/indexName/rules/clear"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()

    async def test_clear_synonyms_(self):
        """
        clearSynonyms
        """
        _req = await self._client.clear_synonyms_with_http_info(
            index_name="indexName",
        )

        assert _req.path == "/1/indexes/indexName/synonyms/clear"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()

    async def test_custom_delete_(self):
        """
        allow del method for a custom path with minimal parameters
        """
        _req = await self._client.custom_delete_with_http_info(
            path="test/minimal",
        )

        assert _req.path == "/test/minimal"
        assert _req.verb == "DELETE"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_custom_delete_1(self):
        """
        allow del method for a custom path with all parameters
        """
        _req = await self._client.custom_delete_with_http_info(
            path="test/all",
            parameters={
                "query": "parameters",
            },
        )

        assert _req.path == "/test/all"
        assert _req.verb == "DELETE"
        assert _req.query_parameters.items() == {"query": "parameters"}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_custom_get_(self):
        """
        allow get method for a custom path with minimal parameters
        """
        _req = await self._client.custom_get_with_http_info(
            path="test/minimal",
        )

        assert _req.path == "/test/minimal"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_custom_get_1(self):
        """
        allow get method for a custom path with all parameters
        """
        _req = await self._client.custom_get_with_http_info(
            path="test/all",
            parameters={
                "query": "parameters with space",
            },
        )

        assert _req.path == "/test/all"
        assert _req.verb == "GET"
        assert (
            _req.query_parameters.items()
            == {"query": "parameters%20with%20space"}.items()
        )
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_custom_get_2(self):
        """
        requestOptions should be escaped too
        """
        _req = await self._client.custom_get_with_http_info(
            path="test/all",
            parameters={
                "query": "to be overriden",
            },
            request_options={
                "headers": loads("""{"x-header-1":"spaces are left alone"}"""),
                "query_parameters": loads(
                    """{"query":"parameters with space","and an array":["array","with spaces"]}"""
                ),
            },
        )

        assert _req.path == "/test/all"
        assert _req.verb == "GET"
        assert (
            _req.query_parameters.items()
            == {
                "query": "parameters%20with%20space",
                "and%20an%20array": "array%2Cwith%20spaces",
            }.items()
        )
        assert _req.headers.items() >= {"x-header-1": "spaces are left alone"}.items()
        assert _req.data is None

    async def test_custom_post_(self):
        """
        allow post method for a custom path with minimal parameters
        """
        _req = await self._client.custom_post_with_http_info(
            path="test/minimal",
        )

        assert _req.path == "/test/minimal"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{}""")

    async def test_custom_post_1(self):
        """
        allow post method for a custom path with all parameters
        """
        _req = await self._client.custom_post_with_http_info(
            path="test/all",
            parameters={
                "query": "parameters",
            },
            body={
                "body": "parameters",
            },
        )

        assert _req.path == "/test/all"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {"query": "parameters"}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"body":"parameters"}""")

    async def test_custom_post_2(self):
        """
        requestOptions can override default query parameters
        """
        _req = await self._client.custom_post_with_http_info(
            path="test/requestOptions",
            parameters={
                "query": "parameters",
            },
            body={
                "facet": "filters",
            },
            request_options={
                "query_parameters": loads("""{"query":"myQueryParameter"}"""),
            },
        )

        assert _req.path == "/test/requestOptions"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {"query": "myQueryParameter"}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"facet":"filters"}""")

    async def test_custom_post_3(self):
        """
        requestOptions merges query parameters with default ones
        """
        _req = await self._client.custom_post_with_http_info(
            path="test/requestOptions",
            parameters={
                "query": "parameters",
            },
            body={
                "facet": "filters",
            },
            request_options={
                "query_parameters": loads("""{"query2":"myQueryParameter"}"""),
            },
        )

        assert _req.path == "/test/requestOptions"
        assert _req.verb == "POST"
        assert (
            _req.query_parameters.items()
            == {"query": "parameters", "query2": "myQueryParameter"}.items()
        )
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"facet":"filters"}""")

    async def test_custom_post_4(self):
        """
        requestOptions can override default headers
        """
        _req = await self._client.custom_post_with_http_info(
            path="test/requestOptions",
            parameters={
                "query": "parameters",
            },
            body={
                "facet": "filters",
            },
            request_options={
                "headers": loads("""{"x-algolia-api-key":"myApiKey"}"""),
            },
        )

        assert _req.path == "/test/requestOptions"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {"query": "parameters"}.items()
        assert _req.headers.items() >= {"x-algolia-api-key": "myApiKey"}.items()
        assert loads(_req.data) == loads("""{"facet":"filters"}""")

    async def test_custom_post_5(self):
        """
        requestOptions merges headers with default ones
        """
        _req = await self._client.custom_post_with_http_info(
            path="test/requestOptions",
            parameters={
                "query": "parameters",
            },
            body={
                "facet": "filters",
            },
            request_options={
                "headers": loads("""{"x-algolia-api-key":"myApiKey"}"""),
            },
        )

        assert _req.path == "/test/requestOptions"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {"query": "parameters"}.items()
        assert _req.headers.items() >= {"x-algolia-api-key": "myApiKey"}.items()
        assert loads(_req.data) == loads("""{"facet":"filters"}""")

    async def test_custom_post_6(self):
        """
        requestOptions queryParameters accepts booleans
        """
        _req = await self._client.custom_post_with_http_info(
            path="test/requestOptions",
            parameters={
                "query": "parameters",
            },
            body={
                "facet": "filters",
            },
            request_options={
                "query_parameters": loads("""{"isItWorking":true}"""),
            },
        )

        assert _req.path == "/test/requestOptions"
        assert _req.verb == "POST"
        assert (
            _req.query_parameters.items()
            == {"query": "parameters", "isItWorking": "true"}.items()
        )
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"facet":"filters"}""")

    async def test_custom_post_7(self):
        """
        requestOptions queryParameters accepts integers
        """
        _req = await self._client.custom_post_with_http_info(
            path="test/requestOptions",
            parameters={
                "query": "parameters",
            },
            body={
                "facet": "filters",
            },
            request_options={
                "query_parameters": loads("""{"myParam":2}"""),
            },
        )

        assert _req.path == "/test/requestOptions"
        assert _req.verb == "POST"
        assert (
            _req.query_parameters.items()
            == {"query": "parameters", "myParam": "2"}.items()
        )
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"facet":"filters"}""")

    async def test_custom_post_8(self):
        """
        requestOptions queryParameters accepts list of string
        """
        _req = await self._client.custom_post_with_http_info(
            path="test/requestOptions",
            parameters={
                "query": "parameters",
            },
            body={
                "facet": "filters",
            },
            request_options={
                "query_parameters": loads("""{"myParam":["b and c","d"]}"""),
            },
        )

        assert _req.path == "/test/requestOptions"
        assert _req.verb == "POST"
        assert (
            _req.query_parameters.items()
            == {"query": "parameters", "myParam": "b%20and%20c%2Cd"}.items()
        )
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"facet":"filters"}""")

    async def test_custom_post_9(self):
        """
        requestOptions queryParameters accepts list of booleans
        """
        _req = await self._client.custom_post_with_http_info(
            path="test/requestOptions",
            parameters={
                "query": "parameters",
            },
            body={
                "facet": "filters",
            },
            request_options={
                "query_parameters": loads("""{"myParam":[true,true,false]}"""),
            },
        )

        assert _req.path == "/test/requestOptions"
        assert _req.verb == "POST"
        assert (
            _req.query_parameters.items()
            == {"query": "parameters", "myParam": "true%2Ctrue%2Cfalse"}.items()
        )
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"facet":"filters"}""")

    async def test_custom_post_10(self):
        """
        requestOptions queryParameters accepts list of integers
        """
        _req = await self._client.custom_post_with_http_info(
            path="test/requestOptions",
            parameters={
                "query": "parameters",
            },
            body={
                "facet": "filters",
            },
            request_options={
                "query_parameters": loads("""{"myParam":[1,2]}"""),
            },
        )

        assert _req.path == "/test/requestOptions"
        assert _req.verb == "POST"
        assert (
            _req.query_parameters.items()
            == {"query": "parameters", "myParam": "1%2C2"}.items()
        )
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"facet":"filters"}""")

    async def test_custom_put_(self):
        """
        allow put method for a custom path with minimal parameters
        """
        _req = await self._client.custom_put_with_http_info(
            path="test/minimal",
        )

        assert _req.path == "/test/minimal"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{}""")

    async def test_custom_put_1(self):
        """
        allow put method for a custom path with all parameters
        """
        _req = await self._client.custom_put_with_http_info(
            path="test/all",
            parameters={
                "query": "parameters",
            },
            body={
                "body": "parameters",
            },
        )

        assert _req.path == "/test/all"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {"query": "parameters"}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"body":"parameters"}""")

    async def test_delete_api_key_(self):
        """
        deleteApiKey
        """
        _req = await self._client.delete_api_key_with_http_info(
            key="myTestApiKey",
        )

        assert _req.path == "/1/keys/myTestApiKey"
        assert _req.verb == "DELETE"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_delete_by_(self):
        """
        deleteBy
        """
        _req = await self._client.delete_by_with_http_info(
            index_name="theIndexName",
            delete_by_params={
                "filters": "brand:brandName",
            },
        )

        assert _req.path == "/1/indexes/theIndexName/deleteByQuery"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"filters":"brand:brandName"}""")

    async def test_delete_index_(self):
        """
        deleteIndex
        """
        _req = await self._client.delete_index_with_http_info(
            index_name="theIndexName",
        )

        assert _req.path == "/1/indexes/theIndexName"
        assert _req.verb == "DELETE"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_delete_object_(self):
        """
        deleteObject
        """
        _req = await self._client.delete_object_with_http_info(
            index_name="<YOUR_INDEX_NAME>",
            object_id="uniqueID",
        )

        assert _req.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/uniqueID"
        assert _req.verb == "DELETE"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_delete_rule_(self):
        """
        delete rule simple case
        """
        _req = await self._client.delete_rule_with_http_info(
            index_name="indexName",
            object_id="id1",
        )

        assert _req.path == "/1/indexes/indexName/rules/id1"
        assert _req.verb == "DELETE"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_delete_rule_1(self):
        """
        delete rule with simple characters to encode in objectID
        """
        _req = await self._client.delete_rule_with_http_info(
            index_name="indexName",
            object_id="test/with/slash",
        )

        assert _req.path == "/1/indexes/indexName/rules/test%2Fwith%2Fslash"
        assert _req.verb == "DELETE"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_delete_source_(self):
        """
        deleteSource
        """
        _req = await self._client.delete_source_with_http_info(
            source="theSource",
        )

        assert _req.path == "/1/security/sources/theSource"
        assert _req.verb == "DELETE"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_delete_synonym_(self):
        """
        deleteSynonym
        """
        _req = await self._client.delete_synonym_with_http_info(
            index_name="indexName",
            object_id="id1",
        )

        assert _req.path == "/1/indexes/indexName/synonyms/id1"
        assert _req.verb == "DELETE"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_get_api_key_(self):
        """
        getApiKey
        """
        _req = await self._client.get_api_key_with_http_info(
            key="myTestApiKey",
        )

        assert _req.path == "/1/keys/myTestApiKey"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_get_app_task_(self):
        """
        getAppTask
        """
        _req = await self._client.get_app_task_with_http_info(
            task_id=123,
        )

        assert _req.path == "/1/task/123"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_get_dictionary_languages_(self):
        """
        get getDictionaryLanguages
        """
        _req = await self._client.get_dictionary_languages_with_http_info()

        assert _req.path == "/1/dictionaries/*/languages"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_get_dictionary_settings_(self):
        """
        get getDictionarySettings results
        """
        _req = await self._client.get_dictionary_settings_with_http_info()

        assert _req.path == "/1/dictionaries/*/settings"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_get_logs_(self):
        """
        getLogs with minimal parameters
        """
        _req = await self._client.get_logs_with_http_info()

        assert _req.path == "/1/logs"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_get_logs_1(self):
        """
        getLogs with parameters
        """
        _req = await self._client.get_logs_with_http_info(
            offset=5,
            length=10,
            index_name="theIndexName",
            type="all",
        )

        assert _req.path == "/1/logs"
        assert _req.verb == "GET"
        assert (
            _req.query_parameters.items()
            == {
                "offset": "5",
                "length": "10",
                "indexName": "theIndexName",
                "type": "all",
            }.items()
        )
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_get_object_(self):
        """
        getObject
        """
        _req = await self._client.get_object_with_http_info(
            index_name="theIndexName",
            object_id="uniqueID",
            attributes_to_retrieve=[
                "attr1",
                "attr2",
            ],
        )

        assert _req.path == "/1/indexes/theIndexName/uniqueID"
        assert _req.verb == "GET"
        assert (
            _req.query_parameters.items()
            == {"attributesToRetrieve": "attr1%2Cattr2"}.items()
        )
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_get_objects_(self):
        """
        getObjects
        """
        _req = await self._client.get_objects_with_http_info(
            get_objects_params={
                "requests": [
                    {
                        "attributesToRetrieve": [
                            "attr1",
                            "attr2",
                        ],
                        "objectID": "uniqueID",
                        "indexName": "theIndexName",
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/*/objects"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"attributesToRetrieve":["attr1","attr2"],"objectID":"uniqueID","indexName":"theIndexName"}]}"""
        )

    async def test_get_rule_(self):
        """
        getRule
        """
        _req = await self._client.get_rule_with_http_info(
            index_name="indexName",
            object_id="id1",
        )

        assert _req.path == "/1/indexes/indexName/rules/id1"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_get_settings_(self):
        """
        getSettings
        """
        _req = await self._client.get_settings_with_http_info(
            index_name="cts_e2e_settings",
        )

        assert _req.path == "/1/indexes/cts_e2e_settings/settings"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

        raw_resp = await SearchClient(
            self._e2e_app_id, self._e2e_api_key
        ).get_settings_with_http_info(
            index_name="cts_e2e_settings",
        )
        assert raw_resp.status_code == 200

        resp = await SearchClient(self._e2e_app_id, self._e2e_api_key).get_settings(
            index_name="cts_e2e_settings",
        )
        _expected_body = loads(
            """{"minWordSizefor1Typo":4,"minWordSizefor2Typos":8,"hitsPerPage":100,"maxValuesPerFacet":100,"paginationLimitedTo":10,"exactOnSingleWordQuery":"attribute","ranking":["typo","geo","words","filters","proximity","attribute","exact","custom"],"separatorsToIndex":"","removeWordsIfNoResults":"none","queryType":"prefixLast","highlightPreTag":"<em>","highlightPostTag":"</em>","alternativesAsExact":["ignorePlurals","singleWordSynonym"]}"""
        )
        assert self._helpers.union(_expected_body, resp) == _expected_body

    async def test_get_sources_(self):
        """
        getSources
        """
        _req = await self._client.get_sources_with_http_info()

        assert _req.path == "/1/security/sources"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_get_synonym_(self):
        """
        getSynonym
        """
        _req = await self._client.get_synonym_with_http_info(
            index_name="indexName",
            object_id="id1",
        )

        assert _req.path == "/1/indexes/indexName/synonyms/id1"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_get_task_(self):
        """
        getTask
        """
        _req = await self._client.get_task_with_http_info(
            index_name="theIndexName",
            task_id=123,
        )

        assert _req.path == "/1/indexes/theIndexName/task/123"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_get_top_user_ids_(self):
        """
        getTopUserIds
        """
        _req = await self._client.get_top_user_ids_with_http_info()

        assert _req.path == "/1/clusters/mapping/top"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_get_user_id_(self):
        """
        getUserId
        """
        _req = await self._client.get_user_id_with_http_info(
            user_id="uniqueID",
        )

        assert _req.path == "/1/clusters/mapping/uniqueID"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_has_pending_mappings_(self):
        """
        hasPendingMappings with minimal parameters
        """
        _req = await self._client.has_pending_mappings_with_http_info()

        assert _req.path == "/1/clusters/mapping/pending"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_has_pending_mappings_1(self):
        """
        hasPendingMappings with parameters
        """
        _req = await self._client.has_pending_mappings_with_http_info(
            get_clusters=True,
        )

        assert _req.path == "/1/clusters/mapping/pending"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {"getClusters": "true"}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_list_api_keys_(self):
        """
        listApiKeys
        """
        _req = await self._client.list_api_keys_with_http_info()

        assert _req.path == "/1/keys"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_list_clusters_(self):
        """
        listClusters
        """
        _req = await self._client.list_clusters_with_http_info()

        assert _req.path == "/1/clusters"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_list_indices_(self):
        """
        listIndices with minimal parameters
        """
        _req = await self._client.list_indices_with_http_info()

        assert _req.path == "/1/indexes"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_list_indices_1(self):
        """
        listIndices with parameters
        """
        _req = await self._client.list_indices_with_http_info(
            page=8,
            hits_per_page=3,
        )

        assert _req.path == "/1/indexes"
        assert _req.verb == "GET"
        assert (
            _req.query_parameters.items() == {"page": "8", "hitsPerPage": "3"}.items()
        )
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_list_user_ids_(self):
        """
        listUserIds with minimal parameters
        """
        _req = await self._client.list_user_ids_with_http_info()

        assert _req.path == "/1/clusters/mapping"
        assert _req.verb == "GET"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_list_user_ids_1(self):
        """
        listUserIds with parameters
        """
        _req = await self._client.list_user_ids_with_http_info(
            page=8,
            hits_per_page=100,
        )

        assert _req.path == "/1/clusters/mapping"
        assert _req.verb == "GET"
        assert (
            _req.query_parameters.items() == {"page": "8", "hitsPerPage": "100"}.items()
        )
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_multiple_batch_(self):
        """
        multipleBatch
        """
        _req = await self._client.multiple_batch_with_http_info(
            batch_params={
                "requests": [
                    {
                        "action": "addObject",
                        "body": {
                            "key": "value",
                        },
                        "indexName": "theIndexName",
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/*/batch"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"action":"addObject","body":{"key":"value"},"indexName":"theIndexName"}]}"""
        )

    async def test_operation_index_(self):
        """
        scopes
        """
        _req = await self._client.operation_index_with_http_info(
            index_name="<SOURCE_INDEX_NAME>",
            operation_index_params={
                "operation": "move",
                "destination": "<DESTINATION_INDEX_NAME>",
                "scope": [
                    "rules",
                    "settings",
                ],
            },
        )

        assert _req.path == "/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"operation":"move","destination":"<DESTINATION_INDEX_NAME>","scope":["rules","settings"]}"""
        )

    async def test_operation_index_1(self):
        """
        copy
        """
        _req = await self._client.operation_index_with_http_info(
            index_name="<SOURCE_INDEX_NAME>",
            operation_index_params={
                "operation": "copy",
                "destination": "<DESTINATION_INDEX_NAME>",
            },
        )

        assert _req.path == "/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"operation":"copy","destination":"<DESTINATION_INDEX_NAME>"}"""
        )

    async def test_operation_index_2(self):
        """
        move
        """
        _req = await self._client.operation_index_with_http_info(
            index_name="<SOURCE_INDEX_NAME>",
            operation_index_params={
                "operation": "move",
                "destination": "<DESTINATION_INDEX_NAME>",
            },
        )

        assert _req.path == "/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"operation":"move","destination":"<DESTINATION_INDEX_NAME>"}"""
        )

    async def test_partial_update_object_(self):
        """
        partialUpdateObject
        """
        _req = await self._client.partial_update_object_with_http_info(
            index_name="theIndexName",
            object_id="uniqueID",
            attributes_to_update={
                "id1": "test",
                "id2": {
                    "_operation": "AddUnique",
                    "value": "test2",
                },
            },
            create_if_not_exists=True,
        )

        assert _req.path == "/1/indexes/theIndexName/uniqueID/partial"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {"createIfNotExists": "true"}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"id1":"test","id2":{"_operation":"AddUnique","value":"test2"}}"""
        )

    async def test_remove_user_id_(self):
        """
        removeUserId
        """
        _req = await self._client.remove_user_id_with_http_info(
            user_id="uniqueID",
        )

        assert _req.path == "/1/clusters/mapping/uniqueID"
        assert _req.verb == "DELETE"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert _req.data is None

    async def test_replace_sources_(self):
        """
        replaceSources
        """
        _req = await self._client.replace_sources_with_http_info(
            source=[
                {
                    "source": "theSource",
                    "description": "theDescription",
                },
            ],
        )

        assert _req.path == "/1/security/sources"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """[{"source":"theSource","description":"theDescription"}]"""
        )

    async def test_restore_api_key_(self):
        """
        restoreApiKey
        """
        _req = await self._client.restore_api_key_with_http_info(
            key="myApiKey",
        )

        assert _req.path == "/1/keys/myApiKey/restore"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()

    async def test_save_object_(self):
        """
        saveObject
        """
        _req = await self._client.save_object_with_http_info(
            index_name="<YOUR_INDEX_NAME>",
            body={
                "objectID": "id",
                "test": "val",
            },
        )

        assert _req.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"objectID":"id","test":"val"}""")

    async def test_save_rule_(self):
        """
        saveRule with minimal parameters
        """
        _req = await self._client.save_rule_with_http_info(
            index_name="indexName",
            object_id="id1",
            rule={
                "objectID": "id1",
                "conditions": [
                    {
                        "pattern": "apple",
                        "anchoring": "contains",
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/indexName/rules/id1"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains"}]}"""
        )

    async def test_save_rule_1(self):
        """
        saveRule with all parameters
        """
        _req = await self._client.save_rule_with_http_info(
            index_name="indexName",
            object_id="id1",
            rule={
                "objectID": "id1",
                "conditions": [
                    {
                        "pattern": "apple",
                        "anchoring": "contains",
                        "alternatives": False,
                        "context": "search",
                    },
                ],
                "consequence": {
                    "params": {
                        "filters": "brand:apple",
                        "query": {
                            "remove": [
                                "algolia",
                            ],
                            "edits": [
                                {
                                    "type": "remove",
                                    "delete": "abc",
                                    "insert": "cde",
                                },
                                {
                                    "type": "replace",
                                    "delete": "abc",
                                    "insert": "cde",
                                },
                            ],
                        },
                    },
                    "hide": [
                        {
                            "objectID": "321",
                        },
                    ],
                    "filterPromotes": False,
                    "userData": {"algolia": "aloglia"},
                    "promote": [
                        {
                            "objectID": "abc",
                            "position": 3,
                        },
                        {
                            "objectIDs": [
                                "abc",
                                "def",
                            ],
                            "position": 1,
                        },
                    ],
                },
                "description": "test",
                "enabled": True,
                "validity": [
                    {
                        "from": 1656670273,
                        "until": 1656670277,
                    },
                ],
            },
            forward_to_replicas=True,
        )

        assert _req.path == "/1/indexes/indexName/rules/id1"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {"forwardToReplicas": "true"}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains","alternatives":false,"context":"search"}],"consequence":{"params":{"filters":"brand:apple","query":{"remove":["algolia"],"edits":[{"type":"remove","delete":"abc","insert":"cde"},{"type":"replace","delete":"abc","insert":"cde"}]}},"hide":[{"objectID":"321"}],"filterPromotes":false,"userData":{"algolia":"aloglia"},"promote":[{"objectID":"abc","position":3},{"objectIDs":["abc","def"],"position":1}]},"description":"test","enabled":true,"validity":[{"from":1656670273,"until":1656670277}]}"""
        )

    async def test_save_rules_(self):
        """
        saveRules with minimal parameters
        """
        _req = await self._client.save_rules_with_http_info(
            index_name="<YOUR_INDEX_NAME>",
            rules=[
                {
                    "objectID": "a-rule-id",
                    "conditions": [
                        {
                            "pattern": "smartphone",
                            "anchoring": "contains",
                        },
                    ],
                },
                {
                    "objectID": "a-second-rule-id",
                    "conditions": [
                        {
                            "pattern": "apple",
                            "anchoring": "contains",
                        },
                    ],
                },
            ],
            forward_to_replicas=False,
            clear_existing_rules=True,
        )

        assert _req.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch"
        assert _req.verb == "POST"
        assert (
            _req.query_parameters.items()
            == {"forwardToReplicas": "false", "clearExistingRules": "true"}.items()
        )
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """[{"objectID":"a-rule-id","conditions":[{"pattern":"smartphone","anchoring":"contains"}]},{"objectID":"a-second-rule-id","conditions":[{"pattern":"apple","anchoring":"contains"}]}]"""
        )

    async def test_save_rules_1(self):
        """
        saveRules with all parameters
        """
        _req = await self._client.save_rules_with_http_info(
            index_name="<YOUR_INDEX_NAME>",
            rules=[
                {
                    "objectID": "id1",
                    "conditions": [
                        {
                            "pattern": "apple",
                            "anchoring": "contains",
                            "alternatives": False,
                            "context": "search",
                        },
                    ],
                    "consequence": {
                        "params": {
                            "filters": "brand:apple",
                            "query": {
                                "remove": [
                                    "algolia",
                                ],
                                "edits": [
                                    {
                                        "type": "remove",
                                        "delete": "abc",
                                        "insert": "cde",
                                    },
                                    {
                                        "type": "replace",
                                        "delete": "abc",
                                        "insert": "cde",
                                    },
                                ],
                            },
                        },
                        "hide": [
                            {
                                "objectID": "321",
                            },
                        ],
                        "filterPromotes": False,
                        "userData": {"algolia": "aloglia"},
                        "promote": [
                            {
                                "objectID": "abc",
                                "position": 3,
                            },
                            {
                                "objectIDs": [
                                    "abc",
                                    "def",
                                ],
                                "position": 1,
                            },
                        ],
                    },
                    "description": "test",
                    "enabled": True,
                    "validity": [
                        {
                            "from": 1656670273,
                            "until": 1656670277,
                        },
                    ],
                },
            ],
            forward_to_replicas=True,
            clear_existing_rules=True,
        )

        assert _req.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch"
        assert _req.verb == "POST"
        assert (
            _req.query_parameters.items()
            == {"forwardToReplicas": "true", "clearExistingRules": "true"}.items()
        )
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """[{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains","alternatives":false,"context":"search"}],"consequence":{"params":{"filters":"brand:apple","query":{"remove":["algolia"],"edits":[{"type":"remove","delete":"abc","insert":"cde"},{"type":"replace","delete":"abc","insert":"cde"}]}},"hide":[{"objectID":"321"}],"filterPromotes":false,"userData":{"algolia":"aloglia"},"promote":[{"objectID":"abc","position":3},{"objectIDs":["abc","def"],"position":1}]},"description":"test","enabled":true,"validity":[{"from":1656670273,"until":1656670277}]}]"""
        )

    async def test_save_synonym_(self):
        """
        saveSynonym
        """
        _req = await self._client.save_synonym_with_http_info(
            index_name="indexName",
            object_id="id1",
            synonym_hit={
                "objectID": "id1",
                "type": "synonym",
                "synonyms": [
                    "car",
                    "vehicule",
                    "auto",
                ],
            },
            forward_to_replicas=True,
        )

        assert _req.path == "/1/indexes/indexName/synonyms/id1"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {"forwardToReplicas": "true"}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"objectID":"id1","type":"synonym","synonyms":["car","vehicule","auto"]}"""
        )

    async def test_save_synonyms_(self):
        """
        saveSynonyms
        """
        _req = await self._client.save_synonyms_with_http_info(
            index_name="<YOUR_INDEX_NAME>",
            synonym_hit=[
                {
                    "objectID": "id1",
                    "type": "synonym",
                    "synonyms": [
                        "car",
                        "vehicule",
                        "auto",
                    ],
                },
                {
                    "objectID": "id2",
                    "type": "onewaysynonym",
                    "input": "iphone",
                    "synonyms": [
                        "ephone",
                        "aphone",
                        "yphone",
                    ],
                },
            ],
            forward_to_replicas=True,
            replace_existing_synonyms=True,
        )

        assert _req.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/synonyms/batch"
        assert _req.verb == "POST"
        assert (
            _req.query_parameters.items()
            == {"forwardToReplicas": "true", "replaceExistingSynonyms": "true"}.items()
        )
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """[{"objectID":"id1","type":"synonym","synonyms":["car","vehicule","auto"]},{"objectID":"id2","type":"onewaysynonym","input":"iphone","synonyms":["ephone","aphone","yphone"]}]"""
        )

    async def test_search_(self):
        """
        withHitsPerPage
        """
        _req = await self._client.search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "<YOUR_INDEX_NAME>",
                        "query": "<YOUR_QUERY>",
                        "hitsPerPage": 50,
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/*/queries"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","hitsPerPage":50}]}"""
        )

    async def test_search_1(self):
        """
        filterOnly
        """
        _req = await self._client.search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "<YOUR_INDEX_NAME>",
                        "query": "<YOUR_QUERY>",
                        "filters": "actor:Scarlett Johansson",
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/*/queries"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"actor:Scarlett Johansson"}]}"""
        )

    async def test_search_2(self):
        """
        filterOr
        """
        _req = await self._client.search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "<YOUR_INDEX_NAME>",
                        "query": "<YOUR_QUERY>",
                        "filters": "actor:Tom Cruise OR actor:Scarlett Johansson",
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/*/queries"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"actor:Tom Cruise OR actor:Scarlett Johansson"}]}"""
        )

    async def test_search_3(self):
        """
        filterNot
        """
        _req = await self._client.search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "<YOUR_INDEX_NAME>",
                        "query": "<YOUR_QUERY>",
                        "filters": "NOT actor:Nicolas Cage",
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/*/queries"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"NOT actor:Nicolas Cage"}]}"""
        )

    async def test_search_4(self):
        """
        search for a single hits request with minimal parameters
        """
        _req = await self._client.search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "cts_e2e_search_empty_index",
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/*/queries"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"indexName":"cts_e2e_search_empty_index"}]}"""
        )

        raw_resp = await SearchClient(
            self._e2e_app_id, self._e2e_api_key
        ).search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "cts_e2e_search_empty_index",
                    },
                ],
            },
        )
        assert raw_resp.status_code == 200

        resp = await SearchClient(self._e2e_app_id, self._e2e_api_key).search(
            search_method_params={
                "requests": [
                    {
                        "indexName": "cts_e2e_search_empty_index",
                    },
                ],
            },
        )
        _expected_body = loads(
            """{"results":[{"hits":[],"page":0,"nbHits":0,"nbPages":0,"hitsPerPage":20,"exhaustiveNbHits":true,"exhaustiveTypo":true,"exhaustive":{"nbHits":true,"typo":true},"query":"","params":"","index":"cts_e2e_search_empty_index","renderingContent":{}}]}"""
        )
        assert self._helpers.union(_expected_body, resp) == _expected_body

    async def test_search_5(self):
        """
        retrieveFacets
        """
        _req = await self._client.search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "<YOUR_INDEX_NAME>",
                        "query": "<YOUR_QUERY>",
                        "facets": [
                            "author",
                            "genre",
                        ],
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/*/queries"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","facets":["author","genre"]}]}"""
        )

    async def test_search_6(self):
        """
        retrieveFacetsWildcard
        """
        _req = await self._client.search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "<YOUR_INDEX_NAME>",
                        "query": "<YOUR_QUERY>",
                        "facets": [
                            "*",
                        ],
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/*/queries"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","facets":["*"]}]}"""
        )

    async def test_search_7(self):
        """
        search for a single facet request with minimal parameters
        """
        _req = await self._client.search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "cts_e2e_search_facet",
                        "type": "facet",
                        "facet": "editor",
                    },
                ],
                "strategy": "stopIfEnoughMatches",
            },
        )

        assert _req.path == "/1/indexes/*/queries"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"indexName":"cts_e2e_search_facet","type":"facet","facet":"editor"}],"strategy":"stopIfEnoughMatches"}"""
        )

        raw_resp = await SearchClient(
            self._e2e_app_id, self._e2e_api_key
        ).search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "cts_e2e_search_facet",
                        "type": "facet",
                        "facet": "editor",
                    },
                ],
                "strategy": "stopIfEnoughMatches",
            },
        )
        assert raw_resp.status_code == 200

        resp = await SearchClient(self._e2e_app_id, self._e2e_api_key).search(
            search_method_params={
                "requests": [
                    {
                        "indexName": "cts_e2e_search_facet",
                        "type": "facet",
                        "facet": "editor",
                    },
                ],
                "strategy": "stopIfEnoughMatches",
            },
        )
        _expected_body = loads(
            """{"results":[{"exhaustiveFacetsCount":true,"facetHits":[{"count":1,"highlighted":"goland","value":"goland"},{"count":1,"highlighted":"neovim","value":"neovim"},{"count":1,"highlighted":"visual studio","value":"visual studio"},{"count":1,"highlighted":"vscode","value":"vscode"}]}]}"""
        )
        assert self._helpers.union(_expected_body, resp) == _expected_body

    async def test_search_8(self):
        """
        search for a single hits request with all parameters
        """
        _req = await self._client.search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "theIndexName",
                        "query": "myQuery",
                        "hitsPerPage": 50,
                        "type": "default",
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/*/queries"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"indexName":"theIndexName","query":"myQuery","hitsPerPage":50,"type":"default"}]}"""
        )

    async def test_search_9(self):
        """
        search for a single facet request with all parameters
        """
        _req = await self._client.search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "theIndexName",
                        "type": "facet",
                        "facet": "theFacet",
                        "facetQuery": "theFacetQuery",
                        "query": "theQuery",
                        "maxFacetHits": 50,
                    },
                ],
                "strategy": "stopIfEnoughMatches",
            },
        )

        assert _req.path == "/1/indexes/*/queries"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"indexName":"theIndexName","type":"facet","facet":"theFacet","facetQuery":"theFacetQuery","query":"theQuery","maxFacetHits":50}],"strategy":"stopIfEnoughMatches"}"""
        )

    async def test_search_10(self):
        """
        search for multiple mixed requests in multiple indices with minimal parameters
        """
        _req = await self._client.search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "theIndexName",
                    },
                    {
                        "indexName": "theIndexName2",
                        "type": "facet",
                        "facet": "theFacet",
                    },
                    {
                        "indexName": "theIndexName",
                        "type": "default",
                    },
                ],
                "strategy": "stopIfEnoughMatches",
            },
        )

        assert _req.path == "/1/indexes/*/queries"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"indexName":"theIndexName"},{"indexName":"theIndexName2","type":"facet","facet":"theFacet"},{"indexName":"theIndexName","type":"default"}],"strategy":"stopIfEnoughMatches"}"""
        )

    async def test_search_11(self):
        """
        search for multiple mixed requests in multiple indices with all parameters
        """
        _req = await self._client.search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "theIndexName",
                        "type": "facet",
                        "facet": "theFacet",
                        "facetQuery": "theFacetQuery",
                        "query": "theQuery",
                        "maxFacetHits": 50,
                    },
                    {
                        "indexName": "theIndexName",
                        "query": "myQuery",
                        "hitsPerPage": 50,
                        "type": "default",
                    },
                ],
                "strategy": "stopIfEnoughMatches",
            },
        )

        assert _req.path == "/1/indexes/*/queries"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"indexName":"theIndexName","type":"facet","facet":"theFacet","facetQuery":"theFacetQuery","query":"theQuery","maxFacetHits":50},{"indexName":"theIndexName","query":"myQuery","hitsPerPage":50,"type":"default"}],"strategy":"stopIfEnoughMatches"}"""
        )

    async def test_search_12(self):
        """
        search filters accept all of the possible shapes
        """
        _req = await self._client.search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "theIndexName",
                        "facetFilters": "mySearch:filters",
                        "reRankingApplyFilter": "mySearch:filters",
                        "tagFilters": "mySearch:filters",
                        "numericFilters": "mySearch:filters",
                        "optionalFilters": "mySearch:filters",
                    },
                    {
                        "indexName": "theIndexName",
                        "facetFilters": [
                            "mySearch:filters",
                            [
                                "mySearch:filters",
                                [
                                    "mySearch:filters",
                                ],
                            ],
                        ],
                        "reRankingApplyFilter": [
                            "mySearch:filters",
                            [
                                "mySearch:filters",
                            ],
                        ],
                        "tagFilters": [
                            "mySearch:filters",
                            [
                                "mySearch:filters",
                            ],
                        ],
                        "numericFilters": [
                            "mySearch:filters",
                            [
                                "mySearch:filters",
                            ],
                        ],
                        "optionalFilters": [
                            "mySearch:filters",
                            [
                                "mySearch:filters",
                            ],
                        ],
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/*/queries"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"indexName":"theIndexName","facetFilters":"mySearch:filters","reRankingApplyFilter":"mySearch:filters","tagFilters":"mySearch:filters","numericFilters":"mySearch:filters","optionalFilters":"mySearch:filters"},{"indexName":"theIndexName","facetFilters":["mySearch:filters",["mySearch:filters",["mySearch:filters"]]],"reRankingApplyFilter":["mySearch:filters",["mySearch:filters"]],"tagFilters":["mySearch:filters",["mySearch:filters"]],"numericFilters":["mySearch:filters",["mySearch:filters"]],"optionalFilters":["mySearch:filters",["mySearch:filters"]]}]}"""
        )

    async def test_search_13(self):
        """
        search filters end to end
        """
        _req = await self._client.search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "cts_e2e_search_facet",
                        "filters": "editor:'visual studio' OR editor:neovim",
                    },
                    {
                        "indexName": "cts_e2e_search_facet",
                        "facetFilters": [
                            "editor:'visual studio'",
                            "editor:neovim",
                        ],
                    },
                    {
                        "indexName": "cts_e2e_search_facet",
                        "facetFilters": [
                            "editor:'visual studio'",
                            [
                                "editor:neovim",
                            ],
                        ],
                    },
                    {
                        "indexName": "cts_e2e_search_facet",
                        "facetFilters": [
                            "editor:'visual studio'",
                            [
                                "editor:neovim",
                                [
                                    "editor:goland",
                                ],
                            ],
                        ],
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/*/queries"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"indexName":"cts_e2e_search_facet","filters":"editor:'visual studio' OR editor:neovim"},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'","editor:neovim"]},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'",["editor:neovim"]]},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'",["editor:neovim",["editor:goland"]]]}]}"""
        )

        raw_resp = await SearchClient(
            self._e2e_app_id, self._e2e_api_key
        ).search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "indexName": "cts_e2e_search_facet",
                        "filters": "editor:'visual studio' OR editor:neovim",
                    },
                    {
                        "indexName": "cts_e2e_search_facet",
                        "facetFilters": [
                            "editor:'visual studio'",
                            "editor:neovim",
                        ],
                    },
                    {
                        "indexName": "cts_e2e_search_facet",
                        "facetFilters": [
                            "editor:'visual studio'",
                            [
                                "editor:neovim",
                            ],
                        ],
                    },
                    {
                        "indexName": "cts_e2e_search_facet",
                        "facetFilters": [
                            "editor:'visual studio'",
                            [
                                "editor:neovim",
                                [
                                    "editor:goland",
                                ],
                            ],
                        ],
                    },
                ],
            },
        )
        assert raw_resp.status_code == 200

        resp = await SearchClient(self._e2e_app_id, self._e2e_api_key).search(
            search_method_params={
                "requests": [
                    {
                        "indexName": "cts_e2e_search_facet",
                        "filters": "editor:'visual studio' OR editor:neovim",
                    },
                    {
                        "indexName": "cts_e2e_search_facet",
                        "facetFilters": [
                            "editor:'visual studio'",
                            "editor:neovim",
                        ],
                    },
                    {
                        "indexName": "cts_e2e_search_facet",
                        "facetFilters": [
                            "editor:'visual studio'",
                            [
                                "editor:neovim",
                            ],
                        ],
                    },
                    {
                        "indexName": "cts_e2e_search_facet",
                        "facetFilters": [
                            "editor:'visual studio'",
                            [
                                "editor:neovim",
                                [
                                    "editor:goland",
                                ],
                            ],
                        ],
                    },
                ],
            },
        )
        _expected_body = loads(
            """{"results":[{"hitsPerPage":20,"index":"cts_e2e_search_facet","nbHits":2,"nbPages":1,"page":0,"hits":[{"editor":"visual studio","_highlightResult":{"editor":{"value":"visual studio","matchLevel":"none"}}},{"editor":"neovim","_highlightResult":{"editor":{"value":"neovim","matchLevel":"none"}}}],"query":"","params":"filters=editor%3A%27visual+studio%27+OR+editor%3Aneovim"},{"hitsPerPage":20,"index":"cts_e2e_search_facet","nbHits":0,"nbPages":0,"page":0,"hits":[],"query":"","params":"facetFilters=%5B%22editor%3A%27visual+studio%27%22%2C%22editor%3Aneovim%22%5D"},{"hitsPerPage":20,"index":"cts_e2e_search_facet","nbHits":0,"nbPages":0,"page":0,"hits":[],"query":"","params":"facetFilters=%5B%22editor%3A%27visual+studio%27%22%2C%5B%22editor%3Aneovim%22%5D%5D"},{"hitsPerPage":20,"index":"cts_e2e_search_facet","nbHits":0,"nbPages":0,"page":0,"hits":[],"query":"","params":"facetFilters=%5B%22editor%3A%27visual+studio%27%22%2C%5B%22editor%3Aneovim%22%2C%5B%22editor%3Agoland%22%5D%5D%5D"}]}"""
        )
        assert self._helpers.union(_expected_body, resp) == _expected_body

    async def test_search_14(self):
        """
        search with all search parameters
        """
        _req = await self._client.search_with_http_info(
            search_method_params={
                "requests": [
                    {
                        "advancedSyntax": True,
                        "advancedSyntaxFeatures": [
                            "exactPhrase",
                        ],
                        "allowTyposOnNumericTokens": True,
                        "alternativesAsExact": [
                            "multiWordsSynonym",
                        ],
                        "analytics": True,
                        "analyticsTags": [
                            "",
                        ],
                        "aroundLatLng": "",
                        "aroundLatLngViaIP": True,
                        "aroundPrecision": 0,
                        "aroundRadius": "all",
                        "attributeCriteriaComputedByMinProximity": True,
                        "attributesToHighlight": [
                            "",
                        ],
                        "attributesToRetrieve": [
                            "",
                        ],
                        "attributesToSnippet": [
                            "",
                        ],
                        "clickAnalytics": True,
                        "customRanking": [
                            "",
                        ],
                        "decompoundQuery": True,
                        "disableExactOnAttributes": [
                            "",
                        ],
                        "disableTypoToleranceOnAttributes": [
                            "",
                        ],
                        "distinct": 0,
                        "enableABTest": True,
                        "enablePersonalization": True,
                        "enableReRanking": True,
                        "enableRules": True,
                        "exactOnSingleWordQuery": "attribute",
                        "facetFilters": [
                            "",
                        ],
                        "facetingAfterDistinct": True,
                        "facets": [
                            "",
                        ],
                        "filters": "",
                        "getRankingInfo": True,
                        "highlightPostTag": "",
                        "highlightPreTag": "",
                        "hitsPerPage": 1,
                        "ignorePlurals": False,
                        "indexName": "theIndexName",
                        "insideBoundingBox": [
                            [
                                47.3165,
                                4.9665,
                                47.3424,
                                5.0201,
                            ],
                            [
                                40.9234,
                                2.1185,
                                38.643,
                                1.9916,
                            ],
                        ],
                        "insidePolygon": [
                            [
                                47.3165,
                                4.9665,
                                47.3424,
                                5.0201,
                                47.32,
                                4.9,
                            ],
                            [
                                40.9234,
                                2.1185,
                                38.643,
                                1.9916,
                                39.2587,
                                2.0104,
                            ],
                        ],
                        "keepDiacriticsOnCharacters": "",
                        "length": 1,
                        "maxValuesPerFacet": 0,
                        "minProximity": 1,
                        "minWordSizefor1Typo": 0,
                        "minWordSizefor2Typos": 0,
                        "minimumAroundRadius": 1,
                        "naturalLanguages": [
                            "fr",
                        ],
                        "numericFilters": [
                            "",
                        ],
                        "offset": 0,
                        "optionalFilters": [
                            "",
                        ],
                        "optionalWords": [
                            "",
                        ],
                        "page": 0,
                        "percentileComputation": True,
                        "personalizationImpact": 0,
                        "query": "",
                        "queryLanguages": [
                            "fr",
                        ],
                        "queryType": "prefixAll",
                        "ranking": [
                            "",
                        ],
                        "reRankingApplyFilter": [
                            "",
                        ],
                        "relevancyStrictness": 0,
                        "removeStopWords": True,
                        "removeWordsIfNoResults": "allOptional",
                        "renderingContent": {
                            "facetOrdering": {
                                "facets": {
                                    "order": [
                                        "a",
                                        "b",
                                    ],
                                },
                                "values": {
                                    "a": {
                                        "order": [
                                            "b",
                                        ],
                                        "sortRemainingBy": "count",
                                    },
                                },
                            },
                        },
                        "replaceSynonymsInHighlight": True,
                        "responseFields": [
                            "",
                        ],
                        "restrictHighlightAndSnippetArrays": True,
                        "restrictSearchableAttributes": [
                            "",
                        ],
                        "ruleContexts": [
                            "",
                        ],
                        "similarQuery": "",
                        "snippetEllipsisText": "",
                        "sortFacetValuesBy": "",
                        "sumOrFiltersScores": True,
                        "synonyms": True,
                        "tagFilters": [
                            "",
                        ],
                        "type": "default",
                        "typoTolerance": "min",
                        "userToken": "",
                    },
                ],
            },
        )

        assert _req.path == "/1/indexes/*/queries"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"requests":[{"advancedSyntax":true,"advancedSyntaxFeatures":["exactPhrase"],"allowTyposOnNumericTokens":true,"alternativesAsExact":["multiWordsSynonym"],"analytics":true,"analyticsTags":[""],"aroundLatLng":"","aroundLatLngViaIP":true,"aroundPrecision":0,"aroundRadius":"all","attributeCriteriaComputedByMinProximity":true,"attributesToHighlight":[""],"attributesToRetrieve":[""],"attributesToSnippet":[""],"clickAnalytics":true,"customRanking":[""],"decompoundQuery":true,"disableExactOnAttributes":[""],"disableTypoToleranceOnAttributes":[""],"distinct":0,"enableABTest":true,"enablePersonalization":true,"enableReRanking":true,"enableRules":true,"exactOnSingleWordQuery":"attribute","facetFilters":[""],"facetingAfterDistinct":true,"facets":[""],"filters":"","getRankingInfo":true,"highlightPostTag":"","highlightPreTag":"","hitsPerPage":1,"ignorePlurals":false,"indexName":"theIndexName","insideBoundingBox":[[47.3165,4.9665,47.3424,5.0201],[40.9234,2.1185,38.643,1.9916]],"insidePolygon":[[47.3165,4.9665,47.3424,5.0201,47.32,4.9],[40.9234,2.1185,38.643,1.9916,39.2587,2.0104]],"keepDiacriticsOnCharacters":"","length":1,"maxValuesPerFacet":0,"minProximity":1,"minWordSizefor1Typo":0,"minWordSizefor2Typos":0,"minimumAroundRadius":1,"naturalLanguages":["fr"],"numericFilters":[""],"offset":0,"optionalFilters":[""],"optionalWords":[""],"page":0,"percentileComputation":true,"personalizationImpact":0,"query":"","queryLanguages":["fr"],"queryType":"prefixAll","ranking":[""],"reRankingApplyFilter":[""],"relevancyStrictness":0,"removeStopWords":true,"removeWordsIfNoResults":"allOptional","renderingContent":{"facetOrdering":{"facets":{"order":["a","b"]},"values":{"a":{"order":["b"],"sortRemainingBy":"count"}}}},"replaceSynonymsInHighlight":true,"responseFields":[""],"restrictHighlightAndSnippetArrays":true,"restrictSearchableAttributes":[""],"ruleContexts":[""],"similarQuery":"","snippetEllipsisText":"","sortFacetValuesBy":"","sumOrFiltersScores":true,"synonyms":true,"tagFilters":[""],"type":"default","typoTolerance":"min","userToken":""}]}"""
        )

    async def test_search_dictionary_entries_(self):
        """
        get searchDictionaryEntries results with minimal parameters
        """
        _req = await self._client.search_dictionary_entries_with_http_info(
            dictionary_name="stopwords",
            search_dictionary_entries_params={
                "query": "about",
            },
        )

        assert _req.path == "/1/dictionaries/stopwords/search"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"query":"about"}""")

        raw_resp = await SearchClient(
            self._e2e_app_id, self._e2e_api_key
        ).search_dictionary_entries_with_http_info(
            dictionary_name="stopwords",
            search_dictionary_entries_params={
                "query": "about",
            },
        )
        assert raw_resp.status_code == 200

        resp = await SearchClient(
            self._e2e_app_id, self._e2e_api_key
        ).search_dictionary_entries(
            dictionary_name="stopwords",
            search_dictionary_entries_params={
                "query": "about",
            },
        )
        _expected_body = loads(
            """{"hits":[{"objectID":"86ef58032f47d976ca7130a896086783","language":"en","word":"about"}],"page":0,"nbHits":1,"nbPages":1}"""
        )
        assert self._helpers.union(_expected_body, resp) == _expected_body

    async def test_search_dictionary_entries_1(self):
        """
        get searchDictionaryEntries results with all parameters
        """
        _req = await self._client.search_dictionary_entries_with_http_info(
            dictionary_name="compounds",
            search_dictionary_entries_params={
                "query": "foo",
                "page": 4,
                "hitsPerPage": 2,
                "language": "fr",
            },
        )

        assert _req.path == "/1/dictionaries/compounds/search"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"query":"foo","page":4,"hitsPerPage":2,"language":"fr"}"""
        )

    async def test_search_for_facet_values_(self):
        """
        get searchForFacetValues results with minimal parameters
        """
        _req = await self._client.search_for_facet_values_with_http_info(
            index_name="indexName",
            facet_name="facetName",
        )

        assert _req.path == "/1/indexes/indexName/facets/facetName/query"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{}""")

    async def test_search_for_facet_values_1(self):
        """
        get searchForFacetValues results with all parameters
        """
        _req = await self._client.search_for_facet_values_with_http_info(
            index_name="indexName",
            facet_name="facetName",
            search_for_facet_values_request={
                "params": "query=foo&facetFilters=['bar']",
                "facetQuery": "foo",
                "maxFacetHits": 42,
            },
        )

        assert _req.path == "/1/indexes/indexName/facets/facetName/query"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"params":"query=foo&facetFilters=['bar']","facetQuery":"foo","maxFacetHits":42}"""
        )

    async def test_search_rules_(self):
        """
        searchRules
        """
        _req = await self._client.search_rules_with_http_info(
            index_name="indexName",
            search_rules_params={
                "query": "something",
            },
        )

        assert _req.path == "/1/indexes/indexName/rules/search"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"query":"something"}""")

    async def test_search_single_index_(self):
        """
        search with minimal parameters
        """
        _req = await self._client.search_single_index_with_http_info(
            index_name="indexName",
        )

        assert _req.path == "/1/indexes/indexName/query"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{}""")

    async def test_search_single_index_1(self):
        """
        search with special characters in indexName
        """
        _req = await self._client.search_single_index_with_http_info(
            index_name="cts_e2e_space in index",
        )

        assert _req.path == "/1/indexes/cts_e2e_space%20in%20index/query"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{}""")

        raw_resp = await SearchClient(
            self._e2e_app_id, self._e2e_api_key
        ).search_single_index_with_http_info(
            index_name="cts_e2e_space in index",
        )
        assert raw_resp.status_code == 200

    async def test_search_single_index_2(self):
        """
        search with searchParams
        """
        _req = await self._client.search_single_index_with_http_info(
            index_name="indexName",
            search_params={
                "query": "myQuery",
                "facetFilters": [
                    "tags:algolia",
                ],
            },
        )

        assert _req.path == "/1/indexes/indexName/query"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"query":"myQuery","facetFilters":["tags:algolia"]}"""
        )

    async def test_search_single_index_3(self):
        """
        single search retrieve snippets
        """
        _req = await self._client.search_single_index_with_http_info(
            index_name="cts_e2e_browse",
            search_params={
                "query": "batman mask of the phantasm",
                "attributesToRetrieve": [
                    "*",
                ],
                "attributesToSnippet": [
                    "*:20",
                ],
            },
        )

        assert _req.path == "/1/indexes/cts_e2e_browse/query"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"query":"batman mask of the phantasm","attributesToRetrieve":["*"],"attributesToSnippet":["*:20"]}"""
        )

        raw_resp = await SearchClient(
            self._e2e_app_id, self._e2e_api_key
        ).search_single_index_with_http_info(
            index_name="cts_e2e_browse",
            search_params={
                "query": "batman mask of the phantasm",
                "attributesToRetrieve": [
                    "*",
                ],
                "attributesToSnippet": [
                    "*:20",
                ],
            },
        )
        assert raw_resp.status_code == 200

        resp = await SearchClient(
            self._e2e_app_id, self._e2e_api_key
        ).search_single_index(
            index_name="cts_e2e_browse",
            search_params={
                "query": "batman mask of the phantasm",
                "attributesToRetrieve": [
                    "*",
                ],
                "attributesToSnippet": [
                    "*:20",
                ],
            },
        )
        _expected_body = loads(
            """{"nbHits":1,"hits":[{"_snippetResult":{"genres":[{"value":"Animated","matchLevel":"none"},{"value":"Superhero","matchLevel":"none"},{"value":"Romance","matchLevel":"none"}],"year":{"value":"1993","matchLevel":"none"}},"_highlightResult":{"genres":[{"value":"Animated","matchLevel":"none","matchedWords":[]},{"value":"Superhero","matchLevel":"none","matchedWords":[]},{"value":"Romance","matchLevel":"none","matchedWords":[]}],"year":{"value":"1993","matchLevel":"none","matchedWords":[]}}}]}"""
        )
        assert self._helpers.union(_expected_body, resp) == _expected_body

    async def test_search_synonyms_(self):
        """
        searchSynonyms with minimal parameters
        """
        _req = await self._client.search_synonyms_with_http_info(
            index_name="indexName",
        )

        assert _req.path == "/1/indexes/indexName/synonyms/search"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{}""")

    async def test_search_synonyms_1(self):
        """
        searchSynonyms with all parameters
        """
        _req = await self._client.search_synonyms_with_http_info(
            index_name="indexName",
            search_synonyms_params={
                "query": "myQuery",
                "type": "altcorrection1",
                "page": 10,
                "hitsPerPage": 10,
            },
        )

        assert _req.path == "/1/indexes/indexName/synonyms/search"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"query":"myQuery","type":"altcorrection1","page":10,"hitsPerPage":10}"""
        )

    async def test_search_user_ids_(self):
        """
        searchUserIds
        """
        _req = await self._client.search_user_ids_with_http_info(
            search_user_ids_params={
                "query": "test",
                "clusterName": "theClusterName",
                "page": 5,
                "hitsPerPage": 10,
            },
        )

        assert _req.path == "/1/clusters/mapping/search"
        assert _req.verb == "POST"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"query":"test","clusterName":"theClusterName","page":5,"hitsPerPage":10}"""
        )

    async def test_set_dictionary_settings_(self):
        """
        get setDictionarySettings results with minimal parameters
        """
        _req = await self._client.set_dictionary_settings_with_http_info(
            dictionary_settings_params={
                "disableStandardEntries": {
                    "plurals": {
                        "fr": False,
                        "en": False,
                        "ru": True,
                    },
                },
            },
        )

        assert _req.path == "/1/dictionaries/*/settings"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"disableStandardEntries":{"plurals":{"fr":false,"en":false,"ru":true}}}"""
        )

    async def test_set_dictionary_settings_1(self):
        """
        get setDictionarySettings results with all parameters
        """
        _req = await self._client.set_dictionary_settings_with_http_info(
            dictionary_settings_params={
                "disableStandardEntries": {
                    "plurals": {
                        "fr": False,
                        "en": False,
                        "ru": True,
                    },
                    "stopwords": {
                        "fr": False,
                    },
                    "compounds": {
                        "ru": True,
                    },
                },
            },
        )

        assert _req.path == "/1/dictionaries/*/settings"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"disableStandardEntries":{"plurals":{"fr":false,"en":false,"ru":true},"stopwords":{"fr":false},"compounds":{"ru":true}}}"""
        )

    async def test_set_settings_(self):
        """
        setSettingsAttributesForFaceting
        """
        _req = await self._client.set_settings_with_http_info(
            index_name="<YOUR_INDEX_NAME>",
            index_settings={
                "attributesForFaceting": [
                    "actor",
                    "filterOnly(category)",
                    "searchable(publisher)",
                ],
            },
        )

        assert _req.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"attributesForFaceting":["actor","filterOnly(category)","searchable(publisher)"]}"""
        )

    async def test_set_settings_1(self):
        """
        setSettings with minimal parameters
        """
        _req = await self._client.set_settings_with_http_info(
            index_name="cts_e2e_settings",
            index_settings={
                "paginationLimitedTo": 10,
            },
            forward_to_replicas=True,
        )

        assert _req.path == "/1/indexes/cts_e2e_settings/settings"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {"forwardToReplicas": "true"}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"paginationLimitedTo":10}""")

        raw_resp = await SearchClient(
            self._e2e_app_id, self._e2e_api_key
        ).set_settings_with_http_info(
            index_name="cts_e2e_settings",
            index_settings={
                "paginationLimitedTo": 10,
            },
            forward_to_replicas=True,
        )
        assert raw_resp.status_code == 200

    async def test_set_settings_2(self):
        """
        setSettings allow boolean `typoTolerance`
        """
        _req = await self._client.set_settings_with_http_info(
            index_name="theIndexName",
            index_settings={
                "typoTolerance": True,
            },
            forward_to_replicas=True,
        )

        assert _req.path == "/1/indexes/theIndexName/settings"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {"forwardToReplicas": "true"}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"typoTolerance":true}""")

    async def test_set_settings_3(self):
        """
        setSettings allow enum `typoTolerance`
        """
        _req = await self._client.set_settings_with_http_info(
            index_name="theIndexName",
            index_settings={
                "typoTolerance": "min",
            },
            forward_to_replicas=True,
        )

        assert _req.path == "/1/indexes/theIndexName/settings"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {"forwardToReplicas": "true"}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"typoTolerance":"min"}""")

    async def test_set_settings_4(self):
        """
        setSettings allow boolean `ignorePlurals`
        """
        _req = await self._client.set_settings_with_http_info(
            index_name="theIndexName",
            index_settings={
                "ignorePlurals": True,
            },
            forward_to_replicas=True,
        )

        assert _req.path == "/1/indexes/theIndexName/settings"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {"forwardToReplicas": "true"}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"ignorePlurals":true}""")

    async def test_set_settings_5(self):
        """
        setSettings allow list of string `ignorePlurals`
        """
        _req = await self._client.set_settings_with_http_info(
            index_name="theIndexName",
            index_settings={
                "ignorePlurals": [
                    "fr",
                ],
            },
            forward_to_replicas=True,
        )

        assert _req.path == "/1/indexes/theIndexName/settings"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {"forwardToReplicas": "true"}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"ignorePlurals":["fr"]}""")

    async def test_set_settings_6(self):
        """
        setSettings allow boolean `removeStopWords`
        """
        _req = await self._client.set_settings_with_http_info(
            index_name="theIndexName",
            index_settings={
                "removeStopWords": True,
            },
            forward_to_replicas=True,
        )

        assert _req.path == "/1/indexes/theIndexName/settings"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {"forwardToReplicas": "true"}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"removeStopWords":true}""")

    async def test_set_settings_7(self):
        """
        setSettings allow list of string `removeStopWords`
        """
        _req = await self._client.set_settings_with_http_info(
            index_name="theIndexName",
            index_settings={
                "removeStopWords": [
                    "fr",
                ],
            },
            forward_to_replicas=True,
        )

        assert _req.path == "/1/indexes/theIndexName/settings"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {"forwardToReplicas": "true"}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"removeStopWords":["fr"]}""")

    async def test_set_settings_8(self):
        """
        setSettings allow boolean `distinct`
        """
        _req = await self._client.set_settings_with_http_info(
            index_name="theIndexName",
            index_settings={
                "distinct": True,
            },
            forward_to_replicas=True,
        )

        assert _req.path == "/1/indexes/theIndexName/settings"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {"forwardToReplicas": "true"}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"distinct":true}""")

    async def test_set_settings_9(self):
        """
        setSettings allow integers for `distinct`
        """
        _req = await self._client.set_settings_with_http_info(
            index_name="theIndexName",
            index_settings={
                "distinct": 1,
            },
            forward_to_replicas=True,
        )

        assert _req.path == "/1/indexes/theIndexName/settings"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {"forwardToReplicas": "true"}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads("""{"distinct":1}""")

    async def test_set_settings_10(self):
        """
        setSettings allow all `indexSettings`
        """
        _req = await self._client.set_settings_with_http_info(
            index_name="theIndexName",
            index_settings={
                "advancedSyntax": True,
                "advancedSyntaxFeatures": [
                    "exactPhrase",
                ],
                "allowCompressionOfIntegerArray": True,
                "allowTyposOnNumericTokens": True,
                "alternativesAsExact": [
                    "singleWordSynonym",
                ],
                "attributeCriteriaComputedByMinProximity": True,
                "attributeForDistinct": "test",
                "attributesForFaceting": [
                    "algolia",
                ],
                "attributesToHighlight": [
                    "algolia",
                ],
                "attributesToRetrieve": [
                    "algolia",
                ],
                "attributesToSnippet": [
                    "algolia",
                ],
                "attributesToTransliterate": [
                    "algolia",
                ],
                "camelCaseAttributes": [
                    "algolia",
                ],
                "customNormalization": {
                    "algolia": {
                        "aloglia": "aglolia",
                    },
                },
                "customRanking": [
                    "algolia",
                ],
                "decompoundQuery": False,
                "decompoundedAttributes": {
                    "algolia": "aloglia",
                },
                "disableExactOnAttributes": [
                    "algolia",
                ],
                "disablePrefixOnAttributes": [
                    "algolia",
                ],
                "disableTypoToleranceOnAttributes": [
                    "algolia",
                ],
                "disableTypoToleranceOnWords": [
                    "algolia",
                ],
                "distinct": 3,
                "enablePersonalization": True,
                "enableReRanking": False,
                "enableRules": True,
                "exactOnSingleWordQuery": "attribute",
                "highlightPreTag": "<span>",
                "highlightPostTag": "</span>",
                "hitsPerPage": 10,
                "ignorePlurals": False,
                "indexLanguages": [
                    "fr",
                ],
                "keepDiacriticsOnCharacters": "abc",
                "maxFacetHits": 20,
                "maxValuesPerFacet": 30,
                "minProximity": 6,
                "minWordSizefor1Typo": 5,
                "minWordSizefor2Typos": 11,
                "mode": "neuralSearch",
                "numericAttributesForFiltering": [
                    "algolia",
                ],
                "optionalWords": [
                    "myspace",
                ],
                "paginationLimitedTo": 0,
                "queryLanguages": [
                    "fr",
                ],
                "queryType": "prefixLast",
                "ranking": [
                    "geo",
                ],
                "reRankingApplyFilter": "mySearch:filters",
                "relevancyStrictness": 10,
                "removeStopWords": False,
                "removeWordsIfNoResults": "lastWords",
                "renderingContent": {
                    "facetOrdering": {
                        "facets": {
                            "order": [
                                "a",
                                "b",
                            ],
                        },
                        "values": {
                            "a": {
                                "order": [
                                    "b",
                                ],
                                "sortRemainingBy": "count",
                            },
                        },
                    },
                },
                "replaceSynonymsInHighlight": True,
                "replicas": [
                    "",
                ],
                "responseFields": [
                    "algolia",
                ],
                "restrictHighlightAndSnippetArrays": True,
                "searchableAttributes": [
                    "foo",
                ],
                "semanticSearch": {
                    "eventSources": [
                        "foo",
                    ],
                },
                "separatorsToIndex": "bar",
                "snippetEllipsisText": "---",
                "sortFacetValuesBy": "date",
                "typoTolerance": False,
                "unretrievableAttributes": [
                    "foo",
                ],
                "userData": {
                    "user": "data",
                },
            },
        )

        assert _req.path == "/1/indexes/theIndexName/settings"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"advancedSyntax":true,"advancedSyntaxFeatures":["exactPhrase"],"allowCompressionOfIntegerArray":true,"allowTyposOnNumericTokens":true,"alternativesAsExact":["singleWordSynonym"],"attributeCriteriaComputedByMinProximity":true,"attributeForDistinct":"test","attributesForFaceting":["algolia"],"attributesToHighlight":["algolia"],"attributesToRetrieve":["algolia"],"attributesToSnippet":["algolia"],"attributesToTransliterate":["algolia"],"camelCaseAttributes":["algolia"],"customNormalization":{"algolia":{"aloglia":"aglolia"}},"customRanking":["algolia"],"decompoundQuery":false,"decompoundedAttributes":{"algolia":"aloglia"},"disableExactOnAttributes":["algolia"],"disablePrefixOnAttributes":["algolia"],"disableTypoToleranceOnAttributes":["algolia"],"disableTypoToleranceOnWords":["algolia"],"distinct":3,"enablePersonalization":true,"enableReRanking":false,"enableRules":true,"exactOnSingleWordQuery":"attribute","highlightPreTag":"<span>","highlightPostTag":"</span>","hitsPerPage":10,"ignorePlurals":false,"indexLanguages":["fr"],"keepDiacriticsOnCharacters":"abc","maxFacetHits":20,"maxValuesPerFacet":30,"minProximity":6,"minWordSizefor1Typo":5,"minWordSizefor2Typos":11,"mode":"neuralSearch","numericAttributesForFiltering":["algolia"],"optionalWords":["myspace"],"paginationLimitedTo":0,"queryLanguages":["fr"],"queryType":"prefixLast","ranking":["geo"],"reRankingApplyFilter":"mySearch:filters","relevancyStrictness":10,"removeStopWords":false,"removeWordsIfNoResults":"lastWords","renderingContent":{"facetOrdering":{"facets":{"order":["a","b"]},"values":{"a":{"order":["b"],"sortRemainingBy":"count"}}}},"replaceSynonymsInHighlight":true,"replicas":[""],"responseFields":["algolia"],"restrictHighlightAndSnippetArrays":true,"searchableAttributes":["foo"],"semanticSearch":{"eventSources":["foo"]},"separatorsToIndex":"bar","snippetEllipsisText":"---","sortFacetValuesBy":"date","typoTolerance":false,"unretrievableAttributes":["foo"],"userData":{"user":"data"}}"""
        )

    async def test_update_api_key_(self):
        """
        updateApiKey
        """
        _req = await self._client.update_api_key_with_http_info(
            key="myApiKey",
            api_key={
                "acl": [
                    "search",
                    "addObject",
                ],
                "validity": 300,
                "maxQueriesPerIPPerHour": 100,
                "maxHitsPerQuery": 20,
            },
        )

        assert _req.path == "/1/keys/myApiKey"
        assert _req.verb == "PUT"
        assert _req.query_parameters.items() == {}.items()
        assert _req.headers.items() >= {}.items()
        assert loads(_req.data) == loads(
            """{"acl":["search","addObject"],"validity":300,"maxQueriesPerIPPerHour":100,"maxHitsPerQuery":20}"""
        )

    def test_generate_secured_api_key_0(self):
        """
        allow generating a secured api key without restrictions
        """
        _resp = self._client.generate_secured_api_key(parent_api_key="foo")
        assert (
            _resp
            == "Yzc2MzU2ZWZhMTlkMjE5ZDFkN2UwOGNjYjIwYjFkMjZkYjUzYjE0MzE1NmY0MDZjOTlkY2I4ZTA4NzZkNmM1NXt9"
        )

    def test_generate_secured_api_key_1(self):
        """
        allow generating a secured api key with a dict of restrictions
        """
        _resp = self._client.generate_secured_api_key(
            parent_api_key="foo",
            restrictions={
                "search_params": {"query": "foo"},
                "valid_until": 100,
                "restrict_indices": ["bar"],
                "restrict_sources": "baz",
                "user_token": "foobarbaz",
            },
        )
        assert (
            _resp
            == "OGM3YTUyNjI5MTExNjEwNWQ5ZTJhYzBlMWFmY2VjNTg3MmRlZTM4MjZmNzk2MjVmOTJkZGUyNjFhZTQzNDJlNXsic2VhcmNoX3BhcmFtcyI6ICJ7XCJxdWVyeVwiOiBcImZvb1wifSIsICJ2YWxpZF91bnRpbCI6ICIxMDAiLCAicmVzdHJpY3RfaW5kaWNlcyI6ICJiYXIiLCAicmVzdHJpY3Rfc291cmNlcyI6ICJiYXoiLCAidXNlcl90b2tlbiI6ICJmb29iYXJiYXoifQ=="
        )

    def test_generate_secured_api_key_2(self):
        """
        allow generating a secured api key with the model
        """
        _resp = self._client.generate_secured_api_key(
            parent_api_key="bar",
            restrictions=SecuredAPIKeyRestrictions(
                search_params={"query": "bar", "page": 3},
                valid_until=42,
                restrict_indices=["baz"],
                restrict_sources="foo",
                user_token="bazbarfoo",
            ),
        )
        assert (
            _resp
            == "NmIzMWY4NjlmOGJlZTQxZmI2MjRhZDkwZTY0NWRiY2E3Yzk0NWNhNDMyMjI5NWZiNDk2YzliZjM1YTA1M2Y3Y3sic2VhcmNoUGFyYW1zIjogIntcInF1ZXJ5XCI6IFwiYmFyXCIsIFwic2ltaWxhclF1ZXJ5XCI6IFwiXCIsIFwic3VtT3JGaWx0ZXJzU2NvcmVzXCI6IGZhbHNlLCBcImZhY2V0aW5nQWZ0ZXJEaXN0aW5jdFwiOiBmYWxzZSwgXCJwYWdlXCI6IDMsIFwiYXJvdW5kTGF0TG5nXCI6IFwiXCIsIFwiYXJvdW5kTGF0TG5nVmlhSVBcIjogZmFsc2UsIFwicGVyc29uYWxpemF0aW9uSW1wYWN0XCI6IDEwMCwgXCJnZXRSYW5raW5nSW5mb1wiOiBmYWxzZSwgXCJzeW5vbnltc1wiOiB0cnVlLCBcImNsaWNrQW5hbHl0aWNzXCI6IGZhbHNlLCBcImFuYWx5dGljc1wiOiB0cnVlLCBcInBlcmNlbnRpbGVDb21wdXRhdGlvblwiOiB0cnVlLCBcImVuYWJsZUFCVGVzdFwiOiB0cnVlLCBcInJlbGV2YW5jeVN0cmljdG5lc3NcIjogMTAwLCBcImhpZ2hsaWdodFByZVRhZ1wiOiBcIjxlbT5cIiwgXCJoaWdobGlnaHRQb3N0VGFnXCI6IFwiPC9lbT5cIiwgXCJzbmlwcGV0RWxsaXBzaXNUZXh0XCI6IFwiXFx1MjAyNlwiLCBcInJlc3RyaWN0SGlnaGxpZ2h0QW5kU25pcHBldEFycmF5c1wiOiBmYWxzZSwgXCJoaXRzUGVyUGFnZVwiOiAyMCwgXCJtaW5Xb3JkU2l6ZWZvcjFUeXBvXCI6IDQsIFwibWluV29yZFNpemVmb3IyVHlwb3NcIjogOCwgXCJhbGxvd1R5cG9zT25OdW1lcmljVG9rZW5zXCI6IHRydWUsIFwia2VlcERpYWNyaXRpY3NPbkNoYXJhY3RlcnNcIjogXCJcIiwgXCJkZWNvbXBvdW5kUXVlcnlcIjogdHJ1ZSwgXCJlbmFibGVSdWxlc1wiOiB0cnVlLCBcImVuYWJsZVBlcnNvbmFsaXphdGlvblwiOiBmYWxzZSwgXCJhZHZhbmNlZFN5bnRheFwiOiBmYWxzZSwgXCJyZXBsYWNlU3lub255bXNJbkhpZ2hsaWdodFwiOiBmYWxzZSwgXCJtaW5Qcm94aW1pdHlcIjogMSwgXCJtYXhGYWNldEhpdHNcIjogMTAsIFwibWF4VmFsdWVzUGVyRmFjZXRcIjogMTAwLCBcInNvcnRGYWNldFZhbHVlc0J5XCI6IFwiY291bnRcIiwgXCJhdHRyaWJ1dGVDcml0ZXJpYUNvbXB1dGVkQnlNaW5Qcm94aW1pdHlcIjogZmFsc2UsIFwiZW5hYmxlUmVSYW5raW5nXCI6IHRydWV9IiwgInZhbGlkVW50aWwiOiAiNDIiLCAicmVzdHJpY3RJbmRpY2VzIjogImJheiIsICJyZXN0cmljdFNvdXJjZXMiOiAiZm9vIiwgInVzZXJUb2tlbiI6ICJiYXpiYXJmb28ifQ=="
        )

    def test_generate_secured_api_key_and_validity_0(self):
        """
        is able to check the remaining validity of a key
        """
        _resp = self._client.generate_secured_api_key(
            parent_api_key="foo", restrictions={"valid_until": 0}
        )
        _validity = self._client.get_secured_api_key_remaining_validity(_resp)
        assert abs(_validity) == int(round(time()))

    def test_generate_secured_api_key_and_validity_1(self):
        """
        throws when the validity field is not found
        """
        try:
            _resp = self._client.generate_secured_api_key("foo", {"valid_until": None})
            self._client.get_secured_api_key_remaining_validity(_resp)
            assert False
        except Exception as e:
            assert str(e) == "valid_until not found in api key."

    def test_generate_secured_api_key_and_validity_2(self):
        """
        throws when the invalid key
        """
        try:
            self._client.get_secured_api_key_remaining_validity("foo")
            assert False
        except Exception as e:
            assert str(e) == "Incorrect padding"

    async def test_replace_all_objects_0(self):
        """
        executes with minimal parameters
        """
        self._client.batch = AsyncMock(
            return_value=BatchResponse(task_id=42, object_ids=["foo", "bar"])
        )
        self._client.operation_index = AsyncMock(
            return_value=UpdatedAtResponse(task_id=21, updated_at="foobar")
        )
        self._client.get_task = AsyncMock(
            return_value=GetTaskResponse(status="published")
        )
        _resp = await self._client.replace_all_objects(
            index_name="foo", objects=[{"name": "John Doe"}]
        )
        self._client.operation_index.assert_called()
        self._client.batch.assert_called()
        self._client.operation_index.assert_called()
        assert _resp == {
            "batch_responses": [BatchResponse(task_id=42, object_ids=["foo", "bar"])],
            "copy_operation_response": UpdatedAtResponse(
                task_id=21, updated_at="foobar"
            ),
            "move_operation_response": UpdatedAtResponse(
                task_id=21, updated_at="foobar"
            ),
        }

    async def test_replace_all_objects_1(self):
        """
        does many calls when len(objects) > batchSize
        """
        self._client.batch = AsyncMock(
            return_value=BatchResponse(task_id=42, object_ids=["foo", "bar"])
        )
        self._client.operation_index = AsyncMock(
            return_value=UpdatedAtResponse(task_id=21, updated_at="foobar")
        )
        self._client.get_task = AsyncMock(
            return_value=GetTaskResponse(status="published")
        )
        _resp = await self._client.replace_all_objects(
            index_name="foo",
            objects=[
                {
                    "name": f"John Doe{i}",
                    "objectID": f"fff2bd4d-bb17-4e21-a0c4-0a8ea5e363f2{i}",
                }
                for i in range(33)
            ],
            batch_size=10,
        )
        self._client.operation_index.assert_called()
        self._client.batch.assert_called()
        self._client.operation_index.assert_called()
        assert _resp == {
            "batch_responses": [
                BatchResponse(task_id=42, object_ids=["foo", "bar"]),
                BatchResponse(task_id=42, object_ids=["foo", "bar"]),
                BatchResponse(task_id=42, object_ids=["foo", "bar"]),
                BatchResponse(task_id=42, object_ids=["foo", "bar"]),
            ],
            "copy_operation_response": UpdatedAtResponse(
                task_id=21, updated_at="foobar"
            ),
            "move_operation_response": UpdatedAtResponse(
                task_id=21, updated_at="foobar"
            ),
        }

    async def test_replace_all_objects_2(self):
        """
        batchSize is 1000 by default
        """
        self._client.batch = AsyncMock(
            return_value=BatchResponse(task_id=42, object_ids=["foo", "bar"])
        )
        self._client.operation_index = AsyncMock(
            return_value=UpdatedAtResponse(task_id=21, updated_at="foobar")
        )
        self._client.get_task = AsyncMock(
            return_value=GetTaskResponse(status="published")
        )
        _resp = await self._client.replace_all_objects(
            index_name="foo",
            objects=[
                {
                    "name": f"John Doe{i}",
                    "objectID": f"fff2bd4d-bb17-4e21-a0c4-0a8ea5e363f2{i}",
                }
                for i in range(1001)
            ],
        )
        self._client.operation_index.assert_called()
        self._client.batch.assert_called()
        self._client.operation_index.assert_called()
        assert _resp == {
            "batch_responses": [
                BatchResponse(task_id=42, object_ids=["foo", "bar"]),
                BatchResponse(task_id=42, object_ids=["foo", "bar"]),
            ],
            "copy_operation_response": UpdatedAtResponse(
                task_id=21, updated_at="foobar"
            ),
            "move_operation_response": UpdatedAtResponse(
                task_id=21, updated_at="foobar"
            ),
        }
