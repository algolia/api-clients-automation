// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package algoliasearch.requests

import algoliasearch.EchoInterceptor
import algoliasearch.api.SearchClient
import algoliasearch.config.*
import algoliasearch.search.*
import org.json4s.*
import org.json4s.native.JsonParser.*
import org.scalatest.funsuite.AnyFunSuite

import java.util.concurrent.TimeUnit
import scala.concurrent.duration.Duration
import scala.concurrent.{Await, ExecutionContextExecutor}

class SearchTest extends AnyFunSuite {
  implicit val ec: ExecutionContextExecutor = scala.concurrent.ExecutionContext.global
  implicit val formats: Formats = JsonSupport.format

  def testClient(): (SearchClient, EchoInterceptor) = {
    val echo = EchoInterceptor()
    (
      SearchClient(
        appId = "appId",
        apiKey = "apiKey",
        clientOptions = ClientOptions
          .builder()
          .withRequesterConfig(requester => requester.withInterceptor(echo))
          .build()
      ),
      echo
    )
  }

  test("minimal") {
    val (client, echo) = testClient()
    val future = client.addApiKey(
      apiKey = ApiKey(
        acl = Seq(Acl.withName("search"), Acl.withName("addObject")),
        description = Some("my new api key")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/keys")
    assert(res.method == "POST")
    val expectedBody = parse("""{"acl":["search","addObject"],"description":"my new api key"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("all1") {
    val (client, echo) = testClient()
    val future = client.addApiKey(
      apiKey = ApiKey(
        acl = Seq(Acl.withName("search"), Acl.withName("addObject")),
        description = Some("my new api key"),
        validity = Some(300),
        maxQueriesPerIPPerHour = Some(100),
        maxHitsPerQuery = Some(20)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/keys")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"acl":["search","addObject"],"description":"my new api key","validity":300,"maxQueriesPerIPPerHour":100,"maxHitsPerQuery":20}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("addOrUpdateObject") {
    val (client, echo) = testClient()
    val future = client.addOrUpdateObject(
      indexName = "indexName",
      objectID = "uniqueID",
      body = JObject(List(JField("key", JString("value"))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/uniqueID")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"key":"value"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("appendSource") {
    val (client, echo) = testClient()
    val future = client.appendSource(
      source = Source(
        source = "theSource",
        description = Some("theDescription")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/security/sources/append")
    assert(res.method == "POST")
    val expectedBody = parse("""{"source":"theSource","description":"theDescription"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("simple") {
    val (client, echo) = testClient()
    val future = client.assignUserId(
      xAlgoliaUserID = "user42",
      assignUserIdParams = AssignUserIdParams(
        cluster = "d4242-eu"
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping")
    assert(res.method == "POST")
    val expectedBody = parse("""{"cluster":"d4242-eu"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedHeaders = parse("""{"x-algolia-user-id":"user42"}""").asInstanceOf[JObject].obj.toMap
    val actualHeaders = res.headers
    for ((k, v) <- expectedHeaders) {
      assert(actualHeaders.contains(k))
      assert(actualHeaders(k) == v.asInstanceOf[JString].s)
    }
  }

  test("it should not encode the userID1") {
    val (client, echo) = testClient()
    val future = client.assignUserId(
      xAlgoliaUserID = "user id with spaces",
      assignUserIdParams = AssignUserIdParams(
        cluster = "cluster with spaces"
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping")
    assert(res.method == "POST")
    val expectedBody = parse("""{"cluster":"cluster with spaces"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedHeaders = parse("""{"x-algolia-user-id":"user id with spaces"}""").asInstanceOf[JObject].obj.toMap
    val actualHeaders = res.headers
    for ((k, v) <- expectedHeaders) {
      assert(actualHeaders.contains(k))
      assert(actualHeaders(k) == v.asInstanceOf[JString].s)
    }
  }

  test("addObject") {
    val (client, echo) = testClient()
    val future = client.batch(
      indexName = "<YOUR_INDEX_NAME>",
      batchWriteParams = BatchWriteParams(
        requests = Seq(
          BatchRequest(
            action = Action.withName("addObject"),
            body = JObject(List(JField("key", JString("bar")), JField("foo", JString("1"))))
          ),
          BatchRequest(
            action = Action.withName("addObject"),
            body = JObject(List(JField("key", JString("baz")), JField("foo", JString("2"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"action":"addObject","body":{"key":"bar","foo":"1"}},{"action":"addObject","body":{"key":"baz","foo":"2"}}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("clear1") {
    val (client, echo) = testClient()
    val future = client.batch(
      indexName = "<YOUR_INDEX_NAME>",
      batchWriteParams = BatchWriteParams(
        requests = Seq(
          BatchRequest(
            action = Action.withName("clear"),
            body = JObject(List(JField("key", JString("value"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch")
    assert(res.method == "POST")
    val expectedBody = parse("""{"requests":[{"action":"clear","body":{"key":"value"}}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("delete2") {
    val (client, echo) = testClient()
    val future = client.batch(
      indexName = "<YOUR_INDEX_NAME>",
      batchWriteParams = BatchWriteParams(
        requests = Seq(
          BatchRequest(
            action = Action.withName("delete"),
            body = JObject(List(JField("key", JString("value"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch")
    assert(res.method == "POST")
    val expectedBody = parse("""{"requests":[{"action":"delete","body":{"key":"value"}}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("deleteObject3") {
    val (client, echo) = testClient()
    val future = client.batch(
      indexName = "<YOUR_INDEX_NAME>",
      batchWriteParams = BatchWriteParams(
        requests = Seq(
          BatchRequest(
            action = Action.withName("deleteObject"),
            body = JObject(List(JField("key", JString("value"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch")
    assert(res.method == "POST")
    val expectedBody = parse("""{"requests":[{"action":"deleteObject","body":{"key":"value"}}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("partialUpdateObject4") {
    val (client, echo) = testClient()
    val future = client.batch(
      indexName = "<YOUR_INDEX_NAME>",
      batchWriteParams = BatchWriteParams(
        requests = Seq(
          BatchRequest(
            action = Action.withName("partialUpdateObject"),
            body = JObject(List(JField("key", JString("value"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch")
    assert(res.method == "POST")
    val expectedBody = parse("""{"requests":[{"action":"partialUpdateObject","body":{"key":"value"}}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("partialUpdateObjectNoCreate5") {
    val (client, echo) = testClient()
    val future = client.batch(
      indexName = "<YOUR_INDEX_NAME>",
      batchWriteParams = BatchWriteParams(
        requests = Seq(
          BatchRequest(
            action = Action.withName("partialUpdateObjectNoCreate"),
            body = JObject(List(JField("key", JString("value"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch")
    assert(res.method == "POST")
    val expectedBody = parse("""{"requests":[{"action":"partialUpdateObjectNoCreate","body":{"key":"value"}}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("updateObject6") {
    val (client, echo) = testClient()
    val future = client.batch(
      indexName = "<YOUR_INDEX_NAME>",
      batchWriteParams = BatchWriteParams(
        requests = Seq(
          BatchRequest(
            action = Action.withName("updateObject"),
            body = JObject(List(JField("key", JString("value"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch")
    assert(res.method == "POST")
    val expectedBody = parse("""{"requests":[{"action":"updateObject","body":{"key":"value"}}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("batchAssignUserIds") {
    val (client, echo) = testClient()
    val future = client.batchAssignUserIds(
      xAlgoliaUserID = "userID",
      batchAssignUserIdsParams = BatchAssignUserIdsParams(
        cluster = "theCluster",
        users = Seq("user1", "user2")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping/batch")
    assert(res.method == "POST")
    val expectedBody = parse("""{"cluster":"theCluster","users":["user1","user2"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedHeaders = parse("""{"x-algolia-user-id":"userID"}""").asInstanceOf[JObject].obj.toMap
    val actualHeaders = res.headers
    for ((k, v) <- expectedHeaders) {
      assert(actualHeaders.contains(k))
      assert(actualHeaders(k) == v.asInstanceOf[JString].s)
    }
  }

  test("replace") {
    val (client, echo) = testClient()
    val future = client.batchDictionaryEntries(
      dictionaryName = DictionaryType.withName("plurals"),
      batchDictionaryEntriesParams = BatchDictionaryEntriesParams(
        clearExistingDictionaryEntries = Some(true),
        requests = Seq(
          BatchDictionaryEntriesRequest(
            action = DictionaryAction.withName("addEntry"),
            body = DictionaryEntry(
              objectID = "1",
              language = Some(SupportedLanguage.withName("en")),
              word = Some("fancy"),
              words = Some(Seq("believe", "algolia")),
              decomposition = Some(Seq("trust", "algolia")),
              state = Some(DictionaryEntryState.withName("enabled"))
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/plurals/batch")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"clearExistingDictionaryEntries":true,"requests":[{"action":"addEntry","body":{"objectID":"1","language":"en","word":"fancy","words":["believe","algolia"],"decomposition":["trust","algolia"],"state":"enabled"}}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("delete1") {
    val (client, echo) = testClient()
    val future = client.batchDictionaryEntries(
      dictionaryName = DictionaryType.withName("plurals"),
      batchDictionaryEntriesParams = BatchDictionaryEntriesParams(
        clearExistingDictionaryEntries = Some(true),
        requests = Seq(
          BatchDictionaryEntriesRequest(
            action = DictionaryAction.withName("deleteEntry"),
            body = DictionaryEntry(
              objectID = "1"
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/plurals/batch")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"clearExistingDictionaryEntries":true,"requests":[{"action":"deleteEntry","body":{"objectID":"1"}}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("append2") {
    val (client, echo) = testClient()
    val future = client.batchDictionaryEntries(
      dictionaryName = DictionaryType.withName("stopwords"),
      batchDictionaryEntriesParams = BatchDictionaryEntriesParams(
        requests = Seq(
          BatchDictionaryEntriesRequest(
            action = DictionaryAction.withName("addEntry"),
            body = DictionaryEntry(
              objectID = "1",
              language = Some(SupportedLanguage.withName("en")),
              additionalProperties = Some(List(JField("additional", JString("try me"))))
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/stopwords/batch")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"requests":[{"action":"addEntry","body":{"objectID":"1","language":"en","additional":"try me"}}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("browse with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.browse(
      indexName = "cts_e2e_browse"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/cts_e2e_browse/browse")
    assert(res.method == "POST")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("browse with search parameters1") {
    val (client, echo) = testClient()
    val future = client.browse(
      indexName = "indexName",
      browseParams = Some(
        BrowseParamsObject(
          query = Some("myQuery"),
          facetFilters = Some(FacetFilters(Seq(FacetFilters("tags:algolia"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/browse")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"myQuery","facetFilters":["tags:algolia"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("browse allow a cursor in parameters2") {
    val (client, echo) = testClient()
    val future = client.browse(
      indexName = "indexName",
      browseParams = Some(
        BrowseParamsObject(
          cursor = Some("test")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/browse")
    assert(res.method == "POST")
    val expectedBody = parse("""{"cursor":"test"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("browse with query string3") {
    val (client, echo) = testClient()
    val future = client.browse(
      indexName = "indexName",
      browseParams = Some(
        SearchParamsString(
          params = Some("foo=bar&cursor=test")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/browse")
    assert(res.method == "POST")
    val expectedBody = parse("""{"params":"foo=bar&cursor=test"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("clearObjects") {
    val (client, echo) = testClient()
    val future = client.clearObjects(
      indexName = "theIndexName"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/clear")
    assert(res.method == "POST")
    assert(res.body.contains("{}"))
  }

  test("clearRules") {
    val (client, echo) = testClient()
    val future = client.clearRules(
      indexName = "indexName"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/clear")
    assert(res.method == "POST")
    assert(res.body.contains("{}"))
  }

  test("clearSynonyms") {
    val (client, echo) = testClient()
    val future = client.clearSynonyms(
      indexName = "indexName"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/synonyms/clear")
    assert(res.method == "POST")
    assert(res.body.contains("{}"))
  }

  test("allow del method for a custom path with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.customDelete[JObject](
      path = "test/minimal"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/minimal")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("allow del method for a custom path with all parameters1") {
    val (client, echo) = testClient()
    val future = client.customDelete[JObject](
      path = "test/all",
      parameters = Some(Map("query" -> "parameters"))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/all")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"query":"parameters"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("allow get method for a custom path with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.customGet[JObject](
      path = "test/minimal"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/minimal")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("allow get method for a custom path with all parameters1") {
    val (client, echo) = testClient()
    val future = client.customGet[JObject](
      path = "test/all",
      parameters = Some(Map("query" -> "parameters with space"))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/all")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"query":"parameters%20with%20space"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions should be escaped too2") {
    val (client, echo) = testClient()
    val future = client.customGet[JObject](
      path = "test/all",
      parameters = Some(Map("query" -> "to be overridden")),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("query", "parameters with space")
          .withQueryParameter("and an array", Seq("array", "with spaces"))
          .withHeader("x-header-1", "spaces are left alone")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/all")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"query":"parameters%20with%20space","and%20an%20array":"array%2Cwith%20spaces"}""")
      .asInstanceOf[JObject]
      .obj
      .toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
    val expectedHeaders = parse("""{"x-header-1":"spaces are left alone"}""").asInstanceOf[JObject].obj.toMap
    val actualHeaders = res.headers
    for ((k, v) <- expectedHeaders) {
      assert(actualHeaders.contains(k))
      assert(actualHeaders(k) == v.asInstanceOf[JString].s)
    }
  }

  test("allow post method for a custom path with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/minimal"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/minimal")
    assert(res.method == "POST")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("allow post method for a custom path with all parameters1") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/all",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("body", JString("parameters")))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/all")
    assert(res.method == "POST")
    val expectedBody = parse("""{"body":"parameters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions can override default query parameters2") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("query", "myQueryParameter")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"myQueryParameter"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions merges query parameters with default ones3") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("query2", "myQueryParameter")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters","query2":"myQueryParameter"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions can override default headers4") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withHeader("x-algolia-api-key", "ALGOLIA_API_KEY")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
    val expectedHeaders = parse("""{"x-algolia-api-key":"ALGOLIA_API_KEY"}""").asInstanceOf[JObject].obj.toMap
    val actualHeaders = res.headers
    for ((k, v) <- expectedHeaders) {
      assert(actualHeaders.contains(k))
      assert(actualHeaders(k) == v.asInstanceOf[JString].s)
    }
  }

  test("requestOptions merges headers with default ones5") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withHeader("x-algolia-api-key", "ALGOLIA_API_KEY")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
    val expectedHeaders = parse("""{"x-algolia-api-key":"ALGOLIA_API_KEY"}""").asInstanceOf[JObject].obj.toMap
    val actualHeaders = res.headers
    for ((k, v) <- expectedHeaders) {
      assert(actualHeaders.contains(k))
      assert(actualHeaders(k) == v.asInstanceOf[JString].s)
    }
  }

  test("requestOptions queryParameters accepts booleans6") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("isItWorking", true)
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters","isItWorking":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions queryParameters accepts integers7") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("myParam", 2)
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters","myParam":"2"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions queryParameters accepts list of string8") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("myParam", Seq("b and c", "d"))
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters","myParam":"b%20and%20c%2Cd"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions queryParameters accepts list of booleans9") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("myParam", Seq(true, true, false))
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery =
      parse("""{"query":"parameters","myParam":"true%2Ctrue%2Cfalse"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions queryParameters accepts list of integers10") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("myParam", Seq(1, 2))
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters","myParam":"1%2C2"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("allow put method for a custom path with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.customPut[JObject](
      path = "test/minimal"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/minimal")
    assert(res.method == "PUT")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("allow put method for a custom path with all parameters1") {
    val (client, echo) = testClient()
    val future = client.customPut[JObject](
      path = "test/all",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("body", JString("parameters")))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/all")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"body":"parameters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("deleteApiKey") {
    val (client, echo) = testClient()
    val future = client.deleteApiKey(
      key = "myTestApiKey"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/keys/myTestApiKey")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("deleteBy") {
    val (client, echo) = testClient()
    val future = client.deleteBy(
      indexName = "theIndexName",
      deleteByParams = DeleteByParams(
        filters = Some("brand:brandName")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/deleteByQuery")
    assert(res.method == "POST")
    val expectedBody = parse("""{"filters":"brand:brandName"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("deleteIndex") {
    val (client, echo) = testClient()
    val future = client.deleteIndex(
      indexName = "theIndexName"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("deleteObject") {
    val (client, echo) = testClient()
    val future = client.deleteObject(
      indexName = "<YOUR_INDEX_NAME>",
      objectID = "uniqueID"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/uniqueID")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("delete rule simple case") {
    val (client, echo) = testClient()
    val future = client.deleteRule(
      indexName = "indexName",
      objectID = "id1"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/id1")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("delete rule with simple characters to encode in objectID1") {
    val (client, echo) = testClient()
    val future = client.deleteRule(
      indexName = "indexName",
      objectID = "test/with/slash"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/test%2Fwith%2Fslash")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("deleteSource") {
    val (client, echo) = testClient()
    val future = client.deleteSource(
      source = "theSource"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/security/sources/theSource")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("deleteSynonym") {
    val (client, echo) = testClient()
    val future = client.deleteSynonym(
      indexName = "indexName",
      objectID = "id1"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/synonyms/id1")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("getApiKey") {
    val (client, echo) = testClient()
    val future = client.getApiKey(
      key = "myTestApiKey"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/keys/myTestApiKey")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getAppTask") {
    val (client, echo) = testClient()
    val future = client.getAppTask(
      taskID = 123L
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/task/123")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("get getDictionaryLanguages") {
    val (client, echo) = testClient()
    val future = client.getDictionaryLanguages(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/*/languages")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("get getDictionarySettings results") {
    val (client, echo) = testClient()
    val future = client.getDictionarySettings(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/*/settings")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getLogs with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.getLogs(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/logs")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getLogs with parameters1") {
    val (client, echo) = testClient()
    val future = client.getLogs(
      offset = Some(5),
      length = Some(10),
      indexName = Some("theIndexName"),
      `type` = Some(LogType.withName("all"))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/logs")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery =
      parse("""{"offset":"5","length":"10","indexName":"theIndexName","type":"all"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("getObject") {
    val (client, echo) = testClient()
    val future = client.getObject(
      indexName = "theIndexName",
      objectID = "uniqueID",
      attributesToRetrieve = Some(Seq("attr1", "attr2"))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/uniqueID")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"attributesToRetrieve":"attr1%2Cattr2"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("search with a real object1") {
    val (client, echo) = testClient()
    val future = client.getObject(
      indexName = "cts_e2e_browse",
      objectID = "Batman and Robin"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/cts_e2e_browse/Batman%20and%20Robin")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("by ID") {
    val (client, echo) = testClient()
    val future = client.getObjects(
      getObjectsParams = GetObjectsParams(
        requests = Seq(
          GetObjectsRequest(
            objectID = "uniqueID",
            indexName = "theIndexName"
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/objects")
    assert(res.method == "POST")
    val expectedBody = parse("""{"requests":[{"objectID":"uniqueID","indexName":"theIndexName"}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("multiple IDs1") {
    val (client, echo) = testClient()
    val future = client.getObjects(
      getObjectsParams = GetObjectsParams(
        requests = Seq(
          GetObjectsRequest(
            objectID = "uniqueID1",
            indexName = "theIndexName1"
          ),
          GetObjectsRequest(
            objectID = "uniqueID2",
            indexName = "theIndexName2"
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/objects")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"objectID":"uniqueID1","indexName":"theIndexName1"},{"objectID":"uniqueID2","indexName":"theIndexName2"}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("with attributesToRetrieve2") {
    val (client, echo) = testClient()
    val future = client.getObjects(
      getObjectsParams = GetObjectsParams(
        requests = Seq(
          GetObjectsRequest(
            attributesToRetrieve = Some(Seq("attr1", "attr2")),
            objectID = "uniqueID",
            indexName = "theIndexName"
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/objects")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"attributesToRetrieve":["attr1","attr2"],"objectID":"uniqueID","indexName":"theIndexName"}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("getRule") {
    val (client, echo) = testClient()
    val future = client.getRule(
      indexName = "cts_e2e_browse",
      objectID = "qr-1725004648916"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/cts_e2e_browse/rules/qr-1725004648916")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getSettings") {
    val (client, echo) = testClient()
    val future = client.getSettings(
      indexName = "cts_e2e_settings",
      getVersion = Some(2)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/cts_e2e_settings/settings")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"getVersion":"2"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("getSources") {
    val (client, echo) = testClient()
    val future = client.getSources(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/security/sources")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getSynonym") {
    val (client, echo) = testClient()
    val future = client.getSynonym(
      indexName = "indexName",
      objectID = "id1"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/synonyms/id1")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getTask") {
    val (client, echo) = testClient()
    val future = client.getTask(
      indexName = "theIndexName",
      taskID = 123L
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/task/123")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getTopUserIds") {
    val (client, echo) = testClient()
    val future = client.getTopUserIds(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping/top")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getUserId") {
    val (client, echo) = testClient()
    val future = client.getUserId(
      userID = "uniqueID"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping/uniqueID")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("hasPendingMappings with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.hasPendingMappings(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping/pending")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("hasPendingMappings with parameters1") {
    val (client, echo) = testClient()
    val future = client.hasPendingMappings(
      getClusters = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping/pending")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"getClusters":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("listApiKeys") {
    val (client, echo) = testClient()
    val future = client.listApiKeys(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/keys")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("listClusters") {
    val (client, echo) = testClient()
    val future = client.listClusters(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("listIndices with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.listIndices(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("listIndices with parameters1") {
    val (client, echo) = testClient()
    val future = client.listIndices(
      page = Some(8),
      hitsPerPage = Some(3)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"page":"8","hitsPerPage":"3"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("listUserIds with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.listUserIds(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("listUserIds with parameters1") {
    val (client, echo) = testClient()
    val future = client.listUserIds(
      page = Some(8),
      hitsPerPage = Some(100)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"page":"8","hitsPerPage":"100"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("multipleBatch") {
    val (client, echo) = testClient()
    val future = client.multipleBatch(
      batchParams = BatchParams(
        requests = Seq(
          MultipleBatchRequest(
            action = Action.withName("addObject"),
            body = Some(JObject(List(JField("key", JString("value"))))),
            indexName = "theIndexName"
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/batch")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"requests":[{"action":"addObject","body":{"key":"value"},"indexName":"theIndexName"}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("scopes") {
    val (client, echo) = testClient()
    val future = client.operationIndex(
      indexName = "<SOURCE_INDEX_NAME>",
      operationIndexParams = OperationIndexParams(
        operation = OperationType.withName("move"),
        destination = "<DESTINATION_INDEX_NAME>",
        scope = Some(Seq(ScopeType.withName("rules"), ScopeType.withName("settings")))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"operation":"move","destination":"<DESTINATION_INDEX_NAME>","scope":["rules","settings"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("copy1") {
    val (client, echo) = testClient()
    val future = client.operationIndex(
      indexName = "<SOURCE_INDEX_NAME>",
      operationIndexParams = OperationIndexParams(
        operation = OperationType.withName("copy"),
        destination = "<DESTINATION_INDEX_NAME>"
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation")
    assert(res.method == "POST")
    val expectedBody = parse("""{"operation":"copy","destination":"<DESTINATION_INDEX_NAME>"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("move2") {
    val (client, echo) = testClient()
    val future = client.operationIndex(
      indexName = "<SOURCE_INDEX_NAME>",
      operationIndexParams = OperationIndexParams(
        operation = OperationType.withName("move"),
        destination = "<DESTINATION_INDEX_NAME>"
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation")
    assert(res.method == "POST")
    val expectedBody = parse("""{"operation":"move","destination":"<DESTINATION_INDEX_NAME>"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("Partial update with a new value for a string attribute") {
    val (client, echo) = testClient()
    val future = client.partialUpdateObject(
      indexName = "theIndexName",
      objectID = "uniqueID",
      attributesToUpdate = JObject(List(JField("attributeId", JString("new value"))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/uniqueID/partial")
    assert(res.method == "POST")
    val expectedBody = parse("""{"attributeId":"new value"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("Partial update with a new value for an integer attribute1") {
    val (client, echo) = testClient()
    val future = client.partialUpdateObject(
      indexName = "theIndexName",
      objectID = "uniqueID",
      attributesToUpdate = JObject(List(JField("attributeId", JInt(1))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/uniqueID/partial")
    assert(res.method == "POST")
    val expectedBody = parse("""{"attributeId":1}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("Partial update with a new value for a boolean attribute2") {
    val (client, echo) = testClient()
    val future = client.partialUpdateObject(
      indexName = "theIndexName",
      objectID = "uniqueID",
      attributesToUpdate = JObject(List(JField("attributeId", JBool(true))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/uniqueID/partial")
    assert(res.method == "POST")
    val expectedBody = parse("""{"attributeId":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("Partial update with a new value for an array attribute3") {
    val (client, echo) = testClient()
    val future = client.partialUpdateObject(
      indexName = "theIndexName",
      objectID = "uniqueID",
      attributesToUpdate =
        JObject(List(JField("attributeId", JArray(List(JString("one"), JString("two"), JString("three"))))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/uniqueID/partial")
    assert(res.method == "POST")
    val expectedBody = parse("""{"attributeId":["one","two","three"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("Partial update with a new value for an object attribute4") {
    val (client, echo) = testClient()
    val future = client.partialUpdateObject(
      indexName = "theIndexName",
      objectID = "uniqueID",
      attributesToUpdate = JObject(List(JField("attributeId", JObject(List(JField("nested", JString("value")))))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/uniqueID/partial")
    assert(res.method == "POST")
    val expectedBody = parse("""{"attributeId":{"nested":"value"}}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("with visible_by filter5") {
    val (client, echo) = testClient()
    val future = client.partialUpdateObject(
      indexName = "theIndexName",
      objectID = "uniqueID",
      attributesToUpdate = JObject(
        List(
          JField("visible_by", JArray(List(JString("Angela"), JString("group/Finance"), JString("group/Shareholders"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/uniqueID/partial")
    assert(res.method == "POST")
    val expectedBody = parse("""{"visible_by":["Angela","group/Finance","group/Shareholders"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("add men pant6") {
    val (client, echo) = testClient()
    val future = client.partialUpdateObject(
      indexName = "theIndexName",
      objectID = "productId",
      attributesToUpdate = JObject(
        List(
          JField(
            "categoryPageId",
            JObject(List(JField("_operation", JString("Add")), JField("value", JString("men-clothing-pants"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/productId/partial")
    assert(res.method == "POST")
    val expectedBody = parse("""{"categoryPageId":{"_operation":"Add","value":"men-clothing-pants"}}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("remove men pant7") {
    val (client, echo) = testClient()
    val future = client.partialUpdateObject(
      indexName = "theIndexName",
      objectID = "productId",
      attributesToUpdate = JObject(
        List(
          JField(
            "categoryPageId",
            JObject(List(JField("_operation", JString("Remove")), JField("value", JString("men-clothing-pants"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/productId/partial")
    assert(res.method == "POST")
    val expectedBody = parse("""{"categoryPageId":{"_operation":"Remove","value":"men-clothing-pants"}}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("removeUserId") {
    val (client, echo) = testClient()
    val future = client.removeUserId(
      userID = "uniqueID"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping/uniqueID")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("replaceSources") {
    val (client, echo) = testClient()
    val future = client.replaceSources(
      source = Seq(
        Source(
          source = "theSource",
          description = Some("theDescription")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/security/sources")
    assert(res.method == "PUT")
    val expectedBody = parse("""[{"source":"theSource","description":"theDescription"}]""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("restoreApiKey") {
    val (client, echo) = testClient()
    val future = client.restoreApiKey(
      key = "ALGOLIA_API_KEY"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/keys/ALGOLIA_API_KEY/restore")
    assert(res.method == "POST")
    assert(res.body.contains("{}"))
  }

  test("saveObject") {
    val (client, echo) = testClient()
    val future = client.saveObject(
      indexName = "<YOUR_INDEX_NAME>",
      body = JObject(
        List(
          JField("name", JString("Black T-shirt")),
          JField("color", JString("#000000||black")),
          JField("availableIn", JString("https://source.unsplash.com/100x100/?paris||Paris")),
          JField("objectID", JString("myID"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"name":"Black T-shirt","color":"#000000||black","availableIn":"https://source.unsplash.com/100x100/?paris||Paris","objectID":"myID"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("saveRule with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "id1",
      rule = Rule(
        objectID = "id1",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("apple"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              filters = Some("brand:xiaomi")
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/id1")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains"}],"consequence":{"params":{"filters":"brand:xiaomi"}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("saveRule with all parameters1") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "id1",
      rule = Rule(
        objectID = "id1",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("apple"),
              anchoring = Some(Anchoring.withName("contains")),
              alternatives = Some(false),
              context = Some("search")
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              filters = Some("brand:apple"),
              query = Some(
                ConsequenceQueryObject(
                  remove = Some(Seq("algolia")),
                  edits = Some(
                    Seq(
                      Edit(
                        `type` = Some(EditType.withName("remove")),
                        delete = Some("abc"),
                        insert = Some("cde")
                      ),
                      Edit(
                        `type` = Some(EditType.withName("replace")),
                        delete = Some("abc"),
                        insert = Some("cde")
                      )
                    )
                  )
                )
              )
            )
          ),
          hide = Some(
            Seq(
              ConsequenceHide(
                objectID = "321"
              )
            )
          ),
          filterPromotes = Some(false),
          userData = Some(JObject(List(JField("algolia", JString("aloglia"))))),
          promote = Some(
            Seq(
              PromoteObjectID(
                objectID = "abc",
                position = 3
              ),
              PromoteObjectIDs(
                objectIDs = Seq("abc", "def"),
                position = 1
              )
            )
          )
        ),
        description = Some("test"),
        enabled = Some(true),
        validity = Some(
          Seq(
            TimeRange(
              from = Some(1656670273L),
              until = Some(1656670277L)
            )
          )
        )
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/id1")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains","alternatives":false,"context":"search"}],"consequence":{"params":{"filters":"brand:apple","query":{"remove":["algolia"],"edits":[{"type":"remove","delete":"abc","insert":"cde"},{"type":"replace","delete":"abc","insert":"cde"}]}},"hide":[{"objectID":"321"}],"filterPromotes":false,"userData":{"algolia":"aloglia"},"promote":[{"objectID":"abc","position":3},{"objectIDs":["abc","def"],"position":1}]},"description":"test","enabled":true,"validity":[{"from":1656670273,"until":1656670277}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("b2b catalog2") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "article-rule",
      rule = Rule(
        objectID = "article-rule",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("article"),
              anchoring = Some(Anchoring.withName("startsWith"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              query = Some(
                ConsequenceQueryObject(
                  edits = Some(
                    Seq(
                      Edit(
                        `type` = Some(EditType.withName("remove")),
                        delete = Some("article")
                      )
                    )
                  )
                )
              ),
              restrictSearchableAttributes = Some(Seq("title", "book_id"))
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/article-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"article-rule","conditions":[{"pattern":"article","anchoring":"startsWith"}],"consequence":{"params":{"query":{"edits":[{"type":"remove","delete":"article"}]},"restrictSearchableAttributes":["title","book_id"]}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("merchandising and promoting3") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "director-rule",
      rule = Rule(
        objectID = "director-rule",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("{facet:director} director"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              restrictSearchableAttributes = Some(Seq("title", "book_id")),
              automaticFacetFilters = Some(
                AutomaticFacetFilters(
                  Seq(
                    AutomaticFacetFilter(
                      facet = "director"
                    )
                  )
                )
              ),
              query = Some(
                ConsequenceQueryObject(
                  edits = Some(
                    Seq(
                      Edit(
                        `type` = Some(EditType.withName("remove")),
                        delete = Some("director")
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/director-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"director-rule","conditions":[{"pattern":"{facet:director} director","anchoring":"contains"}],"consequence":{"params":{"restrictSearchableAttributes":["title","book_id"],"automaticFacetFilters":[{"facet":"director"}],"query":{"edits":[{"type":"remove","delete":"director"}]}}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("harry potter4") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "harry-potter-rule",
      rule = Rule(
        objectID = "harry-potter-rule",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("harry potter"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          userData = Some(JObject(List(JField("promo_content", JString("20% OFF on all Harry Potter books!")))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/harry-potter-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"harry-potter-rule","conditions":[{"pattern":"harry potter","anchoring":"contains"}],"consequence":{"userData":{"promo_content":"20% OFF on all Harry Potter books!"}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("merchandising empty query5") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "clearance-category-filter",
      rule = Rule(
        objectID = "clearance-category-filter",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some(""),
              anchoring = Some(Anchoring.withName("is")),
              context = Some("landing")
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              optionalFilters = Some(OptionalFilters("clearance:true"))
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/clearance-category-filter")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"clearance-category-filter","conditions":[{"pattern":"","anchoring":"is","context":"landing"}],"consequence":{"params":{"optionalFilters":"clearance:true"}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("redirect6") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "redirect-help-rule",
      rule = Rule(
        objectID = "redirect-help-rule",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("help"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          userData = Some(JObject(List(JField("redirect", JString("https://www.algolia.com/support")))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/redirect-help-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"redirect-help-rule","conditions":[{"pattern":"help","anchoring":"contains"}],"consequence":{"userData":{"redirect":"https://www.algolia.com/support"}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("promote some results over others7") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "tomato-fruit",
      rule = Rule(
        objectID = "tomato-fruit",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("tomato"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              optionalFilters = Some(OptionalFilters("food_group:fruit"))
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/tomato-fruit")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"tomato-fruit","conditions":[{"pattern":"tomato","anchoring":"contains"}],"consequence":{"params":{"optionalFilters":"food_group:fruit"}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("promote several hits8") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "Promote-Apple-Newest",
      rule = Rule(
        objectID = "Promote-Apple-Newest",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("apple"),
              anchoring = Some(Anchoring.withName("is"))
            )
          )
        ),
        consequence = Consequence(
          promote = Some(
            Seq(
              PromoteObjectIDs(
                objectIDs = Seq("iPhone-12345", "watch-123"),
                position = 0
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/Promote-Apple-Newest")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"Promote-Apple-Newest","conditions":[{"pattern":"apple","anchoring":"is"}],"consequence":{"promote":[{"objectIDs":["iPhone-12345","watch-123"],"position":0}]}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("promote newest release9") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "Promote-iPhone-X",
      rule = Rule(
        objectID = "Promote-iPhone-X",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("iPhone"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          promote = Some(
            Seq(
              PromoteObjectID(
                objectID = "iPhone-12345",
                position = 0
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/Promote-iPhone-X")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"Promote-iPhone-X","conditions":[{"pattern":"iPhone","anchoring":"contains"}],"consequence":{"promote":[{"objectID":"iPhone-12345","position":0}]}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("promote single item10") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "promote-harry-potter-box-set",
      rule = Rule(
        objectID = "promote-harry-potter-box-set",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("Harry Potter"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          promote = Some(
            Seq(
              PromoteObjectID(
                objectID = "HP-12345",
                position = 0
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/promote-harry-potter-box-set")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"promote-harry-potter-box-set","conditions":[{"pattern":"Harry Potter","anchoring":"contains"}],"consequence":{"promote":[{"objectID":"HP-12345","position":0}]}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("limit search results11") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "article-rule",
      rule = Rule(
        objectID = "article-rule",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("article"),
              anchoring = Some(Anchoring.withName("startsWith"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              query = Some(
                ConsequenceQueryObject(
                  edits = Some(
                    Seq(
                      Edit(
                        `type` = Some(EditType.withName("remove")),
                        delete = Some("article")
                      )
                    )
                  )
                )
              ),
              restrictSearchableAttributes = Some(Seq("title", "book_id"))
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/article-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"article-rule","conditions":[{"pattern":"article","anchoring":"startsWith"}],"consequence":{"params":{"query":{"edits":[{"type":"remove","delete":"article"}]},"restrictSearchableAttributes":["title","book_id"]}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("query match12") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "tagged-brand-rule",
      rule = Rule(
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("brand: {facet:brand}"),
              anchoring = Some(Anchoring.withName("contains")),
              alternatives = Some(false)
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              automaticFacetFilters = Some(
                AutomaticFacetFilters(
                  Seq(
                    AutomaticFacetFilter(
                      facet = "brand"
                    )
                  )
                )
              ),
              query = Some(
                ConsequenceQueryObject(
                  remove = Some(Seq("brand:", "{facet:brand}"))
                )
              )
            )
          )
        ),
        description = Some("filter on brand: {brand}"),
        objectID = "tagged-brand-rule"
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/tagged-brand-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"conditions":[{"pattern":"brand: {facet:brand}","anchoring":"contains","alternatives":false}],"consequence":{"params":{"automaticFacetFilters":[{"facet":"brand"}],"query":{"remove":["brand:","{facet:brand}"]}}},"description":"filter on brand: {brand}","objectID":"tagged-brand-rule"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("dynamic filtering13") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "color-facets",
      rule = Rule(
        objectID = "color-facets",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("{facet:color}")
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              automaticFacetFilters = Some(
                AutomaticFacetFilters(
                  Seq(
                    AutomaticFacetFilter(
                      facet = "color"
                    )
                  )
                )
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/color-facets")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"color-facets","conditions":[{"pattern":"{facet:color}"}],"consequence":{"params":{"automaticFacetFilters":[{"facet":"color"}]}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("hide hits14") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "hide-12345",
      rule = Rule(
        objectID = "hide-12345",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("cheap"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          hide = Some(
            Seq(
              ConsequenceHide(
                objectID = "to-hide-12345"
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/hide-12345")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"hide-12345","conditions":[{"pattern":"cheap","anchoring":"contains"}],"consequence":{"hide":[{"objectID":"to-hide-12345"}]}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("one rule per facet15") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "red-color",
      rule = Rule(
        objectID = "red-color",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("red"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              query = Some(
                ConsequenceQueryObject(
                  remove = Some(Seq("red"))
                )
              ),
              filters = Some("color:red")
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/red-color")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"red-color","conditions":[{"pattern":"red","anchoring":"contains"}],"consequence":{"params":{"query":{"remove":["red"]},"filters":"color:red"}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("numerical filters16") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "cheap",
      rule = Rule(
        objectID = "cheap",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("cheap"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              query = Some(
                ConsequenceQueryObject(
                  remove = Some(Seq("cheap"))
                )
              ),
              filters = Some("price < 10")
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/cheap")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"cheap","conditions":[{"pattern":"cheap","anchoring":"contains"}],"consequence":{"params":{"query":{"remove":["cheap"]},"filters":"price < 10"}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("negative filters17") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "gluten-free-rule",
      rule = Rule(
        objectID = "gluten-free-rule",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("gluten-free"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              filters = Some("NOT allergens:gluten"),
              query = Some(
                ConsequenceQueryObject(
                  edits = Some(
                    Seq(
                      Edit(
                        `type` = Some(EditType.withName("remove")),
                        delete = Some("gluten-free")
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/gluten-free-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"gluten-free-rule","conditions":[{"pattern":"gluten-free","anchoring":"contains"}],"consequence":{"params":{"filters":"NOT allergens:gluten","query":{"edits":[{"type":"remove","delete":"gluten-free"}]}}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("positive filters18") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "diet-rule",
      rule = Rule(
        objectID = "diet-rule",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("diet"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              filters = Some("'low-carb' OR 'low-fat'"),
              query = Some(
                ConsequenceQueryObject(
                  edits = Some(
                    Seq(
                      Edit(
                        `type` = Some(EditType.withName("remove")),
                        delete = Some("diet")
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/diet-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"diet-rule","conditions":[{"pattern":"diet","anchoring":"contains"}],"consequence":{"params":{"filters":"'low-carb' OR 'low-fat'","query":{"edits":[{"type":"remove","delete":"diet"}]}}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("conditionless19") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "diet-rule",
      rule = Rule(
        objectID = "diet-rule",
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              filters = Some("'low-carb' OR 'low-fat'"),
              query = Some(
                ConsequenceQueryObject(
                  edits = Some(
                    Seq(
                      Edit(
                        `type` = Some(EditType.withName("remove")),
                        delete = Some("diet")
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/diet-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"diet-rule","consequence":{"params":{"filters":"'low-carb' OR 'low-fat'","query":{"edits":[{"type":"remove","delete":"diet"}]}}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("contextual20") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "a-rule-id",
      rule = Rule(
        objectID = "a-rule-id",
        conditions = Some(
          Seq(
            Condition(
              context = Some("mobile")
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              filters = Some("release_date >= 1577836800")
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/a-rule-id")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"a-rule-id","conditions":[{"context":"mobile"}],"consequence":{"params":{"filters":"release_date >= 1577836800"}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("saveRule always active rule21") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "a-rule-id",
      rule = Rule(
        objectID = "a-rule-id",
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              aroundRadius = Some(AroundRadius(1000))
            )
          )
        ),
        validity = Some(
          Seq(
            TimeRange(
              from = Some(1577836800L),
              until = Some(1577836800L)
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/a-rule-id")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"a-rule-id","consequence":{"params":{"aroundRadius":1000}},"validity":[{"from":1577836800,"until":1577836800}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("one sided validity22") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "a-rule-id",
      rule = Rule(
        objectID = "a-rule-id",
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              aroundRadius = Some(AroundRadius(1000))
            )
          )
        ),
        validity = Some(
          Seq(
            TimeRange(
              from = Some(1577836800L)
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/a-rule-id")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"a-rule-id","consequence":{"params":{"aroundRadius":1000}},"validity":[{"from":1577836800}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("saveRules with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.saveRules(
      indexName = "<YOUR_INDEX_NAME>",
      rules = Seq(
        Rule(
          objectID = "a-rule-id",
          conditions = Some(
            Seq(
              Condition(
                pattern = Some("smartphone"),
                anchoring = Some(Anchoring.withName("contains"))
              )
            )
          ),
          consequence = Consequence(
            params = Some(
              ConsequenceParams(
                filters = Some("brand:apple")
              )
            )
          )
        ),
        Rule(
          objectID = "a-second-rule-id",
          conditions = Some(
            Seq(
              Condition(
                pattern = Some("apple"),
                anchoring = Some(Anchoring.withName("contains"))
              )
            )
          ),
          consequence = Consequence(
            params = Some(
              ConsequenceParams(
                filters = Some("brand:samsung")
              )
            )
          )
        )
      ),
      forwardToReplicas = Some(false),
      clearExistingRules = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch")
    assert(res.method == "POST")
    val expectedBody = parse(
      """[{"objectID":"a-rule-id","conditions":[{"pattern":"smartphone","anchoring":"contains"}],"consequence":{"params":{"filters":"brand:apple"}}},{"objectID":"a-second-rule-id","conditions":[{"pattern":"apple","anchoring":"contains"}],"consequence":{"params":{"filters":"brand:samsung"}}}]"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery =
      parse("""{"forwardToReplicas":"false","clearExistingRules":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("saveRules with all parameters1") {
    val (client, echo) = testClient()
    val future = client.saveRules(
      indexName = "<YOUR_INDEX_NAME>",
      rules = Seq(
        Rule(
          objectID = "id1",
          conditions = Some(
            Seq(
              Condition(
                pattern = Some("apple"),
                anchoring = Some(Anchoring.withName("contains")),
                alternatives = Some(false),
                context = Some("search")
              )
            )
          ),
          consequence = Consequence(
            params = Some(
              ConsequenceParams(
                filters = Some("brand:apple"),
                query = Some(
                  ConsequenceQueryObject(
                    remove = Some(Seq("algolia")),
                    edits = Some(
                      Seq(
                        Edit(
                          `type` = Some(EditType.withName("remove")),
                          delete = Some("abc"),
                          insert = Some("cde")
                        ),
                        Edit(
                          `type` = Some(EditType.withName("replace")),
                          delete = Some("abc"),
                          insert = Some("cde")
                        )
                      )
                    )
                  )
                )
              )
            ),
            hide = Some(
              Seq(
                ConsequenceHide(
                  objectID = "321"
                )
              )
            ),
            filterPromotes = Some(false),
            userData = Some(JObject(List(JField("algolia", JString("aloglia"))))),
            promote = Some(
              Seq(
                PromoteObjectID(
                  objectID = "abc",
                  position = 3
                ),
                PromoteObjectIDs(
                  objectIDs = Seq("abc", "def"),
                  position = 1
                )
              )
            )
          ),
          description = Some("test"),
          enabled = Some(true),
          validity = Some(
            Seq(
              TimeRange(
                from = Some(1656670273L),
                until = Some(1656670277L)
              )
            )
          )
        )
      ),
      forwardToReplicas = Some(true),
      clearExistingRules = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch")
    assert(res.method == "POST")
    val expectedBody = parse(
      """[{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains","alternatives":false,"context":"search"}],"consequence":{"params":{"filters":"brand:apple","query":{"remove":["algolia"],"edits":[{"type":"remove","delete":"abc","insert":"cde"},{"type":"replace","delete":"abc","insert":"cde"}]}},"hide":[{"objectID":"321"}],"filterPromotes":false,"userData":{"algolia":"aloglia"},"promote":[{"objectID":"abc","position":3},{"objectIDs":["abc","def"],"position":1}]},"description":"test","enabled":true,"validity":[{"from":1656670273,"until":1656670277}]}]"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery =
      parse("""{"forwardToReplicas":"true","clearExistingRules":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("dynamic filtering2") {
    val (client, echo) = testClient()
    val future = client.saveRules(
      indexName = "<YOUR_INDEX_NAME>",
      rules = Seq(
        Rule(
          objectID = "toaster",
          conditions = Some(
            Seq(
              Condition(
                pattern = Some("toaster"),
                anchoring = Some(Anchoring.withName("contains"))
              )
            )
          ),
          consequence = Consequence(
            params = Some(
              ConsequenceParams(
                query = Some(
                  ConsequenceQueryObject(
                    remove = Some(Seq("toaster"))
                  )
                ),
                filters = Some("product_type:toaster")
              )
            )
          )
        ),
        Rule(
          objectID = "cheap",
          conditions = Some(
            Seq(
              Condition(
                pattern = Some("cheap"),
                anchoring = Some(Anchoring.withName("contains"))
              )
            )
          ),
          consequence = Consequence(
            params = Some(
              ConsequenceParams(
                query = Some(
                  ConsequenceQueryObject(
                    remove = Some(Seq("cheap"))
                  )
                ),
                filters = Some("price < 15")
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch")
    assert(res.method == "POST")
    val expectedBody = parse(
      """[{"objectID":"toaster","conditions":[{"pattern":"toaster","anchoring":"contains"}],"consequence":{"params":{"query":{"remove":["toaster"]},"filters":"product_type:toaster"}}},{"objectID":"cheap","conditions":[{"pattern":"cheap","anchoring":"contains"}],"consequence":{"params":{"query":{"remove":["cheap"]},"filters":"price < 15"}}}]"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enhance search results3") {
    val (client, echo) = testClient()
    val future = client.saveRules(
      indexName = "<YOUR_INDEX_NAME>",
      rules = Seq(
        Rule(
          objectID = "country",
          conditions = Some(
            Seq(
              Condition(
                pattern = Some("{facet:country}"),
                anchoring = Some(Anchoring.withName("contains"))
              )
            )
          ),
          consequence = Consequence(
            params = Some(
              ConsequenceParams(
                aroundLatLngViaIP = Some(false)
              )
            )
          )
        ),
        Rule(
          objectID = "city",
          conditions = Some(
            Seq(
              Condition(
                pattern = Some("{facet:city}"),
                anchoring = Some(Anchoring.withName("contains"))
              )
            )
          ),
          consequence = Consequence(
            params = Some(
              ConsequenceParams(
                aroundLatLngViaIP = Some(false)
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch")
    assert(res.method == "POST")
    val expectedBody = parse(
      """[{"objectID":"country","conditions":[{"pattern":"{facet:country}","anchoring":"contains"}],"consequence":{"params":{"aroundLatLngViaIP":false}}},{"objectID":"city","conditions":[{"pattern":"{facet:city}","anchoring":"contains"}],"consequence":{"params":{"aroundLatLngViaIP":false}}}]"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("saveSynonym") {
    val (client, echo) = testClient()
    val future = client.saveSynonym(
      indexName = "indexName",
      objectID = "id1",
      synonymHit = SynonymHit(
        objectID = "id1",
        `type` = SynonymType.withName("synonym"),
        synonyms = Some(Seq("car", "vehicule", "auto"))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/synonyms/id1")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"objectID":"id1","type":"synonym","synonyms":["car","vehicule","auto"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("saveSynonyms") {
    val (client, echo) = testClient()
    val future = client.saveSynonyms(
      indexName = "<YOUR_INDEX_NAME>",
      synonymHit = Seq(
        SynonymHit(
          objectID = "id1",
          `type` = SynonymType.withName("synonym"),
          synonyms = Some(Seq("car", "vehicule", "auto"))
        ),
        SynonymHit(
          objectID = "id2",
          `type` = SynonymType.withName("onewaysynonym"),
          input = Some("iphone"),
          synonyms = Some(Seq("ephone", "aphone", "yphone"))
        )
      ),
      forwardToReplicas = Some(true),
      replaceExistingSynonyms = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/synonyms/batch")
    assert(res.method == "POST")
    val expectedBody = parse(
      """[{"objectID":"id1","type":"synonym","synonyms":["car","vehicule","auto"]},{"objectID":"id2","type":"onewaysynonym","input":"iphone","synonyms":["ephone","aphone","yphone"]}]"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery =
      parse("""{"forwardToReplicas":"true","replaceExistingSynonyms":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("withHitsPerPage") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "<YOUR_INDEX_NAME>",
            query = Some("<YOUR_QUERY>"),
            hitsPerPage = Some(50)
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","hitsPerPage":50}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filterOnly1") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "<YOUR_INDEX_NAME>",
            query = Some("<YOUR_QUERY>"),
            filters = Some("actor:Scarlett Johansson")
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"actor:Scarlett Johansson"}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filterOr2") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "<YOUR_INDEX_NAME>",
            query = Some("<YOUR_QUERY>"),
            filters = Some("actor:Tom Cruise OR actor:Scarlett Johansson")
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"actor:Tom Cruise OR actor:Scarlett Johansson"}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filterNot3") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "<YOUR_INDEX_NAME>",
            query = Some("<YOUR_QUERY>"),
            filters = Some("NOT actor:Nicolas Cage")
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"NOT actor:Nicolas Cage"}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search for a single hits request with minimal parameters4") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "cts_e2e_search_empty_index"
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse("""{"requests":[{"indexName":"cts_e2e_search_empty_index"}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search with highlight and snippet results5") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "cts_e2e_highlight_snippet_results",
            query = Some("vim"),
            attributesToSnippet = Some(Seq("*:20")),
            attributesToHighlight = Some(Seq("*")),
            attributesToRetrieve = Some(Seq("*"))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"cts_e2e_highlight_snippet_results","query":"vim","attributesToSnippet":["*:20"],"attributesToHighlight":["*"],"attributesToRetrieve":["*"]}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("retrieveFacets6") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "<YOUR_INDEX_NAME>",
            query = Some("<YOUR_QUERY>"),
            facets = Some(Seq("author", "genre"))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","facets":["author","genre"]}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("retrieveFacetsWildcard7") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "<YOUR_INDEX_NAME>",
            query = Some("<YOUR_QUERY>"),
            facets = Some(Seq("*"))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","facets":["*"]}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search for a single facet request with minimal parameters8") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForFacets(
            indexName = "cts_e2e_search_facet",
            `type` = SearchTypeFacet.withName("facet"),
            facet = "editor"
          )
        ),
        strategy = Some(SearchStrategy.withName("stopIfEnoughMatches"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"cts_e2e_search_facet","type":"facet","facet":"editor"}],"strategy":"stopIfEnoughMatches"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search for a single hits request with all parameters9") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "theIndexName",
            query = Some("myQuery"),
            hitsPerPage = Some(50),
            `type` = Some(SearchTypeDefault.withName("default"))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"requests":[{"indexName":"theIndexName","query":"myQuery","hitsPerPage":50,"type":"default"}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search for a single facet request with all parameters10") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForFacets(
            indexName = "theIndexName",
            `type` = SearchTypeFacet.withName("facet"),
            facet = "theFacet",
            facetQuery = Some("theFacetQuery"),
            query = Some("theQuery"),
            maxFacetHits = Some(50)
          )
        ),
        strategy = Some(SearchStrategy.withName("stopIfEnoughMatches"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"theIndexName","type":"facet","facet":"theFacet","facetQuery":"theFacetQuery","query":"theQuery","maxFacetHits":50}],"strategy":"stopIfEnoughMatches"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search for multiple mixed requests in multiple indices with minimal parameters11") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "theIndexName"
          ),
          SearchForFacets(
            indexName = "theIndexName2",
            `type` = SearchTypeFacet.withName("facet"),
            facet = "theFacet"
          ),
          SearchForHits(
            indexName = "theIndexName",
            `type` = Some(SearchTypeDefault.withName("default"))
          )
        ),
        strategy = Some(SearchStrategy.withName("stopIfEnoughMatches"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"theIndexName"},{"indexName":"theIndexName2","type":"facet","facet":"theFacet"},{"indexName":"theIndexName","type":"default"}],"strategy":"stopIfEnoughMatches"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search for multiple mixed requests in multiple indices with all parameters12") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForFacets(
            indexName = "theIndexName",
            `type` = SearchTypeFacet.withName("facet"),
            facet = "theFacet",
            facetQuery = Some("theFacetQuery"),
            query = Some("theQuery"),
            maxFacetHits = Some(50)
          ),
          SearchForHits(
            indexName = "theIndexName",
            query = Some("myQuery"),
            hitsPerPage = Some(50),
            `type` = Some(SearchTypeDefault.withName("default"))
          )
        ),
        strategy = Some(SearchStrategy.withName("stopIfEnoughMatches"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"theIndexName","type":"facet","facet":"theFacet","facetQuery":"theFacetQuery","query":"theQuery","maxFacetHits":50},{"indexName":"theIndexName","query":"myQuery","hitsPerPage":50,"type":"default"}],"strategy":"stopIfEnoughMatches"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search filters accept all of the possible shapes13") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "theIndexName",
            facetFilters = Some(FacetFilters("mySearch:filters")),
            reRankingApplyFilter = Some(ReRankingApplyFilter("mySearch:filters")),
            tagFilters = Some(TagFilters("mySearch:filters")),
            numericFilters = Some(NumericFilters("mySearch:filters")),
            optionalFilters = Some(OptionalFilters("mySearch:filters"))
          ),
          SearchForHits(
            indexName = "theIndexName",
            facetFilters = Some(
              FacetFilters(
                Seq(
                  FacetFilters("mySearch:filters"),
                  FacetFilters(
                    Seq(FacetFilters("mySearch:filters"), FacetFilters(Seq(FacetFilters("mySearch:filters"))))
                  )
                )
              )
            ),
            reRankingApplyFilter = Some(
              ReRankingApplyFilter(
                Seq(
                  ReRankingApplyFilter("mySearch:filters"),
                  ReRankingApplyFilter(Seq(ReRankingApplyFilter("mySearch:filters")))
                )
              )
            ),
            tagFilters =
              Some(TagFilters(Seq(TagFilters("mySearch:filters"), TagFilters(Seq(TagFilters("mySearch:filters")))))),
            numericFilters = Some(
              NumericFilters(
                Seq(NumericFilters("mySearch:filters"), NumericFilters(Seq(NumericFilters("mySearch:filters"))))
              )
            ),
            optionalFilters = Some(
              OptionalFilters(
                Seq(OptionalFilters("mySearch:filters"), OptionalFilters(Seq(OptionalFilters("mySearch:filters"))))
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"theIndexName","facetFilters":"mySearch:filters","reRankingApplyFilter":"mySearch:filters","tagFilters":"mySearch:filters","numericFilters":"mySearch:filters","optionalFilters":"mySearch:filters"},{"indexName":"theIndexName","facetFilters":["mySearch:filters",["mySearch:filters",["mySearch:filters"]]],"reRankingApplyFilter":["mySearch:filters",["mySearch:filters"]],"tagFilters":["mySearch:filters",["mySearch:filters"]],"numericFilters":["mySearch:filters",["mySearch:filters"]],"optionalFilters":["mySearch:filters",["mySearch:filters"]]}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search filters end to end14") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "cts_e2e_search_facet",
            filters = Some("editor:'visual studio' OR editor:neovim")
          ),
          SearchForHits(
            indexName = "cts_e2e_search_facet",
            facetFilters =
              Some(FacetFilters(Seq(FacetFilters("editor:'visual studio'"), FacetFilters("editor:neovim"))))
          ),
          SearchForHits(
            indexName = "cts_e2e_search_facet",
            facetFilters = Some(
              FacetFilters(
                Seq(FacetFilters("editor:'visual studio'"), FacetFilters(Seq(FacetFilters("editor:neovim"))))
              )
            )
          ),
          SearchForHits(
            indexName = "cts_e2e_search_facet",
            facetFilters = Some(
              FacetFilters(
                Seq(
                  FacetFilters("editor:'visual studio'"),
                  FacetFilters(Seq(FacetFilters("editor:neovim"), FacetFilters(Seq(FacetFilters("editor:goland")))))
                )
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"cts_e2e_search_facet","filters":"editor:'visual studio' OR editor:neovim"},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'","editor:neovim"]},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'",["editor:neovim"]]},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'",["editor:neovim",["editor:goland"]]]}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search with all search parameters15") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            advancedSyntax = Some(true),
            advancedSyntaxFeatures = Some(Seq(AdvancedSyntaxFeatures.withName("exactPhrase"))),
            allowTyposOnNumericTokens = Some(true),
            alternativesAsExact = Some(Seq(AlternativesAsExact.withName("multiWordsSynonym"))),
            analytics = Some(true),
            analyticsTags = Some(Seq("")),
            aroundLatLng = Some(""),
            aroundLatLngViaIP = Some(true),
            aroundPrecision = Some(AroundPrecision(0)),
            aroundRadius = Some(AroundRadiusAll.withName("all")),
            attributeCriteriaComputedByMinProximity = Some(true),
            attributesToHighlight = Some(Seq("")),
            attributesToRetrieve = Some(Seq("")),
            attributesToSnippet = Some(Seq("")),
            clickAnalytics = Some(true),
            decompoundQuery = Some(true),
            disableExactOnAttributes = Some(Seq("")),
            disableTypoToleranceOnAttributes = Some(Seq("")),
            distinct = Some(Distinct(0)),
            enableABTest = Some(true),
            enablePersonalization = Some(true),
            enableReRanking = Some(true),
            enableRules = Some(true),
            exactOnSingleWordQuery = Some(ExactOnSingleWordQuery.withName("attribute")),
            facetFilters = Some(FacetFilters(Seq(FacetFilters("")))),
            facetingAfterDistinct = Some(true),
            facets = Some(Seq("")),
            filters = Some(""),
            getRankingInfo = Some(true),
            highlightPostTag = Some(""),
            highlightPreTag = Some(""),
            hitsPerPage = Some(1),
            ignorePlurals = Some(IgnorePlurals(false)),
            indexName = "theIndexName",
            insideBoundingBox =
              Some(InsideBoundingBox(Seq(Seq(47.3165, 4.9665, 47.3424, 5.0201), Seq(40.9234, 2.1185, 38.643, 1.9916)))),
            insidePolygon = Some(
              Seq(
                Seq(47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9),
                Seq(40.9234, 2.1185, 38.643, 1.9916, 39.2587, 2.0104)
              )
            ),
            length = Some(1),
            maxValuesPerFacet = Some(0),
            minProximity = Some(1),
            minWordSizefor1Typo = Some(0),
            minWordSizefor2Typos = Some(0),
            minimumAroundRadius = Some(1),
            naturalLanguages = Some(Seq(SupportedLanguage.withName("fr"))),
            numericFilters = Some(NumericFilters(Seq(NumericFilters("")))),
            offset = Some(0),
            optionalFilters = Some(OptionalFilters(Seq(OptionalFilters("")))),
            optionalWords = Some(OptionalWords(Seq(""))),
            page = Some(0),
            percentileComputation = Some(true),
            personalizationImpact = Some(0),
            query = Some(""),
            queryLanguages = Some(Seq(SupportedLanguage.withName("fr"))),
            queryType = Some(QueryType.withName("prefixAll")),
            ranking = Some(Seq("")),
            reRankingApplyFilter = Some(ReRankingApplyFilter(Seq(ReRankingApplyFilter("")))),
            relevancyStrictness = Some(0),
            removeStopWords = Some(RemoveStopWords(true)),
            removeWordsIfNoResults = Some(RemoveWordsIfNoResults.withName("allOptional")),
            renderingContent = Some(
              RenderingContent(
                facetOrdering = Some(
                  FacetOrdering(
                    facets = Some(
                      Facets(
                        order = Some(Seq("a", "b"))
                      )
                    ),
                    values = Some(
                      Map(
                        "a" -> Value(
                          order = Some(Seq("b")),
                          sortRemainingBy = Some(SortRemainingBy.withName("count"))
                        )
                      )
                    )
                  )
                )
              )
            ),
            replaceSynonymsInHighlight = Some(true),
            responseFields = Some(Seq("")),
            restrictHighlightAndSnippetArrays = Some(true),
            restrictSearchableAttributes = Some(Seq("")),
            ruleContexts = Some(Seq("")),
            similarQuery = Some(""),
            snippetEllipsisText = Some(""),
            sortFacetValuesBy = Some(""),
            sumOrFiltersScores = Some(true),
            synonyms = Some(true),
            tagFilters = Some(TagFilters(Seq(TagFilters("")))),
            `type` = Some(SearchTypeDefault.withName("default")),
            typoTolerance = Some(TypoToleranceEnum.withName("min")),
            userToken = Some("")
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"advancedSyntax":true,"advancedSyntaxFeatures":["exactPhrase"],"allowTyposOnNumericTokens":true,"alternativesAsExact":["multiWordsSynonym"],"analytics":true,"analyticsTags":[""],"aroundLatLng":"","aroundLatLngViaIP":true,"aroundPrecision":0,"aroundRadius":"all","attributeCriteriaComputedByMinProximity":true,"attributesToHighlight":[""],"attributesToRetrieve":[""],"attributesToSnippet":[""],"clickAnalytics":true,"decompoundQuery":true,"disableExactOnAttributes":[""],"disableTypoToleranceOnAttributes":[""],"distinct":0,"enableABTest":true,"enablePersonalization":true,"enableReRanking":true,"enableRules":true,"exactOnSingleWordQuery":"attribute","facetFilters":[""],"facetingAfterDistinct":true,"facets":[""],"filters":"","getRankingInfo":true,"highlightPostTag":"","highlightPreTag":"","hitsPerPage":1,"ignorePlurals":false,"indexName":"theIndexName","insideBoundingBox":[[47.3165,4.9665,47.3424,5.0201],[40.9234,2.1185,38.643,1.9916]],"insidePolygon":[[47.3165,4.9665,47.3424,5.0201,47.32,4.9],[40.9234,2.1185,38.643,1.9916,39.2587,2.0104]],"length":1,"maxValuesPerFacet":0,"minProximity":1,"minWordSizefor1Typo":0,"minWordSizefor2Typos":0,"minimumAroundRadius":1,"naturalLanguages":["fr"],"numericFilters":[""],"offset":0,"optionalFilters":[""],"optionalWords":[""],"page":0,"percentileComputation":true,"personalizationImpact":0,"query":"","queryLanguages":["fr"],"queryType":"prefixAll","ranking":[""],"reRankingApplyFilter":[""],"relevancyStrictness":0,"removeStopWords":true,"removeWordsIfNoResults":"allOptional","renderingContent":{"facetOrdering":{"facets":{"order":["a","b"]},"values":{"a":{"order":["b"],"sortRemainingBy":"count"}}}},"replaceSynonymsInHighlight":true,"responseFields":[""],"restrictHighlightAndSnippetArrays":true,"restrictSearchableAttributes":[""],"ruleContexts":[""],"similarQuery":"","snippetEllipsisText":"","sortFacetValuesBy":"","sumOrFiltersScores":true,"synonyms":true,"tagFilters":[""],"type":"default","typoTolerance":"min","userToken":""}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("get searchDictionaryEntries results with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.searchDictionaryEntries(
      dictionaryName = DictionaryType.withName("stopwords"),
      searchDictionaryEntriesParams = SearchDictionaryEntriesParams(
        query = "about"
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/stopwords/search")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"about"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("get searchDictionaryEntries results with all parameters1") {
    val (client, echo) = testClient()
    val future = client.searchDictionaryEntries(
      dictionaryName = DictionaryType.withName("compounds"),
      searchDictionaryEntriesParams = SearchDictionaryEntriesParams(
        query = "foo",
        page = Some(4),
        hitsPerPage = Some(2),
        language = Some(SupportedLanguage.withName("fr"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/compounds/search")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"foo","page":4,"hitsPerPage":2,"language":"fr"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("get searchForFacetValues results with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.searchForFacetValues(
      indexName = "indexName",
      facetName = "facetName"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/facets/facetName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("get searchForFacetValues results with all parameters1") {
    val (client, echo) = testClient()
    val future = client.searchForFacetValues(
      indexName = "indexName",
      facetName = "facetName",
      searchForFacetValuesRequest = Some(
        SearchForFacetValuesRequest(
          params = Some("query=foo&facetFilters=['bar']"),
          facetQuery = Some("foo"),
          maxFacetHits = Some(42)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/facets/facetName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"params":"query=foo&facetFilters=['bar']","facetQuery":"foo","maxFacetHits":42}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facetName and facetQuery2") {
    val (client, echo) = testClient()
    val future = client.searchForFacetValues(
      indexName = "indexName",
      facetName = "author",
      searchForFacetValuesRequest = Some(
        SearchForFacetValuesRequest(
          facetQuery = Some("stephen")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/facets/author/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facetQuery":"stephen"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchRules") {
    val (client, echo) = testClient()
    val future = client.searchRules(
      indexName = "cts_e2e_browse",
      searchRulesParams = Some(
        SearchRulesParams(
          query = Some("zorro")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/cts_e2e_browse/rules/search")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"zorro"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search with special characters in indexName1") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "cts_e2e_space in index"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/cts_e2e_space%20in%20index/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search with searchParams2") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("myQuery"),
          facetFilters = Some(FacetFilters(Seq(FacetFilters("tags:algolia"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"myQuery","facetFilters":["tags:algolia"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("single search retrieve snippets3") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "cts_e2e_browse",
      searchParams = Some(
        SearchParamsObject(
          query = Some("batman mask of the phantasm"),
          attributesToRetrieve = Some(Seq("*")),
          attributesToSnippet = Some(Seq("*:20"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/cts_e2e_browse/query")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"query":"batman mask of the phantasm","attributesToRetrieve":["*"],"attributesToSnippet":["*:20"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("query4") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("phone")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"phone"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filters5") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("country:US AND price.gross < 2.0")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"filters":"country:US AND price.gross < 2.0"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filters for stores6") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("ben"),
          filters = Some("categories:politics AND store:Gibert Joseph Saint-Michel")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"ben","filters":"categories:politics AND store:Gibert Joseph Saint-Michel"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filters boolean7") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("is_available:true")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"filters":"is_available:true"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("distinct8") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          distinct = Some(Distinct(true))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"distinct":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filtersNumeric9") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("price < 10")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"filters":"price < 10"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filtersTimestamp10") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("NOT date_timestamp:1514764800 TO 1546300799")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"filters":"NOT date_timestamp:1514764800 TO 1546300799"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filtersSumOrFiltersScoresFalse11") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)"),
          sumOrFiltersScores = Some(false)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"filters":"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)","sumOrFiltersScores":false}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filtersSumOrFiltersScoresTrue12") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)"),
          sumOrFiltersScores = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"filters":"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)","sumOrFiltersScores":true}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filtersStephenKing13") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("author:\"Stephen King\"")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"filters":"author:\"Stephen King\""}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filtersNotTags14") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("harry"),
          filters = Some("_tags:non-fiction")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"harry","filters":"_tags:non-fiction"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facetFiltersList15") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          facetFilters = Some(
            FacetFilters(
              Seq(
                FacetFilters("publisher:Penguin"),
                FacetFilters(Seq(FacetFilters("author:Stephen King"), FacetFilters("genre:Horror")))
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facetFilters":["publisher:Penguin",["author:Stephen King","genre:Horror"]]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facetFiltersBook16") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          facetFilters = Some(FacetFilters(Seq(FacetFilters("category:Book"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","facetFilters":["category:Book"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facetFiltersAND17") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          facetFilters = Some(FacetFilters(Seq(FacetFilters("category:Book"), FacetFilters("author:John Doe"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","facetFilters":["category:Book","author:John Doe"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facetFiltersOR18") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          facetFilters =
            Some(FacetFilters(Seq(FacetFilters(Seq(FacetFilters("category:Book"), FacetFilters("author:John Doe"))))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","facetFilters":[["category:Book","author:John Doe"]]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facetFiltersCombined19") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          facetFilters = Some(
            FacetFilters(
              Seq(
                FacetFilters("author:John Doe"),
                FacetFilters(Seq(FacetFilters("category:Book"), FacetFilters("category:Movie")))
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"query":"query","facetFilters":["author:John Doe",["category:Book","category:Movie"]]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facetFiltersNeg20") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          facetFilters = Some(FacetFilters("category:-Ebook"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facetFilters":"category:-Ebook"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filtersAndFacetFilters21") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("(author:\"Stephen King\" OR genre:\"Horror\")"),
          facetFilters = Some(FacetFilters(Seq(FacetFilters("publisher:Penguin"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"filters":"(author:\"Stephen King\" OR genre:\"Horror\")","facetFilters":["publisher:Penguin"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facet author genre22") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          facets = Some(Seq("author", "genre"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facets":["author","genre"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facet wildcard23") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          facets = Some(Seq("*"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facets":["*"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("maxValuesPerFacet24") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          maxValuesPerFacet = Some(1000)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"maxValuesPerFacet":1000}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("aroundLatLng25") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          aroundLatLng = Some("40.71, -74.01")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"aroundLatLng":"40.71, -74.01"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("aroundLatLngViaIP26") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          aroundLatLngViaIP = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"aroundLatLngViaIP":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("aroundRadius27") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          aroundLatLng = Some("40.71, -74.01"),
          aroundRadius = Some(AroundRadius(1000000))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"aroundLatLng":"40.71, -74.01","aroundRadius":1000000}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("insideBoundingBox28") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          insideBoundingBox =
            Some(InsideBoundingBox(Seq(Seq(49.067996905313834, 65.73828125, 25.905859247243498, 128.8046875))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"insideBoundingBox":[[49.067996905313834,65.73828125,25.905859247243498,128.8046875]]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("insidePolygon29") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          insidePolygon = Some(
            Seq(
              Seq(42.01, -124.31, 48.835509470063045, -124.40453125000005, 45.01082951668149, -65.95726562500005,
                31.247243545293433, -81.06578125000004, 25.924152577235226, -97.68234374999997, 32.300311895879545,
                -117.54828125)
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"insidePolygon":[[42.01,-124.31,48.835509470063045,-124.40453125000005,45.01082951668149,-65.95726562500005,31.247243545293433,-81.06578125000004,25.924152577235226,-97.68234374999997,32.300311895879545,-117.54828125]]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("optionalFilters30") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          optionalFilters = Some(OptionalFilters(Seq(OptionalFilters("can_deliver_quickly:true"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"optionalFilters":["can_deliver_quickly:true"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("optionalFiltersMany31") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          optionalFilters = Some(
            OptionalFilters(
              Seq(
                OptionalFilters("brand:Apple<score=3>"),
                OptionalFilters("brand:Samsung<score=2>"),
                OptionalFilters("brand:-Huawei")
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"optionalFilters":["brand:Apple<score=3>","brand:Samsung<score=2>","brand:-Huawei"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("optionalFiltersSimple32") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          optionalFilters =
            Some(OptionalFilters(Seq(OptionalFilters("brand:Apple<score=2>"), OptionalFilters("type:tablet"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"optionalFilters":["brand:Apple<score=2>","type:tablet"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("restrictSearchableAttributes33") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          restrictSearchableAttributes = Some(Seq("title_fr"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"restrictSearchableAttributes":["title_fr"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("getRankingInfo34") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          getRankingInfo = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"getRankingInfo":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("clickAnalytics35") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          clickAnalytics = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"clickAnalytics":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("clickAnalyticsUserToken36") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          clickAnalytics = Some(true),
          userToken = Some("user-1")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"clickAnalytics":true,"userToken":"user-1"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enablePersonalization37") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          enablePersonalization = Some(true),
          userToken = Some("user-1")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"enablePersonalization":true,"userToken":"user-1"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("userToken38") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          userToken = Some("user-1")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"userToken":"user-1"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("userToken123439") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          userToken = Some("user-1234")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","userToken":"user-1234"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("analyticsTag40") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          analyticsTags = Some(Seq("YOUR_ANALYTICS_TAG"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"analyticsTags":["YOUR_ANALYTICS_TAG"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facetFiltersUsers41") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          facetFilters = Some(FacetFilters(Seq(FacetFilters("user:user42"), FacetFilters("user:public"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facetFilters":["user:user42","user:public"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("buildTheQuery42") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("categoryPageId: Men's Clothing"),
          hitsPerPage = Some(50),
          analyticsTags = Some(Seq("mens-clothing"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"filters":"categoryPageId: Men's Clothing","hitsPerPage":50,"analyticsTags":["mens-clothing"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesToHighlightOverride43") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          attributesToHighlight = Some(Seq("title", "content"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","attributesToHighlight":["title","content"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("disableTypoToleranceOnAttributes44") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          disableTypoToleranceOnAttributes = Some(Seq("serial_number"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","disableTypoToleranceOnAttributes":["serial_number"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search query45") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("shirt")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"shirt"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search_everything46") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":""}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("api_filtering_range_example47") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("books"),
          filters = Some("price:10 TO 20")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"books","filters":"price:10 TO 20"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("similarQuery48") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some(""),
          similarQuery = Some("Comedy Drama Crime McDormand Macy Buscemi Stormare Presnell Coen"),
          filters = Some("year:1991 TO 2001")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"query":"","similarQuery":"Comedy Drama Crime McDormand Macy Buscemi Stormare Presnell Coen","filters":"year:1991 TO 2001"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_retrievable_attributes49") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          attributesToRetrieve = Some(Seq("title", "content"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","attributesToRetrieve":["title","content"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("restrict_searchable_attributes50") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          restrictSearchableAttributes = Some(Seq("title", "author"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","restrictSearchableAttributes":["title","author"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_default_relevancy51") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          relevancyStrictness = Some(70)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","relevancyStrictness":70}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("apply_filters52") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          filters = Some("(category:Book OR category:Ebook) AND _tags:published")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","filters":"(category:Book OR category:Ebook) AND _tags:published"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("apply_all_filters53") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          filters = Some(
            "available = 1 AND (category:Book OR NOT category:Ebook) AND _tags:published AND publication_date:1441745506 TO 1441755506 AND inStock > 0 AND author:\"John Doe\""
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"query":"query","filters":"available = 1 AND (category:Book OR NOT category:Ebook) AND _tags:published AND publication_date:1441745506 TO 1441755506 AND inStock > 0 AND author:\"John Doe\""}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("escape_spaces54") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          filters = Some("category:\"Books and Comics\"")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","filters":"category:\"Books and Comics\""}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("escape_keywords55") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          filters = Some("keyword:\"OR\"")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","filters":"keyword:\"OR\""}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("escape_single_quotes56") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          filters = Some("content:\"It's a wonderful day\"")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","filters":"content:\"It's a wonderful day\""}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("escape_double_quotes57") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          filters = Some("content:\"She said \"Hello World\"")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","filters":"content:\"She said \"Hello World\""}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("apply_optional_filters58") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          optionalFilters =
            Some(OptionalFilters(Seq(OptionalFilters("category:Book"), OptionalFilters("author:John Doe"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","optionalFilters":["category:Book","author:John Doe"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("apply_negative_filters59") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          optionalFilters =
            Some(OptionalFilters(Seq(OptionalFilters("category:Book"), OptionalFilters("author:-John Doe"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","optionalFilters":["category:Book","author:-John Doe"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("apply_negative_filters_restaurants60") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          optionalFilters = Some(OptionalFilters(Seq(OptionalFilters("restaurant:-Bert's Inn"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","optionalFilters":["restaurant:-Bert's Inn"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("apply_numeric_filters61") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          numericFilters = Some(
            NumericFilters(
              Seq(
                NumericFilters("price < 1000"),
                NumericFilters(Seq(NumericFilters("inStock = 1"), NumericFilters("deliveryDate < 1441755506")))
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"query":"query","numericFilters":["price < 1000",["inStock = 1","deliveryDate < 1441755506"]]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("apply_tag_filters62") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          tagFilters =
            Some(TagFilters(Seq(TagFilters("SciFi"), TagFilters(Seq(TagFilters("Book"), TagFilters("Movie"))))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","tagFilters":["SciFi",["Book","Movie"]]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_sum_or_filters_scores63") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          sumOrFiltersScores = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","sumOrFiltersScores":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facets_all64") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          facets = Some(Seq("*"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","facets":["*"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("retrieve_only_some_facets65") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          facets = Some(Seq("category", "author"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","facets":["category","author"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_default_max_values_per_facet66") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          maxValuesPerFacet = Some(20)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","maxValuesPerFacet":20}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enable_faceting_after_distinct67") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          facetingAfterDistinct = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","facetingAfterDistinct":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("sort_facet_values_alphabetically68") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          sortFacetValuesBy = Some("count")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","sortFacetValuesBy":"count"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_attributes_to_snippet69") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          attributesToSnippet = Some(Seq("title", "content:80"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","attributesToSnippet":["title","content:80"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_default_highlight_pre_tag70") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          highlightPreTag = Some("<strong>")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","highlightPreTag":"<strong>"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_default_highlight_post_tag71") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          highlightPostTag = Some("</strong>")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","highlightPostTag":"</strong>"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_default_snippet_ellipsis_text72") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          snippetEllipsisText = Some("")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","snippetEllipsisText":""}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enable_restrict_highlight_and_snippet_arrays73") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          restrictHighlightAndSnippetArrays = Some(false)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","restrictHighlightAndSnippetArrays":false}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("access_page74") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          page = Some(0)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","page":0}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_default_hits_per_page75") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          hitsPerPage = Some(10)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","hitsPerPage":10}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("get_nth_hit76") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          offset = Some(4)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","offset":4}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("get_n_results77") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          length = Some(4)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","length":4}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_default_min_word_size_for_one_typo78") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          minWordSizefor1Typo = Some(2)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","minWordSizefor1Typo":2}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_default_min_word_size_for_two_typos79") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          minWordSizefor2Typos = Some(2)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","minWordSizefor2Typos":2}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_default_typo_tolerance_mode80") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          typoTolerance = Some(TypoTolerance(false))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","typoTolerance":false}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("disable_typos_on_numeric_tokens_at_search_time81") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          allowTyposOnNumericTokens = Some(false)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","allowTyposOnNumericTokens":false}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search_around_a_position82") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          aroundLatLng = Some("40.71, -74.01")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","aroundLatLng":"40.71, -74.01"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search_around_server_ip83") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          aroundLatLngViaIP = Some(true)
        )
      ),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withHeader(
            "x-forwarded-for",
            "94.228.178.246 // should be replaced with the actual IP you would like to search around"
          )
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","aroundLatLngViaIP":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedHeaders = parse(
      """{"x-forwarded-for":"94.228.178.246 // should be replaced with the actual IP you would like to search around"}"""
    ).asInstanceOf[JObject].obj.toMap
    val actualHeaders = res.headers
    for ((k, v) <- expectedHeaders) {
      assert(actualHeaders.contains(k))
      assert(actualHeaders(k) == v.asInstanceOf[JString].s)
    }
  }

  test("set_around_radius84") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          aroundRadius = Some(AroundRadius(1000))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","aroundRadius":1000}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("disable_automatic_radius85") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          aroundRadius = Some(AroundRadiusAll.withName("all"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","aroundRadius":"all"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_geo_search_precision86") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          aroundPrecision = Some(AroundPrecision(100))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","aroundPrecision":100}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_geo_search_precision_non_linear87") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          aroundPrecision = Some(
            AroundPrecision(
              Seq(
                Range(
                  from = Some(0),
                  value = Some(25)
                ),
                Range(
                  from = Some(2000),
                  value = Some(1000)
                )
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"query":"query","aroundPrecision":[{"from":0,"value":25},{"from":2000,"value":1000}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_minimum_geo_search_radius88") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          minimumAroundRadius = Some(1000)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","minimumAroundRadius":1000}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search_inside_rectangular_area89") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          insideBoundingBox =
            Some(InsideBoundingBox(Seq(Seq(46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"query":"query","insideBoundingBox":[[46.650828100116044,7.123046875,45.17210966999772,1.009765625]]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search_inside_multiple_rectangular_areas90") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          insideBoundingBox = Some(
            InsideBoundingBox(
              Seq(
                Seq(46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625),
                Seq(49.62625916704081, 4.6181640625, 47.715070300900194, 0.482421875)
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"query":"query","insideBoundingBox":[[46.650828100116044,7.123046875,45.17210966999772,1.009765625],[49.62625916704081,4.6181640625,47.715070300900194,0.482421875]]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search_inside_polygon_area91") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          insidePolygon = Some(
            Seq(Seq(46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"query":"query","insidePolygon":[[46.650828100116044,7.123046875,45.17210966999772,1.009765625,49.62625916704081,4.6181640625]]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search_inside_multiple_polygon_areas92") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          insidePolygon = Some(
            Seq(
              Seq(46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625),
              Seq(49.62625916704081, 4.6181640625, 47.715070300900194, 0.482421875, 45.17210966999772, 1.009765625,
                50.62626704081, 4.6181640625)
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"query":"query","insidePolygon":[[46.650828100116044,7.123046875,45.17210966999772,1.009765625,49.62625916704081,4.6181640625],[49.62625916704081,4.6181640625,47.715070300900194,0.482421875,45.17210966999772,1.009765625,50.62626704081,4.6181640625]]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_querylanguages_override93") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          ignorePlurals = Some(IgnorePlurals(Seq(SupportedLanguage.withName("ca"), SupportedLanguage.withName("es"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","ignorePlurals":["ca","es"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_querylanguages_with_japanese_query94") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          queryLanguages = Some(Seq(SupportedLanguage.withName("ja"), SupportedLanguage.withName("en")))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","queryLanguages":["ja","en"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_natural_languages95") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some(""),
          naturalLanguages = Some(Seq(SupportedLanguage.withName("fr")))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"","naturalLanguages":["fr"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_natural_languages_with_query96") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some(""),
          naturalLanguages = Some(Seq(SupportedLanguage.withName("fr"))),
          removeWordsIfNoResults = Some(RemoveWordsIfNoResults.withName("firstWords"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"","naturalLanguages":["fr"],"removeWordsIfNoResults":"firstWords"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enable_decompound_query_search_time97") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          decompoundQuery = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","decompoundQuery":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enable_rules_search_time98") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          enableRules = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","enableRules":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_rule_contexts99") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          ruleContexts = Some(Seq("front_end", "website2"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","ruleContexts":["front_end","website2"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enable_personalization100") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          enablePersonalization = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","enablePersonalization":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enable_personalization_with_user_token101") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          enablePersonalization = Some(true),
          userToken = Some("123456")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","enablePersonalization":true,"userToken":"123456"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("personalization_impact102") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          personalizationImpact = Some(20)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","personalizationImpact":20}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_user_token103") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          userToken = Some("123456")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","userToken":"123456"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_user_token_with_personalization104") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          enablePersonalization = Some(true),
          userToken = Some("123456")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","enablePersonalization":true,"userToken":"123456"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_default_query_type105") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          queryType = Some(QueryType.withName("prefixAll"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","queryType":"prefixAll"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_default_remove_words_if_no_results106") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          removeWordsIfNoResults = Some(RemoveWordsIfNoResults.withName("lastWords"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","removeWordsIfNoResults":"lastWords"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enable_advanced_syntax_search_time107") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          advancedSyntax = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","advancedSyntax":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("overide_default_optional_words108") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          optionalWords = Some(OptionalWords(Seq("toyota", "2020 2021")))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","optionalWords":["toyota","2020 2021"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("disabling_exact_for_some_attributes_search_time109") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          disableExactOnAttributes = Some(Seq("description"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","disableExactOnAttributes":["description"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_default_exact_single_word_query110") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          exactOnSingleWordQuery = Some(ExactOnSingleWordQuery.withName("none"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","exactOnSingleWordQuery":"none"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_default_aternative_as_exact111") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          alternativesAsExact = Some(Seq(AlternativesAsExact.withName("multiWordsSynonym")))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","alternativesAsExact":["multiWordsSynonym"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enable_advanced_syntax_exact_phrase112") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          advancedSyntax = Some(true),
          advancedSyntaxFeatures = Some(Seq(AdvancedSyntaxFeatures.withName("exactPhrase")))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","advancedSyntax":true,"advancedSyntaxFeatures":["exactPhrase"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enable_advanced_syntax_exclude_words113") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          advancedSyntax = Some(true),
          advancedSyntaxFeatures = Some(Seq(AdvancedSyntaxFeatures.withName("excludeWords")))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","advancedSyntax":true,"advancedSyntaxFeatures":["excludeWords"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_distinct114") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          distinct = Some(Distinct(0))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","distinct":0}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("get_ranking_info115") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          getRankingInfo = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","getRankingInfo":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("disable_click_analytics116") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          clickAnalytics = Some(false)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","clickAnalytics":false}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enable_click_analytics117") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          clickAnalytics = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","clickAnalytics":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("disable_analytics118") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          analytics = Some(false)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","analytics":false}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("add_analytics_tags119") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          analyticsTags = Some(Seq("front_end", "website2"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","analyticsTags":["front_end","website2"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("disable_synonyms120") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          synonyms = Some(false)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","synonyms":false}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_replace_synonyms_in_highlights121") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          replaceSynonymsInHighlight = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","replaceSynonymsInHighlight":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_min_proximity122") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          minProximity = Some(2)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","minProximity":2}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_default_field123") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          responseFields = Some(Seq("hits", "facets"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","responseFields":["hits","facets"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("override_percentile_computation124") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          percentileComputation = Some(false)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","percentileComputation":false}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_ab_test125") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          enableABTest = Some(false)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","enableABTest":false}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_enable_re_ranking126") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query"),
          enableReRanking = Some(false)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query","enableReRanking":false}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("with algolia user id127") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("query")
        )
      ),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withHeader("X-Algolia-User-ID", "user1234")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"query"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("mcm with algolia user id128") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "playlists",
      searchParams = Some(
        SearchParamsObject(
          query = Some("peace")
        )
      ),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withHeader("X-Algolia-User-ID", "user42")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/playlists/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"peace"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchSynonyms with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.searchSynonyms(
      indexName = "indexName"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/synonyms/search")
    assert(res.method == "POST")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchSynonyms with all parameters1") {
    val (client, echo) = testClient()
    val future = client.searchSynonyms(
      indexName = "indexName",
      searchSynonymsParams = Some(
        SearchSynonymsParams(
          query = Some("myQuery"),
          `type` = Some(SynonymType.withName("altcorrection1")),
          page = Some(10),
          hitsPerPage = Some(10)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/synonyms/search")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"myQuery","type":"altcorrection1","page":10,"hitsPerPage":10}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchUserIds") {
    val (client, echo) = testClient()
    val future = client.searchUserIds(
      searchUserIdsParams = SearchUserIdsParams(
        query = "test",
        clusterName = Some("theClusterName"),
        page = Some(5),
        hitsPerPage = Some(10)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping/search")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"test","clusterName":"theClusterName","page":5,"hitsPerPage":10}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("get setDictionarySettings results with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.setDictionarySettings(
      dictionarySettingsParams = DictionarySettingsParams(
        disableStandardEntries = StandardEntries(
          plurals = Some(Map("fr" -> false, "en" -> false, "ru" -> true))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/*/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"disableStandardEntries":{"plurals":{"fr":false,"en":false,"ru":true}}}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("get setDictionarySettings results with all parameters1") {
    val (client, echo) = testClient()
    val future = client.setDictionarySettings(
      dictionarySettingsParams = DictionarySettingsParams(
        disableStandardEntries = StandardEntries(
          plurals = Some(Map("fr" -> false, "en" -> false, "ru" -> true)),
          stopwords = Some(Map("fr" -> false)),
          compounds = Some(Map("ru" -> true))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/*/settings")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"disableStandardEntries":{"plurals":{"fr":false,"en":false,"ru":true},"stopwords":{"fr":false},"compounds":{"ru":true}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("minimal parameters") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "cts_e2e_settings",
      indexSettings = IndexSettings(
        paginationLimitedTo = Some(10),
        typoTolerance = Some(TypoToleranceEnum.withName("false"))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/cts_e2e_settings/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"paginationLimitedTo":10,"typoTolerance":"false"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("boolean typoTolerance1") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        typoTolerance = Some(TypoTolerance(true))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"typoTolerance":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("enum typoTolerance2") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        typoTolerance = Some(TypoToleranceEnum.withName("min"))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"typoTolerance":"min"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("ignorePlurals3") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        ignorePlurals = Some(IgnorePlurals(true))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"ignorePlurals":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("list of string ignorePlurals4") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        ignorePlurals = Some(IgnorePlurals(Seq(SupportedLanguage.withName("fr"))))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"ignorePlurals":["fr"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("removeStopWords boolean5") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        removeStopWords = Some(RemoveStopWords(true))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"removeStopWords":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("removeStopWords list of string6") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        removeStopWords = Some(RemoveStopWords(Seq(SupportedLanguage.withName("fr"))))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"removeStopWords":["fr"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("boolean distinct7") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        distinct = Some(Distinct(true))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"distinct":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("integer distinct8") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        distinct = Some(Distinct(1))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"distinct":1}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("distinct company9") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        attributeForDistinct = Some("company"),
        distinct = Some(Distinct(true))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributeForDistinct":"company","distinct":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("distinct design10") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        attributeForDistinct = Some("design"),
        distinct = Some(Distinct(true))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributeForDistinct":"design","distinct":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("distinct true11") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        distinct = Some(Distinct(true))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"distinct":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("distinct section12") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        attributeForDistinct = Some("section"),
        distinct = Some(Distinct(true))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributeForDistinct":"section","distinct":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting allergens13") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("allergens"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["allergens"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting availableIn14") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("color", "availableIn"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["color","availableIn"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("api_attributes_for_faceting15") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("genre", "author"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["genre","author"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("api_attributes_for_faceting_searchable16") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("genre", "searchable(author)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["genre","searchable(author)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("api_attributes_for_filter_only17") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("filterOnly(genre)", "author"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["filterOnly(genre)","author"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting categoryPageId18") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("searchable(categoryPageId)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["searchable(categoryPageId)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("unretrievableAttributes19") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        unretrievableAttributes = Some(Seq("visible_by"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"unretrievableAttributes":["visible_by"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting user restricted data20") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("filterOnly(visible_by)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["filterOnly(visible_by)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting optional filters21") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("can_deliver_quickly", "restaurant"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["can_deliver_quickly","restaurant"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting redirect index22") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("query_terms"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["query_terms"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting multiple consequences23") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("director"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["director"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting in-depth optional filters24") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("filterOnly(brand)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["filterOnly(brand)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("mode neuralSearch25") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        mode = Some(Mode.withName("neuralSearch"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"mode":"neuralSearch"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("mode keywordSearch26") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        mode = Some(Mode.withName("keywordSearch"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"mode":"keywordSearch"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributes same priority27") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("title,comments", "ingredients"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["title,comments","ingredients"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributes higher priority28") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("title", "ingredients"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["title","ingredients"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("customRanking retweets29") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("desc(retweets)", "desc(likes)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"customRanking":["desc(retweets)","desc(likes)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("customRanking boosted30") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("desc(boosted)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"customRanking":["desc(boosted)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("customRanking pageviews31") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("desc(pageviews)", "desc(comments)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"customRanking":["desc(pageviews)","desc(comments)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("customRanking applying search parameters for a specific query32") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("desc(nb_airline_liaisons)")),
        attributesForFaceting = Some(Seq("city, country"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody =
      parse("""{"customRanking":["desc(nb_airline_liaisons)"],"attributesForFaceting":["city, country"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("customRanking rounded pageviews33") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("desc(rounded_pageviews)", "desc(comments)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"customRanking":["desc(rounded_pageviews)","desc(comments)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("customRanking price34") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("desc(price)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"customRanking":["desc(price)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("ranking exhaustive (price)35") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        ranking =
          Some(Seq("desc(price)", "typo", "geo", "words", "filters", "proximity", "attribute", "exact", "custom"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody =
      parse("""{"ranking":["desc(price)","typo","geo","words","filters","proximity","attribute","exact","custom"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("ranking exhaustive (is_popular)36") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        ranking =
          Some(Seq("desc(is_popular)", "typo", "geo", "words", "filters", "proximity", "attribute", "exact", "custom"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"ranking":["desc(is_popular)","typo","geo","words","filters","proximity","attribute","exact","custom"]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("ranking standard replica37") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        ranking = Some(Seq("desc(post_date_timestamp)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"ranking":["desc(post_date_timestamp)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("ranking virtual replica38") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("desc(post_date_timestamp)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"customRanking":["desc(post_date_timestamp)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("customRanking and ranking sort alphabetically39") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("asc(textual_attribute)")),
        ranking = Some(Seq("custom", "typo", "geo", "words", "filters", "proximity", "attribute", "exact"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"customRanking":["asc(textual_attribute)"],"ranking":["custom","typo","geo","words","filters","proximity","attribute","exact"]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("relevancyStrictness40") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("asc(textual_attribute)")),
        relevancyStrictness = Some(0)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"customRanking":["asc(textual_attribute)"],"relevancyStrictness":0}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("create replica index41") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        replicas = Some(Seq("products_price_desc"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"replicas":["products_price_desc"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("create replica index articles42") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        replicas = Some(Seq("articles_date_desc"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"replicas":["articles_date_desc"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("create virtual replica index43") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        replicas = Some(Seq("virtual(products_price_desc)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"replicas":["virtual(products_price_desc)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("unlink replica index44") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        replicas = Some(Seq(""))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"replicas":[""]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("forwardToReplicas45") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("name", "description"))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["name","description"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("maxValuesPerFacet46") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        maxValuesPerFacet = Some(1000)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"maxValuesPerFacet":1000}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("maxFacetHits47") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        maxFacetHits = Some(100)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"maxFacetHits":100}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting complex48") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("actor", "filterOnly(category)", "searchable(publisher)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["actor","filterOnly(category)","searchable(publisher)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("ranking closest dates49") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        ranking = Some(
          Seq("asc(date_timestamp)", "typo", "geo", "words", "filters", "proximity", "attribute", "exact", "custom")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"ranking":["asc(date_timestamp)","typo","geo","words","filters","proximity","attribute","exact","custom"]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributes item variation50") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("design", "type", "color"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["design","type","color"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributes around location51") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("name", "country", "city", "iata_code")),
        customRanking = Some(Seq("desc(links_count)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody =
      parse("""{"searchableAttributes":["name","country","city","iata_code"],"customRanking":["desc(links_count)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesToHighlight52") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        attributesToHighlight = Some(Seq("author", "title", "content"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesToHighlight":["author","title","content"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesToHighlightStar53") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        attributesToHighlight = Some(Seq("*"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesToHighlight":["*"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("everything54") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        advancedSyntax = Some(true),
        advancedSyntaxFeatures = Some(Seq(AdvancedSyntaxFeatures.withName("exactPhrase"))),
        allowCompressionOfIntegerArray = Some(true),
        allowTyposOnNumericTokens = Some(true),
        alternativesAsExact = Some(Seq(AlternativesAsExact.withName("singleWordSynonym"))),
        attributeCriteriaComputedByMinProximity = Some(true),
        attributeForDistinct = Some("test"),
        attributesForFaceting = Some(Seq("algolia")),
        attributesToHighlight = Some(Seq("algolia")),
        attributesToRetrieve = Some(Seq("algolia")),
        attributesToSnippet = Some(Seq("algolia")),
        attributesToTransliterate = Some(Seq("algolia")),
        camelCaseAttributes = Some(Seq("algolia")),
        customNormalization = Some(Map("algolia" -> Map("aloglia" -> "aglolia"))),
        customRanking = Some(Seq("algolia")),
        decompoundQuery = Some(false),
        decompoundedAttributes = Some(JObject(List(JField("algolia", JString("aloglia"))))),
        disableExactOnAttributes = Some(Seq("algolia")),
        disablePrefixOnAttributes = Some(Seq("algolia")),
        disableTypoToleranceOnAttributes = Some(Seq("algolia")),
        disableTypoToleranceOnWords = Some(Seq("algolia")),
        distinct = Some(Distinct(3)),
        enablePersonalization = Some(true),
        enableReRanking = Some(false),
        enableRules = Some(true),
        exactOnSingleWordQuery = Some(ExactOnSingleWordQuery.withName("attribute")),
        highlightPreTag = Some("<span>"),
        highlightPostTag = Some("</span>"),
        hitsPerPage = Some(10),
        ignorePlurals = Some(IgnorePlurals(false)),
        indexLanguages = Some(Seq(SupportedLanguage.withName("fr"))),
        keepDiacriticsOnCharacters = Some("abc"),
        maxFacetHits = Some(20),
        maxValuesPerFacet = Some(30),
        minProximity = Some(6),
        minWordSizefor1Typo = Some(5),
        minWordSizefor2Typos = Some(11),
        mode = Some(Mode.withName("neuralSearch")),
        numericAttributesForFiltering = Some(Seq("algolia")),
        optionalWords = Some(OptionalWords(Seq("myspace"))),
        paginationLimitedTo = Some(0),
        queryLanguages = Some(Seq(SupportedLanguage.withName("fr"))),
        queryType = Some(QueryType.withName("prefixLast")),
        ranking = Some(Seq("geo")),
        reRankingApplyFilter = Some(ReRankingApplyFilter("mySearch:filters")),
        relevancyStrictness = Some(10),
        removeStopWords = Some(RemoveStopWords(false)),
        removeWordsIfNoResults = Some(RemoveWordsIfNoResults.withName("lastWords")),
        renderingContent = Some(
          RenderingContent(
            facetOrdering = Some(
              FacetOrdering(
                facets = Some(
                  Facets(
                    order = Some(Seq("a", "b"))
                  )
                ),
                values = Some(
                  Map(
                    "a" -> Value(
                      order = Some(Seq("b")),
                      sortRemainingBy = Some(SortRemainingBy.withName("count"))
                    )
                  )
                )
              )
            )
          )
        ),
        replaceSynonymsInHighlight = Some(true),
        replicas = Some(Seq("")),
        responseFields = Some(Seq("algolia")),
        restrictHighlightAndSnippetArrays = Some(true),
        searchableAttributes = Some(Seq("foo")),
        semanticSearch = Some(
          SemanticSearch(
            eventSources = Some(Seq("foo"))
          )
        ),
        separatorsToIndex = Some("bar"),
        snippetEllipsisText = Some("---"),
        sortFacetValuesBy = Some("date"),
        typoTolerance = Some(TypoTolerance(false)),
        unretrievableAttributes = Some(Seq("foo")),
        userData = Some(
          JObject(
            List(
              JField("user", JString("data"))
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"advancedSyntax":true,"advancedSyntaxFeatures":["exactPhrase"],"allowCompressionOfIntegerArray":true,"allowTyposOnNumericTokens":true,"alternativesAsExact":["singleWordSynonym"],"attributeCriteriaComputedByMinProximity":true,"attributeForDistinct":"test","attributesForFaceting":["algolia"],"attributesToHighlight":["algolia"],"attributesToRetrieve":["algolia"],"attributesToSnippet":["algolia"],"attributesToTransliterate":["algolia"],"camelCaseAttributes":["algolia"],"customNormalization":{"algolia":{"aloglia":"aglolia"}},"customRanking":["algolia"],"decompoundQuery":false,"decompoundedAttributes":{"algolia":"aloglia"},"disableExactOnAttributes":["algolia"],"disablePrefixOnAttributes":["algolia"],"disableTypoToleranceOnAttributes":["algolia"],"disableTypoToleranceOnWords":["algolia"],"distinct":3,"enablePersonalization":true,"enableReRanking":false,"enableRules":true,"exactOnSingleWordQuery":"attribute","highlightPreTag":"<span>","highlightPostTag":"</span>","hitsPerPage":10,"ignorePlurals":false,"indexLanguages":["fr"],"keepDiacriticsOnCharacters":"abc","maxFacetHits":20,"maxValuesPerFacet":30,"minProximity":6,"minWordSizefor1Typo":5,"minWordSizefor2Typos":11,"mode":"neuralSearch","numericAttributesForFiltering":["algolia"],"optionalWords":["myspace"],"paginationLimitedTo":0,"queryLanguages":["fr"],"queryType":"prefixLast","ranking":["geo"],"reRankingApplyFilter":"mySearch:filters","relevancyStrictness":10,"removeStopWords":false,"removeWordsIfNoResults":"lastWords","renderingContent":{"facetOrdering":{"facets":{"order":["a","b"]},"values":{"a":{"order":["b"],"sortRemainingBy":"count"}}}},"replaceSynonymsInHighlight":true,"replicas":[""],"responseFields":["algolia"],"restrictHighlightAndSnippetArrays":true,"searchableAttributes":["foo"],"semanticSearch":{"eventSources":["foo"]},"separatorsToIndex":"bar","snippetEllipsisText":"---","sortFacetValuesBy":"date","typoTolerance":false,"unretrievableAttributes":["foo"],"userData":{"user":"data"}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributesWithCustomRankingsAndAttributesForFaceting55") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("brand", "name", "categories", "unordered(description)")),
        customRanking = Some(Seq("desc(popularity)")),
        attributesForFaceting = Some(Seq("searchable(brand)", "type", "categories", "price"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"searchableAttributes":["brand","name","categories","unordered(description)"],"customRanking":["desc(popularity)"],"attributesForFaceting":["searchable(brand)","type","categories","price"]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributesOrdering56") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("unordered(title)", "cast"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["unordered(title)","cast"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributesProductReferenceSuffixes57") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("name", "product_reference", "product_reference_suffixes"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["name","product_reference","product_reference_suffixes"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("queryLanguageAndIgnorePlurals58") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        queryLanguages = Some(Seq(SupportedLanguage.withName("en"))),
        ignorePlurals = Some(IgnorePlurals(true))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"queryLanguages":["en"],"ignorePlurals":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributesInMovies59") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "movies",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("title_eng", "title_fr", "title_es"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/movies/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["title_eng","title_fr","title_es"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("disablePrefixOnAttributes60") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        disablePrefixOnAttributes = Some(Seq("serial_number"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"disablePrefixOnAttributes":["serial_number"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("disableTypoToleranceOnAttributes61") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        disableTypoToleranceOnAttributes = Some(Seq("serial_number"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"disableTypoToleranceOnAttributes":["serial_number"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributesSimpleExample62") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("serial_number"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["serial_number"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributesSimpleExampleAlt63") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("serial_number", "serial_number_suffixes"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["serial_number","serial_number_suffixes"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_searchable_attributes64") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("title,alternative_title", "author", "unordered(text)", "emails.personal"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody =
      parse("""{"searchableAttributes":["title,alternative_title","author","unordered(text)","emails.personal"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_attributes_for_faceting65") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(
          Seq(
            "author",
            "filterOnly(isbn)",
            "searchable(edition)",
            "afterDistinct(category)",
            "afterDistinct(searchable(publisher))"
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"attributesForFaceting":["author","filterOnly(isbn)","searchable(edition)","afterDistinct(category)","afterDistinct(searchable(publisher))"]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("unretrievable_attributes66") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        unretrievableAttributes = Some(Seq("total_number_of_sales"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"unretrievableAttributes":["total_number_of_sales"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_retrievable_attributes67") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        attributesToRetrieve = Some(Seq("author", "title", "content"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesToRetrieve":["author","title","content"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_all_attributes_as_retrievable68") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        attributesToRetrieve = Some(Seq("*"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesToRetrieve":["*"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("specify_attributes_not_to_retrieve69") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        attributesToRetrieve = Some(Seq("*", "-SKU", "-internal_desc"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesToRetrieve":["*","-SKU","-internal_desc"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("neural_search70") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        mode = Some(Mode.withName("neuralSearch"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"mode":"neuralSearch"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("keyword_search71") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        mode = Some(Mode.withName("keywordSearch"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"mode":"keywordSearch"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_ranking72") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        ranking = Some(Seq("typo", "geo", "words", "filters", "attribute", "proximity", "exact", "custom"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody =
      parse("""{"ranking":["typo","geo","words","filters","attribute","proximity","exact","custom"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_ranking_by_attribute_asc73") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        ranking =
          Some(Seq("asc(price)", "typo", "geo", "words", "filters", "proximity", "attribute", "exact", "custom"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody =
      parse("""{"ranking":["asc(price)","typo","geo","words","filters","proximity","attribute","exact","custom"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_ranking_by_attribute_desc74") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        ranking =
          Some(Seq("desc(price)", "typo", "geo", "words", "filters", "proximity", "attribute", "exact", "custom"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody =
      parse("""{"ranking":["desc(price)","typo","geo","words","filters","proximity","attribute","exact","custom"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_custom_ranking75") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("desc(popularity)", "asc(price)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"customRanking":["desc(popularity)","asc(price)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_relevancy76") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        relevancyStrictness = Some(90)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"relevancyStrictness":90}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_replicas77") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        replicas = Some(Seq("name_of_replica_index1", "name_of_replica_index2"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"replicas":["name_of_replica_index1","name_of_replica_index2"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_max_values_per_facet78") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        maxValuesPerFacet = Some(100)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"maxValuesPerFacet":100}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_sort_facet_values_by79") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        sortFacetValuesBy = Some("alpha")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"sortFacetValuesBy":"alpha"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_attributes_to_snippet80") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        attributesToSnippet = Some(Seq("content:80", "description"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesToSnippet":["content:80","description"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_all_attributes_to_snippet81") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        attributesToSnippet = Some(Seq("*:80"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesToSnippet":["*:80"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_highlight_pre_tag82") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        highlightPreTag = Some("<em>")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"highlightPreTag":"<em>"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_highlight_post_tag83") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        highlightPostTag = Some("</em>")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"highlightPostTag":"</em>"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_snippet_ellipsis_text84") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        snippetEllipsisText = Some("")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"snippetEllipsisText":""}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enable_restrict_highlight_and_snippet_arrays_by_default85") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        restrictHighlightAndSnippetArrays = Some(true)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"restrictHighlightAndSnippetArrays":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_hits_per_page86") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        hitsPerPage = Some(20)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"hitsPerPage":20}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_pagination_limit87") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        paginationLimitedTo = Some(1000)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"paginationLimitedTo":1000}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_min_word_size_for_one_typo88") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        minWordSizefor1Typo = Some(4)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"minWordSizefor1Typo":4}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_min_word_size_for_two_typos89") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        minWordSizefor2Typos = Some(4)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"minWordSizefor2Typos":4}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_typo_tolerance_mode90") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        typoTolerance = Some(TypoTolerance(true))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"typoTolerance":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("disable_typos_on_numeric_tokens_by_default91") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        allowTyposOnNumericTokens = Some(false)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"allowTyposOnNumericTokens":false}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("disable_typo_tolerance_for_words92") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        disableTypoToleranceOnWords = Some(Seq("wheel", "1X2BCD"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"disableTypoToleranceOnWords":["wheel","1X2BCD"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_separators_to_index93") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        separatorsToIndex = Some("+#")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"separatorsToIndex":"+#"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_querylanguage_ignoreplurals94") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        queryLanguages = Some(Seq(SupportedLanguage.withName("es"))),
        ignorePlurals = Some(IgnorePlurals(true))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"queryLanguages":["es"],"ignorePlurals":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_attributes_to_transliterate95") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        indexLanguages = Some(Seq(SupportedLanguage.withName("ja"))),
        attributesToTransliterate = Some(Seq("name", "description"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"indexLanguages":["ja"],"attributesToTransliterate":["name","description"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_querylanguage_removestopwords96") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        queryLanguages = Some(Seq(SupportedLanguage.withName("es"))),
        removeStopWords = Some(RemoveStopWords(true))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"queryLanguages":["es"],"removeStopWords":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_camel_case_attributes97") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        camelCaseAttributes = Some(Seq("description"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"camelCaseAttributes":["description"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_decompounded_attributes98") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        decompoundedAttributes = Some(JObject(List(JField("de", JArray(List(JString("name")))))))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"decompoundedAttributes":{"de":["name"]}}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_decompounded_multiple_attributes99") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        decompoundedAttributes = Some(
          JObject(
            List(
              JField("de", JArray(List(JString("name_de"), JString("description_de")))),
              JField("fi", JArray(List(JString("name_fi"), JString("description_fi"))))
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody =
      parse("""{"decompoundedAttributes":{"de":["name_de","description_de"],"fi":["name_fi","description_fi"]}}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_keep_diacritics_on_characters100") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        keepDiacriticsOnCharacters = Some("")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"keepDiacriticsOnCharacters":""}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_custom_normalization101") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customNormalization = Some(Map("default" -> Map("" -> "ae")))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"customNormalization":{"default":{"":"ae"}}}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_querylanguage_both102") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        queryLanguages = Some(Seq(SupportedLanguage.withName("es"))),
        removeStopWords = Some(RemoveStopWords(true)),
        ignorePlurals = Some(IgnorePlurals(true))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"queryLanguages":["es"],"removeStopWords":true,"ignorePlurals":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_indexlanguages103") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        indexLanguages = Some(Seq(SupportedLanguage.withName("ja")))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"indexLanguages":["ja"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enable_decompound_query_by_default104") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        decompoundQuery = Some(true)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"decompoundQuery":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enable_rules_syntax_by_default105") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        enableRules = Some(true)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"enableRules":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enable_personalization_settings106") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        enablePersonalization = Some(true)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"enablePersonalization":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_query_type107") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        queryType = Some(QueryType.withName("prefixLast"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"queryType":"prefixLast"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_remove_words_if_no_result108") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        removeWordsIfNoResults = Some(RemoveWordsIfNoResults.withName("none"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"removeWordsIfNoResults":"none"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enable_advanced_syntax_by_default109") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        advancedSyntax = Some(true)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"advancedSyntax":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_optional_words110") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        optionalWords = Some(OptionalWords(Seq("blue", "iphone case")))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"optionalWords":["blue","iphone case"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("disabling_prefix_search_for_some_attributes_by_default111") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        disablePrefixOnAttributes = Some(Seq("sku"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"disablePrefixOnAttributes":["sku"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("disabling_exact_for_some_attributes_by_default112") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        disableExactOnAttributes = Some(Seq("description"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"disableExactOnAttributes":["description"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_exact_single_word_query113") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        exactOnSingleWordQuery = Some(ExactOnSingleWordQuery.withName("attribute"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"exactOnSingleWordQuery":"attribute"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_aternative_as_exact114") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        alternativesAsExact =
          Some(Seq(AlternativesAsExact.withName("ignorePlurals"), AlternativesAsExact.withName("singleWordSynonym")))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"alternativesAsExact":["ignorePlurals","singleWordSynonym"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_numeric_attributes_for_filtering115") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        numericAttributesForFiltering = Some(Seq("quantity", "popularity"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"numericAttributesForFiltering":["quantity","popularity"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enable_compression_of_integer_array116") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        allowCompressionOfIntegerArray = Some(true)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"allowCompressionOfIntegerArray":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_attributes_for_distinct117") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        attributeForDistinct = Some("url")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributeForDistinct":"url"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_distinct118") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        distinct = Some(Distinct(1)),
        attributeForDistinct = Some("url")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"distinct":1,"attributeForDistinct":"url"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_replace_synonyms_in_highlights119") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        replaceSynonymsInHighlight = Some(false)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"replaceSynonymsInHighlight":false}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_min_proximity120") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        minProximity = Some(1)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"minProximity":1}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_default_field121") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        responseFields = Some(Seq("hits", "hitsPerPage", "nbPages", "page"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"responseFields":["hits","hitsPerPage","nbPages","page"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_max_facet_hits122") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        maxFacetHits = Some(10)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"maxFacetHits":10}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_attribute_criteria_computed_by_min_proximity123") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        attributeCriteriaComputedByMinProximity = Some(true)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributeCriteriaComputedByMinProximity":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_user_data124") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        userData = Some(
          JObject(
            List(
              JField("extraData", JString("This is the custom data that you want to store in your index"))
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody =
      parse("""{"userData":{"extraData":"This is the custom data that you want to store in your index"}}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("set_rendering_content125") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        renderingContent = Some(
          RenderingContent(
            facetOrdering = Some(
              FacetOrdering(
                facets = Some(
                  Facets(
                    order = Some(Seq("size", "brand"))
                  )
                ),
                values = Some(
                  Map(
                    "brand" -> Value(
                      order = Some(Seq("uniqlo")),
                      hide = Some(Seq("muji")),
                      sortRemainingBy = Some(SortRemainingBy.withName("count"))
                    ),
                    "size" -> Value(
                      order = Some(Seq("S", "M", "L")),
                      sortRemainingBy = Some(SortRemainingBy.withName("hidden"))
                    )
                  )
                )
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"renderingContent":{"facetOrdering":{"facets":{"order":["size","brand"]},"values":{"brand":{"order":["uniqlo"],"hide":["muji"],"sortRemainingBy":"count"},"size":{"order":["S","M","L"],"sortRemainingBy":"hidden"}}}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("updateApiKey") {
    val (client, echo) = testClient()
    val future = client.updateApiKey(
      key = "ALGOLIA_API_KEY",
      apiKey = ApiKey(
        acl = Seq(Acl.withName("search"), Acl.withName("addObject")),
        validity = Some(300),
        maxQueriesPerIPPerHour = Some(100),
        maxHitsPerQuery = Some(20)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/keys/ALGOLIA_API_KEY")
    assert(res.method == "PUT")
    val expectedBody =
      parse("""{"acl":["search","addObject"],"validity":300,"maxQueriesPerIPPerHour":100,"maxHitsPerQuery":20}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

}
