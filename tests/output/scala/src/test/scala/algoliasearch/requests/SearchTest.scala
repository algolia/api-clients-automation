// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package algoliasearch.requests

import algoliasearch.EchoInterceptor
import algoliasearch.api.SearchClient
import algoliasearch.config.*
import algoliasearch.search.*
import org.json4s.*
import org.json4s.native.JsonParser.*
import org.scalatest.funsuite.AnyFunSuite

import java.util.concurrent.TimeUnit
import scala.concurrent.duration.Duration
import scala.concurrent.{Await, ExecutionContextExecutor}

class SearchTest extends AnyFunSuite {
  implicit val ec: ExecutionContextExecutor = scala.concurrent.ExecutionContext.global
  implicit val formats: Formats = org.json4s.DefaultFormats

  def testClient(): (SearchClient, EchoInterceptor) = {
    val echo = EchoInterceptor()
    (
      SearchClient(
        appId = "appId",
        apiKey = "apiKey",
        clientOptions = ClientOptions
          .builder()
          .withRequesterConfig(requester => requester.withInterceptor(echo))
          .build()
      ),
      echo
    )
  }

  test("addApiKey") {
    val (client, echo) = testClient()
    val future = client.addApiKey(
      apiKey = ApiKey(
        acl = Seq(Acl.withName("search"), Acl.withName("addObject")),
        description = Some("my new api key"),
        validity = Some(300),
        maxQueriesPerIPPerHour = Some(100),
        maxHitsPerQuery = Some(20)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/keys")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"acl":["search","addObject"],"description":"my new api key","validity":300,"maxQueriesPerIPPerHour":100,"maxHitsPerQuery":20}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("addOrUpdateObject") {
    val (client, echo) = testClient()
    val future = client.addOrUpdateObject(
      indexName = "indexName",
      objectID = "uniqueID",
      body = JObject(List(JField("key", JString("value"))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/uniqueID")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"key":"value"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("appendSource") {
    val (client, echo) = testClient()
    val future = client.appendSource(
      source = Source(
        source = "theSource",
        description = Some("theDescription")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/security/sources/append")
    assert(res.method == "POST")
    val expectedBody = parse("""{"source":"theSource","description":"theDescription"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("simple") {
    val (client, echo) = testClient()
    val future = client.assignUserId(
      xAlgoliaUserID = "user42",
      assignUserIdParams = AssignUserIdParams(
        cluster = "d4242-eu"
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping")
    assert(res.method == "POST")
    val expectedBody = parse("""{"cluster":"d4242-eu"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedHeaders = parse("""{"x-algolia-user-id":"user42"}""").asInstanceOf[JObject].obj.toMap
    val actualHeaders = res.headers
    for ((k, v) <- expectedHeaders) {
      assert(actualHeaders.contains(k))
      assert(actualHeaders(k) == v.asInstanceOf[JString].s)
    }
  }

  test("it should not encode the userID1") {
    val (client, echo) = testClient()
    val future = client.assignUserId(
      xAlgoliaUserID = "user id with spaces",
      assignUserIdParams = AssignUserIdParams(
        cluster = "cluster with spaces"
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping")
    assert(res.method == "POST")
    val expectedBody = parse("""{"cluster":"cluster with spaces"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedHeaders = parse("""{"x-algolia-user-id":"user id with spaces"}""").asInstanceOf[JObject].obj.toMap
    val actualHeaders = res.headers
    for ((k, v) <- expectedHeaders) {
      assert(actualHeaders.contains(k))
      assert(actualHeaders(k) == v.asInstanceOf[JString].s)
    }
  }

  test("addObject") {
    val (client, echo) = testClient()
    val future = client.batch(
      indexName = "<YOUR_INDEX_NAME>",
      batchWriteParams = BatchWriteParams(
        requests = Seq(
          BatchRequest(
            action = Action.withName("addObject"),
            body = JObject(List(JField("key", JString("bar")), JField("foo", JString("1"))))
          ),
          BatchRequest(
            action = Action.withName("addObject"),
            body = JObject(List(JField("key", JString("baz")), JField("foo", JString("2"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"action":"addObject","body":{"key":"bar","foo":"1"}},{"action":"addObject","body":{"key":"baz","foo":"2"}}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("clear1") {
    val (client, echo) = testClient()
    val future = client.batch(
      indexName = "<YOUR_INDEX_NAME>",
      batchWriteParams = BatchWriteParams(
        requests = Seq(
          BatchRequest(
            action = Action.withName("clear"),
            body = JObject(List(JField("key", JString("value"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch")
    assert(res.method == "POST")
    val expectedBody = parse("""{"requests":[{"action":"clear","body":{"key":"value"}}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("delete2") {
    val (client, echo) = testClient()
    val future = client.batch(
      indexName = "<YOUR_INDEX_NAME>",
      batchWriteParams = BatchWriteParams(
        requests = Seq(
          BatchRequest(
            action = Action.withName("delete"),
            body = JObject(List(JField("key", JString("value"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch")
    assert(res.method == "POST")
    val expectedBody = parse("""{"requests":[{"action":"delete","body":{"key":"value"}}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("deleteObject3") {
    val (client, echo) = testClient()
    val future = client.batch(
      indexName = "<YOUR_INDEX_NAME>",
      batchWriteParams = BatchWriteParams(
        requests = Seq(
          BatchRequest(
            action = Action.withName("deleteObject"),
            body = JObject(List(JField("key", JString("value"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch")
    assert(res.method == "POST")
    val expectedBody = parse("""{"requests":[{"action":"deleteObject","body":{"key":"value"}}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("partialUpdateObject4") {
    val (client, echo) = testClient()
    val future = client.batch(
      indexName = "<YOUR_INDEX_NAME>",
      batchWriteParams = BatchWriteParams(
        requests = Seq(
          BatchRequest(
            action = Action.withName("partialUpdateObject"),
            body = JObject(List(JField("key", JString("value"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch")
    assert(res.method == "POST")
    val expectedBody = parse("""{"requests":[{"action":"partialUpdateObject","body":{"key":"value"}}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("partialUpdateObjectNoCreate5") {
    val (client, echo) = testClient()
    val future = client.batch(
      indexName = "<YOUR_INDEX_NAME>",
      batchWriteParams = BatchWriteParams(
        requests = Seq(
          BatchRequest(
            action = Action.withName("partialUpdateObjectNoCreate"),
            body = JObject(List(JField("key", JString("value"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch")
    assert(res.method == "POST")
    val expectedBody = parse("""{"requests":[{"action":"partialUpdateObjectNoCreate","body":{"key":"value"}}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("updateObject6") {
    val (client, echo) = testClient()
    val future = client.batch(
      indexName = "<YOUR_INDEX_NAME>",
      batchWriteParams = BatchWriteParams(
        requests = Seq(
          BatchRequest(
            action = Action.withName("updateObject"),
            body = JObject(List(JField("key", JString("value"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch")
    assert(res.method == "POST")
    val expectedBody = parse("""{"requests":[{"action":"updateObject","body":{"key":"value"}}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("batchAssignUserIds") {
    val (client, echo) = testClient()
    val future = client.batchAssignUserIds(
      xAlgoliaUserID = "userID",
      batchAssignUserIdsParams = BatchAssignUserIdsParams(
        cluster = "theCluster",
        users = Seq("user1", "user2")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping/batch")
    assert(res.method == "POST")
    val expectedBody = parse("""{"cluster":"theCluster","users":["user1","user2"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedHeaders = parse("""{"x-algolia-user-id":"userID"}""").asInstanceOf[JObject].obj.toMap
    val actualHeaders = res.headers
    for ((k, v) <- expectedHeaders) {
      assert(actualHeaders.contains(k))
      assert(actualHeaders(k) == v.asInstanceOf[JString].s)
    }
  }

  test("replace") {
    val (client, echo) = testClient()
    val future = client.batchDictionaryEntries(
      dictionaryName = DictionaryType.withName("plurals"),
      batchDictionaryEntriesParams = BatchDictionaryEntriesParams(
        clearExistingDictionaryEntries = Some(true),
        requests = Seq(
          BatchDictionaryEntriesRequest(
            action = DictionaryAction.withName("addEntry"),
            body = DictionaryEntry(
              objectID = "1",
              language = Some(SupportedLanguage.withName("en")),
              word = Some("fancy"),
              words = Some(Seq("believe", "algolia")),
              decomposition = Some(Seq("trust", "algolia")),
              state = Some(DictionaryEntryState.withName("enabled"))
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/plurals/batch")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"clearExistingDictionaryEntries":true,"requests":[{"action":"addEntry","body":{"objectID":"1","language":"en","word":"fancy","words":["believe","algolia"],"decomposition":["trust","algolia"],"state":"enabled"}}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("delete1") {
    val (client, echo) = testClient()
    val future = client.batchDictionaryEntries(
      dictionaryName = DictionaryType.withName("plurals"),
      batchDictionaryEntriesParams = BatchDictionaryEntriesParams(
        clearExistingDictionaryEntries = Some(true),
        requests = Seq(
          BatchDictionaryEntriesRequest(
            action = DictionaryAction.withName("deleteEntry"),
            body = DictionaryEntry(
              objectID = "1"
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/plurals/batch")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"clearExistingDictionaryEntries":true,"requests":[{"action":"deleteEntry","body":{"objectID":"1"}}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("append2") {
    val (client, echo) = testClient()
    val future = client.batchDictionaryEntries(
      dictionaryName = DictionaryType.withName("stopwords"),
      batchDictionaryEntriesParams = BatchDictionaryEntriesParams(
        requests = Seq(
          BatchDictionaryEntriesRequest(
            action = DictionaryAction.withName("addEntry"),
            body = DictionaryEntry(
              objectID = "1",
              language = Some(SupportedLanguage.withName("en")),
              additionalProperties = Some(List(JField("additional", JString("try me"))))
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/stopwords/batch")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"requests":[{"action":"addEntry","body":{"objectID":"1","language":"en","additional":"try me"}}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("browse with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.browse(
      indexName = "cts_e2e_browse"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/cts_e2e_browse/browse")
    assert(res.method == "POST")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("browse with search parameters1") {
    val (client, echo) = testClient()
    val future = client.browse(
      indexName = "indexName",
      browseParams = Some(
        BrowseParamsObject(
          query = Some("myQuery"),
          facetFilters = Some(FacetFilters(Seq(FacetFilters("tags:algolia"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/browse")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"myQuery","facetFilters":["tags:algolia"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("browse allow a cursor in parameters2") {
    val (client, echo) = testClient()
    val future = client.browse(
      indexName = "indexName",
      browseParams = Some(
        BrowseParamsObject(
          cursor = Some("test")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/browse")
    assert(res.method == "POST")
    val expectedBody = parse("""{"cursor":"test"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("clearObjects") {
    val (client, echo) = testClient()
    val future = client.clearObjects(
      indexName = "theIndexName"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/clear")
    assert(res.method == "POST")
    assert(res.body.contains("{}"))
  }

  test("clearRules") {
    val (client, echo) = testClient()
    val future = client.clearRules(
      indexName = "indexName"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/clear")
    assert(res.method == "POST")
    assert(res.body.contains("{}"))
  }

  test("clearSynonyms") {
    val (client, echo) = testClient()
    val future = client.clearSynonyms(
      indexName = "indexName"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/synonyms/clear")
    assert(res.method == "POST")
    assert(res.body.contains("{}"))
  }

  test("allow del method for a custom path with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.customDelete[JObject](
      path = "test/minimal"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/minimal")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("allow del method for a custom path with all parameters1") {
    val (client, echo) = testClient()
    val future = client.customDelete[JObject](
      path = "test/all",
      parameters = Some(Map("query" -> "parameters"))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/all")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"query":"parameters"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("allow get method for a custom path with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.customGet[JObject](
      path = "test/minimal"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/minimal")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("allow get method for a custom path with all parameters1") {
    val (client, echo) = testClient()
    val future = client.customGet[JObject](
      path = "test/all",
      parameters = Some(Map("query" -> "parameters with space"))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/all")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"query":"parameters%20with%20space"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions should be escaped too2") {
    val (client, echo) = testClient()
    val future = client.customGet[JObject](
      path = "test/all",
      parameters = Some(Map("query" -> "to be overriden")),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("query", "parameters with space")
          .withQueryParameter("and an array", Seq("array", "with spaces"))
          .withHeader("x-header-1", "spaces are left alone")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/all")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"query":"parameters%20with%20space","and%20an%20array":"array%2Cwith%20spaces"}""")
      .asInstanceOf[JObject]
      .obj
      .toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
    val expectedHeaders = parse("""{"x-header-1":"spaces are left alone"}""").asInstanceOf[JObject].obj.toMap
    val actualHeaders = res.headers
    for ((k, v) <- expectedHeaders) {
      assert(actualHeaders.contains(k))
      assert(actualHeaders(k) == v.asInstanceOf[JString].s)
    }
  }

  test("allow post method for a custom path with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/minimal"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/minimal")
    assert(res.method == "POST")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("allow post method for a custom path with all parameters1") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/all",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("body", JString("parameters")))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/all")
    assert(res.method == "POST")
    val expectedBody = parse("""{"body":"parameters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions can override default query parameters2") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("query", "myQueryParameter")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"myQueryParameter"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions merges query parameters with default ones3") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("query2", "myQueryParameter")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters","query2":"myQueryParameter"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions can override default headers4") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withHeader("x-algolia-api-key", "ALGOLIA_API_KEY")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
    val expectedHeaders = parse("""{"x-algolia-api-key":"ALGOLIA_API_KEY"}""").asInstanceOf[JObject].obj.toMap
    val actualHeaders = res.headers
    for ((k, v) <- expectedHeaders) {
      assert(actualHeaders.contains(k))
      assert(actualHeaders(k) == v.asInstanceOf[JString].s)
    }
  }

  test("requestOptions merges headers with default ones5") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withHeader("x-algolia-api-key", "ALGOLIA_API_KEY")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
    val expectedHeaders = parse("""{"x-algolia-api-key":"ALGOLIA_API_KEY"}""").asInstanceOf[JObject].obj.toMap
    val actualHeaders = res.headers
    for ((k, v) <- expectedHeaders) {
      assert(actualHeaders.contains(k))
      assert(actualHeaders(k) == v.asInstanceOf[JString].s)
    }
  }

  test("requestOptions queryParameters accepts booleans6") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("isItWorking", true)
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters","isItWorking":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions queryParameters accepts integers7") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("myParam", 2)
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters","myParam":"2"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions queryParameters accepts list of string8") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("myParam", Seq("b and c", "d"))
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters","myParam":"b%20and%20c%2Cd"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions queryParameters accepts list of booleans9") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("myParam", Seq(true, true, false))
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery =
      parse("""{"query":"parameters","myParam":"true%2Ctrue%2Cfalse"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions queryParameters accepts list of integers10") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("myParam", Seq(1, 2))
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters","myParam":"1%2C2"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("allow put method for a custom path with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.customPut[JObject](
      path = "test/minimal"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/minimal")
    assert(res.method == "PUT")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("allow put method for a custom path with all parameters1") {
    val (client, echo) = testClient()
    val future = client.customPut[JObject](
      path = "test/all",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("body", JString("parameters")))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/all")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"body":"parameters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("deleteApiKey") {
    val (client, echo) = testClient()
    val future = client.deleteApiKey(
      key = "myTestApiKey"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/keys/myTestApiKey")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("deleteBy") {
    val (client, echo) = testClient()
    val future = client.deleteBy(
      indexName = "theIndexName",
      deleteByParams = DeleteByParams(
        filters = Some("brand:brandName")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/deleteByQuery")
    assert(res.method == "POST")
    val expectedBody = parse("""{"filters":"brand:brandName"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("deleteIndex") {
    val (client, echo) = testClient()
    val future = client.deleteIndex(
      indexName = "theIndexName"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("deleteObject") {
    val (client, echo) = testClient()
    val future = client.deleteObject(
      indexName = "<YOUR_INDEX_NAME>",
      objectID = "uniqueID"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/uniqueID")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("delete rule simple case") {
    val (client, echo) = testClient()
    val future = client.deleteRule(
      indexName = "indexName",
      objectID = "id1"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/id1")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("delete rule with simple characters to encode in objectID1") {
    val (client, echo) = testClient()
    val future = client.deleteRule(
      indexName = "indexName",
      objectID = "test/with/slash"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/test%2Fwith%2Fslash")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("deleteSource") {
    val (client, echo) = testClient()
    val future = client.deleteSource(
      source = "theSource"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/security/sources/theSource")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("deleteSynonym") {
    val (client, echo) = testClient()
    val future = client.deleteSynonym(
      indexName = "indexName",
      objectID = "id1"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/synonyms/id1")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("getApiKey") {
    val (client, echo) = testClient()
    val future = client.getApiKey(
      key = "myTestApiKey"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/keys/myTestApiKey")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getAppTask") {
    val (client, echo) = testClient()
    val future = client.getAppTask(
      taskID = 123L
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/task/123")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("get getDictionaryLanguages") {
    val (client, echo) = testClient()
    val future = client.getDictionaryLanguages(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/*/languages")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("get getDictionarySettings results") {
    val (client, echo) = testClient()
    val future = client.getDictionarySettings(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/*/settings")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getLogs with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.getLogs(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/logs")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getLogs with parameters1") {
    val (client, echo) = testClient()
    val future = client.getLogs(
      offset = Some(5),
      length = Some(10),
      indexName = Some("theIndexName"),
      `type` = Some(LogType.withName("all"))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/logs")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery =
      parse("""{"offset":"5","length":"10","indexName":"theIndexName","type":"all"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("getObject") {
    val (client, echo) = testClient()
    val future = client.getObject(
      indexName = "theIndexName",
      objectID = "uniqueID",
      attributesToRetrieve = Some(Seq("attr1", "attr2"))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/uniqueID")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"attributesToRetrieve":"attr1%2Cattr2"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("search with a real object1") {
    val (client, echo) = testClient()
    val future = client.getObject(
      indexName = "cts_e2e_browse",
      objectID = "Batman and Robin"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/cts_e2e_browse/Batman%20and%20Robin")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getObjects") {
    val (client, echo) = testClient()
    val future = client.getObjects(
      getObjectsParams = GetObjectsParams(
        requests = Seq(
          GetObjectsRequest(
            attributesToRetrieve = Some(Seq("attr1", "attr2")),
            objectID = "uniqueID",
            indexName = "theIndexName"
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/objects")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"attributesToRetrieve":["attr1","attr2"],"objectID":"uniqueID","indexName":"theIndexName"}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("getRule") {
    val (client, echo) = testClient()
    val future = client.getRule(
      indexName = "cts_e2e_browse",
      objectID = "qr-1725004648916"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/cts_e2e_browse/rules/qr-1725004648916")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getSettings") {
    val (client, echo) = testClient()
    val future = client.getSettings(
      indexName = "cts_e2e_settings"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/cts_e2e_settings/settings")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getSources") {
    val (client, echo) = testClient()
    val future = client.getSources(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/security/sources")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getSynonym") {
    val (client, echo) = testClient()
    val future = client.getSynonym(
      indexName = "indexName",
      objectID = "id1"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/synonyms/id1")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getTask") {
    val (client, echo) = testClient()
    val future = client.getTask(
      indexName = "theIndexName",
      taskID = 123L
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/task/123")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getTopUserIds") {
    val (client, echo) = testClient()
    val future = client.getTopUserIds(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping/top")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getUserId") {
    val (client, echo) = testClient()
    val future = client.getUserId(
      userID = "uniqueID"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping/uniqueID")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("hasPendingMappings with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.hasPendingMappings(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping/pending")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("hasPendingMappings with parameters1") {
    val (client, echo) = testClient()
    val future = client.hasPendingMappings(
      getClusters = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping/pending")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"getClusters":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("listApiKeys") {
    val (client, echo) = testClient()
    val future = client.listApiKeys(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/keys")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("listClusters") {
    val (client, echo) = testClient()
    val future = client.listClusters(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("listIndices with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.listIndices(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("listIndices with parameters1") {
    val (client, echo) = testClient()
    val future = client.listIndices(
      page = Some(8),
      hitsPerPage = Some(3)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"page":"8","hitsPerPage":"3"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("listUserIds with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.listUserIds(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("listUserIds with parameters1") {
    val (client, echo) = testClient()
    val future = client.listUserIds(
      page = Some(8),
      hitsPerPage = Some(100)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"page":"8","hitsPerPage":"100"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("multipleBatch") {
    val (client, echo) = testClient()
    val future = client.multipleBatch(
      batchParams = BatchParams(
        requests = Seq(
          MultipleBatchRequest(
            action = Action.withName("addObject"),
            body = Some(JObject(List(JField("key", JString("value"))))),
            indexName = "theIndexName"
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/batch")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"requests":[{"action":"addObject","body":{"key":"value"},"indexName":"theIndexName"}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("scopes") {
    val (client, echo) = testClient()
    val future = client.operationIndex(
      indexName = "<SOURCE_INDEX_NAME>",
      operationIndexParams = OperationIndexParams(
        operation = OperationType.withName("move"),
        destination = "<DESTINATION_INDEX_NAME>",
        scope = Some(Seq(ScopeType.withName("rules"), ScopeType.withName("settings")))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"operation":"move","destination":"<DESTINATION_INDEX_NAME>","scope":["rules","settings"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("copy1") {
    val (client, echo) = testClient()
    val future = client.operationIndex(
      indexName = "<SOURCE_INDEX_NAME>",
      operationIndexParams = OperationIndexParams(
        operation = OperationType.withName("copy"),
        destination = "<DESTINATION_INDEX_NAME>"
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation")
    assert(res.method == "POST")
    val expectedBody = parse("""{"operation":"copy","destination":"<DESTINATION_INDEX_NAME>"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("move2") {
    val (client, echo) = testClient()
    val future = client.operationIndex(
      indexName = "<SOURCE_INDEX_NAME>",
      operationIndexParams = OperationIndexParams(
        operation = OperationType.withName("move"),
        destination = "<DESTINATION_INDEX_NAME>"
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation")
    assert(res.method == "POST")
    val expectedBody = parse("""{"operation":"move","destination":"<DESTINATION_INDEX_NAME>"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("Partial update with a new value for a string attribute") {
    val (client, echo) = testClient()
    val future = client.partialUpdateObject(
      indexName = "theIndexName",
      objectID = "uniqueID",
      attributesToUpdate = JObject(List(JField("attributeId", JString("new value"))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/uniqueID/partial")
    assert(res.method == "POST")
    val expectedBody = parse("""{"attributeId":"new value"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("Partial update with a new value for an integer attribute1") {
    val (client, echo) = testClient()
    val future = client.partialUpdateObject(
      indexName = "theIndexName",
      objectID = "uniqueID",
      attributesToUpdate = JObject(List(JField("attributeId", JInt(1))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/uniqueID/partial")
    assert(res.method == "POST")
    val expectedBody = parse("""{"attributeId":1}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("Partial update with a new value for a boolean attribute2") {
    val (client, echo) = testClient()
    val future = client.partialUpdateObject(
      indexName = "theIndexName",
      objectID = "uniqueID",
      attributesToUpdate = JObject(List(JField("attributeId", JBool(true))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/uniqueID/partial")
    assert(res.method == "POST")
    val expectedBody = parse("""{"attributeId":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("Partial update with a new value for an array attribute3") {
    val (client, echo) = testClient()
    val future = client.partialUpdateObject(
      indexName = "theIndexName",
      objectID = "uniqueID",
      attributesToUpdate =
        JObject(List(JField("attributeId", JArray(List(JString("one"), JString("two"), JString("three"))))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/uniqueID/partial")
    assert(res.method == "POST")
    val expectedBody = parse("""{"attributeId":["one","two","three"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("Partial update with a new value for an object attribute4") {
    val (client, echo) = testClient()
    val future = client.partialUpdateObject(
      indexName = "theIndexName",
      objectID = "uniqueID",
      attributesToUpdate = JObject(List(JField("attributeId", JObject(List(JField("nested", JString("value")))))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/uniqueID/partial")
    assert(res.method == "POST")
    val expectedBody = parse("""{"attributeId":{"nested":"value"}}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("with visible_by filter5") {
    val (client, echo) = testClient()
    val future = client.partialUpdateObject(
      indexName = "theIndexName",
      objectID = "uniqueID",
      attributesToUpdate = JObject(
        List(
          JField("visible_by", JArray(List(JString("Angela"), JString("group/Finance"), JString("group/Shareholders"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/uniqueID/partial")
    assert(res.method == "POST")
    val expectedBody = parse("""{"visible_by":["Angela","group/Finance","group/Shareholders"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("removeUserId") {
    val (client, echo) = testClient()
    val future = client.removeUserId(
      userID = "uniqueID"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping/uniqueID")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("replaceSources") {
    val (client, echo) = testClient()
    val future = client.replaceSources(
      source = Seq(
        Source(
          source = "theSource",
          description = Some("theDescription")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/security/sources")
    assert(res.method == "PUT")
    val expectedBody = parse("""[{"source":"theSource","description":"theDescription"}]""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("restoreApiKey") {
    val (client, echo) = testClient()
    val future = client.restoreApiKey(
      key = "ALGOLIA_API_KEY"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/keys/ALGOLIA_API_KEY/restore")
    assert(res.method == "POST")
    assert(res.body.contains("{}"))
  }

  test("saveObject") {
    val (client, echo) = testClient()
    val future = client.saveObject(
      indexName = "<YOUR_INDEX_NAME>",
      body = JObject(List(JField("objectID", JString("id")), JField("test", JString("val"))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E")
    assert(res.method == "POST")
    val expectedBody = parse("""{"objectID":"id","test":"val"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("saveRule with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "id1",
      rule = Rule(
        objectID = "id1",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("apple"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              filters = Some("brand:xiaomi")
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/id1")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains"}],"consequence":{"params":{"filters":"brand:xiaomi"}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("saveRule with all parameters1") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "id1",
      rule = Rule(
        objectID = "id1",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("apple"),
              anchoring = Some(Anchoring.withName("contains")),
              alternatives = Some(false),
              context = Some("search")
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              filters = Some("brand:apple"),
              query = Some(
                ConsequenceQueryObject(
                  remove = Some(Seq("algolia")),
                  edits = Some(
                    Seq(
                      Edit(
                        `type` = Some(EditType.withName("remove")),
                        delete = Some("abc"),
                        insert = Some("cde")
                      ),
                      Edit(
                        `type` = Some(EditType.withName("replace")),
                        delete = Some("abc"),
                        insert = Some("cde")
                      )
                    )
                  )
                )
              )
            )
          ),
          hide = Some(
            Seq(
              ConsequenceHide(
                objectID = "321"
              )
            )
          ),
          filterPromotes = Some(false),
          userData = Some(JObject(List(JField("algolia", JString("aloglia"))))),
          promote = Some(
            Seq(
              PromoteObjectID(
                objectID = "abc",
                position = 3
              ),
              PromoteObjectIDs(
                objectIDs = Seq("abc", "def"),
                position = 1
              )
            )
          )
        ),
        description = Some("test"),
        enabled = Some(true),
        validity = Some(
          Seq(
            TimeRange(
              from = 1656670273L,
              until = 1656670277L
            )
          )
        )
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/id1")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains","alternatives":false,"context":"search"}],"consequence":{"params":{"filters":"brand:apple","query":{"remove":["algolia"],"edits":[{"type":"remove","delete":"abc","insert":"cde"},{"type":"replace","delete":"abc","insert":"cde"}]}},"hide":[{"objectID":"321"}],"filterPromotes":false,"userData":{"algolia":"aloglia"},"promote":[{"objectID":"abc","position":3},{"objectIDs":["abc","def"],"position":1}]},"description":"test","enabled":true,"validity":[{"from":1656670273,"until":1656670277}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("b2b catalog2") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "article-rule",
      rule = Rule(
        objectID = "article-rule",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("article"),
              anchoring = Some(Anchoring.withName("startsWith"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              query = Some(
                ConsequenceQueryObject(
                  edits = Some(
                    Seq(
                      Edit(
                        `type` = Some(EditType.withName("remove")),
                        delete = Some("article")
                      )
                    )
                  )
                )
              ),
              restrictSearchableAttributes = Some(Seq("title", "book_id"))
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/article-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"article-rule","conditions":[{"pattern":"article","anchoring":"startsWith"}],"consequence":{"params":{"query":{"edits":[{"type":"remove","delete":"article"}]},"restrictSearchableAttributes":["title","book_id"]}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("merchandising and promoting3") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "director-rule",
      rule = Rule(
        objectID = "director-rule",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("{facet:director} director"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              restrictSearchableAttributes = Some(Seq("title", "book_id")),
              automaticFacetFilters = Some(
                AutomaticFacetFilters(
                  Seq(
                    AutomaticFacetFilter(
                      facet = "director"
                    )
                  )
                )
              ),
              query = Some(
                ConsequenceQueryObject(
                  edits = Some(
                    Seq(
                      Edit(
                        `type` = Some(EditType.withName("remove")),
                        delete = Some("director")
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/director-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"director-rule","conditions":[{"pattern":"{facet:director} director","anchoring":"contains"}],"consequence":{"params":{"restrictSearchableAttributes":["title","book_id"],"automaticFacetFilters":[{"facet":"director"}],"query":{"edits":[{"type":"remove","delete":"director"}]}}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("harry potter4") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "harry-potter-rule",
      rule = Rule(
        objectID = "harry-potter-rule",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("harry potter"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          userData = Some(JObject(List(JField("promo_content", JString("20% OFF on all Harry Potter books!")))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/harry-potter-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"harry-potter-rule","conditions":[{"pattern":"harry potter","anchoring":"contains"}],"consequence":{"userData":{"promo_content":"20% OFF on all Harry Potter books!"}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("merchandising empty query5") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "clearance-category-filter",
      rule = Rule(
        objectID = "clearance-category-filter",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some(""),
              anchoring = Some(Anchoring.withName("is")),
              context = Some("landing")
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              optionalFilters = Some(OptionalFilters("clearance:true"))
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/clearance-category-filter")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"clearance-category-filter","conditions":[{"pattern":"","anchoring":"is","context":"landing"}],"consequence":{"params":{"optionalFilters":"clearance:true"}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("redirect6") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "redirect-help-rule",
      rule = Rule(
        objectID = "redirect-help-rule",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("help"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          userData = Some(JObject(List(JField("redirect", JString("https://www.algolia.com/support")))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/redirect-help-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"redirect-help-rule","conditions":[{"pattern":"help","anchoring":"contains"}],"consequence":{"userData":{"redirect":"https://www.algolia.com/support"}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("promote some results over others7") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "tomato-fruit",
      rule = Rule(
        objectID = "tomato-fruit",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("tomato"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              optionalFilters = Some(OptionalFilters("food_group:fruit"))
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/tomato-fruit")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"tomato-fruit","conditions":[{"pattern":"tomato","anchoring":"contains"}],"consequence":{"params":{"optionalFilters":"food_group:fruit"}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("promote several hits8") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "Promote-Apple-Newest",
      rule = Rule(
        objectID = "Promote-Apple-Newest",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("apple"),
              anchoring = Some(Anchoring.withName("is"))
            )
          )
        ),
        consequence = Consequence(
          promote = Some(
            Seq(
              PromoteObjectIDs(
                objectIDs = Seq("iPhone-12345", "watch-123"),
                position = 0
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/Promote-Apple-Newest")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"Promote-Apple-Newest","conditions":[{"pattern":"apple","anchoring":"is"}],"consequence":{"promote":[{"objectIDs":["iPhone-12345","watch-123"],"position":0}]}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("promote newest release9") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "Promote-iPhone-X",
      rule = Rule(
        objectID = "Promote-iPhone-X",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("iPhone"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          promote = Some(
            Seq(
              PromoteObjectID(
                objectID = "iPhone-12345",
                position = 0
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/Promote-iPhone-X")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"Promote-iPhone-X","conditions":[{"pattern":"iPhone","anchoring":"contains"}],"consequence":{"promote":[{"objectID":"iPhone-12345","position":0}]}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("promote single item10") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "promote-harry-potter-box-set",
      rule = Rule(
        objectID = "promote-harry-potter-box-set",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("Harry Potter"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          promote = Some(
            Seq(
              PromoteObjectID(
                objectID = "HP-12345",
                position = 0
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/promote-harry-potter-box-set")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"promote-harry-potter-box-set","conditions":[{"pattern":"Harry Potter","anchoring":"contains"}],"consequence":{"promote":[{"objectID":"HP-12345","position":0}]}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("limit search results11") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "article-rule",
      rule = Rule(
        objectID = "article-rule",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("article"),
              anchoring = Some(Anchoring.withName("startsWith"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              query = Some(
                ConsequenceQueryObject(
                  edits = Some(
                    Seq(
                      Edit(
                        `type` = Some(EditType.withName("remove")),
                        delete = Some("article")
                      )
                    )
                  )
                )
              ),
              restrictSearchableAttributes = Some(Seq("title", "book_id"))
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/article-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"article-rule","conditions":[{"pattern":"article","anchoring":"startsWith"}],"consequence":{"params":{"query":{"edits":[{"type":"remove","delete":"article"}]},"restrictSearchableAttributes":["title","book_id"]}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("query match12") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "tagged-brand-rule",
      rule = Rule(
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("brand: {facet:brand}"),
              anchoring = Some(Anchoring.withName("contains")),
              alternatives = Some(false)
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              automaticFacetFilters = Some(
                AutomaticFacetFilters(
                  Seq(
                    AutomaticFacetFilter(
                      facet = "brand"
                    )
                  )
                )
              ),
              query = Some(
                ConsequenceQueryObject(
                  remove = Some(Seq("brand:", "{facet:brand}"))
                )
              )
            )
          )
        ),
        description = Some("filter on brand: {brand}"),
        objectID = "tagged-brand-rule"
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/tagged-brand-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"conditions":[{"pattern":"brand: {facet:brand}","anchoring":"contains","alternatives":false}],"consequence":{"params":{"automaticFacetFilters":[{"facet":"brand"}],"query":{"remove":["brand:","{facet:brand}"]}}},"description":"filter on brand: {brand}","objectID":"tagged-brand-rule"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("dynamic filtering13") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "color-facets",
      rule = Rule(
        objectID = "color-facets",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("{facet:color}")
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              automaticFacetFilters = Some(
                AutomaticFacetFilters(
                  Seq(
                    AutomaticFacetFilter(
                      facet = "color"
                    )
                  )
                )
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/color-facets")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"color-facets","conditions":[{"pattern":"{facet:color}"}],"consequence":{"params":{"automaticFacetFilters":[{"facet":"color"}]}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("hide hits14") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "hide-12345",
      rule = Rule(
        objectID = "hide-12345",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("cheap"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          hide = Some(
            Seq(
              ConsequenceHide(
                objectID = "to-hide-12345"
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/hide-12345")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"hide-12345","conditions":[{"pattern":"cheap","anchoring":"contains"}],"consequence":{"hide":[{"objectID":"to-hide-12345"}]}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("one rule per facet15") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "red-color",
      rule = Rule(
        objectID = "red-color",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("red"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              query = Some(
                ConsequenceQueryObject(
                  remove = Some(Seq("red"))
                )
              ),
              filters = Some("color:red")
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/red-color")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"red-color","conditions":[{"pattern":"red","anchoring":"contains"}],"consequence":{"params":{"query":{"remove":["red"]},"filters":"color:red"}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("numerical filters16") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "cheap",
      rule = Rule(
        objectID = "cheap",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("cheap"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              query = Some(
                ConsequenceQueryObject(
                  remove = Some(Seq("cheap"))
                )
              ),
              filters = Some("price < 10")
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/cheap")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"cheap","conditions":[{"pattern":"cheap","anchoring":"contains"}],"consequence":{"params":{"query":{"remove":["cheap"]},"filters":"price < 10"}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("negative filters17") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "gluten-free-rule",
      rule = Rule(
        objectID = "gluten-free-rule",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("gluten-free"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              filters = Some("NOT allergens:gluten"),
              query = Some(
                ConsequenceQueryObject(
                  edits = Some(
                    Seq(
                      Edit(
                        `type` = Some(EditType.withName("remove")),
                        delete = Some("gluten-free")
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/gluten-free-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"gluten-free-rule","conditions":[{"pattern":"gluten-free","anchoring":"contains"}],"consequence":{"params":{"filters":"NOT allergens:gluten","query":{"edits":[{"type":"remove","delete":"gluten-free"}]}}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("positive filters18") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "diet-rule",
      rule = Rule(
        objectID = "diet-rule",
        conditions = Some(
          Seq(
            Condition(
              pattern = Some("diet"),
              anchoring = Some(Anchoring.withName("contains"))
            )
          )
        ),
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              filters = Some("'low-carb' OR 'low-fat'"),
              query = Some(
                ConsequenceQueryObject(
                  edits = Some(
                    Seq(
                      Edit(
                        `type` = Some(EditType.withName("remove")),
                        delete = Some("diet")
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/diet-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"diet-rule","conditions":[{"pattern":"diet","anchoring":"contains"}],"consequence":{"params":{"filters":"'low-carb' OR 'low-fat'","query":{"edits":[{"type":"remove","delete":"diet"}]}}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("conditionless19") {
    val (client, echo) = testClient()
    val future = client.saveRule(
      indexName = "indexName",
      objectID = "diet-rule",
      rule = Rule(
        objectID = "diet-rule",
        consequence = Consequence(
          params = Some(
            ConsequenceParams(
              filters = Some("'low-carb' OR 'low-fat'"),
              query = Some(
                ConsequenceQueryObject(
                  edits = Some(
                    Seq(
                      Edit(
                        `type` = Some(EditType.withName("remove")),
                        delete = Some("diet")
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/rules/diet-rule")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"objectID":"diet-rule","consequence":{"params":{"filters":"'low-carb' OR 'low-fat'","query":{"edits":[{"type":"remove","delete":"diet"}]}}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("saveRules with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.saveRules(
      indexName = "<YOUR_INDEX_NAME>",
      rules = Seq(
        Rule(
          objectID = "a-rule-id",
          conditions = Some(
            Seq(
              Condition(
                pattern = Some("smartphone"),
                anchoring = Some(Anchoring.withName("contains"))
              )
            )
          ),
          consequence = Consequence(
            params = Some(
              ConsequenceParams(
                filters = Some("brand:apple")
              )
            )
          )
        ),
        Rule(
          objectID = "a-second-rule-id",
          conditions = Some(
            Seq(
              Condition(
                pattern = Some("apple"),
                anchoring = Some(Anchoring.withName("contains"))
              )
            )
          ),
          consequence = Consequence(
            params = Some(
              ConsequenceParams(
                filters = Some("brand:samsung")
              )
            )
          )
        )
      ),
      forwardToReplicas = Some(false),
      clearExistingRules = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch")
    assert(res.method == "POST")
    val expectedBody = parse(
      """[{"objectID":"a-rule-id","conditions":[{"pattern":"smartphone","anchoring":"contains"}],"consequence":{"params":{"filters":"brand:apple"}}},{"objectID":"a-second-rule-id","conditions":[{"pattern":"apple","anchoring":"contains"}],"consequence":{"params":{"filters":"brand:samsung"}}}]"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery =
      parse("""{"forwardToReplicas":"false","clearExistingRules":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("saveRules with all parameters1") {
    val (client, echo) = testClient()
    val future = client.saveRules(
      indexName = "<YOUR_INDEX_NAME>",
      rules = Seq(
        Rule(
          objectID = "id1",
          conditions = Some(
            Seq(
              Condition(
                pattern = Some("apple"),
                anchoring = Some(Anchoring.withName("contains")),
                alternatives = Some(false),
                context = Some("search")
              )
            )
          ),
          consequence = Consequence(
            params = Some(
              ConsequenceParams(
                filters = Some("brand:apple"),
                query = Some(
                  ConsequenceQueryObject(
                    remove = Some(Seq("algolia")),
                    edits = Some(
                      Seq(
                        Edit(
                          `type` = Some(EditType.withName("remove")),
                          delete = Some("abc"),
                          insert = Some("cde")
                        ),
                        Edit(
                          `type` = Some(EditType.withName("replace")),
                          delete = Some("abc"),
                          insert = Some("cde")
                        )
                      )
                    )
                  )
                )
              )
            ),
            hide = Some(
              Seq(
                ConsequenceHide(
                  objectID = "321"
                )
              )
            ),
            filterPromotes = Some(false),
            userData = Some(JObject(List(JField("algolia", JString("aloglia"))))),
            promote = Some(
              Seq(
                PromoteObjectID(
                  objectID = "abc",
                  position = 3
                ),
                PromoteObjectIDs(
                  objectIDs = Seq("abc", "def"),
                  position = 1
                )
              )
            )
          ),
          description = Some("test"),
          enabled = Some(true),
          validity = Some(
            Seq(
              TimeRange(
                from = 1656670273L,
                until = 1656670277L
              )
            )
          )
        )
      ),
      forwardToReplicas = Some(true),
      clearExistingRules = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch")
    assert(res.method == "POST")
    val expectedBody = parse(
      """[{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains","alternatives":false,"context":"search"}],"consequence":{"params":{"filters":"brand:apple","query":{"remove":["algolia"],"edits":[{"type":"remove","delete":"abc","insert":"cde"},{"type":"replace","delete":"abc","insert":"cde"}]}},"hide":[{"objectID":"321"}],"filterPromotes":false,"userData":{"algolia":"aloglia"},"promote":[{"objectID":"abc","position":3},{"objectIDs":["abc","def"],"position":1}]},"description":"test","enabled":true,"validity":[{"from":1656670273,"until":1656670277}]}]"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery =
      parse("""{"forwardToReplicas":"true","clearExistingRules":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("dynamic filtering2") {
    val (client, echo) = testClient()
    val future = client.saveRules(
      indexName = "<YOUR_INDEX_NAME>",
      rules = Seq(
        Rule(
          objectID = "toaster",
          conditions = Some(
            Seq(
              Condition(
                pattern = Some("toaster"),
                anchoring = Some(Anchoring.withName("contains"))
              )
            )
          ),
          consequence = Consequence(
            params = Some(
              ConsequenceParams(
                query = Some(
                  ConsequenceQueryObject(
                    remove = Some(Seq("toaster"))
                  )
                ),
                filters = Some("product_type:toaster")
              )
            )
          )
        ),
        Rule(
          objectID = "cheap",
          conditions = Some(
            Seq(
              Condition(
                pattern = Some("cheap"),
                anchoring = Some(Anchoring.withName("contains"))
              )
            )
          ),
          consequence = Consequence(
            params = Some(
              ConsequenceParams(
                query = Some(
                  ConsequenceQueryObject(
                    remove = Some(Seq("cheap"))
                  )
                ),
                filters = Some("price < 15")
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch")
    assert(res.method == "POST")
    val expectedBody = parse(
      """[{"objectID":"toaster","conditions":[{"pattern":"toaster","anchoring":"contains"}],"consequence":{"params":{"query":{"remove":["toaster"]},"filters":"product_type:toaster"}}},{"objectID":"cheap","conditions":[{"pattern":"cheap","anchoring":"contains"}],"consequence":{"params":{"query":{"remove":["cheap"]},"filters":"price < 15"}}}]"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enhance search results3") {
    val (client, echo) = testClient()
    val future = client.saveRules(
      indexName = "<YOUR_INDEX_NAME>",
      rules = Seq(
        Rule(
          objectID = "country",
          conditions = Some(
            Seq(
              Condition(
                pattern = Some("{facet:country}"),
                anchoring = Some(Anchoring.withName("contains"))
              )
            )
          ),
          consequence = Consequence(
            params = Some(
              ConsequenceParams(
                aroundLatLngViaIP = Some(false)
              )
            )
          )
        ),
        Rule(
          objectID = "city",
          conditions = Some(
            Seq(
              Condition(
                pattern = Some("{facet:city}"),
                anchoring = Some(Anchoring.withName("contains"))
              )
            )
          ),
          consequence = Consequence(
            params = Some(
              ConsequenceParams(
                aroundLatLngViaIP = Some(false)
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch")
    assert(res.method == "POST")
    val expectedBody = parse(
      """[{"objectID":"country","conditions":[{"pattern":"{facet:country}","anchoring":"contains"}],"consequence":{"params":{"aroundLatLngViaIP":false}}},{"objectID":"city","conditions":[{"pattern":"{facet:city}","anchoring":"contains"}],"consequence":{"params":{"aroundLatLngViaIP":false}}}]"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("saveSynonym") {
    val (client, echo) = testClient()
    val future = client.saveSynonym(
      indexName = "indexName",
      objectID = "id1",
      synonymHit = SynonymHit(
        objectID = "id1",
        `type` = SynonymType.withName("synonym"),
        synonyms = Some(Seq("car", "vehicule", "auto"))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/synonyms/id1")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"objectID":"id1","type":"synonym","synonyms":["car","vehicule","auto"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("saveSynonyms") {
    val (client, echo) = testClient()
    val future = client.saveSynonyms(
      indexName = "<YOUR_INDEX_NAME>",
      synonymHit = Seq(
        SynonymHit(
          objectID = "id1",
          `type` = SynonymType.withName("synonym"),
          synonyms = Some(Seq("car", "vehicule", "auto"))
        ),
        SynonymHit(
          objectID = "id2",
          `type` = SynonymType.withName("onewaysynonym"),
          input = Some("iphone"),
          synonyms = Some(Seq("ephone", "aphone", "yphone"))
        )
      ),
      forwardToReplicas = Some(true),
      replaceExistingSynonyms = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/synonyms/batch")
    assert(res.method == "POST")
    val expectedBody = parse(
      """[{"objectID":"id1","type":"synonym","synonyms":["car","vehicule","auto"]},{"objectID":"id2","type":"onewaysynonym","input":"iphone","synonyms":["ephone","aphone","yphone"]}]"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery =
      parse("""{"forwardToReplicas":"true","replaceExistingSynonyms":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("withHitsPerPage") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "<YOUR_INDEX_NAME>",
            query = Some("<YOUR_QUERY>"),
            hitsPerPage = Some(50)
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","hitsPerPage":50}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filterOnly1") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "<YOUR_INDEX_NAME>",
            query = Some("<YOUR_QUERY>"),
            filters = Some("actor:Scarlett Johansson")
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"actor:Scarlett Johansson"}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filterOr2") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "<YOUR_INDEX_NAME>",
            query = Some("<YOUR_QUERY>"),
            filters = Some("actor:Tom Cruise OR actor:Scarlett Johansson")
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"actor:Tom Cruise OR actor:Scarlett Johansson"}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filterNot3") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "<YOUR_INDEX_NAME>",
            query = Some("<YOUR_QUERY>"),
            filters = Some("NOT actor:Nicolas Cage")
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"NOT actor:Nicolas Cage"}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search for a single hits request with minimal parameters4") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "cts_e2e_search_empty_index"
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse("""{"requests":[{"indexName":"cts_e2e_search_empty_index"}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search with highlight and snippet results5") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "cts_e2e_highlight_snippet_results",
            query = Some("vim"),
            attributesToSnippet = Some(Seq("*:20")),
            attributesToHighlight = Some(Seq("*")),
            attributesToRetrieve = Some(Seq("*"))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"cts_e2e_highlight_snippet_results","query":"vim","attributesToSnippet":["*:20"],"attributesToHighlight":["*"],"attributesToRetrieve":["*"]}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("retrieveFacets6") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "<YOUR_INDEX_NAME>",
            query = Some("<YOUR_QUERY>"),
            facets = Some(Seq("author", "genre"))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","facets":["author","genre"]}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("retrieveFacetsWildcard7") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "<YOUR_INDEX_NAME>",
            query = Some("<YOUR_QUERY>"),
            facets = Some(Seq("*"))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","facets":["*"]}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search for a single facet request with minimal parameters8") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForFacets(
            indexName = "cts_e2e_search_facet",
            `type` = SearchTypeFacet.withName("facet"),
            facet = "editor"
          )
        ),
        strategy = Some(SearchStrategy.withName("stopIfEnoughMatches"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"cts_e2e_search_facet","type":"facet","facet":"editor"}],"strategy":"stopIfEnoughMatches"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search for a single hits request with all parameters9") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "theIndexName",
            query = Some("myQuery"),
            hitsPerPage = Some(50),
            `type` = Some(SearchTypeDefault.withName("default"))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"requests":[{"indexName":"theIndexName","query":"myQuery","hitsPerPage":50,"type":"default"}]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search for a single facet request with all parameters10") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForFacets(
            indexName = "theIndexName",
            `type` = SearchTypeFacet.withName("facet"),
            facet = "theFacet",
            facetQuery = Some("theFacetQuery"),
            query = Some("theQuery"),
            maxFacetHits = Some(50)
          )
        ),
        strategy = Some(SearchStrategy.withName("stopIfEnoughMatches"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"theIndexName","type":"facet","facet":"theFacet","facetQuery":"theFacetQuery","query":"theQuery","maxFacetHits":50}],"strategy":"stopIfEnoughMatches"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search for multiple mixed requests in multiple indices with minimal parameters11") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "theIndexName"
          ),
          SearchForFacets(
            indexName = "theIndexName2",
            `type` = SearchTypeFacet.withName("facet"),
            facet = "theFacet"
          ),
          SearchForHits(
            indexName = "theIndexName",
            `type` = Some(SearchTypeDefault.withName("default"))
          )
        ),
        strategy = Some(SearchStrategy.withName("stopIfEnoughMatches"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"theIndexName"},{"indexName":"theIndexName2","type":"facet","facet":"theFacet"},{"indexName":"theIndexName","type":"default"}],"strategy":"stopIfEnoughMatches"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search for multiple mixed requests in multiple indices with all parameters12") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForFacets(
            indexName = "theIndexName",
            `type` = SearchTypeFacet.withName("facet"),
            facet = "theFacet",
            facetQuery = Some("theFacetQuery"),
            query = Some("theQuery"),
            maxFacetHits = Some(50)
          ),
          SearchForHits(
            indexName = "theIndexName",
            query = Some("myQuery"),
            hitsPerPage = Some(50),
            `type` = Some(SearchTypeDefault.withName("default"))
          )
        ),
        strategy = Some(SearchStrategy.withName("stopIfEnoughMatches"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"theIndexName","type":"facet","facet":"theFacet","facetQuery":"theFacetQuery","query":"theQuery","maxFacetHits":50},{"indexName":"theIndexName","query":"myQuery","hitsPerPage":50,"type":"default"}],"strategy":"stopIfEnoughMatches"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search filters accept all of the possible shapes13") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "theIndexName",
            facetFilters = Some(FacetFilters("mySearch:filters")),
            reRankingApplyFilter = Some(ReRankingApplyFilter("mySearch:filters")),
            tagFilters = Some(TagFilters("mySearch:filters")),
            numericFilters = Some(NumericFilters("mySearch:filters")),
            optionalFilters = Some(OptionalFilters("mySearch:filters"))
          ),
          SearchForHits(
            indexName = "theIndexName",
            facetFilters = Some(
              FacetFilters(
                Seq(
                  FacetFilters("mySearch:filters"),
                  FacetFilters(
                    Seq(FacetFilters("mySearch:filters"), FacetFilters(Seq(FacetFilters("mySearch:filters"))))
                  )
                )
              )
            ),
            reRankingApplyFilter = Some(
              ReRankingApplyFilter(
                Seq(
                  ReRankingApplyFilter("mySearch:filters"),
                  ReRankingApplyFilter(Seq(ReRankingApplyFilter("mySearch:filters")))
                )
              )
            ),
            tagFilters =
              Some(TagFilters(Seq(TagFilters("mySearch:filters"), TagFilters(Seq(TagFilters("mySearch:filters")))))),
            numericFilters = Some(
              NumericFilters(
                Seq(NumericFilters("mySearch:filters"), NumericFilters(Seq(NumericFilters("mySearch:filters"))))
              )
            ),
            optionalFilters = Some(
              OptionalFilters(
                Seq(OptionalFilters("mySearch:filters"), OptionalFilters(Seq(OptionalFilters("mySearch:filters"))))
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"theIndexName","facetFilters":"mySearch:filters","reRankingApplyFilter":"mySearch:filters","tagFilters":"mySearch:filters","numericFilters":"mySearch:filters","optionalFilters":"mySearch:filters"},{"indexName":"theIndexName","facetFilters":["mySearch:filters",["mySearch:filters",["mySearch:filters"]]],"reRankingApplyFilter":["mySearch:filters",["mySearch:filters"]],"tagFilters":["mySearch:filters",["mySearch:filters"]],"numericFilters":["mySearch:filters",["mySearch:filters"]],"optionalFilters":["mySearch:filters",["mySearch:filters"]]}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search filters end to end14") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            indexName = "cts_e2e_search_facet",
            filters = Some("editor:'visual studio' OR editor:neovim")
          ),
          SearchForHits(
            indexName = "cts_e2e_search_facet",
            facetFilters =
              Some(FacetFilters(Seq(FacetFilters("editor:'visual studio'"), FacetFilters("editor:neovim"))))
          ),
          SearchForHits(
            indexName = "cts_e2e_search_facet",
            facetFilters = Some(
              FacetFilters(
                Seq(FacetFilters("editor:'visual studio'"), FacetFilters(Seq(FacetFilters("editor:neovim"))))
              )
            )
          ),
          SearchForHits(
            indexName = "cts_e2e_search_facet",
            facetFilters = Some(
              FacetFilters(
                Seq(
                  FacetFilters("editor:'visual studio'"),
                  FacetFilters(Seq(FacetFilters("editor:neovim"), FacetFilters(Seq(FacetFilters("editor:goland")))))
                )
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"indexName":"cts_e2e_search_facet","filters":"editor:'visual studio' OR editor:neovim"},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'","editor:neovim"]},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'",["editor:neovim"]]},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'",["editor:neovim",["editor:goland"]]]}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search with all search parameters15") {
    val (client, echo) = testClient()
    val future = client.search(
      searchMethodParams = SearchMethodParams(
        requests = Seq(
          SearchForHits(
            advancedSyntax = Some(true),
            advancedSyntaxFeatures = Some(Seq(AdvancedSyntaxFeatures.withName("exactPhrase"))),
            allowTyposOnNumericTokens = Some(true),
            alternativesAsExact = Some(Seq(AlternativesAsExact.withName("multiWordsSynonym"))),
            analytics = Some(true),
            analyticsTags = Some(Seq("")),
            aroundLatLng = Some(""),
            aroundLatLngViaIP = Some(true),
            aroundPrecision = Some(AroundPrecision(0)),
            aroundRadius = Some(AroundRadiusAll.withName("all")),
            attributeCriteriaComputedByMinProximity = Some(true),
            attributesToHighlight = Some(Seq("")),
            attributesToRetrieve = Some(Seq("")),
            attributesToSnippet = Some(Seq("")),
            clickAnalytics = Some(true),
            decompoundQuery = Some(true),
            disableExactOnAttributes = Some(Seq("")),
            disableTypoToleranceOnAttributes = Some(Seq("")),
            distinct = Some(Distinct(0)),
            enableABTest = Some(true),
            enablePersonalization = Some(true),
            enableReRanking = Some(true),
            enableRules = Some(true),
            exactOnSingleWordQuery = Some(ExactOnSingleWordQuery.withName("attribute")),
            facetFilters = Some(FacetFilters(Seq(FacetFilters("")))),
            facetingAfterDistinct = Some(true),
            facets = Some(Seq("")),
            filters = Some(""),
            getRankingInfo = Some(true),
            highlightPostTag = Some(""),
            highlightPreTag = Some(""),
            hitsPerPage = Some(1),
            ignorePlurals = Some(IgnorePlurals(false)),
            indexName = "theIndexName",
            insideBoundingBox =
              Some(InsideBoundingBox(Seq(Seq(47.3165, 4.9665, 47.3424, 5.0201), Seq(40.9234, 2.1185, 38.643, 1.9916)))),
            insidePolygon = Some(
              Seq(
                Seq(47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9),
                Seq(40.9234, 2.1185, 38.643, 1.9916, 39.2587, 2.0104)
              )
            ),
            length = Some(1),
            maxValuesPerFacet = Some(0),
            minProximity = Some(1),
            minWordSizefor1Typo = Some(0),
            minWordSizefor2Typos = Some(0),
            minimumAroundRadius = Some(1),
            naturalLanguages = Some(Seq(SupportedLanguage.withName("fr"))),
            numericFilters = Some(NumericFilters(Seq(NumericFilters("")))),
            offset = Some(0),
            optionalFilters = Some(OptionalFilters(Seq(OptionalFilters("")))),
            optionalWords = Some(OptionalWords(Seq(""))),
            page = Some(0),
            percentileComputation = Some(true),
            personalizationImpact = Some(0),
            query = Some(""),
            queryLanguages = Some(Seq(SupportedLanguage.withName("fr"))),
            queryType = Some(QueryType.withName("prefixAll")),
            ranking = Some(Seq("")),
            reRankingApplyFilter = Some(ReRankingApplyFilter(Seq(ReRankingApplyFilter("")))),
            relevancyStrictness = Some(0),
            removeStopWords = Some(RemoveStopWords(true)),
            removeWordsIfNoResults = Some(RemoveWordsIfNoResults.withName("allOptional")),
            renderingContent = Some(
              RenderingContent(
                facetOrdering = Some(
                  FacetOrdering(
                    facets = Some(
                      Facets(
                        order = Some(Seq("a", "b"))
                      )
                    ),
                    values = Some(
                      Map(
                        "a" -> Value(
                          order = Some(Seq("b")),
                          sortRemainingBy = Some(SortRemainingBy.withName("count"))
                        )
                      )
                    )
                  )
                )
              )
            ),
            replaceSynonymsInHighlight = Some(true),
            responseFields = Some(Seq("")),
            restrictHighlightAndSnippetArrays = Some(true),
            restrictSearchableAttributes = Some(Seq("")),
            ruleContexts = Some(Seq("")),
            similarQuery = Some(""),
            snippetEllipsisText = Some(""),
            sortFacetValuesBy = Some(""),
            sumOrFiltersScores = Some(true),
            synonyms = Some(true),
            tagFilters = Some(TagFilters(Seq(TagFilters("")))),
            `type` = Some(SearchTypeDefault.withName("default")),
            typoTolerance = Some(TypoToleranceEnum.withName("min")),
            userToken = Some("")
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/*/queries")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"requests":[{"advancedSyntax":true,"advancedSyntaxFeatures":["exactPhrase"],"allowTyposOnNumericTokens":true,"alternativesAsExact":["multiWordsSynonym"],"analytics":true,"analyticsTags":[""],"aroundLatLng":"","aroundLatLngViaIP":true,"aroundPrecision":0,"aroundRadius":"all","attributeCriteriaComputedByMinProximity":true,"attributesToHighlight":[""],"attributesToRetrieve":[""],"attributesToSnippet":[""],"clickAnalytics":true,"decompoundQuery":true,"disableExactOnAttributes":[""],"disableTypoToleranceOnAttributes":[""],"distinct":0,"enableABTest":true,"enablePersonalization":true,"enableReRanking":true,"enableRules":true,"exactOnSingleWordQuery":"attribute","facetFilters":[""],"facetingAfterDistinct":true,"facets":[""],"filters":"","getRankingInfo":true,"highlightPostTag":"","highlightPreTag":"","hitsPerPage":1,"ignorePlurals":false,"indexName":"theIndexName","insideBoundingBox":[[47.3165,4.9665,47.3424,5.0201],[40.9234,2.1185,38.643,1.9916]],"insidePolygon":[[47.3165,4.9665,47.3424,5.0201,47.32,4.9],[40.9234,2.1185,38.643,1.9916,39.2587,2.0104]],"length":1,"maxValuesPerFacet":0,"minProximity":1,"minWordSizefor1Typo":0,"minWordSizefor2Typos":0,"minimumAroundRadius":1,"naturalLanguages":["fr"],"numericFilters":[""],"offset":0,"optionalFilters":[""],"optionalWords":[""],"page":0,"percentileComputation":true,"personalizationImpact":0,"query":"","queryLanguages":["fr"],"queryType":"prefixAll","ranking":[""],"reRankingApplyFilter":[""],"relevancyStrictness":0,"removeStopWords":true,"removeWordsIfNoResults":"allOptional","renderingContent":{"facetOrdering":{"facets":{"order":["a","b"]},"values":{"a":{"order":["b"],"sortRemainingBy":"count"}}}},"replaceSynonymsInHighlight":true,"responseFields":[""],"restrictHighlightAndSnippetArrays":true,"restrictSearchableAttributes":[""],"ruleContexts":[""],"similarQuery":"","snippetEllipsisText":"","sortFacetValuesBy":"","sumOrFiltersScores":true,"synonyms":true,"tagFilters":[""],"type":"default","typoTolerance":"min","userToken":""}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("get searchDictionaryEntries results with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.searchDictionaryEntries(
      dictionaryName = DictionaryType.withName("stopwords"),
      searchDictionaryEntriesParams = SearchDictionaryEntriesParams(
        query = "about"
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/stopwords/search")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"about"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("get searchDictionaryEntries results with all parameters1") {
    val (client, echo) = testClient()
    val future = client.searchDictionaryEntries(
      dictionaryName = DictionaryType.withName("compounds"),
      searchDictionaryEntriesParams = SearchDictionaryEntriesParams(
        query = "foo",
        page = Some(4),
        hitsPerPage = Some(2),
        language = Some(SupportedLanguage.withName("fr"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/compounds/search")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"foo","page":4,"hitsPerPage":2,"language":"fr"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("get searchForFacetValues results with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.searchForFacetValues(
      indexName = "indexName",
      facetName = "facetName"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/facets/facetName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("get searchForFacetValues results with all parameters1") {
    val (client, echo) = testClient()
    val future = client.searchForFacetValues(
      indexName = "indexName",
      facetName = "facetName",
      searchForFacetValuesRequest = Some(
        SearchForFacetValuesRequest(
          params = Some("query=foo&facetFilters=['bar']"),
          facetQuery = Some("foo"),
          maxFacetHits = Some(42)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/facets/facetName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"params":"query=foo&facetFilters=['bar']","facetQuery":"foo","maxFacetHits":42}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facetName and facetQuery2") {
    val (client, echo) = testClient()
    val future = client.searchForFacetValues(
      indexName = "indexName",
      facetName = "author",
      searchForFacetValuesRequest = Some(
        SearchForFacetValuesRequest(
          facetQuery = Some("stephen king")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/facets/author/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facetQuery":"stephen king"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchRules") {
    val (client, echo) = testClient()
    val future = client.searchRules(
      indexName = "cts_e2e_browse",
      searchRulesParams = Some(
        SearchRulesParams(
          query = Some("zorro")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/cts_e2e_browse/rules/search")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"zorro"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search with special characters in indexName1") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "cts_e2e_space in index"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/cts_e2e_space%20in%20index/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("search with searchParams2") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("myQuery"),
          facetFilters = Some(FacetFilters(Seq(FacetFilters("tags:algolia"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"myQuery","facetFilters":["tags:algolia"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("single search retrieve snippets3") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "cts_e2e_browse",
      searchParams = Some(
        SearchParamsObject(
          query = Some("batman mask of the phantasm"),
          attributesToRetrieve = Some(Seq("*")),
          attributesToSnippet = Some(Seq("*:20"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/cts_e2e_browse/query")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"query":"batman mask of the phantasm","attributesToRetrieve":["*"],"attributesToSnippet":["*:20"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("query4") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          query = Some("phone")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"phone"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filters5") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("country:US AND price.gross < 2.0")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"filters":"country:US AND price.gross < 2.0"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("distinct6") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          distinct = Some(Distinct(true))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"distinct":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filtersNumeric7") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("price < 10")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"filters":"price < 10"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filtersTimestamp8") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("NOT date_timestamp:1514764800 TO 1546300799")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"filters":"NOT date_timestamp:1514764800 TO 1546300799"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filtersSumOrFiltersScoresFalse9") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)"),
          sumOrFiltersScores = Some(false)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"filters":"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)","sumOrFiltersScores":false}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filtersSumOrFiltersScoresTrue10") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)"),
          sumOrFiltersScores = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"filters":"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)","sumOrFiltersScores":true}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filtersStephenKing11") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("author:\"Stephen King\"")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"filters":"author:\"Stephen King\""}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filtersNotTags12") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("NOT _tags:non-fiction")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"filters":"NOT _tags:non-fiction"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facetFiltersList13") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          facetFilters = Some(
            FacetFilters(
              Seq(
                FacetFilters("publisher:Penguin"),
                FacetFilters(Seq(FacetFilters("author:Stephen King"), FacetFilters("genre:Horror")))
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facetFilters":["publisher:Penguin",["author:Stephen King","genre:Horror"]]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facetFiltersNeg14") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          facetFilters = Some(FacetFilters("category:-Ebook"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facetFilters":"category:-Ebook"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("filtersAndFacetFilters15") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("(author:\"Stephen King\" OR genre:\"Horror\")"),
          facetFilters = Some(FacetFilters(Seq(FacetFilters("publisher:Penguin"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"filters":"(author:\"Stephen King\" OR genre:\"Horror\")","facetFilters":["publisher:Penguin"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facet author genre16") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          facets = Some(Seq("author", "genre"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facets":["author","genre"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facet wildcard17") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          facets = Some(Seq("*"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facets":["*"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("maxValuesPerFacet18") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          maxValuesPerFacet = Some(1000)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"maxValuesPerFacet":1000}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("aroundLatLng19") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          aroundLatLng = Some("40.71, -74.01")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"aroundLatLng":"40.71, -74.01"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("aroundLatLngViaIP20") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          aroundLatLngViaIP = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"aroundLatLngViaIP":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("aroundRadius21") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          aroundLatLng = Some("40.71, -74.01"),
          aroundRadius = Some(AroundRadius(1000000))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"aroundLatLng":"40.71, -74.01","aroundRadius":1000000}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("insideBoundingBox22") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          insideBoundingBox =
            Some(InsideBoundingBox(Seq(Seq(49.067996905313834, 65.73828125, 25.905859247243498, 128.8046875))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"insideBoundingBox":[[49.067996905313834,65.73828125,25.905859247243498,128.8046875]]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("insidePolygon23") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          insidePolygon = Some(
            Seq(
              Seq(42.01, -124.31, 48.835509470063045, -124.40453125000005, 45.01082951668149, -65.95726562500005,
                31.247243545293433, -81.06578125000004, 25.924152577235226, -97.68234374999997, 32.300311895879545,
                -117.54828125)
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"insidePolygon":[[42.01,-124.31,48.835509470063045,-124.40453125000005,45.01082951668149,-65.95726562500005,31.247243545293433,-81.06578125000004,25.924152577235226,-97.68234374999997,32.300311895879545,-117.54828125]]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("insidePolygon24") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          insidePolygon = Some(
            Seq(
              Seq(42.01, -124.31, 48.835509470063045, -124.40453125000005, 45.01082951668149, -65.95726562500005,
                31.247243545293433, -81.06578125000004, 25.924152577235226, -97.68234374999997, 32.300311895879545,
                -117.54828125)
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"insidePolygon":[[42.01,-124.31,48.835509470063045,-124.40453125000005,45.01082951668149,-65.95726562500005,31.247243545293433,-81.06578125000004,25.924152577235226,-97.68234374999997,32.300311895879545,-117.54828125]]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("optionalFilters25") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          optionalFilters = Some(OptionalFilters(Seq(OptionalFilters("can_deliver_quickly:true"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"optionalFilters":["can_deliver_quickly:true"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("optionalFiltersMany26") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          optionalFilters = Some(
            OptionalFilters(
              Seq(
                OptionalFilters("brand:Apple<score=3>"),
                OptionalFilters("brand:Samsung<score=2>"),
                OptionalFilters("brand:-Huawei")
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"optionalFilters":["brand:Apple<score=3>","brand:Samsung<score=2>","brand:-Huawei"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("optionalFiltersSimple27") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          optionalFilters =
            Some(OptionalFilters(Seq(OptionalFilters("brand:Apple<score=2>"), OptionalFilters("type:tablet"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"optionalFilters":["brand:Apple<score=2>","type:tablet"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("restrictSearchableAttributes28") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          restrictSearchableAttributes = Some(Seq("title_fr"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"restrictSearchableAttributes":["title_fr"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("getRankingInfo29") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          getRankingInfo = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"getRankingInfo":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("clickAnalytics30") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          clickAnalytics = Some(true)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"clickAnalytics":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("clickAnalyticsUserToken31") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          clickAnalytics = Some(true),
          userToken = Some("user-1")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"clickAnalytics":true,"userToken":"user-1"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("enablePersonalization32") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          enablePersonalization = Some(true),
          userToken = Some("user-1")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"enablePersonalization":true,"userToken":"user-1"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("userToken33") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          userToken = Some("user-1")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"userToken":"user-1"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("analyticsTag34") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          analyticsTags = Some(Seq("YOUR_ANALYTICS_TAG"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"analyticsTags":["YOUR_ANALYTICS_TAG"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("facetFiltersUsers35") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          facetFilters = Some(FacetFilters(Seq(FacetFilters("user:user42"), FacetFilters("user:public"))))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facetFilters":["user:user42","user:public"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("buildTheQuery36") {
    val (client, echo) = testClient()
    val future = client.searchSingleIndex(
      indexName = "indexName",
      searchParams = Some(
        SearchParamsObject(
          filters = Some("categoryPageId: Men's Clothing"),
          hitsPerPage = Some(50),
          analyticsTags = Some(Seq("mens-clothing"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/query")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"filters":"categoryPageId: Men's Clothing","hitsPerPage":50,"analyticsTags":["mens-clothing"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchSynonyms with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.searchSynonyms(
      indexName = "indexName"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/synonyms/search")
    assert(res.method == "POST")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchSynonyms with all parameters1") {
    val (client, echo) = testClient()
    val future = client.searchSynonyms(
      indexName = "indexName",
      searchSynonymsParams = Some(
        SearchSynonymsParams(
          query = Some("myQuery"),
          `type` = Some(SynonymType.withName("altcorrection1")),
          page = Some(10),
          hitsPerPage = Some(10)
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/indexName/synonyms/search")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"myQuery","type":"altcorrection1","page":10,"hitsPerPage":10}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchUserIds") {
    val (client, echo) = testClient()
    val future = client.searchUserIds(
      searchUserIdsParams = SearchUserIdsParams(
        query = "test",
        clusterName = Some("theClusterName"),
        page = Some(5),
        hitsPerPage = Some(10)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/clusters/mapping/search")
    assert(res.method == "POST")
    val expectedBody = parse("""{"query":"test","clusterName":"theClusterName","page":5,"hitsPerPage":10}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("get setDictionarySettings results with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.setDictionarySettings(
      dictionarySettingsParams = DictionarySettingsParams(
        disableStandardEntries = StandardEntries(
          plurals = Some(Map("fr" -> false, "en" -> false, "ru" -> true))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/*/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"disableStandardEntries":{"plurals":{"fr":false,"en":false,"ru":true}}}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("get setDictionarySettings results with all parameters1") {
    val (client, echo) = testClient()
    val future = client.setDictionarySettings(
      dictionarySettingsParams = DictionarySettingsParams(
        disableStandardEntries = StandardEntries(
          plurals = Some(Map("fr" -> false, "en" -> false, "ru" -> true)),
          stopwords = Some(Map("fr" -> false)),
          compounds = Some(Map("ru" -> true))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/dictionaries/*/settings")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"disableStandardEntries":{"plurals":{"fr":false,"en":false,"ru":true},"stopwords":{"fr":false},"compounds":{"ru":true}}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("minimal parameters") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "cts_e2e_settings",
      indexSettings = IndexSettings(
        paginationLimitedTo = Some(10)
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/cts_e2e_settings/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"paginationLimitedTo":10}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("boolean typoTolerance1") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        typoTolerance = Some(TypoTolerance(true))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"typoTolerance":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("enum typoTolerance2") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        typoTolerance = Some(TypoToleranceEnum.withName("min"))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"typoTolerance":"min"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("ignorePlurals3") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        ignorePlurals = Some(IgnorePlurals(true))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"ignorePlurals":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("list of string ignorePlurals4") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        ignorePlurals = Some(IgnorePlurals(Seq(SupportedLanguage.withName("fr"))))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"ignorePlurals":["fr"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("removeStopWords boolean5") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        removeStopWords = Some(RemoveStopWords(true))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"removeStopWords":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("removeStopWords list of string6") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        removeStopWords = Some(RemoveStopWords(Seq(SupportedLanguage.withName("fr"))))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"removeStopWords":["fr"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("boolean distinct7") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        distinct = Some(Distinct(true))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"distinct":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("integer distinct8") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        distinct = Some(Distinct(1))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"distinct":1}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("distinct company9") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        attributeForDistinct = Some("company"),
        distinct = Some(Distinct(true))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributeForDistinct":"company","distinct":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("distinct design10") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        attributeForDistinct = Some("design"),
        distinct = Some(Distinct(true))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributeForDistinct":"design","distinct":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("distinct true11") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        distinct = Some(Distinct(true))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"distinct":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("distinct section12") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        attributeForDistinct = Some("section"),
        distinct = Some(Distinct(true))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributeForDistinct":"section","distinct":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting allergens13") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("allergens"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["allergens"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting categoryPageId14") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("searchable(categoryPageId)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["searchable(categoryPageId)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("unretrievableAttributes15") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        unretrievableAttributes = Some(Seq("visible_by"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"unretrievableAttributes":["visible_by"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting user restricted data16") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("filterOnly(visible_by)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["filterOnly(visible_by)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting optional filters17") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("can_deliver_quickly", "restaurant"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["can_deliver_quickly","restaurant"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting redirect index18") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("query_terms"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["query_terms"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting multiple consequences19") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("director"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["director"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting in-depth optional filters20") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("filterOnly(brand)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["filterOnly(brand)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("mode neuralSearch21") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        mode = Some(Mode.withName("neuralSearch"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"mode":"neuralSearch"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("mode keywordSearch22") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        mode = Some(Mode.withName("keywordSearch"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"mode":"keywordSearch"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributes same priority23") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("title,comments", "ingredients"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["title,comments","ingredients"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributes higher priority24") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("title", "ingredients"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["title","ingredients"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("customRanking retweets25") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("desc(retweets)", "desc(likes)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"customRanking":["desc(retweets)","desc(likes)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("customRanking boosted26") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("desc(boosted)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"customRanking":["desc(boosted)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("customRanking pageviews27") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("desc(pageviews)", "desc(comments)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"customRanking":["desc(pageviews)","desc(comments)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("customRanking applying search parameters for a specific query28") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("desc(nb_airline_liaisons)")),
        attributesForFaceting = Some(Seq("city, country"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody =
      parse("""{"customRanking":["desc(nb_airline_liaisons)"],"attributesForFaceting":["city, country"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("customRanking rounded pageviews29") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("desc(rounded_pageviews)", "desc(comments)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"customRanking":["desc(rounded_pageviews)","desc(comments)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("customRanking price30") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("desc(price)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"customRanking":["desc(price)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("ranking exhaustive31") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        ranking =
          Some(Seq("desc(price)", "typo", "geo", "words", "filters", "proximity", "attribute", "exact", "custom"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody =
      parse("""{"ranking":["desc(price)","typo","geo","words","filters","proximity","attribute","exact","custom"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("ranking standard replica32") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        ranking = Some(Seq("desc(post_date_timestamp)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"ranking":["desc(post_date_timestamp)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("ranking virtual replica33") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("desc(post_date_timestamp)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"customRanking":["desc(post_date_timestamp)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("customRanking and ranking sort alphabetically34") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("asc(textual_attribute)")),
        ranking = Some(Seq("custom", "typo", "geo", "words", "filters", "proximity", "attribute", "exact"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"customRanking":["asc(textual_attribute)"],"ranking":["custom","typo","geo","words","filters","proximity","attribute","exact"]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("relevancyStrictness35") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        customRanking = Some(Seq("asc(textual_attribute)")),
        relevancyStrictness = Some(0)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"customRanking":["asc(textual_attribute)"],"relevancyStrictness":0}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("create replica index36") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        replicas = Some(Seq("products_price_desc"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"replicas":["products_price_desc"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("create virtual replica index37") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        replicas = Some(Seq("virtual(products_price_desc)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"replicas":["virtual(products_price_desc)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("unlink replica index38") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        replicas = Some(Seq(""))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"replicas":[""]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("forwardToReplicas39") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("name", "description"))
      ),
      forwardToReplicas = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["name","description"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"forwardToReplicas":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("maxValuesPerFacet40") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        maxValuesPerFacet = Some(1000)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"maxValuesPerFacet":1000}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("maxFacetHits41") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        maxFacetHits = Some(1000)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"maxFacetHits":1000}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("attributesForFaceting complex42") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "<YOUR_INDEX_NAME>",
      indexSettings = IndexSettings(
        attributesForFaceting = Some(Seq("actor", "filterOnly(category)", "searchable(publisher)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"attributesForFaceting":["actor","filterOnly(category)","searchable(publisher)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("ranking closest dates43") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        ranking = Some(
          Seq("asc(date_timestamp)", "typo", "geo", "words", "filters", "proximity", "attribute", "exact", "custom")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"ranking":["asc(date_timestamp)","typo","geo","words","filters","proximity","attribute","exact","custom"]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributes item variation44") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("design", "type", "color"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["design","type","color"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributes around location45") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("name", "country", "code", "iata_code")),
        customRanking = Some(Seq("desc(links_count)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody =
      parse("""{"searchableAttributes":["name","country","code","iata_code"],"customRanking":["desc(links_count)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributes around location46") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("name", "country", "code", "iata_code")),
        customRanking = Some(Seq("desc(links_count)"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody =
      parse("""{"searchableAttributes":["name","country","code","iata_code"],"customRanking":["desc(links_count)"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("disableTypoToleranceOnAttributes47") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        disableTypoToleranceOnAttributes = Some(Seq("serial_number"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"disableTypoToleranceOnAttributes":["serial_number"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("everything48") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        advancedSyntax = Some(true),
        advancedSyntaxFeatures = Some(Seq(AdvancedSyntaxFeatures.withName("exactPhrase"))),
        allowCompressionOfIntegerArray = Some(true),
        allowTyposOnNumericTokens = Some(true),
        alternativesAsExact = Some(Seq(AlternativesAsExact.withName("singleWordSynonym"))),
        attributeCriteriaComputedByMinProximity = Some(true),
        attributeForDistinct = Some("test"),
        attributesForFaceting = Some(Seq("algolia")),
        attributesToHighlight = Some(Seq("algolia")),
        attributesToRetrieve = Some(Seq("algolia")),
        attributesToSnippet = Some(Seq("algolia")),
        attributesToTransliterate = Some(Seq("algolia")),
        camelCaseAttributes = Some(Seq("algolia")),
        customNormalization = Some(Map("algolia" -> Map("aloglia" -> "aglolia"))),
        customRanking = Some(Seq("algolia")),
        decompoundQuery = Some(false),
        decompoundedAttributes = Some(JObject(List(JField("algolia", JString("aloglia"))))),
        disableExactOnAttributes = Some(Seq("algolia")),
        disablePrefixOnAttributes = Some(Seq("algolia")),
        disableTypoToleranceOnAttributes = Some(Seq("algolia")),
        disableTypoToleranceOnWords = Some(Seq("algolia")),
        distinct = Some(Distinct(3)),
        enablePersonalization = Some(true),
        enableReRanking = Some(false),
        enableRules = Some(true),
        exactOnSingleWordQuery = Some(ExactOnSingleWordQuery.withName("attribute")),
        highlightPreTag = Some("<span>"),
        highlightPostTag = Some("</span>"),
        hitsPerPage = Some(10),
        ignorePlurals = Some(IgnorePlurals(false)),
        indexLanguages = Some(Seq(SupportedLanguage.withName("fr"))),
        keepDiacriticsOnCharacters = Some("abc"),
        maxFacetHits = Some(20),
        maxValuesPerFacet = Some(30),
        minProximity = Some(6),
        minWordSizefor1Typo = Some(5),
        minWordSizefor2Typos = Some(11),
        mode = Some(Mode.withName("neuralSearch")),
        numericAttributesForFiltering = Some(Seq("algolia")),
        optionalWords = Some(OptionalWords(Seq("myspace"))),
        paginationLimitedTo = Some(0),
        queryLanguages = Some(Seq(SupportedLanguage.withName("fr"))),
        queryType = Some(QueryType.withName("prefixLast")),
        ranking = Some(Seq("geo")),
        reRankingApplyFilter = Some(ReRankingApplyFilter("mySearch:filters")),
        relevancyStrictness = Some(10),
        removeStopWords = Some(RemoveStopWords(false)),
        removeWordsIfNoResults = Some(RemoveWordsIfNoResults.withName("lastWords")),
        renderingContent = Some(
          RenderingContent(
            facetOrdering = Some(
              FacetOrdering(
                facets = Some(
                  Facets(
                    order = Some(Seq("a", "b"))
                  )
                ),
                values = Some(
                  Map(
                    "a" -> Value(
                      order = Some(Seq("b")),
                      sortRemainingBy = Some(SortRemainingBy.withName("count"))
                    )
                  )
                )
              )
            )
          )
        ),
        replaceSynonymsInHighlight = Some(true),
        replicas = Some(Seq("")),
        responseFields = Some(Seq("algolia")),
        restrictHighlightAndSnippetArrays = Some(true),
        searchableAttributes = Some(Seq("foo")),
        semanticSearch = Some(
          SemanticSearch(
            eventSources = Some(Seq("foo"))
          )
        ),
        separatorsToIndex = Some("bar"),
        snippetEllipsisText = Some("---"),
        sortFacetValuesBy = Some("date"),
        typoTolerance = Some(TypoTolerance(false)),
        unretrievableAttributes = Some(Seq("foo")),
        userData = Some(JObject(List(JField("user", JString("data")))))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"advancedSyntax":true,"advancedSyntaxFeatures":["exactPhrase"],"allowCompressionOfIntegerArray":true,"allowTyposOnNumericTokens":true,"alternativesAsExact":["singleWordSynonym"],"attributeCriteriaComputedByMinProximity":true,"attributeForDistinct":"test","attributesForFaceting":["algolia"],"attributesToHighlight":["algolia"],"attributesToRetrieve":["algolia"],"attributesToSnippet":["algolia"],"attributesToTransliterate":["algolia"],"camelCaseAttributes":["algolia"],"customNormalization":{"algolia":{"aloglia":"aglolia"}},"customRanking":["algolia"],"decompoundQuery":false,"decompoundedAttributes":{"algolia":"aloglia"},"disableExactOnAttributes":["algolia"],"disablePrefixOnAttributes":["algolia"],"disableTypoToleranceOnAttributes":["algolia"],"disableTypoToleranceOnWords":["algolia"],"distinct":3,"enablePersonalization":true,"enableReRanking":false,"enableRules":true,"exactOnSingleWordQuery":"attribute","highlightPreTag":"<span>","highlightPostTag":"</span>","hitsPerPage":10,"ignorePlurals":false,"indexLanguages":["fr"],"keepDiacriticsOnCharacters":"abc","maxFacetHits":20,"maxValuesPerFacet":30,"minProximity":6,"minWordSizefor1Typo":5,"minWordSizefor2Typos":11,"mode":"neuralSearch","numericAttributesForFiltering":["algolia"],"optionalWords":["myspace"],"paginationLimitedTo":0,"queryLanguages":["fr"],"queryType":"prefixLast","ranking":["geo"],"reRankingApplyFilter":"mySearch:filters","relevancyStrictness":10,"removeStopWords":false,"removeWordsIfNoResults":"lastWords","renderingContent":{"facetOrdering":{"facets":{"order":["a","b"]},"values":{"a":{"order":["b"],"sortRemainingBy":"count"}}}},"replaceSynonymsInHighlight":true,"replicas":[""],"responseFields":["algolia"],"restrictHighlightAndSnippetArrays":true,"searchableAttributes":["foo"],"semanticSearch":{"eventSources":["foo"]},"separatorsToIndex":"bar","snippetEllipsisText":"---","sortFacetValuesBy":"date","typoTolerance":false,"unretrievableAttributes":["foo"],"userData":{"user":"data"}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributesWithCustomRankingsAndAttributesForFaceting49") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("brand", "name", "categories", "unordered(description)")),
        customRanking = Some(Seq("desc(popularity)")),
        attributesForFaceting = Some(Seq("searchable(brand)", "type", "categories", "price"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"searchableAttributes":["brand","name","categories","unordered(description)"],"customRanking":["desc(popularity)"],"attributesForFaceting":["searchable(brand)","type","categories","price"]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributesProductReferenceSuffixes50") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("name", "product_reference", "product_reference_suffixes"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["name","product_reference","product_reference_suffixes"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("queryLanguageAndIgnorePlurals51") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        queryLanguages = Some(Seq(SupportedLanguage.withName("en"))),
        ignorePlurals = Some(IgnorePlurals(true))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"queryLanguages":["en"],"ignorePlurals":true}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributesInMovies52") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "movies",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("title_eng", "title_fr", "title_es"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/movies/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["title_eng","title_fr","title_es"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("disablePrefixOnAttributes53") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        disablePrefixOnAttributes = Some(Seq("serial_number"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"disablePrefixOnAttributes":["serial_number"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("disableTypoToleranceOnAttributes54") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        disableTypoToleranceOnAttributes = Some(Seq("serial_number"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"disableTypoToleranceOnAttributes":["serial_number"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributesSimpleExample55") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("serial_number"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["serial_number"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchableAttributesSimpleExampleAlt56") {
    val (client, echo) = testClient()
    val future = client.setSettings(
      indexName = "theIndexName",
      indexSettings = IndexSettings(
        searchableAttributes = Some(Seq("serial_number", "serial_number_suffixes"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/indexes/theIndexName/settings")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"searchableAttributes":["serial_number","serial_number_suffixes"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("updateApiKey") {
    val (client, echo) = testClient()
    val future = client.updateApiKey(
      key = "ALGOLIA_API_KEY",
      apiKey = ApiKey(
        acl = Seq(Acl.withName("search"), Acl.withName("addObject")),
        validity = Some(300),
        maxQueriesPerIPPerHour = Some(100),
        maxHitsPerQuery = Some(20)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/keys/ALGOLIA_API_KEY")
    assert(res.method == "PUT")
    val expectedBody =
      parse("""{"acl":["search","addObject"],"validity":300,"maxQueriesPerIPPerHour":100,"maxHitsPerQuery":20}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

}
