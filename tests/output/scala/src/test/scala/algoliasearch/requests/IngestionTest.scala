// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package algoliasearch.requests

import algoliasearch.EchoInterceptor
import algoliasearch.api.IngestionClient
import algoliasearch.config.*
import algoliasearch.ingestion.*
import org.json4s.*
import org.json4s.native.JsonParser.*
import org.scalatest.funsuite.AnyFunSuite

import java.util.concurrent.TimeUnit
import scala.concurrent.duration.Duration
import scala.concurrent.{Await, ExecutionContextExecutor}

class IngestionTest extends AnyFunSuite {
  implicit val ec: ExecutionContextExecutor = scala.concurrent.ExecutionContext.global
  implicit val formats: Formats = JsonSupport.format

  def testClient(): (IngestionClient, EchoInterceptor) = {
    val echo = EchoInterceptor()
    (
      IngestionClient(
        appId = "appId",
        apiKey = "apiKey",
        region = "us",
        clientOptions = ClientOptions
          .builder()
          .withRequesterConfig(requester => requester.withInterceptor(echo))
          .build()
      ),
      echo
    )
  }

  test("createAuthenticationOAuth") {
    val (client, echo) = testClient()
    val future = client.createAuthentication(
      authenticationCreate = AuthenticationCreate(
        `type` = AuthenticationType.withName("oauth"),
        name = "authName",
        input = AuthOAuth(
          url = "http://test.oauth",
          clientId = "myID",
          clientSecret = "mySecret"
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/authentications")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"type":"oauth","name":"authName","input":{"url":"http://test.oauth","client_id":"myID","client_secret":"mySecret"}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("createAuthenticationAlgolia1") {
    val (client, echo) = testClient()
    val future = client.createAuthentication(
      authenticationCreate = AuthenticationCreate(
        `type` = AuthenticationType.withName("algolia"),
        name = "authName",
        input = AuthAlgolia(
          appID = "ALGOLIA_APPLICATION_ID",
          apiKey = "ALGOLIA_API_KEY"
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/authentications")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"type":"algolia","name":"authName","input":{"appID":"ALGOLIA_APPLICATION_ID","apiKey":"ALGOLIA_API_KEY"}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("createDestination") {
    val (client, echo) = testClient()
    val future = client.createDestination(
      destinationCreate = DestinationCreate(
        `type` = DestinationType.withName("search"),
        name = "destinationName",
        input = DestinationInput(
          indexName = "full_name______"
        ),
        authenticationID = Some("6c02aeb1-775e-418e-870b-1faccd4b2c0f")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/destinations")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"type":"search","name":"destinationName","input":{"indexName":"full_name______"},"authenticationID":"6c02aeb1-775e-418e-870b-1faccd4b2c0f"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("with transformationIDs1") {
    val (client, echo) = testClient()
    val future = client.createDestination(
      destinationCreate = DestinationCreate(
        `type` = DestinationType.withName("search"),
        name = "destinationName",
        input = DestinationInput(
          indexName = "full_name______"
        ),
        transformationIDs = Some(Seq("6c02aeb1-775e-418e-870b-1faccd4b2c0f"))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/destinations")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"type":"search","name":"destinationName","input":{"indexName":"full_name______"},"transformationIDs":["6c02aeb1-775e-418e-870b-1faccd4b2c0f"]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("createSource") {
    val (client, echo) = testClient()
    val future = client.createSource(
      sourceCreate = SourceCreate(
        `type` = SourceType.withName("commercetools"),
        name = "sourceName",
        input = Some(
          SourceCommercetools(
            storeKeys = Some(Seq("myStore")),
            locales = Some(Seq("de")),
            url = "http://commercetools.com",
            projectKey = "keyID",
            productQueryPredicate = Some("masterVariant(attributes(name=\"Brand\" and value=\"Algolia\"))")
          )
        ),
        authenticationID = Some("6c02aeb1-775e-418e-870b-1faccd4b2c0f")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/sources")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"type":"commercetools","name":"sourceName","input":{"storeKeys":["myStore"],"locales":["de"],"url":"http://commercetools.com","projectKey":"keyID","productQueryPredicate":"masterVariant(attributes(name=\"Brand\" and value=\"Algolia\"))"},"authenticationID":"6c02aeb1-775e-418e-870b-1faccd4b2c0f"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("push1") {
    val (client, echo) = testClient()
    val future = client.createSource(
      sourceCreate = SourceCreate(
        `type` = SourceType.withName("push"),
        name = "pushezpourentrer"
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/sources")
    assert(res.method == "POST")
    val expectedBody = parse("""{"type":"push","name":"pushezpourentrer"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("task without cron") {
    val (client, echo) = testClient()
    val future = client.createTask(
      taskCreate = TaskCreate(
        sourceID = "search",
        destinationID = "destinationID",
        action = ActionType.withName("replace")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/2/tasks")
    assert(res.method == "POST")
    val expectedBody = parse("""{"sourceID":"search","destinationID":"destinationID","action":"replace"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("task with cron1") {
    val (client, echo) = testClient()
    val future = client.createTask(
      taskCreate = TaskCreate(
        sourceID = "search",
        destinationID = "destinationID",
        cron = Some("* * * * *"),
        action = ActionType.withName("replace"),
        notifications = Some(
          Notifications(
            email = EmailNotifications(
              enabled = Some(true)
            )
          )
        ),
        policies = Some(
          Policies(
            criticalThreshold = Some(8)
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/2/tasks")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"sourceID":"search","destinationID":"destinationID","cron":"* * * * *","action":"replace","notifications":{"email":{"enabled":true}},"policies":{"criticalThreshold":8}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("task shopify2") {
    val (client, echo) = testClient()
    val future = client.createTask(
      taskCreate = TaskCreate(
        sourceID = "search",
        destinationID = "destinationID",
        cron = Some("* * * * *"),
        action = ActionType.withName("replace"),
        input = Some(
          DockerStreamsInput(
            streams = Seq(
              DockerStreams(
                name = "foo",
                syncMode = DockerStreamsSyncMode.withName("incremental")
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/2/tasks")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"sourceID":"search","destinationID":"destinationID","cron":"* * * * *","action":"replace","input":{"streams":[{"name":"foo","syncMode":"incremental"}]}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("createTaskOnDemand") {
    val (client, echo) = testClient()
    val future = client.createTaskV1(
      taskCreate = TaskCreateV1(
        sourceID = "search",
        destinationID = "destinationName",
        trigger = OnDemandTriggerInput(
          `type` = OnDemandTriggerType.withName("onDemand")
        ),
        action = ActionType.withName("replace")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/tasks")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"sourceID":"search","destinationID":"destinationName","trigger":{"type":"onDemand"},"action":"replace"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("createTaskSchedule1") {
    val (client, echo) = testClient()
    val future = client.createTaskV1(
      taskCreate = TaskCreateV1(
        sourceID = "search",
        destinationID = "destinationName",
        trigger = ScheduleTriggerInput(
          `type` = ScheduleTriggerType.withName("schedule"),
          cron = "* * * * *"
        ),
        action = ActionType.withName("replace")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/tasks")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"sourceID":"search","destinationID":"destinationName","trigger":{"type":"schedule","cron":"* * * * *"},"action":"replace"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("createTaskSubscription2") {
    val (client, echo) = testClient()
    val future = client.createTaskV1(
      taskCreate = TaskCreateV1(
        sourceID = "search",
        destinationID = "destinationName",
        trigger = OnDemandTriggerInput(
          `type` = OnDemandTriggerType.withName("onDemand")
        ),
        action = ActionType.withName("replace")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/tasks")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"sourceID":"search","destinationID":"destinationName","trigger":{"type":"onDemand"},"action":"replace"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("task shopify3") {
    val (client, echo) = testClient()
    val future = client.createTaskV1(
      taskCreate = TaskCreateV1(
        sourceID = "search",
        destinationID = "destinationName",
        trigger = OnDemandTriggerInput(
          `type` = OnDemandTriggerType.withName("onDemand")
        ),
        action = ActionType.withName("replace"),
        input = Some(
          DockerStreamsInput(
            streams = Seq(
              DockerStreams(
                name = "foo",
                syncMode = DockerStreamsSyncMode.withName("incremental")
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/tasks")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"sourceID":"search","destinationID":"destinationName","trigger":{"type":"onDemand"},"action":"replace","input":{"streams":[{"name":"foo","syncMode":"incremental"}]}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("createTransformation") {
    val (client, echo) = testClient()
    val future = client.createTransformation(
      transformationCreate = TransformationCreate(
        input = Some(
          TransformationCode(
            code = "foo"
          )
        ),
        `type` = Some(TransformationType.withName("code")),
        name = "bar",
        description = Some("baz")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/transformations")
    assert(res.method == "POST")
    val expectedBody = parse("""{"input":{"code":"foo"},"type":"code","name":"bar","description":"baz"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("allow del method for a custom path with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.customDelete[JObject](
      path = "test/minimal"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/minimal")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("allow del method for a custom path with all parameters1") {
    val (client, echo) = testClient()
    val future = client.customDelete[JObject](
      path = "test/all",
      parameters = Some(Map("query" -> "parameters"))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/all")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"query":"parameters"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("allow get method for a custom path with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.customGet[JObject](
      path = "test/minimal"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/minimal")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("allow get method for a custom path with all parameters1") {
    val (client, echo) = testClient()
    val future = client.customGet[JObject](
      path = "test/all",
      parameters = Some(Map("query" -> "parameters with space"))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/all")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"query":"parameters%20with%20space"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions should be escaped too2") {
    val (client, echo) = testClient()
    val future = client.customGet[JObject](
      path = "test/all",
      parameters = Some(Map("query" -> "to be overridden")),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("query", "parameters with space")
          .withQueryParameter("and an array", Seq("array", "with spaces"))
          .withHeader("x-header-1", "spaces are left alone")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/all")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"query":"parameters%20with%20space","and%20an%20array":"array%2Cwith%20spaces"}""")
      .asInstanceOf[JObject]
      .obj
      .toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
    val expectedHeaders = parse("""{"x-header-1":"spaces are left alone"}""").asInstanceOf[JObject].obj.toMap
    val actualHeaders = res.headers
    for ((k, v) <- expectedHeaders) {
      assert(actualHeaders.contains(k))
      assert(actualHeaders(k) == v.asInstanceOf[JString].s)
    }
  }

  test("allow post method for a custom path with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/minimal"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/minimal")
    assert(res.method == "POST")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("allow post method for a custom path with all parameters1") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/all",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("body", JString("parameters")))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/all")
    assert(res.method == "POST")
    val expectedBody = parse("""{"body":"parameters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions can override default query parameters2") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("query", "myQueryParameter")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"myQueryParameter"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions merges query parameters with default ones3") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("query2", "myQueryParameter")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters","query2":"myQueryParameter"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions can override default headers4") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withHeader("x-algolia-api-key", "ALGOLIA_API_KEY")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
    val expectedHeaders = parse("""{"x-algolia-api-key":"ALGOLIA_API_KEY"}""").asInstanceOf[JObject].obj.toMap
    val actualHeaders = res.headers
    for ((k, v) <- expectedHeaders) {
      assert(actualHeaders.contains(k))
      assert(actualHeaders(k) == v.asInstanceOf[JString].s)
    }
  }

  test("requestOptions merges headers with default ones5") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withHeader("x-algolia-api-key", "ALGOLIA_API_KEY")
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
    val expectedHeaders = parse("""{"x-algolia-api-key":"ALGOLIA_API_KEY"}""").asInstanceOf[JObject].obj.toMap
    val actualHeaders = res.headers
    for ((k, v) <- expectedHeaders) {
      assert(actualHeaders.contains(k))
      assert(actualHeaders(k) == v.asInstanceOf[JString].s)
    }
  }

  test("requestOptions queryParameters accepts booleans6") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("isItWorking", true)
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters","isItWorking":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions queryParameters accepts integers7") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("myParam", 2)
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters","myParam":"2"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions queryParameters accepts list of string8") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("myParam", Seq("b and c", "d"))
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters","myParam":"b%20and%20c%2Cd"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions queryParameters accepts list of booleans9") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("myParam", Seq(true, true, false))
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery =
      parse("""{"query":"parameters","myParam":"true%2Ctrue%2Cfalse"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("requestOptions queryParameters accepts list of integers10") {
    val (client, echo) = testClient()
    val future = client.customPost[JObject](
      path = "test/requestOptions",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("facet", JString("filters"))))),
      requestOptions = Some(
        RequestOptions
          .builder()
          .withQueryParameter("myParam", Seq(1, 2))
          .build()
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/requestOptions")
    assert(res.method == "POST")
    val expectedBody = parse("""{"facet":"filters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters","myParam":"1%2C2"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("allow put method for a custom path with minimal parameters") {
    val (client, echo) = testClient()
    val future = client.customPut[JObject](
      path = "test/minimal"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/minimal")
    assert(res.method == "PUT")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("allow put method for a custom path with all parameters1") {
    val (client, echo) = testClient()
    val future = client.customPut[JObject](
      path = "test/all",
      parameters = Some(Map("query" -> "parameters")),
      body = Some(JObject(List(JField("body", JString("parameters")))))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/test/all")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"body":"parameters"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"query":"parameters"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("deleteAuthentication") {
    val (client, echo) = testClient()
    val future = client.deleteAuthentication(
      authenticationID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/authentications/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("deleteDestination") {
    val (client, echo) = testClient()
    val future = client.deleteDestination(
      destinationID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/destinations/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("deleteSource") {
    val (client, echo) = testClient()
    val future = client.deleteSource(
      sourceID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/sources/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("deleteTask") {
    val (client, echo) = testClient()
    val future = client.deleteTask(
      taskID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/2/tasks/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("deleteTaskV1") {
    val (client, echo) = testClient()
    val future = client.deleteTaskV1(
      taskID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/tasks/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("deleteTransformation") {
    val (client, echo) = testClient()
    val future = client.deleteTransformation(
      transformationID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/transformations/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "DELETE")
    assert(res.body.isEmpty)
  }

  test("disableTask") {
    val (client, echo) = testClient()
    val future = client.disableTask(
      taskID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/2/tasks/6c02aeb1-775e-418e-870b-1faccd4b2c0f/disable")
    assert(res.method == "PUT")
    assert(res.body.contains("{}"))
  }

  test("disableTaskV1") {
    val (client, echo) = testClient()
    val future = client.disableTaskV1(
      taskID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/tasks/6c02aeb1-775e-418e-870b-1faccd4b2c0f/disable")
    assert(res.method == "PUT")
    assert(res.body.contains("{}"))
  }

  test("enableTask") {
    val (client, echo) = testClient()
    val future = client.enableTask(
      taskID = "76ab4c2a-ce17-496f-b7a6-506dc59ee498"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/2/tasks/76ab4c2a-ce17-496f-b7a6-506dc59ee498/enable")
    assert(res.method == "PUT")
    assert(res.body.contains("{}"))
  }

  test("enableTaskV1") {
    val (client, echo) = testClient()
    val future = client.enableTaskV1(
      taskID = "76ab4c2a-ce17-496f-b7a6-506dc59ee498"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/tasks/76ab4c2a-ce17-496f-b7a6-506dc59ee498/enable")
    assert(res.method == "PUT")
    assert(res.body.contains("{}"))
  }

  test("getAuthentication") {
    val (client, echo) = testClient()
    val future = client.getAuthentication(
      authenticationID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/authentications/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getDestination") {
    val (client, echo) = testClient()
    val future = client.getDestination(
      destinationID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/destinations/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getEvent") {
    val (client, echo) = testClient()
    val future = client.getEvent(
      runID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
      eventID = "6c02aeb1-775e-418e-870b-1faccd4b2c0c"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/runs/6c02aeb1-775e-418e-870b-1faccd4b2c0f/events/6c02aeb1-775e-418e-870b-1faccd4b2c0c")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getRun") {
    val (client, echo) = testClient()
    val future = client.getRun(
      runID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/runs/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getSource") {
    val (client, echo) = testClient()
    val future = client.getSource(
      sourceID = "75eeb306-51d3-4e5e-a279-3c92bd8893ac"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/sources/75eeb306-51d3-4e5e-a279-3c92bd8893ac")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getTask") {
    val (client, echo) = testClient()
    val future = client.getTask(
      taskID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/2/tasks/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getTaskV1") {
    val (client, echo) = testClient()
    val future = client.getTaskV1(
      taskID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/tasks/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getTransformation") {
    val (client, echo) = testClient()
    val future = client.getTransformation(
      transformationID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/transformations/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getAuthentications") {
    val (client, echo) = testClient()
    val future = client.listAuthentications(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/authentications")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getAuthentications with query params1") {
    val (client, echo) = testClient()
    val future = client.listAuthentications(
      itemsPerPage = Some(2),
      page = Some(1),
      `type` = Some(Seq(AuthenticationType.withName("basic"), AuthenticationType.withName("algolia"))),
      platform = Some(Seq(PlatformNone.withName("none"))),
      sort = Some(AuthenticationSortKeys.withName("createdAt")),
      order = Some(OrderKeys.withName("asc"))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/authentications")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse(
      """{"itemsPerPage":"2","page":"1","type":"basic%2Calgolia","platform":"none","sort":"createdAt","order":"asc"}"""
    ).asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("getDestinations") {
    val (client, echo) = testClient()
    val future = client.listDestinations(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/destinations")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("getEvents") {
    val (client, echo) = testClient()
    val future = client.listEvents(
      runID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/runs/6c02aeb1-775e-418e-870b-1faccd4b2c0f/events")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("listRuns") {
    val (client, echo) = testClient()
    val future = client.listRuns(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/runs")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("listSources") {
    val (client, echo) = testClient()
    val future = client.listSources(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/sources")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("listTasks") {
    val (client, echo) = testClient()
    val future = client.listTasks(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/2/tasks")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("listTasksV1") {
    val (client, echo) = testClient()
    val future = client.listTasksV1(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/tasks")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("listTransformations") {
    val (client, echo) = testClient()
    val future = client.listTransformations(
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/transformations")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
  }

  test("list with every parameters1") {
    val (client, echo) = testClient()
    val future = client.listTransformations(
      itemsPerPage = Some(2),
      page = Some(1),
      sort = Some(TransformationSortKeys.withName("createdAt")),
      order = Some(OrderKeys.withName("asc")),
      `type` = Some(TransformationType.withName("noCode"))
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/transformations")
    assert(res.method == "GET")
    assert(res.body.isEmpty)
    val expectedQuery = parse("""{"itemsPerPage":"2","page":"1","sort":"createdAt","order":"asc","type":"noCode"}""")
      .asInstanceOf[JObject]
      .obj
      .toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("global push") {
    val (client, echo) = testClient()
    val future = client.push(
      indexName = "foo",
      pushTaskPayload = PushTaskPayload(
        action = Action.withName("addObject"),
        records = Seq(
          PushTaskRecords(
            objectID = "o",
            additionalProperties = Some(List(JField("key", JString("bar")), JField("foo", JString("1"))))
          ),
          PushTaskRecords(
            objectID = "k",
            additionalProperties = Some(List(JField("key", JString("baz")), JField("foo", JString("2"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/push/foo")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"action":"addObject","records":[{"key":"bar","foo":"1","objectID":"o"},{"key":"baz","foo":"2","objectID":"k"}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("global push with watch mode1") {
    val (client, echo) = testClient()
    val future = client.push(
      indexName = "bar",
      pushTaskPayload = PushTaskPayload(
        action = Action.withName("addObject"),
        records = Seq(
          PushTaskRecords(
            objectID = "o",
            additionalProperties = Some(List(JField("key", JString("bar")), JField("foo", JString("1"))))
          ),
          PushTaskRecords(
            objectID = "k",
            additionalProperties = Some(List(JField("key", JString("baz")), JField("foo", JString("2"))))
          )
        )
      ),
      watch = Some(true),
      referenceIndexName = Some("foo")
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/push/bar")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"action":"addObject","records":[{"key":"bar","foo":"1","objectID":"o"},{"key":"baz","foo":"2","objectID":"k"}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"watch":"true","referenceIndexName":"foo"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("pushTask") {
    val (client, echo) = testClient()
    val future = client.pushTask(
      taskID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
      pushTaskPayload = PushTaskPayload(
        action = Action.withName("addObject"),
        records = Seq(
          PushTaskRecords(
            objectID = "o",
            additionalProperties = Some(List(JField("key", JString("bar")), JField("foo", JString("1"))))
          ),
          PushTaskRecords(
            objectID = "k",
            additionalProperties = Some(List(JField("key", JString("baz")), JField("foo", JString("2"))))
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/2/tasks/6c02aeb1-775e-418e-870b-1faccd4b2c0f/push")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"action":"addObject","records":[{"key":"bar","foo":"1","objectID":"o"},{"key":"baz","foo":"2","objectID":"k"}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("allows for watch query parameter1") {
    val (client, echo) = testClient()
    val future = client.pushTask(
      taskID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
      pushTaskPayload = PushTaskPayload(
        action = Action.withName("addObject"),
        records = Seq(
          PushTaskRecords(
            objectID = "o",
            additionalProperties = Some(List(JField("key", JString("bar")), JField("foo", JString("1"))))
          ),
          PushTaskRecords(
            objectID = "k",
            additionalProperties = Some(List(JField("key", JString("baz")), JField("foo", JString("2"))))
          )
        )
      ),
      watch = Some(true)
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/2/tasks/6c02aeb1-775e-418e-870b-1faccd4b2c0f/push")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"action":"addObject","records":[{"key":"bar","foo":"1","objectID":"o"},{"key":"baz","foo":"2","objectID":"k"}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
    val expectedQuery = parse("""{"watch":"true"}""").asInstanceOf[JObject].obj.toMap
    val actualQuery = res.queryParameters
    assert(actualQuery.size == expectedQuery.size)
    for ((k, v) <- actualQuery) {
      assert(expectedQuery.contains(k))
      assert(expectedQuery(k).values == v)
    }
  }

  test("fully replace task without cron") {
    val (client, echo) = testClient()
    val future = client.replaceTask(
      taskID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
      taskReplace = TaskReplace(
        destinationID = "destinationID",
        action = ActionType.withName("replace")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/2/tasks/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"destinationID":"destinationID","action":"replace"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("fully replace task with cron1") {
    val (client, echo) = testClient()
    val future = client.replaceTask(
      taskID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
      taskReplace = TaskReplace(
        destinationID = "destinationID",
        cron = Some("* * * * *"),
        action = ActionType.withName("replace"),
        notifications = Some(
          Notifications(
            email = EmailNotifications(
              enabled = Some(true)
            )
          )
        ),
        policies = Some(
          Policies(
            criticalThreshold = Some(8)
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/2/tasks/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"destinationID":"destinationID","cron":"* * * * *","action":"replace","notifications":{"email":{"enabled":true}},"policies":{"criticalThreshold":8}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("fully replace task shopify2") {
    val (client, echo) = testClient()
    val future = client.replaceTask(
      taskID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
      taskReplace = TaskReplace(
        destinationID = "destinationID",
        cron = Some("* * * * *"),
        action = ActionType.withName("replace"),
        input = Some(
          DockerStreamsInput(
            streams = Seq(
              DockerStreams(
                name = "foo",
                syncMode = DockerStreamsSyncMode.withName("incremental")
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/2/tasks/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "PUT")
    val expectedBody = parse(
      """{"destinationID":"destinationID","cron":"* * * * *","action":"replace","input":{"streams":[{"name":"foo","syncMode":"incremental"}]}}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("runSource") {
    val (client, echo) = testClient()
    val future = client.runSource(
      sourceID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
      runSourcePayload = Some(
        RunSourcePayload(
          indexToInclude = Some(Seq("products_us", "products eu")),
          entityIDs = Some(Seq("1234", "5678")),
          entityType = Some(EntityType.withName("product"))
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/sources/6c02aeb1-775e-418e-870b-1faccd4b2c0f/run")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"indexToInclude":["products_us","products eu"],"entityIDs":["1234","5678"],"entityType":"product"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("runTask") {
    val (client, echo) = testClient()
    val future = client.runTask(
      taskID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/2/tasks/6c02aeb1-775e-418e-870b-1faccd4b2c0f/run")
    assert(res.method == "POST")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("runTaskV1") {
    val (client, echo) = testClient()
    val future = client.runTaskV1(
      taskID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/tasks/6c02aeb1-775e-418e-870b-1faccd4b2c0f/run")
    assert(res.method == "POST")
    val expectedBody = parse("""{}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchAuthentications") {
    val (client, echo) = testClient()
    val future = client.searchAuthentications(
      authenticationSearch = AuthenticationSearch(
        authenticationIDs = Seq("6c02aeb1-775e-418e-870b-1faccd4b2c0f", "947ac9c4-7e58-4c87-b1e7-14a68e99699a")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/authentications/search")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"authenticationIDs":["6c02aeb1-775e-418e-870b-1faccd4b2c0f","947ac9c4-7e58-4c87-b1e7-14a68e99699a"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchDestinations") {
    val (client, echo) = testClient()
    val future = client.searchDestinations(
      destinationSearch = DestinationSearch(
        destinationIDs = Seq("6c02aeb1-775e-418e-870b-1faccd4b2c0f", "947ac9c4-7e58-4c87-b1e7-14a68e99699a")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/destinations/search")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"destinationIDs":["6c02aeb1-775e-418e-870b-1faccd4b2c0f","947ac9c4-7e58-4c87-b1e7-14a68e99699a"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchSources") {
    val (client, echo) = testClient()
    val future = client.searchSources(
      sourceSearch = SourceSearch(
        sourceIDs = Seq("6c02aeb1-775e-418e-870b-1faccd4b2c0f", "947ac9c4-7e58-4c87-b1e7-14a68e99699a")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/sources/search")
    assert(res.method == "POST")
    val expectedBody =
      parse("""{"sourceIDs":["6c02aeb1-775e-418e-870b-1faccd4b2c0f","947ac9c4-7e58-4c87-b1e7-14a68e99699a"]}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchTasks") {
    val (client, echo) = testClient()
    val future = client.searchTasks(
      taskSearch = TaskSearch(
        taskIDs = Seq(
          "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
          "947ac9c4-7e58-4c87-b1e7-14a68e99699a",
          "76ab4c2a-ce17-496f-b7a6-506dc59ee498"
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/2/tasks/search")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"taskIDs":["6c02aeb1-775e-418e-870b-1faccd4b2c0f","947ac9c4-7e58-4c87-b1e7-14a68e99699a","76ab4c2a-ce17-496f-b7a6-506dc59ee498"]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchTasksV1") {
    val (client, echo) = testClient()
    val future = client.searchTasksV1(
      taskSearch = TaskSearch(
        taskIDs = Seq(
          "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
          "947ac9c4-7e58-4c87-b1e7-14a68e99699a",
          "76ab4c2a-ce17-496f-b7a6-506dc59ee498"
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/tasks/search")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"taskIDs":["6c02aeb1-775e-418e-870b-1faccd4b2c0f","947ac9c4-7e58-4c87-b1e7-14a68e99699a","76ab4c2a-ce17-496f-b7a6-506dc59ee498"]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("searchTransformations") {
    val (client, echo) = testClient()
    val future = client.searchTransformations(
      transformationSearch = TransformationSearch(
        transformationIDs = Seq(
          "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
          "947ac9c4-7e58-4c87-b1e7-14a68e99699a",
          "76ab4c2a-ce17-496f-b7a6-506dc59ee498"
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/transformations/search")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"transformationIDs":["6c02aeb1-775e-418e-870b-1faccd4b2c0f","947ac9c4-7e58-4c87-b1e7-14a68e99699a","76ab4c2a-ce17-496f-b7a6-506dc59ee498"]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("triggerDockerSourceDiscover") {
    val (client, echo) = testClient()
    val future = client.triggerDockerSourceDiscover(
      sourceID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f"
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/sources/6c02aeb1-775e-418e-870b-1faccd4b2c0f/discover")
    assert(res.method == "POST")
    assert(res.body.contains("{}"))
  }

  test("tryTransformation") {
    val (client, echo) = testClient()
    val future = client.tryTransformation(
      transformationTry = TransformationTry(
        `type` = Some(TransformationType.withName("code")),
        input = Some(
          TransformationCode(
            code = "foo"
          )
        ),
        sampleRecord = JObject(List(JField("bar", JString("baz"))))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/transformations/try")
    assert(res.method == "POST")
    val expectedBody = parse("""{"type":"code","input":{"code":"foo"},"sampleRecord":{"bar":"baz"}}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("with authentications1") {
    val (client, echo) = testClient()
    val future = client.tryTransformation(
      transformationTry = TransformationTry(
        `type` = Some(TransformationType.withName("code")),
        input = Some(
          TransformationCode(
            code = "foo"
          )
        ),
        sampleRecord = JObject(List(JField("bar", JString("baz")))),
        authentications = Some(
          Seq(
            AuthenticationCreate(
              `type` = AuthenticationType.withName("oauth"),
              name = "authName",
              input = AuthOAuth(
                url = "http://test.oauth",
                clientId = "myID",
                clientSecret = "mySecret"
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/transformations/try")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"type":"code","input":{"code":"foo"},"sampleRecord":{"bar":"baz"},"authentications":[{"type":"oauth","name":"authName","input":{"url":"http://test.oauth","client_id":"myID","client_secret":"mySecret"}}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("tryTransformationBeforeUpdate") {
    val (client, echo) = testClient()
    val future = client.tryTransformationBeforeUpdate(
      transformationID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
      transformationTry = TransformationTry(
        `type` = Some(TransformationType.withName("code")),
        input = Some(
          TransformationCode(
            code = "foo"
          )
        ),
        sampleRecord = JObject(List(JField("bar", JString("baz"))))
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/transformations/6c02aeb1-775e-418e-870b-1faccd4b2c0f/try")
    assert(res.method == "POST")
    val expectedBody = parse("""{"type":"code","input":{"code":"foo"},"sampleRecord":{"bar":"baz"}}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("existing with authentications1") {
    val (client, echo) = testClient()
    val future = client.tryTransformationBeforeUpdate(
      transformationID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
      transformationTry = TransformationTry(
        `type` = Some(TransformationType.withName("code")),
        input = Some(
          TransformationCode(
            code = "foo"
          )
        ),
        sampleRecord = JObject(List(JField("bar", JString("baz")))),
        authentications = Some(
          Seq(
            AuthenticationCreate(
              `type` = AuthenticationType.withName("oauth"),
              name = "authName",
              input = AuthOAuth(
                url = "http://test.oauth",
                clientId = "myID",
                clientSecret = "mySecret"
              )
            )
          )
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/transformations/6c02aeb1-775e-418e-870b-1faccd4b2c0f/try")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"type":"code","input":{"code":"foo"},"sampleRecord":{"bar":"baz"},"authentications":[{"type":"oauth","name":"authName","input":{"url":"http://test.oauth","client_id":"myID","client_secret":"mySecret"}}]}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("updateAuthentication") {
    val (client, echo) = testClient()
    val future = client.updateAuthentication(
      authenticationID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
      authenticationUpdate = AuthenticationUpdate(
        name = Some("newName")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/authentications/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "PATCH")
    val expectedBody = parse("""{"name":"newName"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("updateDestination") {
    val (client, echo) = testClient()
    val future = client.updateDestination(
      destinationID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
      destinationUpdate = DestinationUpdate(
        name = Some("newName")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/destinations/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "PATCH")
    val expectedBody = parse("""{"name":"newName"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("updateSource") {
    val (client, echo) = testClient()
    val future = client.updateSource(
      sourceID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
      sourceUpdate = SourceUpdate(
        name = Some("newName")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/sources/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "PATCH")
    val expectedBody = parse("""{"name":"newName"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("updateTask") {
    val (client, echo) = testClient()
    val future = client.updateTask(
      taskID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
      taskUpdate = TaskUpdate(
        enabled = Some(false),
        cron = Some("* * * * *")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/2/tasks/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "PATCH")
    val expectedBody = parse("""{"enabled":false,"cron":"* * * * *"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("updateTaskV1") {
    val (client, echo) = testClient()
    val future = client.updateTaskV1(
      taskID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
      taskUpdate = TaskUpdateV1(
        enabled = Some(false)
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/tasks/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "PATCH")
    val expectedBody = parse("""{"enabled":false}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("updateTransformation") {
    val (client, echo) = testClient()
    val future = client.updateTransformation(
      transformationID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
      transformationCreate = TransformationCreate(
        input = Some(
          TransformationCode(
            code = "foo"
          )
        ),
        `type` = Some(TransformationType.withName("code")),
        name = "bar",
        description = Some("baz")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/transformations/6c02aeb1-775e-418e-870b-1faccd4b2c0f")
    assert(res.method == "PUT")
    val expectedBody = parse("""{"input":{"code":"foo"},"type":"code","name":"bar","description":"baz"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("validateSource") {
    val (client, echo) = testClient()
    val future = client.validateSource(
      sourceCreate = Some(
        SourceCreate(
          `type` = SourceType.withName("commercetools"),
          name = "sourceName",
          input = Some(
            SourceCommercetools(
              storeKeys = Some(Seq("myStore")),
              locales = Some(Seq("de")),
              url = "http://commercetools.com",
              projectKey = "keyID"
            )
          ),
          authenticationID = Some("6c02aeb1-775e-418e-870b-1faccd4b2c0f")
        )
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/sources/validate")
    assert(res.method == "POST")
    val expectedBody = parse(
      """{"type":"commercetools","name":"sourceName","input":{"storeKeys":["myStore"],"locales":["de"],"url":"http://commercetools.com","projectKey":"keyID"},"authenticationID":"6c02aeb1-775e-418e-870b-1faccd4b2c0f"}"""
    )
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

  test("validateSourceBeforeUpdate") {
    val (client, echo) = testClient()
    val future = client.validateSourceBeforeUpdate(
      sourceID = "6c02aeb1-775e-418e-870b-1faccd4b2c0f",
      sourceUpdate = SourceUpdate(
        name = Some("newName")
      )
    )

    Await.ready(future, Duration.Inf)
    val res = echo.lastResponse.get

    assert(res.path == "/1/sources/6c02aeb1-775e-418e-870b-1faccd4b2c0f/validate")
    assert(res.method == "POST")
    val expectedBody = parse("""{"name":"newName"}""")
    val actualBody = parse(res.body.get)
    assert(actualBody == expectedBody)
  }

}
