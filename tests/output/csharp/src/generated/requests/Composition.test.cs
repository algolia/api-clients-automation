// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
using System.Text.Json;
using Algolia.Search.Clients;
using Algolia.Search.Http;
using Algolia.Search.Models.Composition;
using Algolia.Search.Serializer;
using Algolia.Search.Tests.Utils;
using dotenv.net;
using Quibble.Xunit;
using Xunit;
using Action = Algolia.Search.Models.Composition.Action;

namespace Algolia.Search.requests;

public class CompositionClientRequestTests
{
  private readonly CompositionClient client;
  private readonly EchoHttpRequester _echo;

  public CompositionClientRequestTests()
  {
    _echo = new EchoHttpRequester();
    client = new CompositionClient(new CompositionConfig("appId", "apiKey"), _echo);
  }

  [Fact]
  public void Dispose() { }

  [Fact(DisplayName = "allow del method for a custom path with minimal parameters")]
  public async Task CustomDeleteTest()
  {
    await client.CustomDeleteAsync("test/minimal");

    var req = _echo.LastResponse;
    Assert.Equal("/test/minimal", req.Path);
    Assert.Equal("DELETE", req.Method.ToString());
    Assert.Null(req.Body);
  }

  [Fact(DisplayName = "allow del method for a custom path with all parameters")]
  public async Task CustomDeleteTest1()
  {
    await client.CustomDeleteAsync(
      "test/all",
      new Dictionary<string, object> { { "query", "parameters" } }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/test/all", req.Path);
    Assert.Equal("DELETE", req.Method.ToString());
    Assert.Null(req.Body);
    var expectedQuery = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"query\":\"parameters\"}"
    );
    Assert.NotNull(expectedQuery);

    var actualQuery = req.QueryParameters;
    Assert.Equal(expectedQuery.Count, actualQuery.Count);

    foreach (var actual in actualQuery)
    {
      expectedQuery.TryGetValue(actual.Key, out var expected);
      Assert.Equal(expected, actual.Value);
    }
  }

  [Fact(DisplayName = "allow get method for a custom path with minimal parameters")]
  public async Task CustomGetTest()
  {
    await client.CustomGetAsync("test/minimal");

    var req = _echo.LastResponse;
    Assert.Equal("/test/minimal", req.Path);
    Assert.Equal("GET", req.Method.ToString());
    Assert.Null(req.Body);
  }

  [Fact(DisplayName = "allow get method for a custom path with all parameters")]
  public async Task CustomGetTest1()
  {
    await client.CustomGetAsync(
      "test/all",
      new Dictionary<string, object> { { "query", "parameters with space" } }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/test/all", req.Path);
    Assert.Equal("GET", req.Method.ToString());
    Assert.Null(req.Body);
    var expectedQuery = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"query\":\"parameters%20with%20space\"}"
    );
    Assert.NotNull(expectedQuery);

    var actualQuery = req.QueryParameters;
    Assert.Equal(expectedQuery.Count, actualQuery.Count);

    foreach (var actual in actualQuery)
    {
      expectedQuery.TryGetValue(actual.Key, out var expected);
      Assert.Equal(expected, actual.Value);
    }
  }

  [Fact(DisplayName = "requestOptions should be escaped too")]
  public async Task CustomGetTest2()
  {
    await client.CustomGetAsync(
      "test/all",
      new Dictionary<string, object> { { "query", "to be overriden" } },
      new RequestOptionBuilder()
        .AddExtraQueryParameters("query", "parameters with space")
        .AddExtraQueryParameters("and an array", new List<object> { "array", "with spaces" })
        .AddExtraHeader("x-header-1", "spaces are left alone")
        .Build()
    );

    var req = _echo.LastResponse;
    Assert.Equal("/test/all", req.Path);
    Assert.Equal("GET", req.Method.ToString());
    Assert.Null(req.Body);
    var expectedQuery = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"query\":\"parameters%20with%20space\",\"and%20an%20array\":\"array%2Cwith%20spaces\"}"
    );
    Assert.NotNull(expectedQuery);

    var actualQuery = req.QueryParameters;
    Assert.Equal(expectedQuery.Count, actualQuery.Count);

    foreach (var actual in actualQuery)
    {
      expectedQuery.TryGetValue(actual.Key, out var expected);
      Assert.Equal(expected, actual.Value);
    }
    var expectedHeaders = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"x-header-1\":\"spaces are left alone\"}"
    );
    var actualHeaders = req.Headers;
    foreach (var expectedHeader in expectedHeaders)
    {
      string actualHeaderValue;
      actualHeaders.TryGetValue(expectedHeader.Key, out actualHeaderValue);
      Assert.Equal(expectedHeader.Value, actualHeaderValue);
    }
  }

  [Fact(DisplayName = "allow post method for a custom path with minimal parameters")]
  public async Task CustomPostTest()
  {
    await client.CustomPostAsync("test/minimal");

    var req = _echo.LastResponse;
    Assert.Equal("/test/minimal", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault("{}", req.Body, new JsonDiffConfig(false));
  }

  [Fact(DisplayName = "allow post method for a custom path with all parameters")]
  public async Task CustomPostTest1()
  {
    await client.CustomPostAsync(
      "test/all",
      new Dictionary<string, object> { { "query", "parameters" } },
      new Dictionary<string, string> { { "body", "parameters" } }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/test/all", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"body\":\"parameters\"}",
      req.Body,
      new JsonDiffConfig(false)
    );
    var expectedQuery = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"query\":\"parameters\"}"
    );
    Assert.NotNull(expectedQuery);

    var actualQuery = req.QueryParameters;
    Assert.Equal(expectedQuery.Count, actualQuery.Count);

    foreach (var actual in actualQuery)
    {
      expectedQuery.TryGetValue(actual.Key, out var expected);
      Assert.Equal(expected, actual.Value);
    }
  }

  [Fact(DisplayName = "requestOptions can override default query parameters")]
  public async Task CustomPostTest2()
  {
    await client.CustomPostAsync(
      "test/requestOptions",
      new Dictionary<string, object> { { "query", "parameters" } },
      new Dictionary<string, string> { { "facet", "filters" } },
      new RequestOptionBuilder().AddExtraQueryParameters("query", "myQueryParameter").Build()
    );

    var req = _echo.LastResponse;
    Assert.Equal("/test/requestOptions", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault("{\"facet\":\"filters\"}", req.Body, new JsonDiffConfig(false));
    var expectedQuery = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"query\":\"myQueryParameter\"}"
    );
    Assert.NotNull(expectedQuery);

    var actualQuery = req.QueryParameters;
    Assert.Equal(expectedQuery.Count, actualQuery.Count);

    foreach (var actual in actualQuery)
    {
      expectedQuery.TryGetValue(actual.Key, out var expected);
      Assert.Equal(expected, actual.Value);
    }
  }

  [Fact(DisplayName = "requestOptions merges query parameters with default ones")]
  public async Task CustomPostTest3()
  {
    await client.CustomPostAsync(
      "test/requestOptions",
      new Dictionary<string, object> { { "query", "parameters" } },
      new Dictionary<string, string> { { "facet", "filters" } },
      new RequestOptionBuilder().AddExtraQueryParameters("query2", "myQueryParameter").Build()
    );

    var req = _echo.LastResponse;
    Assert.Equal("/test/requestOptions", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault("{\"facet\":\"filters\"}", req.Body, new JsonDiffConfig(false));
    var expectedQuery = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"query\":\"parameters\",\"query2\":\"myQueryParameter\"}"
    );
    Assert.NotNull(expectedQuery);

    var actualQuery = req.QueryParameters;
    Assert.Equal(expectedQuery.Count, actualQuery.Count);

    foreach (var actual in actualQuery)
    {
      expectedQuery.TryGetValue(actual.Key, out var expected);
      Assert.Equal(expected, actual.Value);
    }
  }

  [Fact(DisplayName = "requestOptions can override default headers")]
  public async Task CustomPostTest4()
  {
    await client.CustomPostAsync(
      "test/requestOptions",
      new Dictionary<string, object> { { "query", "parameters" } },
      new Dictionary<string, string> { { "facet", "filters" } },
      new RequestOptionBuilder().AddExtraHeader("x-algolia-api-key", "ALGOLIA_API_KEY").Build()
    );

    var req = _echo.LastResponse;
    Assert.Equal("/test/requestOptions", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault("{\"facet\":\"filters\"}", req.Body, new JsonDiffConfig(false));
    var expectedQuery = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"query\":\"parameters\"}"
    );
    Assert.NotNull(expectedQuery);

    var actualQuery = req.QueryParameters;
    Assert.Equal(expectedQuery.Count, actualQuery.Count);

    foreach (var actual in actualQuery)
    {
      expectedQuery.TryGetValue(actual.Key, out var expected);
      Assert.Equal(expected, actual.Value);
    }
    var expectedHeaders = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"x-algolia-api-key\":\"ALGOLIA_API_KEY\"}"
    );
    var actualHeaders = req.Headers;
    foreach (var expectedHeader in expectedHeaders)
    {
      string actualHeaderValue;
      actualHeaders.TryGetValue(expectedHeader.Key, out actualHeaderValue);
      Assert.Equal(expectedHeader.Value, actualHeaderValue);
    }
  }

  [Fact(DisplayName = "requestOptions merges headers with default ones")]
  public async Task CustomPostTest5()
  {
    await client.CustomPostAsync(
      "test/requestOptions",
      new Dictionary<string, object> { { "query", "parameters" } },
      new Dictionary<string, string> { { "facet", "filters" } },
      new RequestOptionBuilder().AddExtraHeader("x-algolia-api-key", "ALGOLIA_API_KEY").Build()
    );

    var req = _echo.LastResponse;
    Assert.Equal("/test/requestOptions", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault("{\"facet\":\"filters\"}", req.Body, new JsonDiffConfig(false));
    var expectedQuery = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"query\":\"parameters\"}"
    );
    Assert.NotNull(expectedQuery);

    var actualQuery = req.QueryParameters;
    Assert.Equal(expectedQuery.Count, actualQuery.Count);

    foreach (var actual in actualQuery)
    {
      expectedQuery.TryGetValue(actual.Key, out var expected);
      Assert.Equal(expected, actual.Value);
    }
    var expectedHeaders = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"x-algolia-api-key\":\"ALGOLIA_API_KEY\"}"
    );
    var actualHeaders = req.Headers;
    foreach (var expectedHeader in expectedHeaders)
    {
      string actualHeaderValue;
      actualHeaders.TryGetValue(expectedHeader.Key, out actualHeaderValue);
      Assert.Equal(expectedHeader.Value, actualHeaderValue);
    }
  }

  [Fact(DisplayName = "requestOptions queryParameters accepts booleans")]
  public async Task CustomPostTest6()
  {
    await client.CustomPostAsync(
      "test/requestOptions",
      new Dictionary<string, object> { { "query", "parameters" } },
      new Dictionary<string, string> { { "facet", "filters" } },
      new RequestOptionBuilder().AddExtraQueryParameters("isItWorking", true).Build()
    );

    var req = _echo.LastResponse;
    Assert.Equal("/test/requestOptions", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault("{\"facet\":\"filters\"}", req.Body, new JsonDiffConfig(false));
    var expectedQuery = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"query\":\"parameters\",\"isItWorking\":\"true\"}"
    );
    Assert.NotNull(expectedQuery);

    var actualQuery = req.QueryParameters;
    Assert.Equal(expectedQuery.Count, actualQuery.Count);

    foreach (var actual in actualQuery)
    {
      expectedQuery.TryGetValue(actual.Key, out var expected);
      Assert.Equal(expected, actual.Value);
    }
  }

  [Fact(DisplayName = "requestOptions queryParameters accepts integers")]
  public async Task CustomPostTest7()
  {
    await client.CustomPostAsync(
      "test/requestOptions",
      new Dictionary<string, object> { { "query", "parameters" } },
      new Dictionary<string, string> { { "facet", "filters" } },
      new RequestOptionBuilder().AddExtraQueryParameters("myParam", 2).Build()
    );

    var req = _echo.LastResponse;
    Assert.Equal("/test/requestOptions", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault("{\"facet\":\"filters\"}", req.Body, new JsonDiffConfig(false));
    var expectedQuery = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"query\":\"parameters\",\"myParam\":\"2\"}"
    );
    Assert.NotNull(expectedQuery);

    var actualQuery = req.QueryParameters;
    Assert.Equal(expectedQuery.Count, actualQuery.Count);

    foreach (var actual in actualQuery)
    {
      expectedQuery.TryGetValue(actual.Key, out var expected);
      Assert.Equal(expected, actual.Value);
    }
  }

  [Fact(DisplayName = "requestOptions queryParameters accepts list of string")]
  public async Task CustomPostTest8()
  {
    await client.CustomPostAsync(
      "test/requestOptions",
      new Dictionary<string, object> { { "query", "parameters" } },
      new Dictionary<string, string> { { "facet", "filters" } },
      new RequestOptionBuilder()
        .AddExtraQueryParameters("myParam", new List<object> { "b and c", "d" })
        .Build()
    );

    var req = _echo.LastResponse;
    Assert.Equal("/test/requestOptions", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault("{\"facet\":\"filters\"}", req.Body, new JsonDiffConfig(false));
    var expectedQuery = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"query\":\"parameters\",\"myParam\":\"b%20and%20c%2Cd\"}"
    );
    Assert.NotNull(expectedQuery);

    var actualQuery = req.QueryParameters;
    Assert.Equal(expectedQuery.Count, actualQuery.Count);

    foreach (var actual in actualQuery)
    {
      expectedQuery.TryGetValue(actual.Key, out var expected);
      Assert.Equal(expected, actual.Value);
    }
  }

  [Fact(DisplayName = "requestOptions queryParameters accepts list of booleans")]
  public async Task CustomPostTest9()
  {
    await client.CustomPostAsync(
      "test/requestOptions",
      new Dictionary<string, object> { { "query", "parameters" } },
      new Dictionary<string, string> { { "facet", "filters" } },
      new RequestOptionBuilder()
        .AddExtraQueryParameters("myParam", new List<object> { true, true, false })
        .Build()
    );

    var req = _echo.LastResponse;
    Assert.Equal("/test/requestOptions", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault("{\"facet\":\"filters\"}", req.Body, new JsonDiffConfig(false));
    var expectedQuery = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"query\":\"parameters\",\"myParam\":\"true%2Ctrue%2Cfalse\"}"
    );
    Assert.NotNull(expectedQuery);

    var actualQuery = req.QueryParameters;
    Assert.Equal(expectedQuery.Count, actualQuery.Count);

    foreach (var actual in actualQuery)
    {
      expectedQuery.TryGetValue(actual.Key, out var expected);
      Assert.Equal(expected, actual.Value);
    }
  }

  [Fact(DisplayName = "requestOptions queryParameters accepts list of integers")]
  public async Task CustomPostTest10()
  {
    await client.CustomPostAsync(
      "test/requestOptions",
      new Dictionary<string, object> { { "query", "parameters" } },
      new Dictionary<string, string> { { "facet", "filters" } },
      new RequestOptionBuilder()
        .AddExtraQueryParameters("myParam", new List<object> { 1, 2 })
        .Build()
    );

    var req = _echo.LastResponse;
    Assert.Equal("/test/requestOptions", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault("{\"facet\":\"filters\"}", req.Body, new JsonDiffConfig(false));
    var expectedQuery = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"query\":\"parameters\",\"myParam\":\"1%2C2\"}"
    );
    Assert.NotNull(expectedQuery);

    var actualQuery = req.QueryParameters;
    Assert.Equal(expectedQuery.Count, actualQuery.Count);

    foreach (var actual in actualQuery)
    {
      expectedQuery.TryGetValue(actual.Key, out var expected);
      Assert.Equal(expected, actual.Value);
    }
  }

  [Fact(DisplayName = "allow put method for a custom path with minimal parameters")]
  public async Task CustomPutTest()
  {
    await client.CustomPutAsync("test/minimal");

    var req = _echo.LastResponse;
    Assert.Equal("/test/minimal", req.Path);
    Assert.Equal("PUT", req.Method.ToString());
    JsonAssert.EqualOverrideDefault("{}", req.Body, new JsonDiffConfig(false));
  }

  [Fact(DisplayName = "allow put method for a custom path with all parameters")]
  public async Task CustomPutTest1()
  {
    await client.CustomPutAsync(
      "test/all",
      new Dictionary<string, object> { { "query", "parameters" } },
      new Dictionary<string, string> { { "body", "parameters" } }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/test/all", req.Path);
    Assert.Equal("PUT", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"body\":\"parameters\"}",
      req.Body,
      new JsonDiffConfig(false)
    );
    var expectedQuery = JsonSerializer.Deserialize<Dictionary<string, string>>(
      "{\"query\":\"parameters\"}"
    );
    Assert.NotNull(expectedQuery);

    var actualQuery = req.QueryParameters;
    Assert.Equal(expectedQuery.Count, actualQuery.Count);

    foreach (var actual in actualQuery)
    {
      expectedQuery.TryGetValue(actual.Key, out var expected);
      Assert.Equal(expected, actual.Value);
    }
  }

  [Fact(DisplayName = "deleteComposition")]
  public async Task DeleteCompositionTest()
  {
    await client.DeleteCompositionAsync("1234");

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/1234", req.Path);
    Assert.Equal("DELETE", req.Method.ToString());
    Assert.Null(req.Body);
  }

  [Fact(DisplayName = "deleteCompositionRule")]
  public async Task DeleteCompositionRuleTest()
  {
    await client.DeleteCompositionRuleAsync("1234", "5678");

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/1234/rules/5678", req.Path);
    Assert.Equal("DELETE", req.Method.ToString());
    Assert.Null(req.Body);
  }

  [Fact(DisplayName = "getComposition")]
  public async Task GetCompositionTest()
  {
    await client.GetCompositionAsync("foo");

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/foo", req.Path);
    Assert.Equal("GET", req.Method.ToString());
    Assert.Null(req.Body);
  }

  [Fact(DisplayName = "getRule")]
  public async Task GetRuleTest()
  {
    await client.GetRuleAsync("foo", "123");

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/foo/rules/123", req.Path);
    Assert.Equal("GET", req.Method.ToString());
    Assert.Null(req.Body);
  }

  [Fact(DisplayName = "getTask")]
  public async Task GetTaskTest()
  {
    await client.GetTaskAsync("foo", 42L);

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/foo/task/42", req.Path);
    Assert.Equal("GET", req.Method.ToString());
    Assert.Null(req.Body);
  }

  [Fact(DisplayName = "listCompositions")]
  public async Task ListCompositionsTest()
  {
    await client.ListCompositionsAsync();

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions", req.Path);
    Assert.Equal("GET", req.Method.ToString());
    Assert.Null(req.Body);
  }

  [Fact(DisplayName = "listCompositions")]
  public async Task ListCompositionsTest1()
  {
    await client.ListCompositionsAsync();

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions", req.Path);
    Assert.Equal("GET", req.Method.ToString());
    Assert.Null(req.Body);
  }

  [Fact(DisplayName = "multipleBatch")]
  public async Task MultipleBatchTest()
  {
    await client.MultipleBatchAsync(
      new BatchParams
      {
        Requests = new List<MultipleBatchRequest>
        {
          new MultipleBatchRequest
          {
            Action = Enum.Parse<Action>("Upsert"),
            Body = new BatchCompositionAction(
              new Composition
              {
                ObjectID = "foo",
                Name = "my first composition",
                Behavior = new CompositionBehavior
                {
                  Injection = new Injection
                  {
                    Main = new Main
                    {
                      Source = new CompositionSource
                      {
                        Search = new CompositionSourceSearch { Index = "bar" },
                      },
                    },
                  },
                },
              }
            ),
          },
          new MultipleBatchRequest
          {
            Action = Enum.Parse<Action>("Delete"),
            Body = new BatchCompositionAction(new DeleteCompositionAction { ObjectID = "baz" }),
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/*/batch", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"requests\":[{\"action\":\"upsert\",\"body\":{\"objectID\":\"foo\",\"name\":\"my first composition\",\"behavior\":{\"injection\":{\"main\":{\"source\":{\"search\":{\"index\":\"bar\"}}}}}}},{\"action\":\"delete\",\"body\":{\"objectID\":\"baz\"}}]}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "multipleBatch")]
  public async Task MultipleBatchTest1()
  {
    await client.MultipleBatchAsync(
      new BatchParams
      {
        Requests = new List<MultipleBatchRequest>
        {
          new MultipleBatchRequest
          {
            Action = Enum.Parse<Action>("Upsert"),
            Body = new BatchCompositionAction(
              new Composition
              {
                ObjectID = "my-external-injection-compo",
                Name = "my first composition",
                Behavior = new CompositionBehavior
                {
                  Injection = new Injection
                  {
                    Main = new Main
                    {
                      Source = new CompositionSource
                      {
                        Search = new CompositionSourceSearch { Index = "foo" },
                      },
                    },
                    InjectedItems = new List<InjectedItem>
                    {
                      new InjectedItem
                      {
                        Key = "injectedItem1",
                        Source = new InjectedItemSource(
                          new ExternalSource
                          {
                            External = new External
                            {
                              Index = "foo",
                              Ordering = Enum.Parse<ExternalOrdering>("UserDefined"),
                              Params = new BaseInjectionQueryParameters
                              {
                                Filters = "brand:adidas",
                              },
                            },
                          }
                        ),
                        Position = 2,
                        Length = 1,
                      },
                    },
                  },
                },
              }
            ),
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/*/batch", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"requests\":[{\"action\":\"upsert\",\"body\":{\"objectID\":\"my-external-injection-compo\",\"name\":\"my first composition\",\"behavior\":{\"injection\":{\"main\":{\"source\":{\"search\":{\"index\":\"foo\"}}},\"injectedItems\":[{\"key\":\"injectedItem1\",\"source\":{\"external\":{\"index\":\"foo\",\"ordering\":\"userDefined\",\"params\":{\"filters\":\"brand:adidas\"}}},\"position\":2,\"length\":1}]}}}}]}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "multipleBatch")]
  public async Task MultipleBatchTest2()
  {
    await client.MultipleBatchAsync(
      new BatchParams
      {
        Requests = new List<MultipleBatchRequest>
        {
          new MultipleBatchRequest
          {
            Action = Enum.Parse<Action>("Upsert"),
            Body = new BatchCompositionAction(
              new Composition
              {
                ObjectID = "my-metadata-compo",
                Name = "my composition",
                Behavior = new CompositionBehavior
                {
                  Injection = new Injection
                  {
                    Main = new Main
                    {
                      Source = new CompositionSource
                      {
                        Search = new CompositionSourceSearch
                        {
                          Index = "foo",
                          Params = new MainInjectionQueryParameters { Filters = "brand:adidas" },
                        },
                      },
                    },
                    InjectedItems = new List<InjectedItem>
                    {
                      new InjectedItem
                      {
                        Key = "injectedItem1",
                        Source = new InjectedItemSource(
                          new SearchSource
                          {
                            Search = new Algolia.Search.Models.Composition.Search
                            {
                              Index = "foo",
                              Params = new BaseInjectionQueryParameters
                              {
                                Filters = "brand:adidas",
                              },
                            },
                          }
                        ),
                        Position = 2,
                        Length = 1,
                        Metadata = new InjectedItemMetadata
                        {
                          Hits = new InjectedItemHitsMetadata
                          {
                            AddItemKey = true,
                            Extra = new Dictionary<string, object>
                            {
                              { "my-string", "string" },
                              { "my-bool", true },
                              { "my-number", 42 },
                              {
                                "my-object",
                                new Dictionary<string, object> { { "sub-key", "sub-value" } }
                              },
                            },
                          },
                        },
                      },
                      new InjectedItem
                      {
                        Key = "externalItem",
                        Source = new InjectedItemSource(
                          new SearchSource
                          {
                            Search = new Algolia.Search.Models.Composition.Search
                            {
                              Index = "foo",
                              Params = new BaseInjectionQueryParameters { Filters = "brand:puma" },
                            },
                          }
                        ),
                        Position = 5,
                        Length = 5,
                        Metadata = new InjectedItemMetadata
                        {
                          Hits = new InjectedItemHitsMetadata
                          {
                            AddItemKey = true,
                            Extra = new Dictionary<string, object>
                            {
                              { "my-string", "string" },
                              { "my-bool", true },
                              { "my-number", 42 },
                              {
                                "my-object",
                                new Dictionary<string, object> { { "sub-key", "sub-value" } }
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              }
            ),
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/*/batch", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"requests\":[{\"action\":\"upsert\",\"body\":{\"objectID\":\"my-metadata-compo\",\"name\":\"my composition\",\"behavior\":{\"injection\":{\"main\":{\"source\":{\"search\":{\"index\":\"foo\",\"params\":{\"filters\":\"brand:adidas\"}}}},\"injectedItems\":[{\"key\":\"injectedItem1\",\"source\":{\"search\":{\"index\":\"foo\",\"params\":{\"filters\":\"brand:adidas\"}}},\"position\":2,\"length\":1,\"metadata\":{\"hits\":{\"addItemKey\":true,\"extra\":{\"my-string\":\"string\",\"my-bool\":true,\"my-number\":42,\"my-object\":{\"sub-key\":\"sub-value\"}}}}},{\"key\":\"externalItem\",\"source\":{\"search\":{\"index\":\"foo\",\"params\":{\"filters\":\"brand:puma\"}}},\"position\":5,\"length\":5,\"metadata\":{\"hits\":{\"addItemKey\":true,\"extra\":{\"my-string\":\"string\",\"my-bool\":true,\"my-number\":42,\"my-object\":{\"sub-key\":\"sub-value\"}}}}}]}}}}]}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "multipleBatch")]
  public async Task MultipleBatchTest3()
  {
    await client.MultipleBatchAsync(
      new BatchParams
      {
        Requests = new List<MultipleBatchRequest>
        {
          new MultipleBatchRequest
          {
            Action = Enum.Parse<Action>("Upsert"),
            Body = new BatchCompositionAction(
              new Composition
              {
                ObjectID = "my-compo",
                Name = "my composition",
                Behavior = new CompositionBehavior
                {
                  Injection = new Injection
                  {
                    Main = new Main
                    {
                      Source = new CompositionSource
                      {
                        Search = new CompositionSourceSearch { Index = "foo" },
                      },
                    },
                    InjectedItems = new List<InjectedItem>
                    {
                      new InjectedItem
                      {
                        Key = "my-unique-injected-item-key",
                        Source = new InjectedItemSource(
                          new SearchSource
                          {
                            Search = new Algolia.Search.Models.Composition.Search { Index = "foo" },
                          }
                        ),
                        Position = 2,
                        Length = 1,
                      },
                    },
                    Deduplication = new Deduplication
                    {
                      Positioning = Enum.Parse<DedupPositioning>("Highest"),
                    },
                  },
                },
              }
            ),
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/*/batch", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"requests\":[{\"action\":\"upsert\",\"body\":{\"objectID\":\"my-compo\",\"name\":\"my composition\",\"behavior\":{\"injection\":{\"main\":{\"source\":{\"search\":{\"index\":\"foo\"}}},\"injectedItems\":[{\"key\":\"my-unique-injected-item-key\",\"source\":{\"search\":{\"index\":\"foo\"}},\"position\":2,\"length\":1}],\"deduplication\":{\"positioning\":\"highest\"}}}}}]}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "putComposition")]
  public async Task PutCompositionTest()
  {
    await client.PutCompositionAsync(
      "1234",
      new Composition
      {
        ObjectID = "1234",
        Name = "my first composition",
        Behavior = new CompositionBehavior
        {
          Injection = new Injection
          {
            Main = new Main
            {
              Source = new CompositionSource
              {
                Search = new CompositionSourceSearch { Index = "foo" },
              },
            },
            InjectedItems = new List<InjectedItem>
            {
              new InjectedItem
              {
                Key = "injectedItem1",
                Source = new InjectedItemSource(
                  new SearchSource
                  {
                    Search = new Algolia.Search.Models.Composition.Search { Index = "foo" },
                  }
                ),
                Position = 2,
                Length = 1,
              },
            },
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/1234", req.Path);
    Assert.Equal("PUT", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"objectID\":\"1234\",\"name\":\"my first composition\",\"behavior\":{\"injection\":{\"main\":{\"source\":{\"search\":{\"index\":\"foo\"}}},\"injectedItems\":[{\"key\":\"injectedItem1\",\"source\":{\"search\":{\"index\":\"foo\"}},\"position\":2,\"length\":1}]}}}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "putComposition")]
  public async Task PutCompositionTest1()
  {
    await client.PutCompositionAsync(
      "my-external-injection-compo",
      new Composition
      {
        ObjectID = "my-external-injection-compo",
        Name = "my first composition",
        Behavior = new CompositionBehavior
        {
          Injection = new Injection
          {
            Main = new Main
            {
              Source = new CompositionSource
              {
                Search = new CompositionSourceSearch { Index = "foo" },
              },
            },
            InjectedItems = new List<InjectedItem>
            {
              new InjectedItem
              {
                Key = "injectedItem1",
                Source = new InjectedItemSource(
                  new ExternalSource
                  {
                    External = new External
                    {
                      Index = "foo",
                      Ordering = Enum.Parse<ExternalOrdering>("UserDefined"),
                      Params = new BaseInjectionQueryParameters { Filters = "brand:adidas" },
                    },
                  }
                ),
                Position = 2,
                Length = 1,
              },
            },
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/my-external-injection-compo", req.Path);
    Assert.Equal("PUT", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"objectID\":\"my-external-injection-compo\",\"name\":\"my first composition\",\"behavior\":{\"injection\":{\"main\":{\"source\":{\"search\":{\"index\":\"foo\"}}},\"injectedItems\":[{\"key\":\"injectedItem1\",\"source\":{\"external\":{\"index\":\"foo\",\"ordering\":\"userDefined\",\"params\":{\"filters\":\"brand:adidas\"}}},\"position\":2,\"length\":1}]}}}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "putComposition")]
  public async Task PutCompositionTest2()
  {
    await client.PutCompositionAsync(
      "my-metadata-compo",
      new Composition
      {
        ObjectID = "my-metadata-compo",
        Name = "my composition",
        Behavior = new CompositionBehavior
        {
          Injection = new Injection
          {
            Main = new Main
            {
              Source = new CompositionSource
              {
                Search = new CompositionSourceSearch
                {
                  Index = "foo",
                  Params = new MainInjectionQueryParameters { Filters = "brand:adidas" },
                },
              },
            },
            InjectedItems = new List<InjectedItem>
            {
              new InjectedItem
              {
                Key = "injectedItem1",
                Source = new InjectedItemSource(
                  new SearchSource
                  {
                    Search = new Algolia.Search.Models.Composition.Search
                    {
                      Index = "foo",
                      Params = new BaseInjectionQueryParameters { Filters = "brand:adidas" },
                    },
                  }
                ),
                Position = 2,
                Length = 1,
                Metadata = new InjectedItemMetadata
                {
                  Hits = new InjectedItemHitsMetadata
                  {
                    AddItemKey = true,
                    Extra = new Dictionary<string, object>
                    {
                      { "my-string", "string" },
                      { "my-bool", true },
                      { "my-number", 42 },
                      {
                        "my-object",
                        new Dictionary<string, object> { { "sub-key", "sub-value" } }
                      },
                    },
                  },
                },
              },
              new InjectedItem
              {
                Key = "externalItem",
                Source = new InjectedItemSource(
                  new SearchSource
                  {
                    Search = new Algolia.Search.Models.Composition.Search
                    {
                      Index = "foo",
                      Params = new BaseInjectionQueryParameters { Filters = "brand:puma" },
                    },
                  }
                ),
                Position = 5,
                Length = 5,
                Metadata = new InjectedItemMetadata
                {
                  Hits = new InjectedItemHitsMetadata
                  {
                    AddItemKey = true,
                    Extra = new Dictionary<string, object>
                    {
                      { "my-string", "string" },
                      { "my-bool", true },
                      { "my-number", 42 },
                      {
                        "my-object",
                        new Dictionary<string, object> { { "sub-key", "sub-value" } }
                      },
                    },
                  },
                },
              },
            },
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/my-metadata-compo", req.Path);
    Assert.Equal("PUT", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"objectID\":\"my-metadata-compo\",\"name\":\"my composition\",\"behavior\":{\"injection\":{\"main\":{\"source\":{\"search\":{\"index\":\"foo\",\"params\":{\"filters\":\"brand:adidas\"}}}},\"injectedItems\":[{\"key\":\"injectedItem1\",\"source\":{\"search\":{\"index\":\"foo\",\"params\":{\"filters\":\"brand:adidas\"}}},\"position\":2,\"length\":1,\"metadata\":{\"hits\":{\"addItemKey\":true,\"extra\":{\"my-string\":\"string\",\"my-bool\":true,\"my-number\":42,\"my-object\":{\"sub-key\":\"sub-value\"}}}}},{\"key\":\"externalItem\",\"source\":{\"search\":{\"index\":\"foo\",\"params\":{\"filters\":\"brand:puma\"}}},\"position\":5,\"length\":5,\"metadata\":{\"hits\":{\"addItemKey\":true,\"extra\":{\"my-string\":\"string\",\"my-bool\":true,\"my-number\":42,\"my-object\":{\"sub-key\":\"sub-value\"}}}}}]}}}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "putComposition")]
  public async Task PutCompositionTest3()
  {
    await client.PutCompositionAsync(
      "my-compo",
      new Composition
      {
        ObjectID = "my-compo",
        Name = "my composition",
        Behavior = new CompositionBehavior
        {
          Injection = new Injection
          {
            Main = new Main
            {
              Source = new CompositionSource
              {
                Search = new CompositionSourceSearch
                {
                  Index = "foo",
                  Params = new MainInjectionQueryParameters { Filters = "brand:adidas" },
                },
              },
            },
            InjectedItems = new List<InjectedItem>
            {
              new InjectedItem
              {
                Key = "my-unique-injected-item-key",
                Source = new InjectedItemSource(
                  new SearchSource
                  {
                    Search = new Algolia.Search.Models.Composition.Search { Index = "foo" },
                  }
                ),
                Position = 2,
                Length = 1,
              },
            },
            Deduplication = new Deduplication
            {
              Positioning = Enum.Parse<DedupPositioning>("Highest"),
            },
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/my-compo", req.Path);
    Assert.Equal("PUT", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"objectID\":\"my-compo\",\"name\":\"my composition\",\"behavior\":{\"injection\":{\"main\":{\"source\":{\"search\":{\"index\":\"foo\",\"params\":{\"filters\":\"brand:adidas\"}}}},\"injectedItems\":[{\"key\":\"my-unique-injected-item-key\",\"source\":{\"search\":{\"index\":\"foo\"}},\"position\":2,\"length\":1}],\"deduplication\":{\"positioning\":\"highest\"}}}}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "putCompositionRule")]
  public async Task PutCompositionRuleTest()
  {
    await client.PutCompositionRuleAsync(
      "compositionID",
      "ruleID",
      new CompositionRule
      {
        ObjectID = "ruleID",
        Conditions = new List<Condition>
        {
          new Condition { Anchoring = Enum.Parse<Anchoring>("Is"), Pattern = "test" },
        },
        Consequence = new CompositionRuleConsequence
        {
          Behavior = new CompositionBehavior
          {
            Injection = new Injection
            {
              Main = new Main
              {
                Source = new CompositionSource
                {
                  Search = new CompositionSourceSearch { Index = "foo" },
                },
              },
              InjectedItems = new List<InjectedItem>
              {
                new InjectedItem
                {
                  Key = "injectedItem1",
                  Source = new InjectedItemSource(
                    new SearchSource
                    {
                      Search = new Algolia.Search.Models.Composition.Search { Index = "foo" },
                    }
                  ),
                  Position = 2,
                  Length = 1,
                },
              },
            },
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/compositionID/rules/ruleID", req.Path);
    Assert.Equal("PUT", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"objectID\":\"ruleID\",\"conditions\":[{\"anchoring\":\"is\",\"pattern\":\"test\"}],\"consequence\":{\"behavior\":{\"injection\":{\"main\":{\"source\":{\"search\":{\"index\":\"foo\"}}},\"injectedItems\":[{\"key\":\"injectedItem1\",\"source\":{\"search\":{\"index\":\"foo\"}},\"position\":2,\"length\":1}]}}}}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "putCompositionRule")]
  public async Task PutCompositionRuleTest1()
  {
    await client.PutCompositionRuleAsync(
      "compositionID",
      "rule-with-metadata",
      new CompositionRule
      {
        ObjectID = "rule-with-metadata",
        Conditions = new List<Condition>
        {
          new Condition { Anchoring = Enum.Parse<Anchoring>("Is"), Pattern = "test" },
        },
        Consequence = new CompositionRuleConsequence
        {
          Behavior = new CompositionBehavior
          {
            Injection = new Injection
            {
              Main = new Main
              {
                Source = new CompositionSource
                {
                  Search = new CompositionSourceSearch { Index = "foo" },
                },
              },
              InjectedItems = new List<InjectedItem>
              {
                new InjectedItem
                {
                  Key = "injectedItem1",
                  Source = new InjectedItemSource(
                    new SearchSource
                    {
                      Search = new Algolia.Search.Models.Composition.Search
                      {
                        Index = "foo",
                        Params = new BaseInjectionQueryParameters { Filters = "brand:adidas" },
                      },
                    }
                  ),
                  Position = 2,
                  Length = 1,
                  Metadata = new InjectedItemMetadata
                  {
                    Hits = new InjectedItemHitsMetadata
                    {
                      AddItemKey = true,
                      Extra = new Dictionary<string, object>
                      {
                        { "my-string", "string" },
                        { "my-bool", true },
                        { "my-number", 42 },
                        {
                          "my-object",
                          new Dictionary<string, object> { { "sub-key", "sub-value" } }
                        },
                      },
                    },
                  },
                },
              },
            },
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/compositionID/rules/rule-with-metadata", req.Path);
    Assert.Equal("PUT", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"objectID\":\"rule-with-metadata\",\"conditions\":[{\"anchoring\":\"is\",\"pattern\":\"test\"}],\"consequence\":{\"behavior\":{\"injection\":{\"main\":{\"source\":{\"search\":{\"index\":\"foo\"}}},\"injectedItems\":[{\"key\":\"injectedItem1\",\"source\":{\"search\":{\"index\":\"foo\",\"params\":{\"filters\":\"brand:adidas\"}}},\"position\":2,\"length\":1,\"metadata\":{\"hits\":{\"addItemKey\":true,\"extra\":{\"my-string\":\"string\",\"my-bool\":true,\"my-number\":42,\"my-object\":{\"sub-key\":\"sub-value\"}}}}}]}}}}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "putCompositionRule")]
  public async Task PutCompositionRuleTest2()
  {
    await client.PutCompositionRuleAsync(
      "compositionID",
      "rule-with-exernal-source",
      new CompositionRule
      {
        ObjectID = "rule-with-exernal-source",
        Description = "my description",
        Tags = new List<string> { "tag1", "tag2" },
        Enabled = true,
        Validity = new List<TimeRange>
        {
          new TimeRange { From = 1704063600L, Until = 1704083600L },
        },
        Conditions = new List<Condition>
        {
          new Condition { Anchoring = Enum.Parse<Anchoring>("Contains"), Pattern = "harry" },
          new Condition { Anchoring = Enum.Parse<Anchoring>("Contains"), Pattern = "potter" },
        },
        Consequence = new CompositionRuleConsequence
        {
          Behavior = new CompositionBehavior
          {
            Injection = new Injection
            {
              Main = new Main
              {
                Source = new CompositionSource
                {
                  Search = new CompositionSourceSearch
                  {
                    Index = "my-index",
                    Params = new MainInjectionQueryParameters { Filters = "brand:adidas" },
                  },
                },
              },
              InjectedItems = new List<InjectedItem>
              {
                new InjectedItem
                {
                  Key = "injectedItem",
                  Source = new InjectedItemSource(
                    new ExternalSource
                    {
                      External = new External
                      {
                        Index = "my-index",
                        Params = new BaseInjectionQueryParameters { Filters = "brand:adidas" },
                        Ordering = Enum.Parse<ExternalOrdering>("UserDefined"),
                      },
                    }
                  ),
                  Position = 0,
                  Length = 3,
                },
              },
            },
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/compositionID/rules/rule-with-exernal-source", req.Path);
    Assert.Equal("PUT", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"objectID\":\"rule-with-exernal-source\",\"description\":\"my description\",\"tags\":[\"tag1\",\"tag2\"],\"enabled\":true,\"validity\":[{\"from\":1704063600,\"until\":1704083600}],\"conditions\":[{\"anchoring\":\"contains\",\"pattern\":\"harry\"},{\"anchoring\":\"contains\",\"pattern\":\"potter\"}],\"consequence\":{\"behavior\":{\"injection\":{\"main\":{\"source\":{\"search\":{\"index\":\"my-index\",\"params\":{\"filters\":\"brand:adidas\"}}}},\"injectedItems\":[{\"key\":\"injectedItem\",\"source\":{\"external\":{\"index\":\"my-index\",\"params\":{\"filters\":\"brand:adidas\"},\"ordering\":\"userDefined\"}},\"position\":0,\"length\":3}]}}}}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "putCompositionRule")]
  public async Task PutCompositionRuleTest3()
  {
    await client.PutCompositionRuleAsync(
      "compositionID",
      "rule-with-deduplication",
      new CompositionRule
      {
        ObjectID = "rule-with-deduplication",
        Description = "my description",
        Enabled = true,
        Conditions = new List<Condition>
        {
          new Condition { Anchoring = Enum.Parse<Anchoring>("Contains"), Pattern = "harry" },
        },
        Consequence = new CompositionRuleConsequence
        {
          Behavior = new CompositionBehavior
          {
            Injection = new Injection
            {
              Main = new Main
              {
                Source = new CompositionSource
                {
                  Search = new CompositionSourceSearch { Index = "my-index" },
                },
              },
              InjectedItems = new List<InjectedItem>
              {
                new InjectedItem
                {
                  Key = "my-unique-injected-item-key",
                  Source = new InjectedItemSource(
                    new SearchSource
                    {
                      Search = new Algolia.Search.Models.Composition.Search { Index = "my-index" },
                    }
                  ),
                  Position = 0,
                  Length = 3,
                },
              },
              Deduplication = new Deduplication
              {
                Positioning = Enum.Parse<DedupPositioning>("HighestInjected"),
              },
            },
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/compositionID/rules/rule-with-deduplication", req.Path);
    Assert.Equal("PUT", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"objectID\":\"rule-with-deduplication\",\"description\":\"my description\",\"enabled\":true,\"conditions\":[{\"anchoring\":\"contains\",\"pattern\":\"harry\"}],\"consequence\":{\"behavior\":{\"injection\":{\"main\":{\"source\":{\"search\":{\"index\":\"my-index\"}}},\"injectedItems\":[{\"key\":\"my-unique-injected-item-key\",\"source\":{\"search\":{\"index\":\"my-index\"}},\"position\":0,\"length\":3}],\"deduplication\":{\"positioning\":\"highestInjected\"}}}}}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "saveRules")]
  public async Task SaveRulesTest()
  {
    await client.SaveRulesAsync(
      "foo",
      new CompositionRulesBatchParams
      {
        Requests = new List<RulesMultipleBatchRequest>
        {
          new RulesMultipleBatchRequest
          {
            Action = Enum.Parse<Action>("Upsert"),
            Body = new RulesBatchCompositionAction(
              new CompositionRule
              {
                ObjectID = "123",
                Conditions = new List<Condition> { new Condition { Pattern = "a" } },
                Consequence = new CompositionRuleConsequence
                {
                  Behavior = new CompositionBehavior
                  {
                    Injection = new Injection
                    {
                      Main = new Main
                      {
                        Source = new CompositionSource
                        {
                          Search = new CompositionSourceSearch { Index = "<YOUR_INDEX_NAME>" },
                        },
                      },
                    },
                  },
                },
              }
            ),
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/foo/rules/batch", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"requests\":[{\"action\":\"upsert\",\"body\":{\"objectID\":\"123\",\"conditions\":[{\"pattern\":\"a\"}],\"consequence\":{\"behavior\":{\"injection\":{\"main\":{\"source\":{\"search\":{\"index\":\"<YOUR_INDEX_NAME>\"}}}}}}}}]}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "saveRules")]
  public async Task SaveRulesTest1()
  {
    await client.SaveRulesAsync(
      "rule-with-metadata",
      new CompositionRulesBatchParams
      {
        Requests = new List<RulesMultipleBatchRequest>
        {
          new RulesMultipleBatchRequest
          {
            Action = Enum.Parse<Action>("Upsert"),
            Body = new RulesBatchCompositionAction(
              new CompositionRule
              {
                ObjectID = "rule-with-metadata",
                Conditions = new List<Condition>
                {
                  new Condition { Anchoring = Enum.Parse<Anchoring>("Is"), Pattern = "test" },
                },
                Consequence = new CompositionRuleConsequence
                {
                  Behavior = new CompositionBehavior
                  {
                    Injection = new Injection
                    {
                      Main = new Main
                      {
                        Source = new CompositionSource
                        {
                          Search = new CompositionSourceSearch { Index = "foo" },
                        },
                      },
                      InjectedItems = new List<InjectedItem>
                      {
                        new InjectedItem
                        {
                          Key = "injectedItem1",
                          Source = new InjectedItemSource(
                            new SearchSource
                            {
                              Search = new Algolia.Search.Models.Composition.Search
                              {
                                Index = "foo",
                                Params = new BaseInjectionQueryParameters
                                {
                                  Filters = "brand:adidas",
                                },
                              },
                            }
                          ),
                          Position = 2,
                          Length = 1,
                          Metadata = new InjectedItemMetadata
                          {
                            Hits = new InjectedItemHitsMetadata
                            {
                              AddItemKey = true,
                              Extra = new Dictionary<string, object>
                              {
                                { "my-string", "string" },
                                { "my-bool", true },
                                { "my-number", 42 },
                                {
                                  "my-object",
                                  new Dictionary<string, object> { { "sub-key", "sub-value" } }
                                },
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              }
            ),
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/rule-with-metadata/rules/batch", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"requests\":[{\"action\":\"upsert\",\"body\":{\"objectID\":\"rule-with-metadata\",\"conditions\":[{\"anchoring\":\"is\",\"pattern\":\"test\"}],\"consequence\":{\"behavior\":{\"injection\":{\"main\":{\"source\":{\"search\":{\"index\":\"foo\"}}},\"injectedItems\":[{\"key\":\"injectedItem1\",\"source\":{\"search\":{\"index\":\"foo\",\"params\":{\"filters\":\"brand:adidas\"}}},\"position\":2,\"length\":1,\"metadata\":{\"hits\":{\"addItemKey\":true,\"extra\":{\"my-string\":\"string\",\"my-bool\":true,\"my-number\":42,\"my-object\":{\"sub-key\":\"sub-value\"}}}}}]}}}}}]}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "saveRules")]
  public async Task SaveRulesTest2()
  {
    await client.SaveRulesAsync(
      "rule-with-exernal-source",
      new CompositionRulesBatchParams
      {
        Requests = new List<RulesMultipleBatchRequest>
        {
          new RulesMultipleBatchRequest
          {
            Action = Enum.Parse<Action>("Upsert"),
            Body = new RulesBatchCompositionAction(
              new CompositionRule
              {
                ObjectID = "rule-with-exernal-source",
                Description = "my description",
                Tags = new List<string> { "tag1", "tag2" },
                Enabled = true,
                Validity = new List<TimeRange>
                {
                  new TimeRange { From = 1704063600L, Until = 1704083600L },
                },
                Conditions = new List<Condition>
                {
                  new Condition
                  {
                    Anchoring = Enum.Parse<Anchoring>("Contains"),
                    Pattern = "harry",
                  },
                  new Condition
                  {
                    Anchoring = Enum.Parse<Anchoring>("Contains"),
                    Pattern = "potter",
                  },
                },
                Consequence = new CompositionRuleConsequence
                {
                  Behavior = new CompositionBehavior
                  {
                    Injection = new Injection
                    {
                      Main = new Main
                      {
                        Source = new CompositionSource
                        {
                          Search = new CompositionSourceSearch
                          {
                            Index = "my-index",
                            Params = new MainInjectionQueryParameters { Filters = "brand:adidas" },
                          },
                        },
                      },
                      InjectedItems = new List<InjectedItem>
                      {
                        new InjectedItem
                        {
                          Key = "injectedItem",
                          Source = new InjectedItemSource(
                            new ExternalSource
                            {
                              External = new External
                              {
                                Index = "my-index",
                                Params = new BaseInjectionQueryParameters
                                {
                                  Filters = "brand:adidas",
                                },
                                Ordering = Enum.Parse<ExternalOrdering>("UserDefined"),
                              },
                            }
                          ),
                          Position = 0,
                          Length = 3,
                        },
                      },
                    },
                  },
                },
              }
            ),
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/rule-with-exernal-source/rules/batch", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"requests\":[{\"action\":\"upsert\",\"body\":{\"objectID\":\"rule-with-exernal-source\",\"description\":\"my description\",\"tags\":[\"tag1\",\"tag2\"],\"enabled\":true,\"validity\":[{\"from\":1704063600,\"until\":1704083600}],\"conditions\":[{\"anchoring\":\"contains\",\"pattern\":\"harry\"},{\"anchoring\":\"contains\",\"pattern\":\"potter\"}],\"consequence\":{\"behavior\":{\"injection\":{\"main\":{\"source\":{\"search\":{\"index\":\"my-index\",\"params\":{\"filters\":\"brand:adidas\"}}}},\"injectedItems\":[{\"key\":\"injectedItem\",\"source\":{\"external\":{\"index\":\"my-index\",\"params\":{\"filters\":\"brand:adidas\"},\"ordering\":\"userDefined\"}},\"position\":0,\"length\":3}]}}}}}]}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "saveRules")]
  public async Task SaveRulesTest3()
  {
    await client.SaveRulesAsync(
      "my-compo",
      new CompositionRulesBatchParams
      {
        Requests = new List<RulesMultipleBatchRequest>
        {
          new RulesMultipleBatchRequest
          {
            Action = Enum.Parse<Action>("Upsert"),
            Body = new RulesBatchCompositionAction(
              new CompositionRule
              {
                ObjectID = "rule-with-deduplication",
                Description = "my description",
                Enabled = true,
                Conditions = new List<Condition>
                {
                  new Condition
                  {
                    Anchoring = Enum.Parse<Anchoring>("Contains"),
                    Pattern = "harry",
                  },
                },
                Consequence = new CompositionRuleConsequence
                {
                  Behavior = new CompositionBehavior
                  {
                    Injection = new Injection
                    {
                      Main = new Main
                      {
                        Source = new CompositionSource
                        {
                          Search = new CompositionSourceSearch { Index = "my-index" },
                        },
                      },
                      InjectedItems = new List<InjectedItem>
                      {
                        new InjectedItem
                        {
                          Key = "my-unique-injected-item-key",
                          Source = new InjectedItemSource(
                            new SearchSource
                            {
                              Search = new Algolia.Search.Models.Composition.Search
                              {
                                Index = "my-index",
                              },
                            }
                          ),
                          Position = 0,
                          Length = 3,
                        },
                      },
                      Deduplication = new Deduplication
                      {
                        Positioning = Enum.Parse<DedupPositioning>("HighestInjected"),
                      },
                    },
                  },
                },
              }
            ),
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/my-compo/rules/batch", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"requests\":[{\"action\":\"upsert\",\"body\":{\"objectID\":\"rule-with-deduplication\",\"description\":\"my description\",\"enabled\":true,\"conditions\":[{\"anchoring\":\"contains\",\"pattern\":\"harry\"}],\"consequence\":{\"behavior\":{\"injection\":{\"main\":{\"source\":{\"search\":{\"index\":\"my-index\"}}},\"injectedItems\":[{\"key\":\"my-unique-injected-item-key\",\"source\":{\"search\":{\"index\":\"my-index\"}},\"position\":0,\"length\":3}],\"deduplication\":{\"positioning\":\"highestInjected\"}}}}}}]}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "search")]
  public async Task SearchTest()
  {
    await client.SearchAsync<Hit>(
      "foo",
      new RequestBody { Params = new Params { Query = "batman" } }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/foo/run", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"params\":{\"query\":\"batman\"}}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "search")]
  public async Task SearchTest1()
  {
    await client.SearchAsync<Hit>(
      "foo",
      new RequestBody
      {
        Params = new Params
        {
          Query = "batman",
          InjectedItems = new Dictionary<string, ExternalInjectedItem>
          {
            {
              "injectedItem1",
              new ExternalInjectedItem
              {
                Items = new List<ExternalInjection>
                {
                  new ExternalInjection { ObjectID = "my-object-1" },
                  new ExternalInjection
                  {
                    ObjectID = "my-object-2",
                    Metadata = new Dictionary<string, object>
                    {
                      { "my-string", "string" },
                      { "my-bool", true },
                      { "my-number", 42 },
                      {
                        "my-object",
                        new Dictionary<string, object> { { "sub-key", "sub-value" } }
                      },
                    },
                  },
                },
              }
            },
          },
        },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/foo/run", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"params\":{\"query\":\"batman\",\"injectedItems\":{\"injectedItem1\":{\"items\":[{\"objectID\":\"my-object-1\"},{\"objectID\":\"my-object-2\",\"metadata\":{\"my-string\":\"string\",\"my-bool\":true,\"my-number\":42,\"my-object\":{\"sub-key\":\"sub-value\"}}}]}}}}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }

  [Fact(DisplayName = "searchCompositionRules")]
  public async Task SearchCompositionRulesTest()
  {
    await client.SearchCompositionRulesAsync(
      "foo",
      new SearchCompositionRulesParams { Query = "batman" }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/foo/rules/search", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault("{\"query\":\"batman\"}", req.Body, new JsonDiffConfig(false));
  }

  [Fact(DisplayName = "searchForFacetValues")]
  public async Task SearchForFacetValuesTest()
  {
    await client.SearchForFacetValuesAsync(
      "foo",
      "brand",
      new SearchForFacetValuesRequest
      {
        Params = new SearchForFacetValuesParams { MaxFacetHits = 10 },
      }
    );

    var req = _echo.LastResponse;
    Assert.Equal("/1/compositions/foo/facets/brand/query", req.Path);
    Assert.Equal("POST", req.Method.ToString());
    JsonAssert.EqualOverrideDefault(
      "{\"params\":{\"maxFacetHits\":10}}",
      req.Body,
      new JsonDiffConfig(false)
    );
  }
}
