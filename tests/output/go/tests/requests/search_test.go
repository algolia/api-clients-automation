// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package requests

import (
	"encoding/json"
	"testing"
	"time"

	"github.com/kinbiko/jsonassert"
	"github.com/stretchr/testify/require"

	"gotests/tests"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/search"
	"github.com/algolia/algoliasearch-client-go/v4/algolia/transport"
)

func createSearchClient(t *testing.T) (*search.APIClient, *tests.EchoRequester) {
	t.Helper()

	echo := &tests.EchoRequester{}
	cfg := search.SearchConfiguration{
		Configuration: transport.Configuration{
			AppID:     "appID",
			ApiKey:    "apiKey",
			Requester: echo,
		},
	}
	client, err := search.NewClientWithConfig(cfg)
	require.NoError(t, err)

	return client, echo
}

func TestSearch_AddApiKey(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("addApiKey", func(t *testing.T) {
		_, err := client.AddApiKey(client.NewApiAddApiKeyRequest(

			search.NewEmptyApiKey().SetAcl(
				[]search.Acl{search.Acl("search"), search.Acl("addObject")}).SetDescription("my new api key").SetValidity(300).SetMaxQueriesPerIPPerHour(100).SetMaxHitsPerQuery(20),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/keys", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"acl":["search","addObject"],"description":"my new api key","validity":300,"maxQueriesPerIPPerHour":100,"maxHitsPerQuery":20}`)
	})
}

func TestSearch_AddOrUpdateObject(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("addOrUpdateObject", func(t *testing.T) {
		_, err := client.AddOrUpdateObject(client.NewApiAddOrUpdateObjectRequest(
			"indexName", "uniqueID", map[string]any{"key": "value"},
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/uniqueID", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"key":"value"}`)
	})
}

func TestSearch_AppendSource(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("appendSource", func(t *testing.T) {
		_, err := client.AppendSource(client.NewApiAppendSourceRequest(

			search.NewEmptySource().SetSource("theSource").SetDescription("theDescription"),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/security/sources/append", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"source":"theSource","description":"theDescription"}`)
	})
}

func TestSearch_AssignUserId(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("assignUserId", func(t *testing.T) {
		_, err := client.AssignUserId(client.NewApiAssignUserIdRequest(
			"userID",
			search.NewEmptyAssignUserIdParams().SetCluster("theCluster"),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/clusters/mapping", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"cluster":"theCluster"}`)
		headers := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"x-algolia-user-id":"userID"}`), &headers))
		for k, v := range headers {
			require.Equal(t, v, echo.Header.Get(k))
		}
	})
	t.Run("it should not encode the userID", func(t *testing.T) {
		_, err := client.AssignUserId(client.NewApiAssignUserIdRequest(
			"user id with spaces",
			search.NewEmptyAssignUserIdParams().SetCluster("cluster with spaces"),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/clusters/mapping", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"cluster":"cluster with spaces"}`)
		headers := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"x-algolia-user-id":"user id with spaces"}`), &headers))
		for k, v := range headers {
			require.Equal(t, v, echo.Header.Get(k))
		}
	})
}

func TestSearch_Batch(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("addObject", func(t *testing.T) {
		_, err := client.Batch(client.NewApiBatchRequest(
			"<YOUR_INDEX_NAME>",
			search.NewEmptyBatchWriteParams().SetRequests(
				[]search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action("addObject")).SetBody(map[string]any{"key": "bar", "foo": "1"}), *search.NewEmptyBatchRequest().SetAction(search.Action("addObject")).SetBody(map[string]any{"key": "baz", "foo": "2"})}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"action":"addObject","body":{"key":"bar","foo":"1"}},{"action":"addObject","body":{"key":"baz","foo":"2"}}]}`)
	})
	t.Run("clear", func(t *testing.T) {
		_, err := client.Batch(client.NewApiBatchRequest(
			"<YOUR_INDEX_NAME>",
			search.NewEmptyBatchWriteParams().SetRequests(
				[]search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action("clear")).SetBody(map[string]any{"key": "value"})}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"action":"clear","body":{"key":"value"}}]}`)
	})
	t.Run("delete", func(t *testing.T) {
		_, err := client.Batch(client.NewApiBatchRequest(
			"<YOUR_INDEX_NAME>",
			search.NewEmptyBatchWriteParams().SetRequests(
				[]search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action("delete")).SetBody(map[string]any{"key": "value"})}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"action":"delete","body":{"key":"value"}}]}`)
	})
	t.Run("deleteObject", func(t *testing.T) {
		_, err := client.Batch(client.NewApiBatchRequest(
			"<YOUR_INDEX_NAME>",
			search.NewEmptyBatchWriteParams().SetRequests(
				[]search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action("deleteObject")).SetBody(map[string]any{"key": "value"})}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"action":"deleteObject","body":{"key":"value"}}]}`)
	})
	t.Run("partialUpdateObject", func(t *testing.T) {
		_, err := client.Batch(client.NewApiBatchRequest(
			"<YOUR_INDEX_NAME>",
			search.NewEmptyBatchWriteParams().SetRequests(
				[]search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action("partialUpdateObject")).SetBody(map[string]any{"key": "value"})}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"action":"partialUpdateObject","body":{"key":"value"}}]}`)
	})
	t.Run("partialUpdateObjectNoCreate", func(t *testing.T) {
		_, err := client.Batch(client.NewApiBatchRequest(
			"<YOUR_INDEX_NAME>",
			search.NewEmptyBatchWriteParams().SetRequests(
				[]search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action("partialUpdateObjectNoCreate")).SetBody(map[string]any{"key": "value"})}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"action":"partialUpdateObjectNoCreate","body":{"key":"value"}}]}`)
	})
	t.Run("updateObject", func(t *testing.T) {
		_, err := client.Batch(client.NewApiBatchRequest(
			"<YOUR_INDEX_NAME>",
			search.NewEmptyBatchWriteParams().SetRequests(
				[]search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action("updateObject")).SetBody(map[string]any{"key": "value"})}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"action":"updateObject","body":{"key":"value"}}]}`)
	})
}

func TestSearch_BatchAssignUserIds(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("batchAssignUserIds", func(t *testing.T) {
		_, err := client.BatchAssignUserIds(client.NewApiBatchAssignUserIdsRequest(
			"userID",
			search.NewEmptyBatchAssignUserIdsParams().SetCluster("theCluster").SetUsers(
				[]string{"user1", "user2"}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/clusters/mapping/batch", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"cluster":"theCluster","users":["user1","user2"]}`)
		headers := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"x-algolia-user-id":"userID"}`), &headers))
		for k, v := range headers {
			require.Equal(t, v, echo.Header.Get(k))
		}
	})
}

func TestSearch_BatchDictionaryEntries(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("replace", func(t *testing.T) {
		_, err := client.BatchDictionaryEntries(client.NewApiBatchDictionaryEntriesRequest(
			search.DictionaryType("plurals"),
			search.NewEmptyBatchDictionaryEntriesParams().SetClearExistingDictionaryEntries(true).SetRequests(
				[]search.BatchDictionaryEntriesRequest{*search.NewEmptyBatchDictionaryEntriesRequest().SetAction(search.DictionaryAction("addEntry")).SetBody(
					search.NewEmptyDictionaryEntry().SetObjectID("1").SetLanguage(search.SupportedLanguage("en")).SetWord("fancy").SetWords(
						[]string{"believe", "algolia"}).SetDecomposition(
						[]string{"trust", "algolia"}).SetState(search.DictionaryEntryState("enabled")))}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/dictionaries/plurals/batch", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"clearExistingDictionaryEntries":true,"requests":[{"action":"addEntry","body":{"objectID":"1","language":"en","word":"fancy","words":["believe","algolia"],"decomposition":["trust","algolia"],"state":"enabled"}}]}`)
	})
	t.Run("delete", func(t *testing.T) {
		_, err := client.BatchDictionaryEntries(client.NewApiBatchDictionaryEntriesRequest(
			search.DictionaryType("plurals"),
			search.NewEmptyBatchDictionaryEntriesParams().SetClearExistingDictionaryEntries(true).SetRequests(
				[]search.BatchDictionaryEntriesRequest{*search.NewEmptyBatchDictionaryEntriesRequest().SetAction(search.DictionaryAction("deleteEntry")).SetBody(
					search.NewEmptyDictionaryEntry().SetObjectID("1"))}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/dictionaries/plurals/batch", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"clearExistingDictionaryEntries":true,"requests":[{"action":"deleteEntry","body":{"objectID":"1"}}]}`)
	})
	t.Run("append", func(t *testing.T) {
		_, err := client.BatchDictionaryEntries(client.NewApiBatchDictionaryEntriesRequest(
			search.DictionaryType("stopwords"),
			search.NewEmptyBatchDictionaryEntriesParams().SetRequests(
				[]search.BatchDictionaryEntriesRequest{*search.NewEmptyBatchDictionaryEntriesRequest().SetAction(search.DictionaryAction("addEntry")).SetBody(
					search.NewEmptyDictionaryEntry().SetObjectID("1").SetLanguage(search.SupportedLanguage("en")).SetAdditionalProperty("additional", "try me"))}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/dictionaries/stopwords/batch", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"action":"addEntry","body":{"objectID":"1","language":"en","additional":"try me"}}]}`)
	})
}

func TestSearch_Browse(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("browse with minimal parameters", func(t *testing.T) {
		_, err := client.Browse(client.NewApiBrowseRequest(
			"cts_e2e_browse",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/cts_e2e_browse/browse", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{}`)
	})
	t.Run("browse with search parameters", func(t *testing.T) {
		_, err := client.Browse(client.NewApiBrowseRequest(
			"indexName",
		).WithBrowseParams(search.BrowseParamsObjectAsBrowseParams(
			search.NewEmptyBrowseParamsObject().SetQuery("myQuery").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(
				[]search.FacetFilters{*search.StringAsFacetFilters("tags:algolia")})))))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/browse", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"query":"myQuery","facetFilters":["tags:algolia"]}`)
	})
	t.Run("browse allow a cursor in parameters", func(t *testing.T) {
		_, err := client.Browse(client.NewApiBrowseRequest(
			"indexName",
		).WithBrowseParams(search.BrowseParamsObjectAsBrowseParams(
			search.NewEmptyBrowseParamsObject().SetCursor("test"))))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/browse", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"cursor":"test"}`)
	})
}

func TestSearch_ClearObjects(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("clearObjects", func(t *testing.T) {
		_, err := client.ClearObjects(client.NewApiClearObjectsRequest(
			"theIndexName",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/clear", echo.Path)
		require.Equal(t, "POST", echo.Method)

		require.Empty(t, echo.Body)
	})
}

func TestSearch_ClearRules(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("clearRules", func(t *testing.T) {
		_, err := client.ClearRules(client.NewApiClearRulesRequest(
			"indexName",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/rules/clear", echo.Path)
		require.Equal(t, "POST", echo.Method)

		require.Empty(t, echo.Body)
	})
}

func TestSearch_ClearSynonyms(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("clearSynonyms", func(t *testing.T) {
		_, err := client.ClearSynonyms(client.NewApiClearSynonymsRequest(
			"indexName",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/synonyms/clear", echo.Path)
		require.Equal(t, "POST", echo.Method)

		require.Empty(t, echo.Body)
	})
}

func TestSearch_CustomDelete(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("allow del method for a custom path with minimal parameters", func(t *testing.T) {
		_, err := client.CustomDelete(client.NewApiCustomDeleteRequest(
			"test/minimal",
		))
		require.NoError(t, err)

		require.Equal(t, "/test/minimal", echo.Path)
		require.Equal(t, "DELETE", echo.Method)

		require.Nil(t, echo.Body)
	})
	t.Run("allow del method for a custom path with all parameters", func(t *testing.T) {
		_, err := client.CustomDelete(client.NewApiCustomDeleteRequest(
			"test/all",
		).WithParameters(map[string]any{"query": "parameters"}))
		require.NoError(t, err)

		require.Equal(t, "/test/all", echo.Path)
		require.Equal(t, "DELETE", echo.Method)

		require.Nil(t, echo.Body)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"query":"parameters"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
}

func TestSearch_CustomGet(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("allow get method for a custom path with minimal parameters", func(t *testing.T) {
		_, err := client.CustomGet(client.NewApiCustomGetRequest(
			"test/minimal",
		))
		require.NoError(t, err)

		require.Equal(t, "/test/minimal", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
	t.Run("allow get method for a custom path with all parameters", func(t *testing.T) {
		_, err := client.CustomGet(client.NewApiCustomGetRequest(
			"test/all",
		).WithParameters(map[string]any{"query": "parameters with space"}))
		require.NoError(t, err)

		require.Equal(t, "/test/all", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"query":"parameters%20with%20space"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("requestOptions should be escaped too", func(t *testing.T) {
		_, err := client.CustomGet(client.NewApiCustomGetRequest(
			"test/all",
		).WithParameters(map[string]any{"query": "to be overriden"}),
			search.WithQueryParam("query", "parameters with space"), search.WithQueryParam("and an array",
				[]string{"array", "with spaces"}), search.WithHeaderParam("x-header-1", "spaces are left alone"),
		)
		require.NoError(t, err)

		require.Equal(t, "/test/all", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
		headers := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"x-header-1":"spaces are left alone"}`), &headers))
		for k, v := range headers {
			require.Equal(t, v, echo.Header.Get(k))
		}
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"query":"parameters%20with%20space","and%20an%20array":"array%2Cwith%20spaces"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
}

func TestSearch_CustomPost(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("allow post method for a custom path with minimal parameters", func(t *testing.T) {
		_, err := client.CustomPost(client.NewApiCustomPostRequest(
			"test/minimal",
		))
		require.NoError(t, err)

		require.Equal(t, "/test/minimal", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{}`)
	})
	t.Run("allow post method for a custom path with all parameters", func(t *testing.T) {
		_, err := client.CustomPost(client.NewApiCustomPostRequest(
			"test/all",
		).WithParameters(map[string]any{"query": "parameters"}).WithBody(map[string]any{"body": "parameters"}))
		require.NoError(t, err)

		require.Equal(t, "/test/all", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"body":"parameters"}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"query":"parameters"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("requestOptions can override default query parameters", func(t *testing.T) {
		_, err := client.CustomPost(client.NewApiCustomPostRequest(
			"test/requestOptions",
		).WithParameters(map[string]any{"query": "parameters"}).WithBody(map[string]any{"facet": "filters"}),
			search.WithQueryParam("query", "myQueryParameter"),
		)
		require.NoError(t, err)

		require.Equal(t, "/test/requestOptions", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"facet":"filters"}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"query":"myQueryParameter"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("requestOptions merges query parameters with default ones", func(t *testing.T) {
		_, err := client.CustomPost(client.NewApiCustomPostRequest(
			"test/requestOptions",
		).WithParameters(map[string]any{"query": "parameters"}).WithBody(map[string]any{"facet": "filters"}),
			search.WithQueryParam("query2", "myQueryParameter"),
		)
		require.NoError(t, err)

		require.Equal(t, "/test/requestOptions", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"facet":"filters"}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"query":"parameters","query2":"myQueryParameter"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("requestOptions can override default headers", func(t *testing.T) {
		_, err := client.CustomPost(client.NewApiCustomPostRequest(
			"test/requestOptions",
		).WithParameters(map[string]any{"query": "parameters"}).WithBody(map[string]any{"facet": "filters"}),
			search.WithHeaderParam("x-algolia-api-key", "ALGOLIA_API_KEY"),
		)
		require.NoError(t, err)

		require.Equal(t, "/test/requestOptions", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"facet":"filters"}`)
		headers := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"x-algolia-api-key":"ALGOLIA_API_KEY"}`), &headers))
		for k, v := range headers {
			require.Equal(t, v, echo.Header.Get(k))
		}
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"query":"parameters"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("requestOptions merges headers with default ones", func(t *testing.T) {
		_, err := client.CustomPost(client.NewApiCustomPostRequest(
			"test/requestOptions",
		).WithParameters(map[string]any{"query": "parameters"}).WithBody(map[string]any{"facet": "filters"}),
			search.WithHeaderParam("x-algolia-api-key", "ALGOLIA_API_KEY"),
		)
		require.NoError(t, err)

		require.Equal(t, "/test/requestOptions", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"facet":"filters"}`)
		headers := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"x-algolia-api-key":"ALGOLIA_API_KEY"}`), &headers))
		for k, v := range headers {
			require.Equal(t, v, echo.Header.Get(k))
		}
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"query":"parameters"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("requestOptions queryParameters accepts booleans", func(t *testing.T) {
		_, err := client.CustomPost(client.NewApiCustomPostRequest(
			"test/requestOptions",
		).WithParameters(map[string]any{"query": "parameters"}).WithBody(map[string]any{"facet": "filters"}),
			search.WithQueryParam("isItWorking", true),
		)
		require.NoError(t, err)

		require.Equal(t, "/test/requestOptions", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"facet":"filters"}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"query":"parameters","isItWorking":"true"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("requestOptions queryParameters accepts integers", func(t *testing.T) {
		_, err := client.CustomPost(client.NewApiCustomPostRequest(
			"test/requestOptions",
		).WithParameters(map[string]any{"query": "parameters"}).WithBody(map[string]any{"facet": "filters"}),
			search.WithQueryParam("myParam", 2),
		)
		require.NoError(t, err)

		require.Equal(t, "/test/requestOptions", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"facet":"filters"}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"query":"parameters","myParam":"2"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("requestOptions queryParameters accepts list of string", func(t *testing.T) {
		_, err := client.CustomPost(client.NewApiCustomPostRequest(
			"test/requestOptions",
		).WithParameters(map[string]any{"query": "parameters"}).WithBody(map[string]any{"facet": "filters"}),
			search.WithQueryParam("myParam",
				[]string{"b and c", "d"}),
		)
		require.NoError(t, err)

		require.Equal(t, "/test/requestOptions", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"facet":"filters"}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"query":"parameters","myParam":"b%20and%20c%2Cd"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("requestOptions queryParameters accepts list of booleans", func(t *testing.T) {
		_, err := client.CustomPost(client.NewApiCustomPostRequest(
			"test/requestOptions",
		).WithParameters(map[string]any{"query": "parameters"}).WithBody(map[string]any{"facet": "filters"}),
			search.WithQueryParam("myParam",
				[]bool{true, true, false}),
		)
		require.NoError(t, err)

		require.Equal(t, "/test/requestOptions", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"facet":"filters"}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"query":"parameters","myParam":"true%2Ctrue%2Cfalse"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("requestOptions queryParameters accepts list of integers", func(t *testing.T) {
		_, err := client.CustomPost(client.NewApiCustomPostRequest(
			"test/requestOptions",
		).WithParameters(map[string]any{"query": "parameters"}).WithBody(map[string]any{"facet": "filters"}),
			search.WithQueryParam("myParam",
				[]int32{1, 2}),
		)
		require.NoError(t, err)

		require.Equal(t, "/test/requestOptions", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"facet":"filters"}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"query":"parameters","myParam":"1%2C2"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
}

func TestSearch_CustomPut(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("allow put method for a custom path with minimal parameters", func(t *testing.T) {
		_, err := client.CustomPut(client.NewApiCustomPutRequest(
			"test/minimal",
		))
		require.NoError(t, err)

		require.Equal(t, "/test/minimal", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{}`)
	})
	t.Run("allow put method for a custom path with all parameters", func(t *testing.T) {
		_, err := client.CustomPut(client.NewApiCustomPutRequest(
			"test/all",
		).WithParameters(map[string]any{"query": "parameters"}).WithBody(map[string]any{"body": "parameters"}))
		require.NoError(t, err)

		require.Equal(t, "/test/all", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"body":"parameters"}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"query":"parameters"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
}

func TestSearch_DeleteApiKey(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("deleteApiKey", func(t *testing.T) {
		_, err := client.DeleteApiKey(client.NewApiDeleteApiKeyRequest(
			"myTestApiKey",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/keys/myTestApiKey", echo.Path)
		require.Equal(t, "DELETE", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_DeleteBy(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("deleteBy", func(t *testing.T) {
		_, err := client.DeleteBy(client.NewApiDeleteByRequest(
			"theIndexName",
			search.NewEmptyDeleteByParams().SetFilters("brand:brandName"),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/deleteByQuery", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"filters":"brand:brandName"}`)
	})
}

func TestSearch_DeleteIndex(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("deleteIndex", func(t *testing.T) {
		_, err := client.DeleteIndex(client.NewApiDeleteIndexRequest(
			"theIndexName",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName", echo.Path)
		require.Equal(t, "DELETE", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_DeleteObject(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("deleteObject", func(t *testing.T) {
		_, err := client.DeleteObject(client.NewApiDeleteObjectRequest(
			"<YOUR_INDEX_NAME>", "uniqueID",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/%3CYOUR_INDEX_NAME%3E/uniqueID", echo.Path)
		require.Equal(t, "DELETE", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_DeleteRule(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("delete rule simple case", func(t *testing.T) {
		_, err := client.DeleteRule(client.NewApiDeleteRuleRequest(
			"indexName", "id1",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/rules/id1", echo.Path)
		require.Equal(t, "DELETE", echo.Method)

		require.Nil(t, echo.Body)
	})
	t.Run("delete rule with simple characters to encode in objectID", func(t *testing.T) {
		_, err := client.DeleteRule(client.NewApiDeleteRuleRequest(
			"indexName", "test/with/slash",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/rules/test%2Fwith%2Fslash", echo.Path)
		require.Equal(t, "DELETE", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_DeleteSource(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("deleteSource", func(t *testing.T) {
		_, err := client.DeleteSource(client.NewApiDeleteSourceRequest(
			"theSource",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/security/sources/theSource", echo.Path)
		require.Equal(t, "DELETE", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_DeleteSynonym(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("deleteSynonym", func(t *testing.T) {
		_, err := client.DeleteSynonym(client.NewApiDeleteSynonymRequest(
			"indexName", "id1",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/synonyms/id1", echo.Path)
		require.Equal(t, "DELETE", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_GetApiKey(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("getApiKey", func(t *testing.T) {
		_, err := client.GetApiKey(client.NewApiGetApiKeyRequest(
			"myTestApiKey",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/keys/myTestApiKey", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_GetAppTask(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("getAppTask", func(t *testing.T) {
		_, err := client.GetAppTask(client.NewApiGetAppTaskRequest(
			123,
		))
		require.NoError(t, err)

		require.Equal(t, "/1/task/123", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_GetDictionaryLanguages(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("get getDictionaryLanguages", func(t *testing.T) {
		_, err := client.GetDictionaryLanguages()
		require.NoError(t, err)

		require.Equal(t, "/1/dictionaries/*/languages", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_GetDictionarySettings(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("get getDictionarySettings results", func(t *testing.T) {
		_, err := client.GetDictionarySettings()
		require.NoError(t, err)

		require.Equal(t, "/1/dictionaries/*/settings", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_GetLogs(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("getLogs with minimal parameters", func(t *testing.T) {
		_, err := client.GetLogs(client.NewApiGetLogsRequest())
		require.NoError(t, err)

		require.Equal(t, "/1/logs", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
	t.Run("getLogs with parameters", func(t *testing.T) {
		_, err := client.GetLogs(client.NewApiGetLogsRequest().WithOffset(5).WithLength(10).WithIndexName("theIndexName").WithType(search.LogType("all")))
		require.NoError(t, err)

		require.Equal(t, "/1/logs", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"offset":"5","length":"10","indexName":"theIndexName","type":"all"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
}

func TestSearch_GetObject(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("getObject", func(t *testing.T) {
		_, err := client.GetObject(client.NewApiGetObjectRequest(
			"theIndexName", "uniqueID",
		).WithAttributesToRetrieve(
			[]string{"attr1", "attr2"}))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/uniqueID", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"attributesToRetrieve":"attr1%2Cattr2"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("search with a real object", func(t *testing.T) {
		_, err := client.GetObject(client.NewApiGetObjectRequest(
			"cts_e2e_browse", "Batman and Robin",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/cts_e2e_browse/Batman%20and%20Robin", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_GetObjects(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("getObjects", func(t *testing.T) {
		_, err := client.GetObjects(client.NewApiGetObjectsRequest(

			search.NewEmptyGetObjectsParams().SetRequests(
				[]search.GetObjectsRequest{*search.NewEmptyGetObjectsRequest().SetAttributesToRetrieve(
					[]string{"attr1", "attr2"}).SetObjectID("uniqueID").SetIndexName("theIndexName")}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/objects", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"attributesToRetrieve":["attr1","attr2"],"objectID":"uniqueID","indexName":"theIndexName"}]}`)
	})
}

func TestSearch_GetRule(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("getRule", func(t *testing.T) {
		_, err := client.GetRule(client.NewApiGetRuleRequest(
			"cts_e2e_browse", "qr-1725004648916",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/cts_e2e_browse/rules/qr-1725004648916", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_GetSettings(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("getSettings", func(t *testing.T) {
		_, err := client.GetSettings(client.NewApiGetSettingsRequest(
			"cts_e2e_settings",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/cts_e2e_settings/settings", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_GetSources(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("getSources", func(t *testing.T) {
		_, err := client.GetSources()
		require.NoError(t, err)

		require.Equal(t, "/1/security/sources", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_GetSynonym(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("getSynonym", func(t *testing.T) {
		_, err := client.GetSynonym(client.NewApiGetSynonymRequest(
			"indexName", "id1",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/synonyms/id1", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_GetTask(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("getTask", func(t *testing.T) {
		_, err := client.GetTask(client.NewApiGetTaskRequest(
			"theIndexName", 123,
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/task/123", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_GetTopUserIds(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("getTopUserIds", func(t *testing.T) {
		_, err := client.GetTopUserIds()
		require.NoError(t, err)

		require.Equal(t, "/1/clusters/mapping/top", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_GetUserId(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("getUserId", func(t *testing.T) {
		_, err := client.GetUserId(client.NewApiGetUserIdRequest(
			"uniqueID",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/clusters/mapping/uniqueID", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_HasPendingMappings(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("hasPendingMappings with minimal parameters", func(t *testing.T) {
		_, err := client.HasPendingMappings(client.NewApiHasPendingMappingsRequest())
		require.NoError(t, err)

		require.Equal(t, "/1/clusters/mapping/pending", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
	t.Run("hasPendingMappings with parameters", func(t *testing.T) {
		_, err := client.HasPendingMappings(client.NewApiHasPendingMappingsRequest().WithGetClusters(true))
		require.NoError(t, err)

		require.Equal(t, "/1/clusters/mapping/pending", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"getClusters":"true"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
}

func TestSearch_ListApiKeys(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("listApiKeys", func(t *testing.T) {
		_, err := client.ListApiKeys()
		require.NoError(t, err)

		require.Equal(t, "/1/keys", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_ListClusters(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("listClusters", func(t *testing.T) {
		_, err := client.ListClusters()
		require.NoError(t, err)

		require.Equal(t, "/1/clusters", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_ListIndices(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("listIndices with minimal parameters", func(t *testing.T) {
		_, err := client.ListIndices(client.NewApiListIndicesRequest())
		require.NoError(t, err)

		require.Equal(t, "/1/indexes", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
	t.Run("listIndices with parameters", func(t *testing.T) {
		_, err := client.ListIndices(client.NewApiListIndicesRequest().WithPage(8).WithHitsPerPage(3))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"page":"8","hitsPerPage":"3"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
}

func TestSearch_ListUserIds(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("listUserIds with minimal parameters", func(t *testing.T) {
		_, err := client.ListUserIds(client.NewApiListUserIdsRequest())
		require.NoError(t, err)

		require.Equal(t, "/1/clusters/mapping", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
	})
	t.Run("listUserIds with parameters", func(t *testing.T) {
		_, err := client.ListUserIds(client.NewApiListUserIdsRequest().WithPage(8).WithHitsPerPage(100))
		require.NoError(t, err)

		require.Equal(t, "/1/clusters/mapping", echo.Path)
		require.Equal(t, "GET", echo.Method)

		require.Nil(t, echo.Body)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"page":"8","hitsPerPage":"100"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
}

func TestSearch_MultipleBatch(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("multipleBatch", func(t *testing.T) {
		_, err := client.MultipleBatch(client.NewApiMultipleBatchRequest(

			search.NewEmptyBatchParams().SetRequests(
				[]search.MultipleBatchRequest{*search.NewEmptyMultipleBatchRequest().SetAction(search.Action("addObject")).SetBody(map[string]any{"key": "value"}).SetIndexName("theIndexName")}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/batch", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"action":"addObject","body":{"key":"value"},"indexName":"theIndexName"}]}`)
	})
}

func TestSearch_OperationIndex(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("scopes", func(t *testing.T) {
		_, err := client.OperationIndex(client.NewApiOperationIndexRequest(
			"<SOURCE_INDEX_NAME>",
			search.NewEmptyOperationIndexParams().SetOperation(search.OperationType("move")).SetDestination("<DESTINATION_INDEX_NAME>").SetScope(
				[]search.ScopeType{search.ScopeType("rules"), search.ScopeType("settings")}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"operation":"move","destination":"<DESTINATION_INDEX_NAME>","scope":["rules","settings"]}`)
	})
	t.Run("copy", func(t *testing.T) {
		_, err := client.OperationIndex(client.NewApiOperationIndexRequest(
			"<SOURCE_INDEX_NAME>",
			search.NewEmptyOperationIndexParams().SetOperation(search.OperationType("copy")).SetDestination("<DESTINATION_INDEX_NAME>"),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"operation":"copy","destination":"<DESTINATION_INDEX_NAME>"}`)
	})
	t.Run("move", func(t *testing.T) {
		_, err := client.OperationIndex(client.NewApiOperationIndexRequest(
			"<SOURCE_INDEX_NAME>",
			search.NewEmptyOperationIndexParams().SetOperation(search.OperationType("move")).SetDestination("<DESTINATION_INDEX_NAME>"),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"operation":"move","destination":"<DESTINATION_INDEX_NAME>"}`)
	})
}

func TestSearch_PartialUpdateObject(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("Partial update with a new value for a string attribute", func(t *testing.T) {
		_, err := client.PartialUpdateObject(client.NewApiPartialUpdateObjectRequest(
			"theIndexName", "uniqueID", map[string]any{"attributeId": "new value"},
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/uniqueID/partial", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"attributeId":"new value"}`)
	})
	t.Run("Partial update with a new value for an integer attribute", func(t *testing.T) {
		_, err := client.PartialUpdateObject(client.NewApiPartialUpdateObjectRequest(
			"theIndexName", "uniqueID", map[string]any{"attributeId": 1},
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/uniqueID/partial", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"attributeId":1}`)
	})
	t.Run("Partial update with a new value for a boolean attribute", func(t *testing.T) {
		_, err := client.PartialUpdateObject(client.NewApiPartialUpdateObjectRequest(
			"theIndexName", "uniqueID", map[string]any{"attributeId": true},
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/uniqueID/partial", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"attributeId":true}`)
	})
	t.Run("Partial update with a new value for an array attribute", func(t *testing.T) {
		_, err := client.PartialUpdateObject(client.NewApiPartialUpdateObjectRequest(
			"theIndexName", "uniqueID", map[string]any{"attributeId": []string{"one", "two", "three"}},
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/uniqueID/partial", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"attributeId":["one","two","three"]}`)
	})
	t.Run("Partial update with a new value for an object attribute", func(t *testing.T) {
		_, err := client.PartialUpdateObject(client.NewApiPartialUpdateObjectRequest(
			"theIndexName", "uniqueID", map[string]any{"attributeId": map[string]any{"nested": "value"}},
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/uniqueID/partial", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"attributeId":{"nested":"value"}}`)
	})
}

func TestSearch_RemoveUserId(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("removeUserId", func(t *testing.T) {
		_, err := client.RemoveUserId(client.NewApiRemoveUserIdRequest(
			"uniqueID",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/clusters/mapping/uniqueID", echo.Path)
		require.Equal(t, "DELETE", echo.Method)

		require.Nil(t, echo.Body)
	})
}

func TestSearch_ReplaceSources(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("replaceSources", func(t *testing.T) {
		_, err := client.ReplaceSources(client.NewApiReplaceSourcesRequest(

			[]search.Source{*search.NewEmptySource().SetSource("theSource").SetDescription("theDescription")},
		))
		require.NoError(t, err)

		require.Equal(t, "/1/security/sources", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `[{"source":"theSource","description":"theDescription"}]`)
	})
}

func TestSearch_RestoreApiKey(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("restoreApiKey", func(t *testing.T) {
		_, err := client.RestoreApiKey(client.NewApiRestoreApiKeyRequest(
			"ALGOLIA_API_KEY",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/keys/ALGOLIA_API_KEY/restore", echo.Path)
		require.Equal(t, "POST", echo.Method)

		require.Empty(t, echo.Body)
	})
}

func TestSearch_SaveObject(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("saveObject", func(t *testing.T) {
		_, err := client.SaveObject(client.NewApiSaveObjectRequest(
			"<YOUR_INDEX_NAME>", map[string]any{"objectID": "id", "test": "val"},
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/%3CYOUR_INDEX_NAME%3E", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"objectID":"id","test":"val"}`)
	})
}

func TestSearch_SaveRule(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("saveRule with minimal parameters", func(t *testing.T) {
		_, err := client.SaveRule(client.NewApiSaveRuleRequest(
			"indexName", "id1",
			search.NewEmptyRule().SetObjectID("id1").SetConditions(
				[]search.Condition{*search.NewEmptyCondition().SetPattern("apple").SetAnchoring(search.Anchoring("contains"))}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/rules/id1", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains"}]}`)
	})
	t.Run("saveRule with all parameters", func(t *testing.T) {
		_, err := client.SaveRule(client.NewApiSaveRuleRequest(
			"indexName", "id1",
			search.NewEmptyRule().SetObjectID("id1").SetConditions(
				[]search.Condition{*search.NewEmptyCondition().SetPattern("apple").SetAnchoring(search.Anchoring("contains")).SetAlternatives(false).SetContext("search")}).SetConsequence(
				search.NewEmptyConsequence().SetParams(
					search.NewEmptyConsequenceParams().SetFilters("brand:apple").SetQuery(search.ConsequenceQueryObjectAsConsequenceQuery(
						search.NewEmptyConsequenceQueryObject().SetRemove(
							[]string{"algolia"}).SetEdits(
							[]search.Edit{*search.NewEmptyEdit().SetType(search.EditType("remove")).SetDelete("abc").SetInsert("cde"), *search.NewEmptyEdit().SetType(search.EditType("replace")).SetDelete("abc").SetInsert("cde")})))).SetHide(
					[]search.ConsequenceHide{*search.NewEmptyConsequenceHide().SetObjectID("321")}).SetFilterPromotes(false).SetUserData(map[string]any{"algolia": "aloglia"}).SetPromote(
					[]search.Promote{*search.PromoteObjectIDAsPromote(
						search.NewEmptyPromoteObjectID().SetObjectID("abc").SetPosition(3)), *search.PromoteObjectIDsAsPromote(
						search.NewEmptyPromoteObjectIDs().SetObjectIDs(
							[]string{"abc", "def"}).SetPosition(1))})).SetDescription("test").SetEnabled(true).SetValidity(
				[]search.TimeRange{*search.NewEmptyTimeRange().SetFrom(1656670273).SetUntil(1656670277)}),
		).WithForwardToReplicas(true))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/rules/id1", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains","alternatives":false,"context":"search"}],"consequence":{"params":{"filters":"brand:apple","query":{"remove":["algolia"],"edits":[{"type":"remove","delete":"abc","insert":"cde"},{"type":"replace","delete":"abc","insert":"cde"}]}},"hide":[{"objectID":"321"}],"filterPromotes":false,"userData":{"algolia":"aloglia"},"promote":[{"objectID":"abc","position":3},{"objectIDs":["abc","def"],"position":1}]},"description":"test","enabled":true,"validity":[{"from":1656670273,"until":1656670277}]}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"forwardToReplicas":"true"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
}

func TestSearch_SaveRules(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("saveRules with minimal parameters", func(t *testing.T) {
		_, err := client.SaveRules(client.NewApiSaveRulesRequest(
			"<YOUR_INDEX_NAME>",
			[]search.Rule{*search.NewEmptyRule().SetObjectID("a-rule-id").SetConditions(
				[]search.Condition{*search.NewEmptyCondition().SetPattern("smartphone").SetAnchoring(search.Anchoring("contains"))}), *search.NewEmptyRule().SetObjectID("a-second-rule-id").SetConditions(
				[]search.Condition{*search.NewEmptyCondition().SetPattern("apple").SetAnchoring(search.Anchoring("contains"))})},
		).WithForwardToReplicas(false).WithClearExistingRules(true))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `[{"objectID":"a-rule-id","conditions":[{"pattern":"smartphone","anchoring":"contains"}]},{"objectID":"a-second-rule-id","conditions":[{"pattern":"apple","anchoring":"contains"}]}]`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"forwardToReplicas":"false","clearExistingRules":"true"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("saveRules with all parameters", func(t *testing.T) {
		_, err := client.SaveRules(client.NewApiSaveRulesRequest(
			"<YOUR_INDEX_NAME>",
			[]search.Rule{*search.NewEmptyRule().SetObjectID("id1").SetConditions(
				[]search.Condition{*search.NewEmptyCondition().SetPattern("apple").SetAnchoring(search.Anchoring("contains")).SetAlternatives(false).SetContext("search")}).SetConsequence(
				search.NewEmptyConsequence().SetParams(
					search.NewEmptyConsequenceParams().SetFilters("brand:apple").SetQuery(search.ConsequenceQueryObjectAsConsequenceQuery(
						search.NewEmptyConsequenceQueryObject().SetRemove(
							[]string{"algolia"}).SetEdits(
							[]search.Edit{*search.NewEmptyEdit().SetType(search.EditType("remove")).SetDelete("abc").SetInsert("cde"), *search.NewEmptyEdit().SetType(search.EditType("replace")).SetDelete("abc").SetInsert("cde")})))).SetHide(
					[]search.ConsequenceHide{*search.NewEmptyConsequenceHide().SetObjectID("321")}).SetFilterPromotes(false).SetUserData(map[string]any{"algolia": "aloglia"}).SetPromote(
					[]search.Promote{*search.PromoteObjectIDAsPromote(
						search.NewEmptyPromoteObjectID().SetObjectID("abc").SetPosition(3)), *search.PromoteObjectIDsAsPromote(
						search.NewEmptyPromoteObjectIDs().SetObjectIDs(
							[]string{"abc", "def"}).SetPosition(1))})).SetDescription("test").SetEnabled(true).SetValidity(
				[]search.TimeRange{*search.NewEmptyTimeRange().SetFrom(1656670273).SetUntil(1656670277)})},
		).WithForwardToReplicas(true).WithClearExistingRules(true))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `[{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains","alternatives":false,"context":"search"}],"consequence":{"params":{"filters":"brand:apple","query":{"remove":["algolia"],"edits":[{"type":"remove","delete":"abc","insert":"cde"},{"type":"replace","delete":"abc","insert":"cde"}]}},"hide":[{"objectID":"321"}],"filterPromotes":false,"userData":{"algolia":"aloglia"},"promote":[{"objectID":"abc","position":3},{"objectIDs":["abc","def"],"position":1}]},"description":"test","enabled":true,"validity":[{"from":1656670273,"until":1656670277}]}]`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"forwardToReplicas":"true","clearExistingRules":"true"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
}

func TestSearch_SaveSynonym(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("saveSynonym", func(t *testing.T) {
		_, err := client.SaveSynonym(client.NewApiSaveSynonymRequest(
			"indexName", "id1",
			search.NewEmptySynonymHit().SetObjectID("id1").SetType(search.SynonymType("synonym")).SetSynonyms(
				[]string{"car", "vehicule", "auto"}),
		).WithForwardToReplicas(true))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/synonyms/id1", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"objectID":"id1","type":"synonym","synonyms":["car","vehicule","auto"]}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"forwardToReplicas":"true"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
}

func TestSearch_SaveSynonyms(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("saveSynonyms", func(t *testing.T) {
		_, err := client.SaveSynonyms(client.NewApiSaveSynonymsRequest(
			"<YOUR_INDEX_NAME>",
			[]search.SynonymHit{*search.NewEmptySynonymHit().SetObjectID("id1").SetType(search.SynonymType("synonym")).SetSynonyms(
				[]string{"car", "vehicule", "auto"}), *search.NewEmptySynonymHit().SetObjectID("id2").SetType(search.SynonymType("onewaysynonym")).SetInput("iphone").SetSynonyms(
				[]string{"ephone", "aphone", "yphone"})},
		).WithForwardToReplicas(true).WithReplaceExistingSynonyms(true))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/%3CYOUR_INDEX_NAME%3E/synonyms/batch", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `[{"objectID":"id1","type":"synonym","synonyms":["car","vehicule","auto"]},{"objectID":"id2","type":"onewaysynonym","input":"iphone","synonyms":["ephone","aphone","yphone"]}]`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"forwardToReplicas":"true","replaceExistingSynonyms":"true"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
}

func TestSearch_Search(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("withHitsPerPage", func(t *testing.T) {
		_, err := client.Search(client.NewApiSearchRequest(

			search.NewEmptySearchMethodParams().SetRequests(
				[]search.SearchQuery{*search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("<YOUR_INDEX_NAME>").SetQuery("<YOUR_QUERY>").SetHitsPerPage(50))}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/queries", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","hitsPerPage":50}]}`)
	})
	t.Run("filterOnly", func(t *testing.T) {
		_, err := client.Search(client.NewApiSearchRequest(

			search.NewEmptySearchMethodParams().SetRequests(
				[]search.SearchQuery{*search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("<YOUR_INDEX_NAME>").SetQuery("<YOUR_QUERY>").SetFilters("actor:Scarlett Johansson"))}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/queries", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"actor:Scarlett Johansson"}]}`)
	})
	t.Run("filterOr", func(t *testing.T) {
		_, err := client.Search(client.NewApiSearchRequest(

			search.NewEmptySearchMethodParams().SetRequests(
				[]search.SearchQuery{*search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("<YOUR_INDEX_NAME>").SetQuery("<YOUR_QUERY>").SetFilters("actor:Tom Cruise OR actor:Scarlett Johansson"))}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/queries", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"actor:Tom Cruise OR actor:Scarlett Johansson"}]}`)
	})
	t.Run("filterNot", func(t *testing.T) {
		_, err := client.Search(client.NewApiSearchRequest(

			search.NewEmptySearchMethodParams().SetRequests(
				[]search.SearchQuery{*search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("<YOUR_INDEX_NAME>").SetQuery("<YOUR_QUERY>").SetFilters("NOT actor:Nicolas Cage"))}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/queries", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"NOT actor:Nicolas Cage"}]}`)
	})
	t.Run("search for a single hits request with minimal parameters", func(t *testing.T) {
		_, err := client.Search(client.NewApiSearchRequest(

			search.NewEmptySearchMethodParams().SetRequests(
				[]search.SearchQuery{*search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("cts_e2e_search_empty_index"))}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/queries", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"indexName":"cts_e2e_search_empty_index"}]}`)
	})
	t.Run("search with highlight and snippet results", func(t *testing.T) {
		_, err := client.Search(client.NewApiSearchRequest(

			search.NewEmptySearchMethodParams().SetRequests(
				[]search.SearchQuery{*search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("cts_e2e_highlight_snippet_results").SetQuery("vim").SetAttributesToSnippet(
						[]string{"*:20"}).SetAttributesToHighlight(
						[]string{"*"}).SetAttributesToRetrieve(
						[]string{"*"}))}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/queries", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"indexName":"cts_e2e_highlight_snippet_results","query":"vim","attributesToSnippet":["*:20"],"attributesToHighlight":["*"],"attributesToRetrieve":["*"]}]}`)
	})
	t.Run("retrieveFacets", func(t *testing.T) {
		_, err := client.Search(client.NewApiSearchRequest(

			search.NewEmptySearchMethodParams().SetRequests(
				[]search.SearchQuery{*search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("<YOUR_INDEX_NAME>").SetQuery("<YOUR_QUERY>").SetFacets(
						[]string{"author", "genre"}))}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/queries", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","facets":["author","genre"]}]}`)
	})
	t.Run("retrieveFacetsWildcard", func(t *testing.T) {
		_, err := client.Search(client.NewApiSearchRequest(

			search.NewEmptySearchMethodParams().SetRequests(
				[]search.SearchQuery{*search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("<YOUR_INDEX_NAME>").SetQuery("<YOUR_QUERY>").SetFacets(
						[]string{"*"}))}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/queries", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","facets":["*"]}]}`)
	})
	t.Run("search for a single facet request with minimal parameters", func(t *testing.T) {
		_, err := client.Search(client.NewApiSearchRequest(

			search.NewEmptySearchMethodParams().SetRequests(
				[]search.SearchQuery{*search.SearchForFacetsAsSearchQuery(
					search.NewEmptySearchForFacets().SetIndexName("cts_e2e_search_facet").SetType(search.SearchTypeFacet("facet")).SetFacet("editor"))}).SetStrategy(search.SearchStrategy("stopIfEnoughMatches")),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/queries", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"indexName":"cts_e2e_search_facet","type":"facet","facet":"editor"}],"strategy":"stopIfEnoughMatches"}`)
	})
	t.Run("search for a single hits request with all parameters", func(t *testing.T) {
		_, err := client.Search(client.NewApiSearchRequest(

			search.NewEmptySearchMethodParams().SetRequests(
				[]search.SearchQuery{*search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("theIndexName").SetQuery("myQuery").SetHitsPerPage(50).SetType(search.SearchTypeDefault("default")))}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/queries", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"indexName":"theIndexName","query":"myQuery","hitsPerPage":50,"type":"default"}]}`)
	})
	t.Run("search for a single facet request with all parameters", func(t *testing.T) {
		_, err := client.Search(client.NewApiSearchRequest(

			search.NewEmptySearchMethodParams().SetRequests(
				[]search.SearchQuery{*search.SearchForFacetsAsSearchQuery(
					search.NewEmptySearchForFacets().SetIndexName("theIndexName").SetType(search.SearchTypeFacet("facet")).SetFacet("theFacet").SetFacetQuery("theFacetQuery").SetQuery("theQuery").SetMaxFacetHits(50))}).SetStrategy(search.SearchStrategy("stopIfEnoughMatches")),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/queries", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"indexName":"theIndexName","type":"facet","facet":"theFacet","facetQuery":"theFacetQuery","query":"theQuery","maxFacetHits":50}],"strategy":"stopIfEnoughMatches"}`)
	})
	t.Run("search for multiple mixed requests in multiple indices with minimal parameters", func(t *testing.T) {
		_, err := client.Search(client.NewApiSearchRequest(

			search.NewEmptySearchMethodParams().SetRequests(
				[]search.SearchQuery{*search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("theIndexName")), *search.SearchForFacetsAsSearchQuery(
					search.NewEmptySearchForFacets().SetIndexName("theIndexName2").SetType(search.SearchTypeFacet("facet")).SetFacet("theFacet")), *search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("theIndexName").SetType(search.SearchTypeDefault("default")))}).SetStrategy(search.SearchStrategy("stopIfEnoughMatches")),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/queries", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"indexName":"theIndexName"},{"indexName":"theIndexName2","type":"facet","facet":"theFacet"},{"indexName":"theIndexName","type":"default"}],"strategy":"stopIfEnoughMatches"}`)
	})
	t.Run("search for multiple mixed requests in multiple indices with all parameters", func(t *testing.T) {
		_, err := client.Search(client.NewApiSearchRequest(

			search.NewEmptySearchMethodParams().SetRequests(
				[]search.SearchQuery{*search.SearchForFacetsAsSearchQuery(
					search.NewEmptySearchForFacets().SetIndexName("theIndexName").SetType(search.SearchTypeFacet("facet")).SetFacet("theFacet").SetFacetQuery("theFacetQuery").SetQuery("theQuery").SetMaxFacetHits(50)), *search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("theIndexName").SetQuery("myQuery").SetHitsPerPage(50).SetType(search.SearchTypeDefault("default")))}).SetStrategy(search.SearchStrategy("stopIfEnoughMatches")),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/queries", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"indexName":"theIndexName","type":"facet","facet":"theFacet","facetQuery":"theFacetQuery","query":"theQuery","maxFacetHits":50},{"indexName":"theIndexName","query":"myQuery","hitsPerPage":50,"type":"default"}],"strategy":"stopIfEnoughMatches"}`)
	})
	t.Run("search filters accept all of the possible shapes", func(t *testing.T) {
		_, err := client.Search(client.NewApiSearchRequest(

			search.NewEmptySearchMethodParams().SetRequests(
				[]search.SearchQuery{*search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("theIndexName").SetFacetFilters(search.StringAsFacetFilters("mySearch:filters")).SetReRankingApplyFilter(search.StringAsReRankingApplyFilter("mySearch:filters")).SetTagFilters(search.StringAsTagFilters("mySearch:filters")).SetNumericFilters(search.StringAsNumericFilters("mySearch:filters")).SetOptionalFilters(search.StringAsOptionalFilters("mySearch:filters"))), *search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("theIndexName").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(
						[]search.FacetFilters{*search.StringAsFacetFilters("mySearch:filters"), *search.ArrayOfFacetFiltersAsFacetFilters(
							[]search.FacetFilters{*search.StringAsFacetFilters("mySearch:filters"), *search.ArrayOfFacetFiltersAsFacetFilters(
								[]search.FacetFilters{*search.StringAsFacetFilters("mySearch:filters")})})})).SetReRankingApplyFilter(search.ArrayOfReRankingApplyFilterAsReRankingApplyFilter(
						[]search.ReRankingApplyFilter{*search.StringAsReRankingApplyFilter("mySearch:filters"), *search.ArrayOfReRankingApplyFilterAsReRankingApplyFilter(
							[]search.ReRankingApplyFilter{*search.StringAsReRankingApplyFilter("mySearch:filters")})})).SetTagFilters(search.ArrayOfTagFiltersAsTagFilters(
						[]search.TagFilters{*search.StringAsTagFilters("mySearch:filters"), *search.ArrayOfTagFiltersAsTagFilters(
							[]search.TagFilters{*search.StringAsTagFilters("mySearch:filters")})})).SetNumericFilters(search.ArrayOfNumericFiltersAsNumericFilters(
						[]search.NumericFilters{*search.StringAsNumericFilters("mySearch:filters"), *search.ArrayOfNumericFiltersAsNumericFilters(
							[]search.NumericFilters{*search.StringAsNumericFilters("mySearch:filters")})})).SetOptionalFilters(search.ArrayOfOptionalFiltersAsOptionalFilters(
						[]search.OptionalFilters{*search.StringAsOptionalFilters("mySearch:filters"), *search.ArrayOfOptionalFiltersAsOptionalFilters(
							[]search.OptionalFilters{*search.StringAsOptionalFilters("mySearch:filters")})})))}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/queries", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"indexName":"theIndexName","facetFilters":"mySearch:filters","reRankingApplyFilter":"mySearch:filters","tagFilters":"mySearch:filters","numericFilters":"mySearch:filters","optionalFilters":"mySearch:filters"},{"indexName":"theIndexName","facetFilters":["mySearch:filters",["mySearch:filters",["mySearch:filters"]]],"reRankingApplyFilter":["mySearch:filters",["mySearch:filters"]],"tagFilters":["mySearch:filters",["mySearch:filters"]],"numericFilters":["mySearch:filters",["mySearch:filters"]],"optionalFilters":["mySearch:filters",["mySearch:filters"]]}]}`)
	})
	t.Run("search filters end to end", func(t *testing.T) {
		_, err := client.Search(client.NewApiSearchRequest(

			search.NewEmptySearchMethodParams().SetRequests(
				[]search.SearchQuery{*search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("cts_e2e_search_facet").SetFilters("editor:'visual studio' OR editor:neovim")), *search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("cts_e2e_search_facet").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(
						[]search.FacetFilters{*search.StringAsFacetFilters("editor:'visual studio'"), *search.StringAsFacetFilters("editor:neovim")}))), *search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("cts_e2e_search_facet").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(
						[]search.FacetFilters{*search.StringAsFacetFilters("editor:'visual studio'"), *search.ArrayOfFacetFiltersAsFacetFilters(
							[]search.FacetFilters{*search.StringAsFacetFilters("editor:neovim")})}))), *search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetIndexName("cts_e2e_search_facet").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(
						[]search.FacetFilters{*search.StringAsFacetFilters("editor:'visual studio'"), *search.ArrayOfFacetFiltersAsFacetFilters(
							[]search.FacetFilters{*search.StringAsFacetFilters("editor:neovim"), *search.ArrayOfFacetFiltersAsFacetFilters(
								[]search.FacetFilters{*search.StringAsFacetFilters("editor:goland")})})})))}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/queries", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"indexName":"cts_e2e_search_facet","filters":"editor:'visual studio' OR editor:neovim"},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'","editor:neovim"]},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'",["editor:neovim"]]},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'",["editor:neovim",["editor:goland"]]]}]}`)
	})
	t.Run("search with all search parameters", func(t *testing.T) {
		_, err := client.Search(client.NewApiSearchRequest(

			search.NewEmptySearchMethodParams().SetRequests(
				[]search.SearchQuery{*search.SearchForHitsAsSearchQuery(
					search.NewEmptySearchForHits().SetAdvancedSyntax(true).SetAdvancedSyntaxFeatures(
						[]search.AdvancedSyntaxFeatures{search.AdvancedSyntaxFeatures("exactPhrase")}).SetAllowTyposOnNumericTokens(true).SetAlternativesAsExact(
						[]search.AlternativesAsExact{search.AlternativesAsExact("multiWordsSynonym")}).SetAnalytics(true).SetAnalyticsTags(
						[]string{""}).SetAroundLatLng("").SetAroundLatLngViaIP(true).SetAroundPrecision(search.Int32AsAroundPrecision(0)).SetAroundRadius(search.AroundRadiusAllAsAroundRadius(search.AroundRadiusAll("all"))).SetAttributeCriteriaComputedByMinProximity(true).SetAttributesToHighlight(
						[]string{""}).SetAttributesToRetrieve(
						[]string{""}).SetAttributesToSnippet(
						[]string{""}).SetClickAnalytics(true).SetCustomRanking(
						[]string{""}).SetDecompoundQuery(true).SetDisableExactOnAttributes(
						[]string{""}).SetDisableTypoToleranceOnAttributes(
						[]string{""}).SetDistinct(search.Int32AsDistinct(0)).SetEnableABTest(true).SetEnablePersonalization(true).SetEnableReRanking(true).SetEnableRules(true).SetExactOnSingleWordQuery(search.ExactOnSingleWordQuery("attribute")).SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(
						[]search.FacetFilters{*search.StringAsFacetFilters("")})).SetFacetingAfterDistinct(true).SetFacets(
						[]string{""}).SetFilters("").SetGetRankingInfo(true).SetHighlightPostTag("").SetHighlightPreTag("").SetHitsPerPage(1).SetIgnorePlurals(search.BoolAsIgnorePlurals(false)).SetIndexName("theIndexName").SetInsideBoundingBox(search.ArrayOfArrayOfFloat64AsInsideBoundingBox(
						[][]float64{
							[]float64{47.3165, 4.9665, 47.3424, 5.0201},
							[]float64{40.9234, 2.1185, 38.643, 1.9916}})).SetInsidePolygon(
						[][]float64{
							[]float64{47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9},
							[]float64{40.9234, 2.1185, 38.643, 1.9916, 39.2587, 2.0104}}).SetKeepDiacriticsOnCharacters("").SetLength(1).SetMaxValuesPerFacet(0).SetMinProximity(1).SetMinWordSizefor1Typo(0).SetMinWordSizefor2Typos(0).SetMinimumAroundRadius(1).SetNaturalLanguages(
						[]search.SupportedLanguage{search.SupportedLanguage("fr")}).SetNumericFilters(search.ArrayOfNumericFiltersAsNumericFilters(
						[]search.NumericFilters{*search.StringAsNumericFilters("")})).SetOffset(0).SetOptionalFilters(search.ArrayOfOptionalFiltersAsOptionalFilters(
						[]search.OptionalFilters{*search.StringAsOptionalFilters("")})).SetOptionalWords(search.ArrayOfStringAsOptionalWords(
						[]string{""})).SetPage(0).SetPercentileComputation(true).SetPersonalizationImpact(0).SetQuery("").SetQueryLanguages(
						[]search.SupportedLanguage{search.SupportedLanguage("fr")}).SetQueryType(search.QueryType("prefixAll")).SetRanking(
						[]string{""}).SetReRankingApplyFilter(search.ArrayOfReRankingApplyFilterAsReRankingApplyFilter(
						[]search.ReRankingApplyFilter{*search.StringAsReRankingApplyFilter("")})).SetRelevancyStrictness(0).SetRemoveStopWords(search.BoolAsRemoveStopWords(true)).SetRemoveWordsIfNoResults(search.RemoveWordsIfNoResults("allOptional")).SetRenderingContent(
						search.NewEmptyRenderingContent().SetFacetOrdering(
							search.NewEmptyFacetOrdering().SetFacets(
								search.NewEmptyFacets().SetOrder(
									[]string{"a", "b"})).SetValues(map[string]search.Value{"a": *search.NewEmptyValue().SetOrder(
								[]string{"b"}).SetSortRemainingBy(search.SortRemainingBy("count"))}))).SetReplaceSynonymsInHighlight(true).SetResponseFields(
						[]string{""}).SetRestrictHighlightAndSnippetArrays(true).SetRestrictSearchableAttributes(
						[]string{""}).SetRuleContexts(
						[]string{""}).SetSimilarQuery("").SetSnippetEllipsisText("").SetSortFacetValuesBy("").SetSumOrFiltersScores(true).SetSynonyms(true).SetTagFilters(search.ArrayOfTagFiltersAsTagFilters(
						[]search.TagFilters{*search.StringAsTagFilters("")})).SetType(search.SearchTypeDefault("default")).SetTypoTolerance(search.TypoToleranceEnumAsTypoTolerance(search.TypoToleranceEnum("min"))).SetUserToken(""))}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/*/queries", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"requests":[{"advancedSyntax":true,"advancedSyntaxFeatures":["exactPhrase"],"allowTyposOnNumericTokens":true,"alternativesAsExact":["multiWordsSynonym"],"analytics":true,"analyticsTags":[""],"aroundLatLng":"","aroundLatLngViaIP":true,"aroundPrecision":0,"aroundRadius":"all","attributeCriteriaComputedByMinProximity":true,"attributesToHighlight":[""],"attributesToRetrieve":[""],"attributesToSnippet":[""],"clickAnalytics":true,"customRanking":[""],"decompoundQuery":true,"disableExactOnAttributes":[""],"disableTypoToleranceOnAttributes":[""],"distinct":0,"enableABTest":true,"enablePersonalization":true,"enableReRanking":true,"enableRules":true,"exactOnSingleWordQuery":"attribute","facetFilters":[""],"facetingAfterDistinct":true,"facets":[""],"filters":"","getRankingInfo":true,"highlightPostTag":"","highlightPreTag":"","hitsPerPage":1,"ignorePlurals":false,"indexName":"theIndexName","insideBoundingBox":[[47.3165,4.9665,47.3424,5.0201],[40.9234,2.1185,38.643,1.9916]],"insidePolygon":[[47.3165,4.9665,47.3424,5.0201,47.32,4.9],[40.9234,2.1185,38.643,1.9916,39.2587,2.0104]],"keepDiacriticsOnCharacters":"","length":1,"maxValuesPerFacet":0,"minProximity":1,"minWordSizefor1Typo":0,"minWordSizefor2Typos":0,"minimumAroundRadius":1,"naturalLanguages":["fr"],"numericFilters":[""],"offset":0,"optionalFilters":[""],"optionalWords":[""],"page":0,"percentileComputation":true,"personalizationImpact":0,"query":"","queryLanguages":["fr"],"queryType":"prefixAll","ranking":[""],"reRankingApplyFilter":[""],"relevancyStrictness":0,"removeStopWords":true,"removeWordsIfNoResults":"allOptional","renderingContent":{"facetOrdering":{"facets":{"order":["a","b"]},"values":{"a":{"order":["b"],"sortRemainingBy":"count"}}}},"replaceSynonymsInHighlight":true,"responseFields":[""],"restrictHighlightAndSnippetArrays":true,"restrictSearchableAttributes":[""],"ruleContexts":[""],"similarQuery":"","snippetEllipsisText":"","sortFacetValuesBy":"","sumOrFiltersScores":true,"synonyms":true,"tagFilters":[""],"type":"default","typoTolerance":"min","userToken":""}]}`)
	})
}

func TestSearch_SearchDictionaryEntries(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("get searchDictionaryEntries results with minimal parameters", func(t *testing.T) {
		_, err := client.SearchDictionaryEntries(client.NewApiSearchDictionaryEntriesRequest(
			search.DictionaryType("stopwords"),
			search.NewEmptySearchDictionaryEntriesParams().SetQuery("about"),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/dictionaries/stopwords/search", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"query":"about"}`)
	})
	t.Run("get searchDictionaryEntries results with all parameters", func(t *testing.T) {
		_, err := client.SearchDictionaryEntries(client.NewApiSearchDictionaryEntriesRequest(
			search.DictionaryType("compounds"),
			search.NewEmptySearchDictionaryEntriesParams().SetQuery("foo").SetPage(4).SetHitsPerPage(2).SetLanguage(search.SupportedLanguage("fr")),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/dictionaries/compounds/search", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"query":"foo","page":4,"hitsPerPage":2,"language":"fr"}`)
	})
}

func TestSearch_SearchForFacetValues(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("get searchForFacetValues results with minimal parameters", func(t *testing.T) {
		_, err := client.SearchForFacetValues(client.NewApiSearchForFacetValuesRequest(
			"indexName", "facetName",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/facets/facetName/query", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{}`)
	})
	t.Run("get searchForFacetValues results with all parameters", func(t *testing.T) {
		_, err := client.SearchForFacetValues(client.NewApiSearchForFacetValuesRequest(
			"indexName", "facetName",
		).WithSearchForFacetValuesRequest(
			search.NewEmptySearchForFacetValuesRequest().SetParams("query=foo&facetFilters=['bar']").SetFacetQuery("foo").SetMaxFacetHits(42)))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/facets/facetName/query", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"params":"query=foo&facetFilters=['bar']","facetQuery":"foo","maxFacetHits":42}`)
	})
}

func TestSearch_SearchRules(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("searchRules", func(t *testing.T) {
		_, err := client.SearchRules(client.NewApiSearchRulesRequest(
			"cts_e2e_browse",
		).WithSearchRulesParams(
			search.NewEmptySearchRulesParams().SetQuery("zorro")))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/cts_e2e_browse/rules/search", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"query":"zorro"}`)
	})
}

func TestSearch_SearchSingleIndex(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("search with minimal parameters", func(t *testing.T) {
		_, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(
			"indexName",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/query", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{}`)
	})
	t.Run("search with special characters in indexName", func(t *testing.T) {
		_, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(
			"cts_e2e_space in index",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/cts_e2e_space%20in%20index/query", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{}`)
	})
	t.Run("search with searchParams", func(t *testing.T) {
		_, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(
			"indexName",
		).WithSearchParams(search.SearchParamsObjectAsSearchParams(
			search.NewEmptySearchParamsObject().SetQuery("myQuery").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(
				[]search.FacetFilters{*search.StringAsFacetFilters("tags:algolia")})))))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/query", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"query":"myQuery","facetFilters":["tags:algolia"]}`)
	})
	t.Run("single search retrieve snippets", func(t *testing.T) {
		_, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(
			"cts_e2e_browse",
		).WithSearchParams(search.SearchParamsObjectAsSearchParams(
			search.NewEmptySearchParamsObject().SetQuery("batman mask of the phantasm").SetAttributesToRetrieve(
				[]string{"*"}).SetAttributesToSnippet(
				[]string{"*:20"}))))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/cts_e2e_browse/query", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"query":"batman mask of the phantasm","attributesToRetrieve":["*"],"attributesToSnippet":["*:20"]}`)
	})
}

func TestSearch_SearchSynonyms(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("searchSynonyms with minimal parameters", func(t *testing.T) {
		_, err := client.SearchSynonyms(client.NewApiSearchSynonymsRequest(
			"indexName",
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/synonyms/search", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{}`)
	})
	t.Run("searchSynonyms with all parameters", func(t *testing.T) {
		_, err := client.SearchSynonyms(client.NewApiSearchSynonymsRequest(
			"indexName",
		).WithSearchSynonymsParams(
			search.NewEmptySearchSynonymsParams().SetQuery("myQuery").SetType(search.SynonymType("altcorrection1")).SetPage(10).SetHitsPerPage(10)))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/indexName/synonyms/search", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"query":"myQuery","type":"altcorrection1","page":10,"hitsPerPage":10}`)
	})
}

func TestSearch_SearchUserIds(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("searchUserIds", func(t *testing.T) {
		_, err := client.SearchUserIds(client.NewApiSearchUserIdsRequest(

			search.NewEmptySearchUserIdsParams().SetQuery("test").SetClusterName("theClusterName").SetPage(5).SetHitsPerPage(10),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/clusters/mapping/search", echo.Path)
		require.Equal(t, "POST", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"query":"test","clusterName":"theClusterName","page":5,"hitsPerPage":10}`)
	})
}

func TestSearch_SetDictionarySettings(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("get setDictionarySettings results with minimal parameters", func(t *testing.T) {
		_, err := client.SetDictionarySettings(client.NewApiSetDictionarySettingsRequest(

			search.NewEmptyDictionarySettingsParams().SetDisableStandardEntries(
				search.NewEmptyStandardEntries().SetPlurals(map[string]bool{"fr": false, "en": false, "ru": true})),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/dictionaries/*/settings", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"disableStandardEntries":{"plurals":{"fr":false,"en":false,"ru":true}}}`)
	})
	t.Run("get setDictionarySettings results with all parameters", func(t *testing.T) {
		_, err := client.SetDictionarySettings(client.NewApiSetDictionarySettingsRequest(

			search.NewEmptyDictionarySettingsParams().SetDisableStandardEntries(
				search.NewEmptyStandardEntries().SetPlurals(map[string]bool{"fr": false, "en": false, "ru": true}).SetStopwords(map[string]bool{"fr": false}).SetCompounds(map[string]bool{"ru": true})),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/dictionaries/*/settings", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"disableStandardEntries":{"plurals":{"fr":false,"en":false,"ru":true},"stopwords":{"fr":false},"compounds":{"ru":true}}}`)
	})
}

func TestSearch_SetSettings(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("setSettingsAttributesForFaceting", func(t *testing.T) {
		_, err := client.SetSettings(client.NewApiSetSettingsRequest(
			"<YOUR_INDEX_NAME>",
			search.NewEmptyIndexSettings().SetAttributesForFaceting(
				[]string{"actor", "filterOnly(category)", "searchable(publisher)"}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"attributesForFaceting":["actor","filterOnly(category)","searchable(publisher)"]}`)
	})
	t.Run("setSettings with minimal parameters", func(t *testing.T) {
		_, err := client.SetSettings(client.NewApiSetSettingsRequest(
			"cts_e2e_settings",
			search.NewEmptyIndexSettings().SetPaginationLimitedTo(10),
		).WithForwardToReplicas(true))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/cts_e2e_settings/settings", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"paginationLimitedTo":10}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"forwardToReplicas":"true"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("setSettings allow boolean `typoTolerance`", func(t *testing.T) {
		_, err := client.SetSettings(client.NewApiSetSettingsRequest(
			"theIndexName",
			search.NewEmptyIndexSettings().SetTypoTolerance(search.BoolAsTypoTolerance(true)),
		).WithForwardToReplicas(true))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/settings", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"typoTolerance":true}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"forwardToReplicas":"true"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("setSettings allow enum `typoTolerance`", func(t *testing.T) {
		_, err := client.SetSettings(client.NewApiSetSettingsRequest(
			"theIndexName",
			search.NewEmptyIndexSettings().SetTypoTolerance(search.TypoToleranceEnumAsTypoTolerance(search.TypoToleranceEnum("min"))),
		).WithForwardToReplicas(true))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/settings", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"typoTolerance":"min"}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"forwardToReplicas":"true"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("setSettings allow boolean `ignorePlurals`", func(t *testing.T) {
		_, err := client.SetSettings(client.NewApiSetSettingsRequest(
			"theIndexName",
			search.NewEmptyIndexSettings().SetIgnorePlurals(search.BoolAsIgnorePlurals(true)),
		).WithForwardToReplicas(true))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/settings", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"ignorePlurals":true}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"forwardToReplicas":"true"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("setSettings allow list of string `ignorePlurals`", func(t *testing.T) {
		_, err := client.SetSettings(client.NewApiSetSettingsRequest(
			"theIndexName",
			search.NewEmptyIndexSettings().SetIgnorePlurals(search.ArrayOfSupportedLanguageAsIgnorePlurals(
				[]search.SupportedLanguage{search.SupportedLanguage("fr")})),
		).WithForwardToReplicas(true))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/settings", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"ignorePlurals":["fr"]}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"forwardToReplicas":"true"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("setSettings allow boolean `removeStopWords`", func(t *testing.T) {
		_, err := client.SetSettings(client.NewApiSetSettingsRequest(
			"theIndexName",
			search.NewEmptyIndexSettings().SetRemoveStopWords(search.BoolAsRemoveStopWords(true)),
		).WithForwardToReplicas(true))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/settings", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"removeStopWords":true}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"forwardToReplicas":"true"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("setSettings allow list of string `removeStopWords`", func(t *testing.T) {
		_, err := client.SetSettings(client.NewApiSetSettingsRequest(
			"theIndexName",
			search.NewEmptyIndexSettings().SetRemoveStopWords(search.ArrayOfSupportedLanguageAsRemoveStopWords(
				[]search.SupportedLanguage{search.SupportedLanguage("fr")})),
		).WithForwardToReplicas(true))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/settings", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"removeStopWords":["fr"]}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"forwardToReplicas":"true"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("setSettings allow boolean `distinct`", func(t *testing.T) {
		_, err := client.SetSettings(client.NewApiSetSettingsRequest(
			"theIndexName",
			search.NewEmptyIndexSettings().SetDistinct(search.BoolAsDistinct(true)),
		).WithForwardToReplicas(true))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/settings", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"distinct":true}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"forwardToReplicas":"true"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("setSettings allow integers for `distinct`", func(t *testing.T) {
		_, err := client.SetSettings(client.NewApiSetSettingsRequest(
			"theIndexName",
			search.NewEmptyIndexSettings().SetDistinct(search.Int32AsDistinct(1)),
		).WithForwardToReplicas(true))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/settings", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"distinct":1}`)
		queryParams := map[string]string{}
		require.NoError(t, json.Unmarshal([]byte(`{"forwardToReplicas":"true"}`), &queryParams))
		require.Len(t, queryParams, len(echo.Query))
		for k, v := range queryParams {
			require.Equal(t, v, echo.Query.Get(k))
		}
	})
	t.Run("setSettings allow all `indexSettings`", func(t *testing.T) {
		_, err := client.SetSettings(client.NewApiSetSettingsRequest(
			"theIndexName",
			search.NewEmptyIndexSettings().SetAdvancedSyntax(true).SetAdvancedSyntaxFeatures(
				[]search.AdvancedSyntaxFeatures{search.AdvancedSyntaxFeatures("exactPhrase")}).SetAllowCompressionOfIntegerArray(true).SetAllowTyposOnNumericTokens(true).SetAlternativesAsExact(
				[]search.AlternativesAsExact{search.AlternativesAsExact("singleWordSynonym")}).SetAttributeCriteriaComputedByMinProximity(true).SetAttributeForDistinct("test").SetAttributesForFaceting(
				[]string{"algolia"}).SetAttributesToHighlight(
				[]string{"algolia"}).SetAttributesToRetrieve(
				[]string{"algolia"}).SetAttributesToSnippet(
				[]string{"algolia"}).SetAttributesToTransliterate(
				[]string{"algolia"}).SetCamelCaseAttributes(
				[]string{"algolia"}).SetCustomNormalization(map[string]map[string]string{"algolia": map[string]string{"aloglia": "aglolia"}}).SetCustomRanking(
				[]string{"algolia"}).SetDecompoundQuery(false).SetDecompoundedAttributes(map[string]any{"algolia": "aloglia"}).SetDisableExactOnAttributes(
				[]string{"algolia"}).SetDisablePrefixOnAttributes(
				[]string{"algolia"}).SetDisableTypoToleranceOnAttributes(
				[]string{"algolia"}).SetDisableTypoToleranceOnWords(
				[]string{"algolia"}).SetDistinct(search.Int32AsDistinct(3)).SetEnablePersonalization(true).SetEnableReRanking(false).SetEnableRules(true).SetExactOnSingleWordQuery(search.ExactOnSingleWordQuery("attribute")).SetHighlightPreTag("<span>").SetHighlightPostTag("</span>").SetHitsPerPage(10).SetIgnorePlurals(search.BoolAsIgnorePlurals(false)).SetIndexLanguages(
				[]search.SupportedLanguage{search.SupportedLanguage("fr")}).SetKeepDiacriticsOnCharacters("abc").SetMaxFacetHits(20).SetMaxValuesPerFacet(30).SetMinProximity(6).SetMinWordSizefor1Typo(5).SetMinWordSizefor2Typos(11).SetMode(search.Mode("neuralSearch")).SetNumericAttributesForFiltering(
				[]string{"algolia"}).SetOptionalWords(search.ArrayOfStringAsOptionalWords(
				[]string{"myspace"})).SetPaginationLimitedTo(0).SetQueryLanguages(
				[]search.SupportedLanguage{search.SupportedLanguage("fr")}).SetQueryType(search.QueryType("prefixLast")).SetRanking(
				[]string{"geo"}).SetReRankingApplyFilter(search.StringAsReRankingApplyFilter("mySearch:filters")).SetRelevancyStrictness(10).SetRemoveStopWords(search.BoolAsRemoveStopWords(false)).SetRemoveWordsIfNoResults(search.RemoveWordsIfNoResults("lastWords")).SetRenderingContent(
				search.NewEmptyRenderingContent().SetFacetOrdering(
					search.NewEmptyFacetOrdering().SetFacets(
						search.NewEmptyFacets().SetOrder(
							[]string{"a", "b"})).SetValues(map[string]search.Value{"a": *search.NewEmptyValue().SetOrder(
						[]string{"b"}).SetSortRemainingBy(search.SortRemainingBy("count"))}))).SetReplaceSynonymsInHighlight(true).SetReplicas(
				[]string{""}).SetResponseFields(
				[]string{"algolia"}).SetRestrictHighlightAndSnippetArrays(true).SetSearchableAttributes(
				[]string{"foo"}).SetSemanticSearch(
				search.NewEmptySemanticSearch().SetEventSources(
					[]string{"foo"})).SetSeparatorsToIndex("bar").SetSnippetEllipsisText("---").SetSortFacetValuesBy("date").SetTypoTolerance(search.BoolAsTypoTolerance(false)).SetUnretrievableAttributes(
				[]string{"foo"}).SetUserData(map[string]any{"user": "data"}),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/indexes/theIndexName/settings", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"advancedSyntax":true,"advancedSyntaxFeatures":["exactPhrase"],"allowCompressionOfIntegerArray":true,"allowTyposOnNumericTokens":true,"alternativesAsExact":["singleWordSynonym"],"attributeCriteriaComputedByMinProximity":true,"attributeForDistinct":"test","attributesForFaceting":["algolia"],"attributesToHighlight":["algolia"],"attributesToRetrieve":["algolia"],"attributesToSnippet":["algolia"],"attributesToTransliterate":["algolia"],"camelCaseAttributes":["algolia"],"customNormalization":{"algolia":{"aloglia":"aglolia"}},"customRanking":["algolia"],"decompoundQuery":false,"decompoundedAttributes":{"algolia":"aloglia"},"disableExactOnAttributes":["algolia"],"disablePrefixOnAttributes":["algolia"],"disableTypoToleranceOnAttributes":["algolia"],"disableTypoToleranceOnWords":["algolia"],"distinct":3,"enablePersonalization":true,"enableReRanking":false,"enableRules":true,"exactOnSingleWordQuery":"attribute","highlightPreTag":"<span>","highlightPostTag":"</span>","hitsPerPage":10,"ignorePlurals":false,"indexLanguages":["fr"],"keepDiacriticsOnCharacters":"abc","maxFacetHits":20,"maxValuesPerFacet":30,"minProximity":6,"minWordSizefor1Typo":5,"minWordSizefor2Typos":11,"mode":"neuralSearch","numericAttributesForFiltering":["algolia"],"optionalWords":["myspace"],"paginationLimitedTo":0,"queryLanguages":["fr"],"queryType":"prefixLast","ranking":["geo"],"reRankingApplyFilter":"mySearch:filters","relevancyStrictness":10,"removeStopWords":false,"removeWordsIfNoResults":"lastWords","renderingContent":{"facetOrdering":{"facets":{"order":["a","b"]},"values":{"a":{"order":["b"],"sortRemainingBy":"count"}}}},"replaceSynonymsInHighlight":true,"replicas":[""],"responseFields":["algolia"],"restrictHighlightAndSnippetArrays":true,"searchableAttributes":["foo"],"semanticSearch":{"eventSources":["foo"]},"separatorsToIndex":"bar","snippetEllipsisText":"---","sortFacetValuesBy":"date","typoTolerance":false,"unretrievableAttributes":["foo"],"userData":{"user":"data"}}`)
	})
}

func TestSearch_UpdateApiKey(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("updateApiKey", func(t *testing.T) {
		_, err := client.UpdateApiKey(client.NewApiUpdateApiKeyRequest(
			"ALGOLIA_API_KEY",
			search.NewEmptyApiKey().SetAcl(
				[]search.Acl{search.Acl("search"), search.Acl("addObject")}).SetValidity(300).SetMaxQueriesPerIPPerHour(100).SetMaxHitsPerQuery(20),
		))
		require.NoError(t, err)

		require.Equal(t, "/1/keys/ALGOLIA_API_KEY", echo.Path)
		require.Equal(t, "PUT", echo.Method)

		ja := jsonassert.New(t)
		ja.Assertf(*echo.Body, `{"acl":["search","addObject"],"validity":300,"maxQueriesPerIPPerHour":100,"maxHitsPerQuery":20}`)
	})
}

func TestSearch_GenerateSecuredApiKey(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("generates a key without restrictions", func(t *testing.T) {
		key, err := client.GenerateSecuredApiKey("foo", nil)
		require.NoError(t, err)

		require.Equal(t, "NjgzNzE2ZDlkN2Y4MmVlZDE3NGM2Y2FlYmUwODZlZTkzMzc2Yzc5ZDdjNjFkZDY3MGVhMDBmN2Y4ZDZlYjBhOA==", key)
	})

	t.Run("generates a key with restrictions", func(t *testing.T) {
		key, err := client.GenerateSecuredApiKey("foo", search.NewSecuredApiKeyRestrictions().SetValidUntil(100).SetRestrictIndices([]string{"bar"}).SetRestrictSources("192,168.1.0/24").SetUserToken("foobarbaz").SetSearchParams(search.NewSearchParamsObject().SetQuery("foo")))
		require.NoError(t, err)

		require.Equal(t, "NGMxODk0MjViNjM3ODcxNjc4NWU4Y2I5NGIxNDAzMTg4MjU5Mjc4YTEwMzU4Mjk2YjBiMmVjOWViYTIyOTBiY3F1ZXJ5PWZvbyZyZXN0cmljdEluZGljZXM9YmFyJnJlc3RyaWN0U291cmNlcz0xOTIlMkMxNjguMS4wJTJGMjQmdXNlclRva2VuPWZvb2JhcmJheiZ2YWxpZFVudGlsPTEwMA==", key)
	})
}

func TestSearch_GetSecuredApiKeyRemainingVaildity(t *testing.T) {
	client, echo := createSearchClient(t)
	_ = echo

	t.Run("is able to check the remaining validity of a key", func(t *testing.T) {
		key, err := client.GenerateSecuredApiKey("foo", search.NewSecuredApiKeyRestrictions().SetValidUntil(42))
		require.NoError(t, err)

		require.Equal(t, "NDI5ZjRkMTRiNTBlZmExZWIyN2I3NzczOGUwMzE0NjYwMDU1M2M3NjYyY2IxODZhMDAxMWEwOWJmZjE5MzY0NnZhbGlkVW50aWw9NDI=", key)

		validity, err := client.GetSecuredApiKeyRemainingValidity(key)
		require.NoError(t, err)

		require.Greater(t, validity, -time.Now().UnixNano())
	})
}
