package e2e

// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

import (
	"context"
	"encoding/json"
	"gotests/tests"
	"os"
	"testing"

	"github.com/joho/godotenv"
	"github.com/kinbiko/jsonassert"
	"github.com/stretchr/testify/require"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/next/search"
	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

func createE2ESearchClient(t *testing.T) *search.APIClient {
	t.Helper()

	appID := os.Getenv("ALGOLIA_APPLICATION_ID")
	if appID == "" && os.Getenv("CI") != "true" {
		err := godotenv.Load("../../../../.env")
		require.NoError(t, err)

		appID = os.Getenv("ALGOLIA_APPLICATION_ID")
	}

	apiKey := os.Getenv("ALGOLIA_ADMIN_KEY")
	client, err := search.NewClient(appID, apiKey)
	require.NoError(t, err)

	return client
}

func TestSearchE2E_Browse(t *testing.T) {
	t.Parallel()
	t.Run("browse with minimal parameters", func(t *testing.T) {
		t.Parallel()

		client := createE2ESearchClient(t)
		res, err := client.Browse(context.Background(), "cts_e2e_browse", nil)
		require.NoError(t, err)

		_ = res

		rawBody, err := json.Marshal(res)
		require.NoError(t, err)

		var rawBodyMap any

		err = json.Unmarshal(rawBody, &rawBodyMap)
		require.NoError(t, err)

		expectedBodyRaw := `{"page":0,"nbHits":33191,"nbPages":34,"hitsPerPage":1000,"query":"","params":""}`

		var expectedBody any

		err = json.Unmarshal([]byte(expectedBodyRaw), &expectedBody)
		require.NoError(t, err)

		unionBody := tests.Union(t, expectedBody, rawBodyMap)
		unionBodyRaw, err := json.Marshal(unionBody)
		require.NoError(t, err)

		jsonassert.New(t).Assertf(string(unionBodyRaw), expectedBodyRaw)
	})
}

func TestSearchE2E_GetObject(t *testing.T) {
	t.Parallel()
	t.Run("search with a real object", func(t *testing.T) {
		t.Parallel()

		client := createE2ESearchClient(t)
		res, err := client.GetObject(context.Background(), "cts_e2e_browse", "Batman and Robin", nil)
		require.NoError(t, err)

		_ = res

		rawBody, err := json.Marshal(res)
		require.NoError(t, err)

		var rawBodyMap any

		err = json.Unmarshal(rawBody, &rawBodyMap)
		require.NoError(t, err)

		expectedBodyRaw := `{"objectID":"Batman and Robin","title":"Batman and Robin","year":1949,"cast":["Robert Lowery","Johnny Duncan","Jane Adams"]}`

		var expectedBody any

		err = json.Unmarshal([]byte(expectedBodyRaw), &expectedBody)
		require.NoError(t, err)

		unionBody := tests.Union(t, expectedBody, rawBodyMap)
		unionBodyRaw, err := json.Marshal(unionBody)
		require.NoError(t, err)

		jsonassert.New(t).Assertf(string(unionBodyRaw), expectedBodyRaw)
	})
}

func TestSearchE2E_GetRule(t *testing.T) {
	t.Parallel()
	t.Run("getRule", func(t *testing.T) {
		t.Parallel()

		client := createE2ESearchClient(t)
		res, err := client.GetRule(context.Background(), "cts_e2e_browse", "qr-1725004648916")
		require.NoError(t, err)

		_ = res

		rawBody, err := json.Marshal(res)
		require.NoError(t, err)

		var rawBodyMap any

		err = json.Unmarshal(rawBody, &rawBodyMap)
		require.NoError(t, err)

		expectedBodyRaw := `{"description":"test_rule","enabled":true,"objectID":"qr-1725004648916","conditions":[{"alternatives":true,"anchoring":"contains","pattern":"zorro"}],"consequence":{"params":{"ignorePlurals":"true"},"filterPromotes":true,"promote":[{"objectIDs":["Æon Flux"],"position":0}]}}`

		var expectedBody any

		err = json.Unmarshal([]byte(expectedBodyRaw), &expectedBody)
		require.NoError(t, err)

		unionBody := tests.Union(t, expectedBody, rawBodyMap)
		unionBodyRaw, err := json.Marshal(unionBody)
		require.NoError(t, err)

		jsonassert.New(t).Assertf(string(unionBodyRaw), expectedBodyRaw)
	})
}

func TestSearchE2E_GetSettings(t *testing.T) {
	t.Parallel()
	t.Run("getSettings", func(t *testing.T) {
		t.Parallel()

		client := createE2ESearchClient(t)
		res, err := client.GetSettings(context.Background(), "cts_e2e_settings", utils.ToPtr(2))
		require.NoError(t, err)

		_ = res

		rawBody, err := json.Marshal(res)
		require.NoError(t, err)

		var rawBodyMap any

		err = json.Unmarshal(rawBody, &rawBodyMap)
		require.NoError(t, err)

		expectedBodyRaw := `{"minWordSizefor1Typo":4,"minWordSizefor2Typos":8,"hitsPerPage":100,"maxValuesPerFacet":100,"paginationLimitedTo":10,"exactOnSingleWordQuery":"attribute","ranking":["typo","geo","words","filters","proximity","attribute","exact","custom"],"separatorsToIndex":"","removeWordsIfNoResults":"none","queryType":"prefixLast","highlightPreTag":"<em>","highlightPostTag":"</em>","alternativesAsExact":["ignorePlurals","singleWordSynonym"],"typoTolerance":"false"}`

		var expectedBody any

		err = json.Unmarshal([]byte(expectedBodyRaw), &expectedBody)
		require.NoError(t, err)

		unionBody := tests.Union(t, expectedBody, rawBodyMap)
		unionBodyRaw, err := json.Marshal(unionBody)
		require.NoError(t, err)

		jsonassert.New(t).Assertf(string(unionBodyRaw), expectedBodyRaw)
	})
}

func TestSearchE2E_Search(t *testing.T) {
	t.Parallel()
	t.Run("search for a single hits request with minimal parameters", func(t *testing.T) {
		t.Parallel()

		client := createE2ESearchClient(t)
		res, err := client.Search(context.Background(),
			[]search.SearchQuery{*search.SearchForHitsAsSearchQuery(
				search.NewEmptySearchForHits().SetIndexName("cts_e2e_search_empty_index"))}, nil)
		require.NoError(t, err)

		_ = res

		rawBody, err := json.Marshal(res)
		require.NoError(t, err)

		var rawBodyMap any

		err = json.Unmarshal(rawBody, &rawBodyMap)
		require.NoError(t, err)

		expectedBodyRaw := `{"results":[{"hits":[],"page":0,"nbHits":0,"nbPages":0,"hitsPerPage":20,"exhaustiveNbHits":true,"exhaustiveTypo":true,"exhaustive":{"nbHits":true,"typo":true},"query":"","params":"","index":"cts_e2e_search_empty_index","renderingContent":{}}]}`

		var expectedBody any

		err = json.Unmarshal([]byte(expectedBodyRaw), &expectedBody)
		require.NoError(t, err)

		unionBody := tests.Union(t, expectedBody, rawBodyMap)
		unionBodyRaw, err := json.Marshal(unionBody)
		require.NoError(t, err)

		jsonassert.New(t).Assertf(string(unionBodyRaw), expectedBodyRaw)
	})
	t.Run("search with highlight and snippet results", func(t *testing.T) {
		t.Parallel()

		client := createE2ESearchClient(t)
		res, err := client.Search(context.Background(),
			[]search.SearchQuery{*search.SearchForHitsAsSearchQuery(
				search.NewEmptySearchForHits().SetIndexName("cts_e2e_highlight_snippet_results").SetQuery("vim").SetAttributesToSnippet(
					[]string{"*:20"}).SetAttributesToHighlight(
					[]string{"*"}).SetAttributesToRetrieve(
					[]string{"*"}))}, nil)
		require.NoError(t, err)

		_ = res

		rawBody, err := json.Marshal(res)
		require.NoError(t, err)

		var rawBodyMap any

		err = json.Unmarshal(rawBody, &rawBodyMap)
		require.NoError(t, err)

		expectedBodyRaw := `{"results":[{"hits":[{"editor":{"name":"vim","type":"beforeneovim"},"names":["vim",":q"],"_snippetResult":{"editor":{"name":{"value":"<em>vim</em>","matchLevel":"full"},"type":{"value":"beforeneovim","matchLevel":"none"}},"names":[{"value":"<em>vim</em>","matchLevel":"full"},{"value":":q","matchLevel":"none"}]},"_highlightResult":{"editor":{"name":{"value":"<em>vim</em>","matchLevel":"full","fullyHighlighted":true,"matchedWords":["vim"]},"type":{"value":"beforeneovim","matchLevel":"none","matchedWords":[]}},"names":[{"value":"<em>vim</em>","matchLevel":"full","fullyHighlighted":true,"matchedWords":["vim"]},{"value":":q","matchLevel":"none","matchedWords":[]}]}}],"nbHits":1,"page":0,"nbPages":1,"hitsPerPage":20,"exhaustiveNbHits":true,"exhaustiveTypo":true,"exhaustive":{"nbHits":true,"typo":true},"query":"vim","index":"cts_e2e_highlight_snippet_results","renderingContent":{}}]}`

		var expectedBody any

		err = json.Unmarshal([]byte(expectedBodyRaw), &expectedBody)
		require.NoError(t, err)

		unionBody := tests.Union(t, expectedBody, rawBodyMap)
		unionBodyRaw, err := json.Marshal(unionBody)
		require.NoError(t, err)

		jsonassert.New(t).Assertf(string(unionBodyRaw), expectedBodyRaw)
	})
	t.Run("search for a single facet request with minimal parameters", func(t *testing.T) {
		t.Parallel()

		client := createE2ESearchClient(t)
		res, err := client.Search(context.Background(),
			[]search.SearchQuery{*search.SearchForFacetsAsSearchQuery(
				search.NewEmptySearchForFacets().SetIndexName("cts_e2e_search_facet").SetType(search.SEARCH_TYPE_FACET_FACET).SetFacet("editor"))}, utils.ToPtr(search.SEARCH_STRATEGY_STOP_IF_ENOUGH_MATCHES))
		require.NoError(t, err)

		_ = res

		rawBody, err := json.Marshal(res)
		require.NoError(t, err)

		var rawBodyMap any

		err = json.Unmarshal(rawBody, &rawBodyMap)
		require.NoError(t, err)

		expectedBodyRaw := `{"results":[{"exhaustiveFacetsCount":true,"facetHits":[{"count":1,"highlighted":"goland","value":"goland"},{"count":1,"highlighted":"neovim","value":"neovim"},{"count":1,"highlighted":"visual studio","value":"visual studio"},{"count":1,"highlighted":"vscode","value":"vscode"}]}]}`

		var expectedBody any

		err = json.Unmarshal([]byte(expectedBodyRaw), &expectedBody)
		require.NoError(t, err)

		unionBody := tests.Union(t, expectedBody, rawBodyMap)
		unionBodyRaw, err := json.Marshal(unionBody)
		require.NoError(t, err)

		jsonassert.New(t).Assertf(string(unionBodyRaw), expectedBodyRaw)
	})
	t.Run("search filters end to end", func(t *testing.T) {
		t.Parallel()

		client := createE2ESearchClient(t)
		res, err := client.Search(context.Background(),
			[]search.SearchQuery{*search.SearchForHitsAsSearchQuery(
				search.NewEmptySearchForHits().SetIndexName("cts_e2e_search_facet").SetFilters("editor:'visual studio' OR editor:neovim")), *search.SearchForHitsAsSearchQuery(
				search.NewEmptySearchForHits().SetIndexName("cts_e2e_search_facet").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(
					[]search.FacetFilters{*search.StringAsFacetFilters("editor:'visual studio'"), *search.StringAsFacetFilters("editor:neovim")}))), *search.SearchForHitsAsSearchQuery(
				search.NewEmptySearchForHits().SetIndexName("cts_e2e_search_facet").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(
					[]search.FacetFilters{*search.StringAsFacetFilters("editor:'visual studio'"), *search.ArrayOfFacetFiltersAsFacetFilters(
						[]search.FacetFilters{*search.StringAsFacetFilters("editor:neovim")})}))), *search.SearchForHitsAsSearchQuery(
				search.NewEmptySearchForHits().SetIndexName("cts_e2e_search_facet").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(
					[]search.FacetFilters{*search.StringAsFacetFilters("editor:'visual studio'"), *search.ArrayOfFacetFiltersAsFacetFilters(
						[]search.FacetFilters{*search.StringAsFacetFilters("editor:neovim"), *search.ArrayOfFacetFiltersAsFacetFilters(
							[]search.FacetFilters{*search.StringAsFacetFilters("editor:goland")})})})))}, nil)
		require.NoError(t, err)

		_ = res

		rawBody, err := json.Marshal(res)
		require.NoError(t, err)

		var rawBodyMap any

		err = json.Unmarshal(rawBody, &rawBodyMap)
		require.NoError(t, err)

		expectedBodyRaw := `{"results":[{"hitsPerPage":20,"index":"cts_e2e_search_facet","nbHits":2,"nbPages":1,"page":0,"hits":[{"editor":"visual studio","_highlightResult":{"editor":{"value":"visual studio","matchLevel":"none"}}},{"editor":"neovim","_highlightResult":{"editor":{"value":"neovim","matchLevel":"none"}}}],"query":"","params":"filters=editor%%3A%%27visual+studio%%27+OR+editor%%3Aneovim"},{"hitsPerPage":20,"index":"cts_e2e_search_facet","nbHits":0,"nbPages":0,"page":0,"hits":[],"query":"","params":"facetFilters=%%5B%%22editor%%3A%%27visual+studio%%27%%22%%2C%%22editor%%3Aneovim%%22%%5D"},{"hitsPerPage":20,"index":"cts_e2e_search_facet","nbHits":0,"nbPages":0,"page":0,"hits":[],"query":"","params":"facetFilters=%%5B%%22editor%%3A%%27visual+studio%%27%%22%%2C%%5B%%22editor%%3Aneovim%%22%%5D%%5D"},{"hitsPerPage":20,"index":"cts_e2e_search_facet","nbHits":0,"nbPages":0,"page":0,"hits":[],"query":"","params":"facetFilters=%%5B%%22editor%%3A%%27visual+studio%%27%%22%%2C%%5B%%22editor%%3Aneovim%%22%%2C%%5B%%22editor%%3Agoland%%22%%5D%%5D%%5D"}]}`

		var expectedBody any

		err = json.Unmarshal([]byte(expectedBodyRaw), &expectedBody)
		require.NoError(t, err)

		unionBody := tests.Union(t, expectedBody, rawBodyMap)
		unionBodyRaw, err := json.Marshal(unionBody)
		require.NoError(t, err)

		jsonassert.New(t).Assertf(string(unionBodyRaw), expectedBodyRaw)
	})
}

func TestSearchE2E_SearchDictionaryEntries(t *testing.T) {
	t.Parallel()
	t.Run("get searchDictionaryEntries results with minimal parameters", func(t *testing.T) {
		t.Parallel()

		client := createE2ESearchClient(t)
		res, err := client.SearchDictionaryEntries(context.Background(), search.DICTIONARY_TYPE_STOPWORDS, "about", nil)
		require.NoError(t, err)

		_ = res

		rawBody, err := json.Marshal(res)
		require.NoError(t, err)

		var rawBodyMap any

		err = json.Unmarshal(rawBody, &rawBodyMap)
		require.NoError(t, err)

		expectedBodyRaw := `{"hits":[{"objectID":"86ef58032f47d976ca7130a896086783","language":"en","word":"about"}],"page":0,"nbHits":1,"nbPages":1}`

		var expectedBody any

		err = json.Unmarshal([]byte(expectedBodyRaw), &expectedBody)
		require.NoError(t, err)

		unionBody := tests.Union(t, expectedBody, rawBodyMap)
		unionBodyRaw, err := json.Marshal(unionBody)
		require.NoError(t, err)

		jsonassert.New(t).Assertf(string(unionBodyRaw), expectedBodyRaw)
	})
}

func TestSearchE2E_SearchRules(t *testing.T) {
	t.Parallel()
	t.Run("searchRules", func(t *testing.T) {
		t.Parallel()

		client := createE2ESearchClient(t)
		res, err := client.SearchRules(context.Background(), "cts_e2e_browse", search.NewSearchRulesOptions().WithQuery("zorro"))
		require.NoError(t, err)

		_ = res

		rawBody, err := json.Marshal(res)
		require.NoError(t, err)

		var rawBodyMap any

		err = json.Unmarshal(rawBody, &rawBodyMap)
		require.NoError(t, err)

		expectedBodyRaw := `{"hits":[{"conditions":[{"alternatives":true,"anchoring":"contains","pattern":"zorro"}],"consequence":{"params":{"ignorePlurals":"true"},"filterPromotes":true,"promote":[{"objectIDs":["Æon Flux"],"position":0}]},"description":"test_rule","enabled":true,"objectID":"qr-1725004648916"}],"nbHits":1,"nbPages":1,"page":0}`

		var expectedBody any

		err = json.Unmarshal([]byte(expectedBodyRaw), &expectedBody)
		require.NoError(t, err)

		unionBody := tests.Union(t, expectedBody, rawBodyMap)
		unionBodyRaw, err := json.Marshal(unionBody)
		require.NoError(t, err)

		jsonassert.New(t).Assertf(string(unionBodyRaw), expectedBodyRaw)
	})
}

func TestSearchE2E_SearchSingleIndex(t *testing.T) {
	t.Parallel()
	t.Run("search with special characters in indexName", func(t *testing.T) {
		t.Parallel()

		client := createE2ESearchClient(t)
		res, err := client.SearchSingleIndex(context.Background(), "cts_e2e_space in index", nil)
		require.NoError(t, err)

		_ = res
	})
	t.Run("single search retrieve snippets", func(t *testing.T) {
		t.Parallel()

		client := createE2ESearchClient(t)
		res, err := client.SearchSingleIndex(context.Background(), "cts_e2e_browse", search.SearchParamsObjectAsSearchParams(
			search.NewEmptySearchParamsObject().SetQuery("batman mask of the phantasm").SetAttributesToRetrieve(
				[]string{"*"}).SetAttributesToSnippet(
				[]string{"*:20"})))
		require.NoError(t, err)

		_ = res

		rawBody, err := json.Marshal(res)
		require.NoError(t, err)

		var rawBodyMap any

		err = json.Unmarshal(rawBody, &rawBodyMap)
		require.NoError(t, err)

		expectedBodyRaw := `{"nbHits":1,"hits":[{"_snippetResult":{"genres":[{"value":"Animated","matchLevel":"none"},{"value":"Superhero","matchLevel":"none"},{"value":"Romance","matchLevel":"none"}],"year":{"value":"1993","matchLevel":"none"}},"_highlightResult":{"genres":[{"value":"Animated","matchLevel":"none","matchedWords":[]},{"value":"Superhero","matchLevel":"none","matchedWords":[]},{"value":"Romance","matchLevel":"none","matchedWords":[]}],"year":{"value":"1993","matchLevel":"none","matchedWords":[]}}}]}`

		var expectedBody any

		err = json.Unmarshal([]byte(expectedBodyRaw), &expectedBody)
		require.NoError(t, err)

		unionBody := tests.Union(t, expectedBody, rawBodyMap)
		unionBodyRaw, err := json.Marshal(unionBody)
		require.NoError(t, err)

		jsonassert.New(t).Assertf(string(unionBodyRaw), expectedBodyRaw)
	})
}

func TestSearchE2E_SetSettings(t *testing.T) {
	t.Parallel()
	t.Run("minimal parameters", func(t *testing.T) {
		t.Parallel()

		client := createE2ESearchClient(t)
		res, err := client.SetSettings(
			context.Background(),
			"cts_e2e_settings",
			search.NewEmptyIndexSettings().
				SetPaginationLimitedTo(10).
				SetTypoTolerance(search.TypoToleranceEnumAsTypoTolerance(search.TYPO_TOLERANCE_ENUM_FALSE)),
			utils.ToPtr(true),
		)
		require.NoError(t, err)

		_ = res
	})
}
