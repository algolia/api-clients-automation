# Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
require "algolia"
require "test/unit"

class TestSearchClient < Test::Unit::TestCase
  def setup
    @client = Algolia::SearchClient.create(
      "APP_ID",
      "API_KEY",

      {requester: Algolia::Transport::EchoRequester.new}
    )
  end

  # minimal
  def test_add_api_key
    req = @client.add_api_key_with_http_info(
      Algolia::Search::ApiKey.new(acl: ["search", "addObject"], description: "my new api key")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/keys", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"acl\":[\"search\",\"addObject\"],\"description\":\"my new api key\"}"),
      JSON.parse(req.body)
    )
  end

  # all
  def test_add_api_key1
    req = @client.add_api_key_with_http_info(
      Algolia::Search::ApiKey.new(
        acl: ["search", "addObject"],
        description: "my new api key",
        validity: 300,
        max_queries_per_ip_per_hour: 100,
        max_hits_per_query: 20
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/keys", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"acl\":[\"search\",\"addObject\"],\"description\":\"my new api key\",\"validity\":300,\"maxQueriesPerIPPerHour\":100,\"maxHitsPerQuery\":20}"
      ),
      JSON.parse(req.body)
    )
  end

  # addOrUpdateObject
  def test_add_or_update_object
    req = @client.add_or_update_object_with_http_info("indexName", "uniqueID", {key: "value"})

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/uniqueID", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"key\":\"value\"}"), JSON.parse(req.body))
  end

  # appendSource
  def test_append_source
    req = @client.append_source_with_http_info(
      Algolia::Search::Source.new(source: "theSource", description: "theDescription")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/security/sources/append", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"source\":\"theSource\",\"description\":\"theDescription\"}"), JSON.parse(req.body))
  end

  # simple
  def test_assign_user_id
    req = @client.assign_user_id_with_http_info("user42", Algolia::Search::AssignUserIdParams.new(cluster: "d4242-eu"))

    assert_equal(:post, req.method)
    assert_equal("/1/clusters/mapping", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(
      ({:"x-algolia-user-id" => "user42"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )
    assert_equal(JSON.parse("{\"cluster\":\"d4242-eu\"}"), JSON.parse(req.body))
  end

  # it should not encode the userID
  def test_assign_user_id1
    req = @client.assign_user_id_with_http_info(
      "user id with spaces",
      Algolia::Search::AssignUserIdParams.new(cluster: "cluster with spaces")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/clusters/mapping", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(
      ({:"x-algolia-user-id" => "user id with spaces"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )
    assert_equal(JSON.parse("{\"cluster\":\"cluster with spaces\"}"), JSON.parse(req.body))
  end

  # addObject
  def test_batch
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::BatchWriteParams.new(
        requests: [
          Algolia::Search::BatchRequest.new(action: "addObject", body: {key: "bar", foo: "1"}),
          Algolia::Search::BatchRequest.new(action: "addObject", body: {key: "baz", foo: "2"})
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"action\":\"addObject\",\"body\":{\"key\":\"bar\",\"foo\":\"1\"}},{\"action\":\"addObject\",\"body\":{\"key\":\"baz\",\"foo\":\"2\"}}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # clear
  def test_batch1
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::BatchWriteParams.new(
        requests: [Algolia::Search::BatchRequest.new(action: "clear", body: {key: "value"})]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"clear\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # delete
  def test_batch2
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::BatchWriteParams.new(
        requests: [Algolia::Search::BatchRequest.new(action: "delete", body: {key: "value"})]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"delete\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # deleteObject
  def test_batch3
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::BatchWriteParams.new(
        requests: [Algolia::Search::BatchRequest.new(action: "deleteObject", body: {key: "value"})]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"deleteObject\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # partialUpdateObject
  def test_batch4
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::BatchWriteParams.new(
        requests: [Algolia::Search::BatchRequest.new(action: "partialUpdateObject", body: {key: "value"})]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"partialUpdateObject\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # partialUpdateObjectNoCreate
  def test_batch5
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::BatchWriteParams.new(
        requests: [Algolia::Search::BatchRequest.new(action: "partialUpdateObjectNoCreate", body: {key: "value"})]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"partialUpdateObjectNoCreate\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # updateObject
  def test_batch6
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::BatchWriteParams.new(
        requests: [Algolia::Search::BatchRequest.new(action: "updateObject", body: {key: "value"})]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"updateObject\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # batchAssignUserIds
  def test_batch_assign_user_ids
    req = @client.batch_assign_user_ids_with_http_info(
      "userID",
      Algolia::Search::BatchAssignUserIdsParams.new(cluster: "theCluster", users: ["user1", "user2"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/clusters/mapping/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(
      ({:"x-algolia-user-id" => "userID"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )
    assert_equal(JSON.parse("{\"cluster\":\"theCluster\",\"users\":[\"user1\",\"user2\"]}"), JSON.parse(req.body))
  end

  # replace
  def test_batch_dictionary_entries
    req = @client.batch_dictionary_entries_with_http_info(
      "plurals",
      Algolia::Search::BatchDictionaryEntriesParams.new(
        clear_existing_dictionary_entries: true,
        requests: [
          Algolia::Search::BatchDictionaryEntriesRequest.new(
            action: "addEntry",
            body: Algolia::Search::DictionaryEntry.new(
              algolia_object_id: "1",
              language: "en",
              word: "fancy",
              words: ["believe", "algolia"],
              decomposition: ["trust", "algolia"],
              state: "enabled"
            )
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/dictionaries/plurals/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"clearExistingDictionaryEntries\":true,\"requests\":[{\"action\":\"addEntry\",\"body\":{\"objectID\":\"1\",\"language\":\"en\",\"word\":\"fancy\",\"words\":[\"believe\",\"algolia\"],\"decomposition\":[\"trust\",\"algolia\"],\"state\":\"enabled\"}}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # delete
  def test_batch_dictionary_entries1
    req = @client.batch_dictionary_entries_with_http_info(
      "plurals",
      Algolia::Search::BatchDictionaryEntriesParams.new(
        clear_existing_dictionary_entries: true,
        requests: [
          Algolia::Search::BatchDictionaryEntriesRequest.new(
            action: "deleteEntry",
            body: Algolia::Search::DictionaryEntry.new(algolia_object_id: "1")
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/dictionaries/plurals/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"clearExistingDictionaryEntries\":true,\"requests\":[{\"action\":\"deleteEntry\",\"body\":{\"objectID\":\"1\"}}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # append
  def test_batch_dictionary_entries2
    req = @client.batch_dictionary_entries_with_http_info(
      "stopwords",
      Algolia::Search::BatchDictionaryEntriesParams.new(
        requests: [
          Algolia::Search::BatchDictionaryEntriesRequest.new(
            action: "addEntry",
            body: Algolia::Search::DictionaryEntry.new(algolia_object_id: "1", language: "en", additional: "try me")
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/dictionaries/stopwords/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"action\":\"addEntry\",\"body\":{\"objectID\":\"1\",\"language\":\"en\",\"additional\":\"try me\"}}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # browse with minimal parameters
  def test_browse
    req = @client.browse_with_http_info("cts_e2e_browse")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/cts_e2e_browse/browse", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # browse with search parameters
  def test_browse1
    req = @client.browse_with_http_info(
      "indexName",
      Algolia::Search::BrowseParamsObject.new(query: "myQuery", facet_filters: ["tags:algolia"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/browse", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"myQuery\",\"facetFilters\":[\"tags:algolia\"]}"), JSON.parse(req.body))
  end

  # browse allow a cursor in parameters
  def test_browse2
    req = @client.browse_with_http_info("indexName", Algolia::Search::BrowseParamsObject.new(cursor: "test"))

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/browse", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"cursor\":\"test\"}"), JSON.parse(req.body))
  end

  # browse with query string
  def test_browse3
    req = @client.browse_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsString.new(params: "foo=bar&cursor=test")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/browse", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"params\":\"foo=bar&cursor=test\"}"), JSON.parse(req.body))
  end

  # clearObjects
  def test_clear_objects
    req = @client.clear_objects_with_http_info("theIndexName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/clear", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
  end

  # clearRules
  def test_clear_rules
    req = @client.clear_rules_with_http_info("indexName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/rules/clear", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
  end

  # clearSynonyms
  def test_clear_synonyms
    req = @client.clear_synonyms_with_http_info("indexName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/synonyms/clear", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
  end

  # allow del method for a custom path with minimal parameters
  def test_custom_delete
    req = @client.custom_delete_with_http_info("test/minimal")

    assert_equal(:delete, req.method)
    assert_equal("/test/minimal", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # allow del method for a custom path with all parameters
  def test_custom_delete1
    req = @client.custom_delete_with_http_info("test/all", {query: "parameters"})

    assert_equal(:delete, req.method)
    assert_equal("/test/all", req.path)
    assert_equal({:"query" => "parameters"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # allow get method for a custom path with minimal parameters
  def test_custom_get
    req = @client.custom_get_with_http_info("test/minimal")

    assert_equal(:get, req.method)
    assert_equal("/test/minimal", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # allow get method for a custom path with all parameters
  def test_custom_get1
    req = @client.custom_get_with_http_info("test/all", {query: "parameters with space"})

    assert_equal(:get, req.method)
    assert_equal("/test/all", req.path)
    assert_equal({:"query" => "parameters%20with%20space"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # requestOptions should be escaped too
  def test_custom_get2
    req = @client.custom_get_with_http_info(
      "test/all",
      {query: "to be overridden"},
      {
        :header_params => {"x-header-1" => "spaces are left alone"},
        :query_params => JSON.parse(
          "{\"query\":\"parameters with space\",\"and an array\":[\"array\",\"with spaces\"]}",
          :symbolize_names => true
        )
      }
    )

    assert_equal(:get, req.method)
    assert_equal("/test/all", req.path)
    assert_equal(
      {:"query" => "parameters%20with%20space", :"and%20an%20array" => "array%2Cwith%20spaces"}.to_a,
      req.query_params.to_a
    )
    assert(
      ({:"x-header-1" => "spaces are left alone"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )

    assert(req.body.nil?, "body is not nil")
  end

  # allow post method for a custom path with minimal parameters
  def test_custom_post
    req = @client.custom_post_with_http_info("test/minimal")

    assert_equal(:post, req.method)
    assert_equal("/test/minimal", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # allow post method for a custom path with all parameters
  def test_custom_post1
    req = @client.custom_post_with_http_info("test/all", {query: "parameters"}, {body: "parameters"})

    assert_equal(:post, req.method)
    assert_equal("/test/all", req.path)
    assert_equal({:"query" => "parameters"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"body\":\"parameters\"}"), JSON.parse(req.body))
  end

  # requestOptions can override default query parameters
  def test_custom_post2
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"query\":\"myQueryParameter\"}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "myQueryParameter"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions merges query parameters with default ones
  def test_custom_post3
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"query2\":\"myQueryParameter\"}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"query2" => "myQueryParameter"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions can override default headers
  def test_custom_post4
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:header_params => {"x-algolia-api-key" => "ALGOLIA_API_KEY"}}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters"}.to_a, req.query_params.to_a)
    assert(
      ({:"x-algolia-api-key" => "ALGOLIA_API_KEY"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions merges headers with default ones
  def test_custom_post5
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:header_params => {"x-algolia-api-key" => "ALGOLIA_API_KEY"}}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters"}.to_a, req.query_params.to_a)
    assert(
      ({:"x-algolia-api-key" => "ALGOLIA_API_KEY"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions queryParameters accepts booleans
  def test_custom_post6
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"isItWorking\":true}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"isItWorking" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions queryParameters accepts integers
  def test_custom_post7
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"myParam\":2}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"myParam" => "2"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions queryParameters accepts list of string
  def test_custom_post8
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"myParam\":[\"b and c\",\"d\"]}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"myParam" => "b%20and%20c%2Cd"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions queryParameters accepts list of booleans
  def test_custom_post9
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"myParam\":[true,true,false]}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"myParam" => "true%2Ctrue%2Cfalse"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions queryParameters accepts list of integers
  def test_custom_post10
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"myParam\":[1,2]}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"myParam" => "1%2C2"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # allow put method for a custom path with minimal parameters
  def test_custom_put
    req = @client.custom_put_with_http_info("test/minimal")

    assert_equal(:put, req.method)
    assert_equal("/test/minimal", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # allow put method for a custom path with all parameters
  def test_custom_put1
    req = @client.custom_put_with_http_info("test/all", {query: "parameters"}, {body: "parameters"})

    assert_equal(:put, req.method)
    assert_equal("/test/all", req.path)
    assert_equal({:"query" => "parameters"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"body\":\"parameters\"}"), JSON.parse(req.body))
  end

  # deleteApiKey
  def test_delete_api_key
    req = @client.delete_api_key_with_http_info("myTestApiKey")

    assert_equal(:delete, req.method)
    assert_equal("/1/keys/myTestApiKey", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # deleteBy
  def test_delete_by
    req = @client.delete_by_with_http_info(
      "theIndexName",
      Algolia::Search::DeleteByParams.new(filters: "brand:brandName")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/deleteByQuery", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"filters\":\"brand:brandName\"}"), JSON.parse(req.body))
  end

  # deleteIndex
  def test_delete_index
    req = @client.delete_index_with_http_info("theIndexName")

    assert_equal(:delete, req.method)
    assert_equal("/1/indexes/theIndexName", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # deleteObject
  def test_delete_object
    req = @client.delete_object_with_http_info("<YOUR_INDEX_NAME>", "uniqueID")

    assert_equal(:delete, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/uniqueID", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # delete rule simple case
  def test_delete_rule
    req = @client.delete_rule_with_http_info("indexName", "id1")

    assert_equal(:delete, req.method)
    assert_equal("/1/indexes/indexName/rules/id1", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # delete rule with simple characters to encode in objectID
  def test_delete_rule1
    req = @client.delete_rule_with_http_info("indexName", "test/with/slash")

    assert_equal(:delete, req.method)
    assert_equal("/1/indexes/indexName/rules/test%2Fwith%2Fslash", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # deleteSource
  def test_delete_source
    req = @client.delete_source_with_http_info("theSource")

    assert_equal(:delete, req.method)
    assert_equal("/1/security/sources/theSource", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # deleteSynonym
  def test_delete_synonym
    req = @client.delete_synonym_with_http_info("indexName", "id1")

    assert_equal(:delete, req.method)
    assert_equal("/1/indexes/indexName/synonyms/id1", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getApiKey
  def test_get_api_key
    req = @client.get_api_key_with_http_info("myTestApiKey")

    assert_equal(:get, req.method)
    assert_equal("/1/keys/myTestApiKey", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getAppTask
  def test_get_app_task
    req = @client.get_app_task_with_http_info(123)

    assert_equal(:get, req.method)
    assert_equal("/1/task/123", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # get getDictionaryLanguages
  def test_get_dictionary_languages
    req = @client.get_dictionary_languages_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/dictionaries/*/languages", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # get getDictionarySettings results
  def test_get_dictionary_settings
    req = @client.get_dictionary_settings_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/dictionaries/*/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getLogs with minimal parameters
  def test_get_logs
    req = @client.get_logs_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/logs", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getLogs with parameters
  def test_get_logs1
    req = @client.get_logs_with_http_info(5, 10, "theIndexName", "all")

    assert_equal(:get, req.method)
    assert_equal("/1/logs", req.path)
    assert_equal(
      {:"offset" => "5", :"length" => "10", :"indexName" => "theIndexName", :"type" => "all"}.to_a,
      req.query_params.to_a
    )
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getObject
  def test_get_object
    req = @client.get_object_with_http_info("theIndexName", "uniqueID", ["attr1", "attr2"])

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/theIndexName/uniqueID", req.path)
    assert_equal({:"attributesToRetrieve" => "attr1%2Cattr2"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # search with a real object
  def test_get_object1
    req = @client.get_object_with_http_info("cts_e2e_browse", "Batman and Robin")

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/cts_e2e_browse/Batman%20and%20Robin", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # by ID
  def test_get_objects
    req = @client.get_objects_with_http_info(
      Algolia::Search::GetObjectsParams.new(
        requests: [Algolia::Search::GetObjectsRequest.new(algolia_object_id: "uniqueID", index_name: "theIndexName")]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/objects", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"objectID\":\"uniqueID\",\"indexName\":\"theIndexName\"}]}"),
      JSON.parse(req.body)
    )
  end

  # multiple IDs
  def test_get_objects1
    req = @client.get_objects_with_http_info(
      Algolia::Search::GetObjectsParams.new(
        requests: [
          Algolia::Search::GetObjectsRequest.new(algolia_object_id: "uniqueID1", index_name: "theIndexName1"),
          Algolia::Search::GetObjectsRequest.new(algolia_object_id: "uniqueID2", index_name: "theIndexName2")
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/objects", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"objectID\":\"uniqueID1\",\"indexName\":\"theIndexName1\"},{\"objectID\":\"uniqueID2\",\"indexName\":\"theIndexName2\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # with attributesToRetrieve
  def test_get_objects2
    req = @client.get_objects_with_http_info(
      Algolia::Search::GetObjectsParams.new(
        requests: [
          Algolia::Search::GetObjectsRequest.new(
            attributes_to_retrieve: ["attr1", "attr2"],
            algolia_object_id: "uniqueID",
            index_name: "theIndexName"
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/objects", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"attributesToRetrieve\":[\"attr1\",\"attr2\"],\"objectID\":\"uniqueID\",\"indexName\":\"theIndexName\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # getRule
  def test_get_rule
    req = @client.get_rule_with_http_info("cts_e2e_browse", "qr-1725004648916")

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/cts_e2e_browse/rules/qr-1725004648916", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getSettings
  def test_get_settings
    req = @client.get_settings_with_http_info("cts_e2e_settings", 2)

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/cts_e2e_settings/settings", req.path)
    assert_equal({:"getVersion" => "2"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getSources
  def test_get_sources
    req = @client.get_sources_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/security/sources", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getSynonym
  def test_get_synonym
    req = @client.get_synonym_with_http_info("indexName", "id1")

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/indexName/synonyms/id1", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getTask
  def test_get_task
    req = @client.get_task_with_http_info("theIndexName", 123)

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/theIndexName/task/123", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getTopUserIds
  def test_get_top_user_ids
    req = @client.get_top_user_ids_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping/top", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getUserId
  def test_get_user_id
    req = @client.get_user_id_with_http_info("uniqueID")

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping/uniqueID", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # hasPendingMappings with minimal parameters
  def test_has_pending_mappings
    req = @client.has_pending_mappings_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping/pending", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # hasPendingMappings with parameters
  def test_has_pending_mappings1
    req = @client.has_pending_mappings_with_http_info(true)

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping/pending", req.path)
    assert_equal({:"getClusters" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listApiKeys
  def test_list_api_keys
    req = @client.list_api_keys_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/keys", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listClusters
  def test_list_clusters
    req = @client.list_clusters_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/clusters", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listIndices with minimal parameters
  def test_list_indices
    req = @client.list_indices_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/indexes", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listIndices with parameters
  def test_list_indices1
    req = @client.list_indices_with_http_info(8, 3)

    assert_equal(:get, req.method)
    assert_equal("/1/indexes", req.path)
    assert_equal({:"page" => "8", :"hitsPerPage" => "3"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listUserIds with minimal parameters
  def test_list_user_ids
    req = @client.list_user_ids_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listUserIds with parameters
  def test_list_user_ids1
    req = @client.list_user_ids_with_http_info(8, 100)

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping", req.path)
    assert_equal({:"page" => "8", :"hitsPerPage" => "100"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # multipleBatch
  def test_multiple_batch
    req = @client.multiple_batch_with_http_info(
      Algolia::Search::BatchParams.new(
        requests: [
          Algolia::Search::MultipleBatchRequest.new(
            action: "addObject",
            body: {key: "value"},
            index_name: "theIndexName"
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"action\":\"addObject\",\"body\":{\"key\":\"value\"},\"indexName\":\"theIndexName\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # scopes
  def test_operation_index
    req = @client.operation_index_with_http_info(
      "<SOURCE_INDEX_NAME>",
      Algolia::Search::OperationIndexParams.new(
        operation: "move",
        destination: "<DESTINATION_INDEX_NAME>",
        scope: ["rules", "settings"]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"operation\":\"move\",\"destination\":\"<DESTINATION_INDEX_NAME>\",\"scope\":[\"rules\",\"settings\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # copy
  def test_operation_index1
    req = @client.operation_index_with_http_info(
      "<SOURCE_INDEX_NAME>",
      Algolia::Search::OperationIndexParams.new(operation: "copy", destination: "<DESTINATION_INDEX_NAME>")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"operation\":\"copy\",\"destination\":\"<DESTINATION_INDEX_NAME>\"}"),
      JSON.parse(req.body)
    )
  end

  # move
  def test_operation_index2
    req = @client.operation_index_with_http_info(
      "<SOURCE_INDEX_NAME>",
      Algolia::Search::OperationIndexParams.new(operation: "move", destination: "<DESTINATION_INDEX_NAME>")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"operation\":\"move\",\"destination\":\"<DESTINATION_INDEX_NAME>\"}"),
      JSON.parse(req.body)
    )
  end

  # Partial update with a new value for a string attribute
  def test_partial_update_object
    req = @client.partial_update_object_with_http_info("theIndexName", "uniqueID", {attributeId: "new value"})

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/uniqueID/partial", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeId\":\"new value\"}"), JSON.parse(req.body))
  end

  # Partial update with a new value for an integer attribute
  def test_partial_update_object1
    req = @client.partial_update_object_with_http_info("theIndexName", "uniqueID", {attributeId: 1})

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/uniqueID/partial", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeId\":1}"), JSON.parse(req.body))
  end

  # Partial update with a new value for a boolean attribute
  def test_partial_update_object2
    req = @client.partial_update_object_with_http_info("theIndexName", "uniqueID", {attributeId: true})

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/uniqueID/partial", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeId\":true}"), JSON.parse(req.body))
  end

  # Partial update with a new value for an array attribute
  def test_partial_update_object3
    req = @client.partial_update_object_with_http_info(
      "theIndexName",
      "uniqueID",
      {attributeId: ["one", "two", "three"]}
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/uniqueID/partial", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeId\":[\"one\",\"two\",\"three\"]}"), JSON.parse(req.body))
  end

  # Partial update with a new value for an object attribute
  def test_partial_update_object4
    req = @client.partial_update_object_with_http_info("theIndexName", "uniqueID", {attributeId: {nested: "value"}})

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/uniqueID/partial", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeId\":{\"nested\":\"value\"}}"), JSON.parse(req.body))
  end

  # with visible_by filter
  def test_partial_update_object5
    req = @client.partial_update_object_with_http_info(
      "theIndexName",
      "uniqueID",
      {visible_by: ["Angela", "group/Finance", "group/Shareholders"]}
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/uniqueID/partial", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"visible_by\":[\"Angela\",\"group/Finance\",\"group/Shareholders\"]}"),
      JSON.parse(req.body)
    )
  end

  # add men pant
  def test_partial_update_object6
    req = @client.partial_update_object_with_http_info(
      "theIndexName",
      "productId",
      {categoryPageId: {_operation: "Add", value: "men-clothing-pants"}}
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/productId/partial", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"categoryPageId\":{\"_operation\":\"Add\",\"value\":\"men-clothing-pants\"}}"),
      JSON.parse(req.body)
    )
  end

  # remove men pant
  def test_partial_update_object7
    req = @client.partial_update_object_with_http_info(
      "theIndexName",
      "productId",
      {categoryPageId: {_operation: "Remove", value: "men-clothing-pants"}}
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/productId/partial", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"categoryPageId\":{\"_operation\":\"Remove\",\"value\":\"men-clothing-pants\"}}"),
      JSON.parse(req.body)
    )
  end

  # removeUserId
  def test_remove_user_id
    req = @client.remove_user_id_with_http_info("uniqueID")

    assert_equal(:delete, req.method)
    assert_equal("/1/clusters/mapping/uniqueID", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # replaceSources
  def test_replace_sources
    req = @client.replace_sources_with_http_info(
      [Algolia::Search::Source.new(source: "theSource", description: "theDescription")]
    )

    assert_equal(:put, req.method)
    assert_equal("/1/security/sources", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("[{\"source\":\"theSource\",\"description\":\"theDescription\"}]"), JSON.parse(req.body))
  end

  # restoreApiKey
  def test_restore_api_key
    req = @client.restore_api_key_with_http_info("ALGOLIA_API_KEY")

    assert_equal(:post, req.method)
    assert_equal("/1/keys/ALGOLIA_API_KEY/restore", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
  end

  # saveObject
  def test_save_object
    req = @client.save_object_with_http_info(
      "<YOUR_INDEX_NAME>",
      {
        name: "Black T-shirt",
        color: "#000000||black",
        availableIn: "https://source.unsplash.com/100x100/?paris||Paris",
        objectID: "myID"
      }
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"name\":\"Black T-shirt\",\"color\":\"#000000||black\",\"availableIn\":\"https://source.unsplash.com/100x100/?paris||Paris\",\"objectID\":\"myID\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # saveRule with minimal parameters
  def test_save_rule
    req = @client.save_rule_with_http_info(
      "indexName",
      "id1",
      Algolia::Search::Rule.new(
        algolia_object_id: "id1",
        conditions: [Algolia::Search::Condition.new(pattern: "apple", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(filters: "brand:xiaomi")
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/id1", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"id1\",\"conditions\":[{\"pattern\":\"apple\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"filters\":\"brand:xiaomi\"}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # saveRule with all parameters
  def test_save_rule1
    req = @client.save_rule_with_http_info(
      "indexName",
      "id1",
      Algolia::Search::Rule.new(
        algolia_object_id: "id1",
        conditions: [
          Algolia::Search::Condition.new(
            pattern: "apple",
            anchoring: "contains",
            alternatives: false,
            context: "search"
          )
        ],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            filters: "brand:apple",
            query: Algolia::Search::ConsequenceQueryObject.new(
              remove: ["algolia"],
              edits: [
                Algolia::Search::Edit.new(type: "remove", delete: "abc", insert: "cde"),
                Algolia::Search::Edit.new(type: "replace", delete: "abc", insert: "cde")
              ]
            )
          ),
          hide: [Algolia::Search::ConsequenceHide.new(algolia_object_id: "321")],
          filter_promotes: false,
          user_data: {algolia: "aloglia"},
          promote: [
            Algolia::Search::PromoteObjectID.new(algolia_object_id: "abc", position: 3),
            Algolia::Search::PromoteObjectIDs.new(object_ids: ["abc", "def"], position: 1)
          ]
        ),
        description: "test",
        enabled: true,
        validity: [Algolia::Search::TimeRange.new(from: 1656670273, _until: 1656670277)]
      ),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/id1", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"id1\",\"conditions\":[{\"pattern\":\"apple\",\"anchoring\":\"contains\",\"alternatives\":false,\"context\":\"search\"}],\"consequence\":{\"params\":{\"filters\":\"brand:apple\",\"query\":{\"remove\":[\"algolia\"],\"edits\":[{\"type\":\"remove\",\"delete\":\"abc\",\"insert\":\"cde\"},{\"type\":\"replace\",\"delete\":\"abc\",\"insert\":\"cde\"}]}},\"hide\":[{\"objectID\":\"321\"}],\"filterPromotes\":false,\"userData\":{\"algolia\":\"aloglia\"},\"promote\":[{\"objectID\":\"abc\",\"position\":3},{\"objectIDs\":[\"abc\",\"def\"],\"position\":1}]},\"description\":\"test\",\"enabled\":true,\"validity\":[{\"from\":1656670273,\"until\":1656670277}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # b2b catalog
  def test_save_rule2
    req = @client.save_rule_with_http_info(
      "indexName",
      "article-rule",
      Algolia::Search::Rule.new(
        algolia_object_id: "article-rule",
        conditions: [Algolia::Search::Condition.new(pattern: "article", anchoring: "startsWith")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            query: Algolia::Search::ConsequenceQueryObject.new(
              edits: [Algolia::Search::Edit.new(type: "remove", delete: "article")]
            ),
            restrict_searchable_attributes: ["title", "book_id"]
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/article-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"article-rule\",\"conditions\":[{\"pattern\":\"article\",\"anchoring\":\"startsWith\"}],\"consequence\":{\"params\":{\"query\":{\"edits\":[{\"type\":\"remove\",\"delete\":\"article\"}]},\"restrictSearchableAttributes\":[\"title\",\"book_id\"]}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # merchandising and promoting
  def test_save_rule3
    req = @client.save_rule_with_http_info(
      "indexName",
      "director-rule",
      Algolia::Search::Rule.new(
        algolia_object_id: "director-rule",
        conditions: [Algolia::Search::Condition.new(pattern: "{facet:director} director", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            restrict_searchable_attributes: ["title", "book_id"],
            automatic_facet_filters: [Algolia::Search::AutomaticFacetFilter.new(facet: "director")],
            query: Algolia::Search::ConsequenceQueryObject.new(
              edits: [Algolia::Search::Edit.new(type: "remove", delete: "director")]
            )
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/director-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"director-rule\",\"conditions\":[{\"pattern\":\"{facet:director} director\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"restrictSearchableAttributes\":[\"title\",\"book_id\"],\"automaticFacetFilters\":[{\"facet\":\"director\"}],\"query\":{\"edits\":[{\"type\":\"remove\",\"delete\":\"director\"}]}}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # harry potter
  def test_save_rule4
    req = @client.save_rule_with_http_info(
      "indexName",
      "harry-potter-rule",
      Algolia::Search::Rule.new(
        algolia_object_id: "harry-potter-rule",
        conditions: [Algolia::Search::Condition.new(pattern: "harry potter", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(user_data: {promo_content: "20% OFF on all Harry Potter books!"})
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/harry-potter-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"harry-potter-rule\",\"conditions\":[{\"pattern\":\"harry potter\",\"anchoring\":\"contains\"}],\"consequence\":{\"userData\":{\"promo_content\":\"20% OFF on all Harry Potter books!\"}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # merchandising empty query
  def test_save_rule5
    req = @client.save_rule_with_http_info(
      "indexName",
      "clearance-category-filter",
      Algolia::Search::Rule.new(
        algolia_object_id: "clearance-category-filter",
        conditions: [Algolia::Search::Condition.new(pattern: "", anchoring: "is", context: "landing")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(optional_filters: "clearance:true")
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/clearance-category-filter", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"clearance-category-filter\",\"conditions\":[{\"pattern\":\"\",\"anchoring\":\"is\",\"context\":\"landing\"}],\"consequence\":{\"params\":{\"optionalFilters\":\"clearance:true\"}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # redirect
  def test_save_rule6
    req = @client.save_rule_with_http_info(
      "indexName",
      "redirect-help-rule",
      Algolia::Search::Rule.new(
        algolia_object_id: "redirect-help-rule",
        conditions: [Algolia::Search::Condition.new(pattern: "help", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(user_data: {redirect: "https://www.algolia.com/support"})
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/redirect-help-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"redirect-help-rule\",\"conditions\":[{\"pattern\":\"help\",\"anchoring\":\"contains\"}],\"consequence\":{\"userData\":{\"redirect\":\"https://www.algolia.com/support\"}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # promote some results over others
  def test_save_rule7
    req = @client.save_rule_with_http_info(
      "indexName",
      "tomato-fruit",
      Algolia::Search::Rule.new(
        algolia_object_id: "tomato-fruit",
        conditions: [Algolia::Search::Condition.new(pattern: "tomato", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(optional_filters: "food_group:fruit")
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/tomato-fruit", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"tomato-fruit\",\"conditions\":[{\"pattern\":\"tomato\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"optionalFilters\":\"food_group:fruit\"}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # promote several hits
  def test_save_rule8
    req = @client.save_rule_with_http_info(
      "indexName",
      "Promote-Apple-Newest",
      Algolia::Search::Rule.new(
        algolia_object_id: "Promote-Apple-Newest",
        conditions: [Algolia::Search::Condition.new(pattern: "apple", anchoring: "is")],
        consequence: Algolia::Search::Consequence.new(
          promote: [Algolia::Search::PromoteObjectIDs.new(object_ids: ["iPhone-12345", "watch-123"], position: 0)]
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/Promote-Apple-Newest", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"Promote-Apple-Newest\",\"conditions\":[{\"pattern\":\"apple\",\"anchoring\":\"is\"}],\"consequence\":{\"promote\":[{\"objectIDs\":[\"iPhone-12345\",\"watch-123\"],\"position\":0}]}}"
      ),
      JSON.parse(req.body)
    )
  end

  # promote newest release
  def test_save_rule9
    req = @client.save_rule_with_http_info(
      "indexName",
      "Promote-iPhone-X",
      Algolia::Search::Rule.new(
        algolia_object_id: "Promote-iPhone-X",
        conditions: [Algolia::Search::Condition.new(pattern: "iPhone", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          promote: [Algolia::Search::PromoteObjectID.new(algolia_object_id: "iPhone-12345", position: 0)]
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/Promote-iPhone-X", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"Promote-iPhone-X\",\"conditions\":[{\"pattern\":\"iPhone\",\"anchoring\":\"contains\"}],\"consequence\":{\"promote\":[{\"objectID\":\"iPhone-12345\",\"position\":0}]}}"
      ),
      JSON.parse(req.body)
    )
  end

  # promote single item
  def test_save_rule10
    req = @client.save_rule_with_http_info(
      "indexName",
      "promote-harry-potter-box-set",
      Algolia::Search::Rule.new(
        algolia_object_id: "promote-harry-potter-box-set",
        conditions: [Algolia::Search::Condition.new(pattern: "Harry Potter", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          promote: [Algolia::Search::PromoteObjectID.new(algolia_object_id: "HP-12345", position: 0)]
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/promote-harry-potter-box-set", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"promote-harry-potter-box-set\",\"conditions\":[{\"pattern\":\"Harry Potter\",\"anchoring\":\"contains\"}],\"consequence\":{\"promote\":[{\"objectID\":\"HP-12345\",\"position\":0}]}}"
      ),
      JSON.parse(req.body)
    )
  end

  # limit search results
  def test_save_rule11
    req = @client.save_rule_with_http_info(
      "indexName",
      "article-rule",
      Algolia::Search::Rule.new(
        algolia_object_id: "article-rule",
        conditions: [Algolia::Search::Condition.new(pattern: "article", anchoring: "startsWith")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            query: Algolia::Search::ConsequenceQueryObject.new(
              edits: [Algolia::Search::Edit.new(type: "remove", delete: "article")]
            ),
            restrict_searchable_attributes: ["title", "book_id"]
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/article-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"article-rule\",\"conditions\":[{\"pattern\":\"article\",\"anchoring\":\"startsWith\"}],\"consequence\":{\"params\":{\"query\":{\"edits\":[{\"type\":\"remove\",\"delete\":\"article\"}]},\"restrictSearchableAttributes\":[\"title\",\"book_id\"]}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # query match
  def test_save_rule12
    req = @client.save_rule_with_http_info(
      "indexName",
      "tagged-brand-rule",
      Algolia::Search::Rule.new(
        conditions: [
          Algolia::Search::Condition.new(pattern: "brand: {facet:brand}", anchoring: "contains", alternatives: false)
        ],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            automatic_facet_filters: [Algolia::Search::AutomaticFacetFilter.new(facet: "brand")],
            query: Algolia::Search::ConsequenceQueryObject.new(remove: ["brand:", "{facet:brand}"])
          )
        ),
        description: "filter on brand: {brand}",
        algolia_object_id: "tagged-brand-rule"
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/tagged-brand-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"conditions\":[{\"pattern\":\"brand: {facet:brand}\",\"anchoring\":\"contains\",\"alternatives\":false}],\"consequence\":{\"params\":{\"automaticFacetFilters\":[{\"facet\":\"brand\"}],\"query\":{\"remove\":[\"brand:\",\"{facet:brand}\"]}}},\"description\":\"filter on brand: {brand}\",\"objectID\":\"tagged-brand-rule\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # dynamic filtering
  def test_save_rule13
    req = @client.save_rule_with_http_info(
      "indexName",
      "color-facets",
      Algolia::Search::Rule.new(
        algolia_object_id: "color-facets",
        conditions: [Algolia::Search::Condition.new(pattern: "{facet:color}")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            automatic_facet_filters: [Algolia::Search::AutomaticFacetFilter.new(facet: "color")]
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/color-facets", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"color-facets\",\"conditions\":[{\"pattern\":\"{facet:color}\"}],\"consequence\":{\"params\":{\"automaticFacetFilters\":[{\"facet\":\"color\"}]}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # hide hits
  def test_save_rule14
    req = @client.save_rule_with_http_info(
      "indexName",
      "hide-12345",
      Algolia::Search::Rule.new(
        algolia_object_id: "hide-12345",
        conditions: [Algolia::Search::Condition.new(pattern: "cheap", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          hide: [Algolia::Search::ConsequenceHide.new(algolia_object_id: "to-hide-12345")]
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/hide-12345", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"hide-12345\",\"conditions\":[{\"pattern\":\"cheap\",\"anchoring\":\"contains\"}],\"consequence\":{\"hide\":[{\"objectID\":\"to-hide-12345\"}]}}"
      ),
      JSON.parse(req.body)
    )
  end

  # one rule per facet
  def test_save_rule15
    req = @client.save_rule_with_http_info(
      "indexName",
      "red-color",
      Algolia::Search::Rule.new(
        algolia_object_id: "red-color",
        conditions: [Algolia::Search::Condition.new(pattern: "red", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            query: Algolia::Search::ConsequenceQueryObject.new(remove: ["red"]),
            filters: "color:red"
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/red-color", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"red-color\",\"conditions\":[{\"pattern\":\"red\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"query\":{\"remove\":[\"red\"]},\"filters\":\"color:red\"}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # numerical filters
  def test_save_rule16
    req = @client.save_rule_with_http_info(
      "indexName",
      "cheap",
      Algolia::Search::Rule.new(
        algolia_object_id: "cheap",
        conditions: [Algolia::Search::Condition.new(pattern: "cheap", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            query: Algolia::Search::ConsequenceQueryObject.new(remove: ["cheap"]),
            filters: "price < 10"
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/cheap", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"cheap\",\"conditions\":[{\"pattern\":\"cheap\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"query\":{\"remove\":[\"cheap\"]},\"filters\":\"price < 10\"}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # negative filters
  def test_save_rule17
    req = @client.save_rule_with_http_info(
      "indexName",
      "gluten-free-rule",
      Algolia::Search::Rule.new(
        algolia_object_id: "gluten-free-rule",
        conditions: [Algolia::Search::Condition.new(pattern: "gluten-free", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            filters: "NOT allergens:gluten",
            query: Algolia::Search::ConsequenceQueryObject.new(
              edits: [Algolia::Search::Edit.new(type: "remove", delete: "gluten-free")]
            )
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/gluten-free-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"gluten-free-rule\",\"conditions\":[{\"pattern\":\"gluten-free\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"filters\":\"NOT allergens:gluten\",\"query\":{\"edits\":[{\"type\":\"remove\",\"delete\":\"gluten-free\"}]}}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # positive filters
  def test_save_rule18
    req = @client.save_rule_with_http_info(
      "indexName",
      "diet-rule",
      Algolia::Search::Rule.new(
        algolia_object_id: "diet-rule",
        conditions: [Algolia::Search::Condition.new(pattern: "diet", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            filters: "'low-carb' OR 'low-fat'",
            query: Algolia::Search::ConsequenceQueryObject.new(
              edits: [Algolia::Search::Edit.new(type: "remove", delete: "diet")]
            )
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/diet-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"diet-rule\",\"conditions\":[{\"pattern\":\"diet\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"filters\":\"'low-carb' OR 'low-fat'\",\"query\":{\"edits\":[{\"type\":\"remove\",\"delete\":\"diet\"}]}}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # conditionless
  def test_save_rule19
    req = @client.save_rule_with_http_info(
      "indexName",
      "diet-rule",
      Algolia::Search::Rule.new(
        algolia_object_id: "diet-rule",
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            filters: "'low-carb' OR 'low-fat'",
            query: Algolia::Search::ConsequenceQueryObject.new(
              edits: [Algolia::Search::Edit.new(type: "remove", delete: "diet")]
            )
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/diet-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"diet-rule\",\"consequence\":{\"params\":{\"filters\":\"'low-carb' OR 'low-fat'\",\"query\":{\"edits\":[{\"type\":\"remove\",\"delete\":\"diet\"}]}}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # contextual
  def test_save_rule20
    req = @client.save_rule_with_http_info(
      "indexName",
      "a-rule-id",
      Algolia::Search::Rule.new(
        algolia_object_id: "a-rule-id",
        conditions: [Algolia::Search::Condition.new(context: "mobile")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(filters: "release_date >= 1577836800")
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/a-rule-id", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"a-rule-id\",\"conditions\":[{\"context\":\"mobile\"}],\"consequence\":{\"params\":{\"filters\":\"release_date >= 1577836800\"}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # saveRule always active rule
  def test_save_rule21
    req = @client.save_rule_with_http_info(
      "indexName",
      "a-rule-id",
      Algolia::Search::Rule.new(
        algolia_object_id: "a-rule-id",
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(around_radius: 1000)
        ),
        validity: [Algolia::Search::TimeRange.new(from: 1577836800, _until: 1577836800)]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/a-rule-id", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"a-rule-id\",\"consequence\":{\"params\":{\"aroundRadius\":1000}},\"validity\":[{\"from\":1577836800,\"until\":1577836800}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # one sided validity
  def test_save_rule22
    req = @client.save_rule_with_http_info(
      "indexName",
      "a-rule-id",
      Algolia::Search::Rule.new(
        algolia_object_id: "a-rule-id",
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(around_radius: 1000)
        ),
        validity: [Algolia::Search::TimeRange.new(from: 1577836800)]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/a-rule-id", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"a-rule-id\",\"consequence\":{\"params\":{\"aroundRadius\":1000}},\"validity\":[{\"from\":1577836800}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # saveRules with minimal parameters
  def test_save_rules
    req = @client.save_rules_with_http_info(
      "<YOUR_INDEX_NAME>",
      [
        Algolia::Search::Rule.new(
          algolia_object_id: "a-rule-id",
          conditions: [Algolia::Search::Condition.new(pattern: "smartphone", anchoring: "contains")],
          consequence: Algolia::Search::Consequence.new(
            params: Algolia::Search::ConsequenceParams.new(filters: "brand:apple")
          )
        ),
        Algolia::Search::Rule.new(
          algolia_object_id: "a-second-rule-id",
          conditions: [Algolia::Search::Condition.new(pattern: "apple", anchoring: "contains")],
          consequence: Algolia::Search::Consequence.new(
            params: Algolia::Search::ConsequenceParams.new(filters: "brand:samsung")
          )
        )
      ],
      false,
      true
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch", req.path)
    assert_equal({:"forwardToReplicas" => "false", :"clearExistingRules" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "[{\"objectID\":\"a-rule-id\",\"conditions\":[{\"pattern\":\"smartphone\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"filters\":\"brand:apple\"}}},{\"objectID\":\"a-second-rule-id\",\"conditions\":[{\"pattern\":\"apple\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"filters\":\"brand:samsung\"}}}]"
      ),
      JSON.parse(req.body)
    )
  end

  # saveRules with all parameters
  def test_save_rules1
    req = @client.save_rules_with_http_info(
      "<YOUR_INDEX_NAME>",
      [
        Algolia::Search::Rule.new(
          algolia_object_id: "id1",
          conditions: [
            Algolia::Search::Condition.new(
              pattern: "apple",
              anchoring: "contains",
              alternatives: false,
              context: "search"
            )
          ],
          consequence: Algolia::Search::Consequence.new(
            params: Algolia::Search::ConsequenceParams.new(
              filters: "brand:apple",
              query: Algolia::Search::ConsequenceQueryObject.new(
                remove: ["algolia"],
                edits: [
                  Algolia::Search::Edit.new(type: "remove", delete: "abc", insert: "cde"),
                  Algolia::Search::Edit.new(type: "replace", delete: "abc", insert: "cde")
                ]
              )
            ),
            hide: [Algolia::Search::ConsequenceHide.new(algolia_object_id: "321")],
            filter_promotes: false,
            user_data: {algolia: "aloglia"},
            promote: [
              Algolia::Search::PromoteObjectID.new(algolia_object_id: "abc", position: 3),
              Algolia::Search::PromoteObjectIDs.new(object_ids: ["abc", "def"], position: 1)
            ]
          ),
          description: "test",
          enabled: true,
          validity: [Algolia::Search::TimeRange.new(from: 1656670273, _until: 1656670277)]
        )
      ],
      true,
      true
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch", req.path)
    assert_equal({:"forwardToReplicas" => "true", :"clearExistingRules" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "[{\"objectID\":\"id1\",\"conditions\":[{\"pattern\":\"apple\",\"anchoring\":\"contains\",\"alternatives\":false,\"context\":\"search\"}],\"consequence\":{\"params\":{\"filters\":\"brand:apple\",\"query\":{\"remove\":[\"algolia\"],\"edits\":[{\"type\":\"remove\",\"delete\":\"abc\",\"insert\":\"cde\"},{\"type\":\"replace\",\"delete\":\"abc\",\"insert\":\"cde\"}]}},\"hide\":[{\"objectID\":\"321\"}],\"filterPromotes\":false,\"userData\":{\"algolia\":\"aloglia\"},\"promote\":[{\"objectID\":\"abc\",\"position\":3},{\"objectIDs\":[\"abc\",\"def\"],\"position\":1}]},\"description\":\"test\",\"enabled\":true,\"validity\":[{\"from\":1656670273,\"until\":1656670277}]}]"
      ),
      JSON.parse(req.body)
    )
  end

  # dynamic filtering
  def test_save_rules2
    req = @client.save_rules_with_http_info(
      "<YOUR_INDEX_NAME>",
      [
        Algolia::Search::Rule.new(
          algolia_object_id: "toaster",
          conditions: [Algolia::Search::Condition.new(pattern: "toaster", anchoring: "contains")],
          consequence: Algolia::Search::Consequence.new(
            params: Algolia::Search::ConsequenceParams.new(
              query: Algolia::Search::ConsequenceQueryObject.new(remove: ["toaster"]),
              filters: "product_type:toaster"
            )
          )
        ),
        Algolia::Search::Rule.new(
          algolia_object_id: "cheap",
          conditions: [Algolia::Search::Condition.new(pattern: "cheap", anchoring: "contains")],
          consequence: Algolia::Search::Consequence.new(
            params: Algolia::Search::ConsequenceParams.new(
              query: Algolia::Search::ConsequenceQueryObject.new(remove: ["cheap"]),
              filters: "price < 15"
            )
          )
        )
      ]
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "[{\"objectID\":\"toaster\",\"conditions\":[{\"pattern\":\"toaster\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"query\":{\"remove\":[\"toaster\"]},\"filters\":\"product_type:toaster\"}}},{\"objectID\":\"cheap\",\"conditions\":[{\"pattern\":\"cheap\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"query\":{\"remove\":[\"cheap\"]},\"filters\":\"price < 15\"}}}]"
      ),
      JSON.parse(req.body)
    )
  end

  # enhance search results
  def test_save_rules3
    req = @client.save_rules_with_http_info(
      "<YOUR_INDEX_NAME>",
      [
        Algolia::Search::Rule.new(
          algolia_object_id: "country",
          conditions: [Algolia::Search::Condition.new(pattern: "{facet:country}", anchoring: "contains")],
          consequence: Algolia::Search::Consequence.new(
            params: Algolia::Search::ConsequenceParams.new(around_lat_lng_via_ip: false)
          )
        ),
        Algolia::Search::Rule.new(
          algolia_object_id: "city",
          conditions: [Algolia::Search::Condition.new(pattern: "{facet:city}", anchoring: "contains")],
          consequence: Algolia::Search::Consequence.new(
            params: Algolia::Search::ConsequenceParams.new(around_lat_lng_via_ip: false)
          )
        )
      ]
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "[{\"objectID\":\"country\",\"conditions\":[{\"pattern\":\"{facet:country}\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"aroundLatLngViaIP\":false}}},{\"objectID\":\"city\",\"conditions\":[{\"pattern\":\"{facet:city}\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"aroundLatLngViaIP\":false}}}]"
      ),
      JSON.parse(req.body)
    )
  end

  # saveSynonym
  def test_save_synonym
    req = @client.save_synonym_with_http_info(
      "indexName",
      "id1",
      Algolia::Search::SynonymHit.new(algolia_object_id: "id1", type: "synonym", synonyms: ["car", "vehicule", "auto"]),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/synonyms/id1", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"objectID\":\"id1\",\"type\":\"synonym\",\"synonyms\":[\"car\",\"vehicule\",\"auto\"]}"),
      JSON.parse(req.body)
    )
  end

  # saveSynonyms
  def test_save_synonyms
    req = @client.save_synonyms_with_http_info(
      "<YOUR_INDEX_NAME>",
      [
        Algolia::Search::SynonymHit.new(
          algolia_object_id: "id1",
          type: "synonym",
          synonyms: ["car", "vehicule", "auto"]
        ),
        Algolia::Search::SynonymHit.new(
          algolia_object_id: "id2",
          type: "onewaysynonym",
          input: "iphone",
          synonyms: ["ephone", "aphone", "yphone"]
        )
      ],
      true,
      true
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/synonyms/batch", req.path)
    assert_equal({:"forwardToReplicas" => "true", :"replaceExistingSynonyms" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "[{\"objectID\":\"id1\",\"type\":\"synonym\",\"synonyms\":[\"car\",\"vehicule\",\"auto\"]},{\"objectID\":\"id2\",\"type\":\"onewaysynonym\",\"input\":\"iphone\",\"synonyms\":[\"ephone\",\"aphone\",\"yphone\"]}]"
      ),
      JSON.parse(req.body)
    )
  end

  # withHitsPerPage
  def test_search
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(index_name: "<YOUR_INDEX_NAME>", query: "<YOUR_QUERY>", hits_per_page: 50)
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"hitsPerPage\":50}]}"),
      JSON.parse(req.body)
    )
  end

  # filterOnly
  def test_search1
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            index_name: "<YOUR_INDEX_NAME>",
            query: "<YOUR_QUERY>",
            filters: "actor:Scarlett Johansson"
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"filters\":\"actor:Scarlett Johansson\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # filterOr
  def test_search2
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            index_name: "<YOUR_INDEX_NAME>",
            query: "<YOUR_QUERY>",
            filters: "actor:Tom Cruise OR actor:Scarlett Johansson"
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"filters\":\"actor:Tom Cruise OR actor:Scarlett Johansson\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # filterNot
  def test_search3
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            index_name: "<YOUR_INDEX_NAME>",
            query: "<YOUR_QUERY>",
            filters: "NOT actor:Nicolas Cage"
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"filters\":\"NOT actor:Nicolas Cage\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # search for a single hits request with minimal parameters
  def test_search4
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [Algolia::Search::SearchForHits.new(index_name: "cts_e2e_search_empty_index")]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"requests\":[{\"indexName\":\"cts_e2e_search_empty_index\"}]}"), JSON.parse(req.body))
  end

  # search with highlight and snippet results
  def test_search5
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            index_name: "cts_e2e_highlight_snippet_results",
            query: "vim",
            attributes_to_snippet: ["*:20"],
            attributes_to_highlight: ["*"],
            attributes_to_retrieve: ["*"]
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"cts_e2e_highlight_snippet_results\",\"query\":\"vim\",\"attributesToSnippet\":[\"*:20\"],\"attributesToHighlight\":[\"*\"],\"attributesToRetrieve\":[\"*\"]}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # retrieveFacets
  def test_search6
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            index_name: "<YOUR_INDEX_NAME>",
            query: "<YOUR_QUERY>",
            facets: ["author", "genre"]
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"facets\":[\"author\",\"genre\"]}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # retrieveFacetsWildcard
  def test_search7
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(index_name: "<YOUR_INDEX_NAME>", query: "<YOUR_QUERY>", facets: ["*"])
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"facets\":[\"*\"]}]}"),
      JSON.parse(req.body)
    )
  end

  # search for a single facet request with minimal parameters
  def test_search8
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForFacets.new(index_name: "cts_e2e_search_facet", type: "facet", facet: "editor")
        ],
        strategy: "stopIfEnoughMatches"
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"cts_e2e_search_facet\",\"type\":\"facet\",\"facet\":\"editor\"}],\"strategy\":\"stopIfEnoughMatches\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # search for a single hits request with all parameters
  def test_search9
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            index_name: "theIndexName",
            query: "myQuery",
            hits_per_page: 50,
            type: "default"
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"theIndexName\",\"query\":\"myQuery\",\"hitsPerPage\":50,\"type\":\"default\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # search for a single facet request with all parameters
  def test_search10
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForFacets.new(
            index_name: "theIndexName",
            type: "facet",
            facet: "theFacet",
            facet_query: "theFacetQuery",
            query: "theQuery",
            max_facet_hits: 50
          )
        ],
        strategy: "stopIfEnoughMatches"
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"theIndexName\",\"type\":\"facet\",\"facet\":\"theFacet\",\"facetQuery\":\"theFacetQuery\",\"query\":\"theQuery\",\"maxFacetHits\":50}],\"strategy\":\"stopIfEnoughMatches\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # search for multiple mixed requests in multiple indices with minimal parameters
  def test_search11
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(index_name: "theIndexName"),
          Algolia::Search::SearchForFacets.new(index_name: "theIndexName2", type: "facet", facet: "theFacet"),
          Algolia::Search::SearchForHits.new(index_name: "theIndexName", type: "default")
        ],
        strategy: "stopIfEnoughMatches"
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"theIndexName\"},{\"indexName\":\"theIndexName2\",\"type\":\"facet\",\"facet\":\"theFacet\"},{\"indexName\":\"theIndexName\",\"type\":\"default\"}],\"strategy\":\"stopIfEnoughMatches\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # search for multiple mixed requests in multiple indices with all parameters
  def test_search12
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForFacets.new(
            index_name: "theIndexName",
            type: "facet",
            facet: "theFacet",
            facet_query: "theFacetQuery",
            query: "theQuery",
            max_facet_hits: 50
          ),
          Algolia::Search::SearchForHits.new(
            index_name: "theIndexName",
            query: "myQuery",
            hits_per_page: 50,
            type: "default"
          )
        ],
        strategy: "stopIfEnoughMatches"
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"theIndexName\",\"type\":\"facet\",\"facet\":\"theFacet\",\"facetQuery\":\"theFacetQuery\",\"query\":\"theQuery\",\"maxFacetHits\":50},{\"indexName\":\"theIndexName\",\"query\":\"myQuery\",\"hitsPerPage\":50,\"type\":\"default\"}],\"strategy\":\"stopIfEnoughMatches\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # search filters accept all of the possible shapes
  def test_search13
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            index_name: "theIndexName",
            facet_filters: "mySearch:filters",
            re_ranking_apply_filter: "mySearch:filters",
            tag_filters: "mySearch:filters",
            numeric_filters: "mySearch:filters",
            optional_filters: "mySearch:filters"
          ),
          Algolia::Search::SearchForHits.new(
            index_name: "theIndexName",
            facet_filters: ["mySearch:filters", ["mySearch:filters", ["mySearch:filters"]]],
            re_ranking_apply_filter: ["mySearch:filters", ["mySearch:filters"]],
            tag_filters: ["mySearch:filters", ["mySearch:filters"]],
            numeric_filters: ["mySearch:filters", ["mySearch:filters"]],
            optional_filters: ["mySearch:filters", ["mySearch:filters"]]
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"theIndexName\",\"facetFilters\":\"mySearch:filters\",\"reRankingApplyFilter\":\"mySearch:filters\",\"tagFilters\":\"mySearch:filters\",\"numericFilters\":\"mySearch:filters\",\"optionalFilters\":\"mySearch:filters\"},{\"indexName\":\"theIndexName\",\"facetFilters\":[\"mySearch:filters\",[\"mySearch:filters\",[\"mySearch:filters\"]]],\"reRankingApplyFilter\":[\"mySearch:filters\",[\"mySearch:filters\"]],\"tagFilters\":[\"mySearch:filters\",[\"mySearch:filters\"]],\"numericFilters\":[\"mySearch:filters\",[\"mySearch:filters\"]],\"optionalFilters\":[\"mySearch:filters\",[\"mySearch:filters\"]]}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # search filters end to end
  def test_search14
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            index_name: "cts_e2e_search_facet",
            filters: "editor:'visual studio' OR editor:neovim"
          ),
          Algolia::Search::SearchForHits.new(
            index_name: "cts_e2e_search_facet",
            facet_filters: ["editor:'visual studio'", "editor:neovim"]
          ),
          Algolia::Search::SearchForHits.new(
            index_name: "cts_e2e_search_facet",
            facet_filters: ["editor:'visual studio'", ["editor:neovim"]]
          ),
          Algolia::Search::SearchForHits.new(
            index_name: "cts_e2e_search_facet",
            facet_filters: ["editor:'visual studio'", ["editor:neovim", ["editor:goland"]]]
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"cts_e2e_search_facet\",\"filters\":\"editor:'visual studio' OR editor:neovim\"},{\"indexName\":\"cts_e2e_search_facet\",\"facetFilters\":[\"editor:'visual studio'\",\"editor:neovim\"]},{\"indexName\":\"cts_e2e_search_facet\",\"facetFilters\":[\"editor:'visual studio'\",[\"editor:neovim\"]]},{\"indexName\":\"cts_e2e_search_facet\",\"facetFilters\":[\"editor:'visual studio'\",[\"editor:neovim\",[\"editor:goland\"]]]}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # search with all search parameters
  def test_search15
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            advanced_syntax: true,
            advanced_syntax_features: ["exactPhrase"],
            allow_typos_on_numeric_tokens: true,
            alternatives_as_exact: ["multiWordsSynonym"],
            analytics: true,
            analytics_tags: [""],
            around_lat_lng: "",
            around_lat_lng_via_ip: true,
            around_precision: 0,
            around_radius: "all",
            attribute_criteria_computed_by_min_proximity: true,
            attributes_to_highlight: [""],
            attributes_to_retrieve: [""],
            attributes_to_snippet: [""],
            click_analytics: true,
            decompound_query: true,
            disable_exact_on_attributes: [""],
            disable_typo_tolerance_on_attributes: [""],
            distinct: 0,
            enable_ab_test: true,
            enable_personalization: true,
            enable_re_ranking: true,
            enable_rules: true,
            exact_on_single_word_query: "attribute",
            facet_filters: [""],
            faceting_after_distinct: true,
            facets: [""],
            filters: "",
            get_ranking_info: true,
            highlight_post_tag: "",
            highlight_pre_tag: "",
            hits_per_page: 1,
            ignore_plurals: false,
            index_name: "theIndexName",
            inside_bounding_box: [[47.3165, 4.9665, 47.3424, 5.0201], [40.9234, 2.1185, 38.643, 1.9916]],
            inside_polygon: [
              [47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9],
              [40.9234, 2.1185, 38.643, 1.9916, 39.2587, 2.0104]
            ],
            length: 1,
            max_values_per_facet: 0,
            min_proximity: 1,
            min_word_sizefor1_typo: 0,
            min_word_sizefor2_typos: 0,
            minimum_around_radius: 1,
            natural_languages: ["fr"],
            numeric_filters: [""],
            offset: 0,
            optional_filters: [""],
            optional_words: [""],
            page: 0,
            percentile_computation: true,
            personalization_impact: 0,
            query: "",
            query_languages: ["fr"],
            query_type: "prefixAll",
            ranking: [""],
            re_ranking_apply_filter: [""],
            relevancy_strictness: 0,
            remove_stop_words: true,
            remove_words_if_no_results: "allOptional",
            rendering_content: Algolia::Search::RenderingContent.new(
              facet_ordering: Algolia::Search::FacetOrdering.new(
                facets: Algolia::Search::Facets.new(order: ["a", "b"]),
                values: {a: Algolia::Search::Value.new(order: ["b"], sort_remaining_by: "count")}
              )
            ),
            replace_synonyms_in_highlight: true,
            response_fields: [""],
            restrict_highlight_and_snippet_arrays: true,
            restrict_searchable_attributes: [""],
            rule_contexts: [""],
            similar_query: "",
            snippet_ellipsis_text: "",
            sort_facet_values_by: "",
            sum_or_filters_scores: true,
            synonyms: true,
            tag_filters: [""],
            type: "default",
            typo_tolerance: "min",
            user_token: ""
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"advancedSyntax\":true,\"advancedSyntaxFeatures\":[\"exactPhrase\"],\"allowTyposOnNumericTokens\":true,\"alternativesAsExact\":[\"multiWordsSynonym\"],\"analytics\":true,\"analyticsTags\":[\"\"],\"aroundLatLng\":\"\",\"aroundLatLngViaIP\":true,\"aroundPrecision\":0,\"aroundRadius\":\"all\",\"attributeCriteriaComputedByMinProximity\":true,\"attributesToHighlight\":[\"\"],\"attributesToRetrieve\":[\"\"],\"attributesToSnippet\":[\"\"],\"clickAnalytics\":true,\"decompoundQuery\":true,\"disableExactOnAttributes\":[\"\"],\"disableTypoToleranceOnAttributes\":[\"\"],\"distinct\":0,\"enableABTest\":true,\"enablePersonalization\":true,\"enableReRanking\":true,\"enableRules\":true,\"exactOnSingleWordQuery\":\"attribute\",\"facetFilters\":[\"\"],\"facetingAfterDistinct\":true,\"facets\":[\"\"],\"filters\":\"\",\"getRankingInfo\":true,\"highlightPostTag\":\"\",\"highlightPreTag\":\"\",\"hitsPerPage\":1,\"ignorePlurals\":false,\"indexName\":\"theIndexName\",\"insideBoundingBox\":[[47.3165,4.9665,47.3424,5.0201],[40.9234,2.1185,38.643,1.9916]],\"insidePolygon\":[[47.3165,4.9665,47.3424,5.0201,47.32,4.9],[40.9234,2.1185,38.643,1.9916,39.2587,2.0104]],\"length\":1,\"maxValuesPerFacet\":0,\"minProximity\":1,\"minWordSizefor1Typo\":0,\"minWordSizefor2Typos\":0,\"minimumAroundRadius\":1,\"naturalLanguages\":[\"fr\"],\"numericFilters\":[\"\"],\"offset\":0,\"optionalFilters\":[\"\"],\"optionalWords\":[\"\"],\"page\":0,\"percentileComputation\":true,\"personalizationImpact\":0,\"query\":\"\",\"queryLanguages\":[\"fr\"],\"queryType\":\"prefixAll\",\"ranking\":[\"\"],\"reRankingApplyFilter\":[\"\"],\"relevancyStrictness\":0,\"removeStopWords\":true,\"removeWordsIfNoResults\":\"allOptional\",\"renderingContent\":{\"facetOrdering\":{\"facets\":{\"order\":[\"a\",\"b\"]},\"values\":{\"a\":{\"order\":[\"b\"],\"sortRemainingBy\":\"count\"}}}},\"replaceSynonymsInHighlight\":true,\"responseFields\":[\"\"],\"restrictHighlightAndSnippetArrays\":true,\"restrictSearchableAttributes\":[\"\"],\"ruleContexts\":[\"\"],\"similarQuery\":\"\",\"snippetEllipsisText\":\"\",\"sortFacetValuesBy\":\"\",\"sumOrFiltersScores\":true,\"synonyms\":true,\"tagFilters\":[\"\"],\"type\":\"default\",\"typoTolerance\":\"min\",\"userToken\":\"\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # get searchDictionaryEntries results with minimal parameters
  def test_search_dictionary_entries
    req = @client.search_dictionary_entries_with_http_info(
      "stopwords",
      Algolia::Search::SearchDictionaryEntriesParams.new(query: "about")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/dictionaries/stopwords/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"about\"}"), JSON.parse(req.body))
  end

  # get searchDictionaryEntries results with all parameters
  def test_search_dictionary_entries1
    req = @client.search_dictionary_entries_with_http_info(
      "compounds",
      Algolia::Search::SearchDictionaryEntriesParams.new(query: "foo", page: 4, hits_per_page: 2, language: "fr")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/dictionaries/compounds/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"foo\",\"page\":4,\"hitsPerPage\":2,\"language\":\"fr\"}"),
      JSON.parse(req.body)
    )
  end

  # get searchForFacetValues results with minimal parameters
  def test_search_for_facet_values
    req = @client.search_for_facet_values_with_http_info("indexName", "facetName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/facets/facetName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # get searchForFacetValues results with all parameters
  def test_search_for_facet_values1
    req = @client.search_for_facet_values_with_http_info(
      "indexName",
      "facetName",
      Algolia::Search::SearchForFacetValuesRequest.new(
        params: "query=foo&facetFilters=['bar']",
        facet_query: "foo",
        max_facet_hits: 42
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/facets/facetName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"params\":\"query=foo&facetFilters=['bar']\",\"facetQuery\":\"foo\",\"maxFacetHits\":42}"),
      JSON.parse(req.body)
    )
  end

  # facetName and facetQuery
  def test_search_for_facet_values2
    req = @client.search_for_facet_values_with_http_info(
      "indexName",
      "author",
      Algolia::Search::SearchForFacetValuesRequest.new(facet_query: "stephen")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/facets/author/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facetQuery\":\"stephen\"}"), JSON.parse(req.body))
  end

  # searchRules
  def test_search_rules
    req = @client.search_rules_with_http_info("cts_e2e_browse", Algolia::Search::SearchRulesParams.new(query: "zorro"))

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/cts_e2e_browse/rules/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"zorro\"}"), JSON.parse(req.body))
  end

  # search with minimal parameters
  def test_search_single_index
    req = @client.search_single_index_with_http_info("indexName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # search with special characters in indexName
  def test_search_single_index1
    req = @client.search_single_index_with_http_info("cts_e2e_space in index")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/cts_e2e_space%20in%20index/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # search with searchParams
  def test_search_single_index2
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "myQuery", facet_filters: ["tags:algolia"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"myQuery\",\"facetFilters\":[\"tags:algolia\"]}"), JSON.parse(req.body))
  end

  # single search retrieve snippets
  def test_search_single_index3
    req = @client.search_single_index_with_http_info(
      "cts_e2e_browse",
      Algolia::Search::SearchParamsObject.new(
        query: "batman mask of the phantasm",
        attributes_to_retrieve: ["*"],
        attributes_to_snippet: ["*:20"]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/cts_e2e_browse/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"query\":\"batman mask of the phantasm\",\"attributesToRetrieve\":[\"*\"],\"attributesToSnippet\":[\"*:20\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # query
  def test_search_single_index4
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "phone")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"phone\"}"), JSON.parse(req.body))
  end

  # filters
  def test_search_single_index5
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(filters: "country:US AND price.gross < 2.0")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"filters\":\"country:US AND price.gross < 2.0\"}"), JSON.parse(req.body))
  end

  # filters for stores
  def test_search_single_index6
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        query: "ben",
        filters: "categories:politics AND store:Gibert Joseph Saint-Michel"
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"ben\",\"filters\":\"categories:politics AND store:Gibert Joseph Saint-Michel\"}"),
      JSON.parse(req.body)
    )
  end

  # filters boolean
  def test_search_single_index7
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(filters: "is_available:true")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"filters\":\"is_available:true\"}"), JSON.parse(req.body))
  end

  # distinct
  def test_search_single_index8
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(distinct: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"distinct\":true}"), JSON.parse(req.body))
  end

  # filtersNumeric
  def test_search_single_index9
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(filters: "price < 10")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"filters\":\"price < 10\"}"), JSON.parse(req.body))
  end

  # filtersTimestamp
  def test_search_single_index10
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(filters: "NOT date_timestamp:1514764800 TO 1546300799")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"filters\":\"NOT date_timestamp:1514764800 TO 1546300799\"}"), JSON.parse(req.body))
  end

  # filtersSumOrFiltersScoresFalse
  def test_search_single_index11
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        filters: "(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)",
        sum_or_filters_scores: false
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"filters\":\"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\",\"sumOrFiltersScores\":false}"
      ),
      JSON.parse(req.body)
    )
  end

  # filtersSumOrFiltersScoresTrue
  def test_search_single_index12
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        filters: "(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)",
        sum_or_filters_scores: true
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"filters\":\"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\",\"sumOrFiltersScores\":true}"
      ),
      JSON.parse(req.body)
    )
  end

  # filtersStephenKing
  def test_search_single_index13
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(filters: "author:\"Stephen King\"")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"filters\":\"author:\\\"Stephen King\\\"\"}"), JSON.parse(req.body))
  end

  # filtersNotTags
  def test_search_single_index14
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "harry", filters: "_tags:non-fiction")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"harry\",\"filters\":\"_tags:non-fiction\"}"), JSON.parse(req.body))
  end

  # facetFiltersList
  def test_search_single_index15
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        facet_filters: ["publisher:Penguin", ["author:Stephen King", "genre:Horror"]]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"facetFilters\":[\"publisher:Penguin\",[\"author:Stephen King\",\"genre:Horror\"]]}"),
      JSON.parse(req.body)
    )
  end

  # facetFiltersBook
  def test_search_single_index16
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", facet_filters: ["category:Book"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"facetFilters\":[\"category:Book\"]}"), JSON.parse(req.body))
  end

  # facetFiltersAND
  def test_search_single_index17
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", facet_filters: ["category:Book", "author:John Doe"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"facetFilters\":[\"category:Book\",\"author:John Doe\"]}"),
      JSON.parse(req.body)
    )
  end

  # facetFiltersOR
  def test_search_single_index18
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", facet_filters: [["category:Book", "author:John Doe"]])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"facetFilters\":[[\"category:Book\",\"author:John Doe\"]]}"),
      JSON.parse(req.body)
    )
  end

  # facetFiltersCombined
  def test_search_single_index19
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        query: "query",
        facet_filters: ["author:John Doe", ["category:Book", "category:Movie"]]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"facetFilters\":[\"author:John Doe\",[\"category:Book\",\"category:Movie\"]]}"),
      JSON.parse(req.body)
    )
  end

  # facetFiltersNeg
  def test_search_single_index20
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(facet_filters: "category:-Ebook")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facetFilters\":\"category:-Ebook\"}"), JSON.parse(req.body))
  end

  # filtersAndFacetFilters
  def test_search_single_index21
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        filters: "(author:\"Stephen King\" OR genre:\"Horror\")",
        facet_filters: ["publisher:Penguin"]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"filters\":\"(author:\\\"Stephen King\\\" OR genre:\\\"Horror\\\")\",\"facetFilters\":[\"publisher:Penguin\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # facet author genre
  def test_search_single_index22
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(facets: ["author", "genre"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facets\":[\"author\",\"genre\"]}"), JSON.parse(req.body))
  end

  # facet wildcard
  def test_search_single_index23
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(facets: ["*"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facets\":[\"*\"]}"), JSON.parse(req.body))
  end

  # maxValuesPerFacet
  def test_search_single_index24
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(max_values_per_facet: 1000)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"maxValuesPerFacet\":1000}"), JSON.parse(req.body))
  end

  # aroundLatLng
  def test_search_single_index25
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(around_lat_lng: "40.71, -74.01")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"aroundLatLng\":\"40.71, -74.01\"}"), JSON.parse(req.body))
  end

  # aroundLatLngViaIP
  def test_search_single_index26
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(around_lat_lng_via_ip: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"aroundLatLngViaIP\":true}"), JSON.parse(req.body))
  end

  # aroundRadius
  def test_search_single_index27
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(around_lat_lng: "40.71, -74.01", around_radius: 1000000)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"aroundLatLng\":\"40.71, -74.01\",\"aroundRadius\":1000000}"), JSON.parse(req.body))
  end

  # insideBoundingBox
  def test_search_single_index28
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        inside_bounding_box: [[49.067996905313834, 65.73828125, 25.905859247243498, 128.8046875]]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"insideBoundingBox\":[[49.067996905313834,65.73828125,25.905859247243498,128.8046875]]}"),
      JSON.parse(req.body)
    )
  end

  # insidePolygon
  def test_search_single_index29
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        inside_polygon: [
          [
            42.01,
            -124.31,
            48.835509470063045,
            -124.40453125000005,
            45.01082951668149,
            -65.95726562500005,
            31.247243545293433,
            -81.06578125000004,
            25.924152577235226,
            -97.68234374999997,
            32.300311895879545,
            -117.54828125
          ]
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"insidePolygon\":[[42.01,-124.31,48.835509470063045,-124.40453125000005,45.01082951668149,-65.95726562500005,31.247243545293433,-81.06578125000004,25.924152577235226,-97.68234374999997,32.300311895879545,-117.54828125]]}"
      ),
      JSON.parse(req.body)
    )
  end

  # optionalFilters
  def test_search_single_index30
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(optional_filters: ["can_deliver_quickly:true"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"optionalFilters\":[\"can_deliver_quickly:true\"]}"), JSON.parse(req.body))
  end

  # optionalFiltersMany
  def test_search_single_index31
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        optional_filters: ["brand:Apple<score=3>", "brand:Samsung<score=2>", "brand:-Huawei"]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"optionalFilters\":[\"brand:Apple<score=3>\",\"brand:Samsung<score=2>\",\"brand:-Huawei\"]}"),
      JSON.parse(req.body)
    )
  end

  # optionalFiltersSimple
  def test_search_single_index32
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(optional_filters: ["brand:Apple<score=2>", "type:tablet"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"optionalFilters\":[\"brand:Apple<score=2>\",\"type:tablet\"]}"), JSON.parse(req.body))
  end

  # restrictSearchableAttributes
  def test_search_single_index33
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(restrict_searchable_attributes: ["title_fr"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"restrictSearchableAttributes\":[\"title_fr\"]}"), JSON.parse(req.body))
  end

  # getRankingInfo
  def test_search_single_index34
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(get_ranking_info: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"getRankingInfo\":true}"), JSON.parse(req.body))
  end

  # clickAnalytics
  def test_search_single_index35
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(click_analytics: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"clickAnalytics\":true}"), JSON.parse(req.body))
  end

  # clickAnalyticsUserToken
  def test_search_single_index36
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(click_analytics: true, user_token: "user-1")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"clickAnalytics\":true,\"userToken\":\"user-1\"}"), JSON.parse(req.body))
  end

  # enablePersonalization
  def test_search_single_index37
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(enable_personalization: true, user_token: "user-1")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"enablePersonalization\":true,\"userToken\":\"user-1\"}"), JSON.parse(req.body))
  end

  # userToken
  def test_search_single_index38
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(user_token: "user-1")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"userToken\":\"user-1\"}"), JSON.parse(req.body))
  end

  # userToken1234
  def test_search_single_index39
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", user_token: "user-1234")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"userToken\":\"user-1234\"}"), JSON.parse(req.body))
  end

  # analyticsTag
  def test_search_single_index40
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(analytics_tags: ["YOUR_ANALYTICS_TAG"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"analyticsTags\":[\"YOUR_ANALYTICS_TAG\"]}"), JSON.parse(req.body))
  end

  # facetFiltersUsers
  def test_search_single_index41
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(facet_filters: ["user:user42", "user:public"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facetFilters\":[\"user:user42\",\"user:public\"]}"), JSON.parse(req.body))
  end

  # buildTheQuery
  def test_search_single_index42
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        filters: "categoryPageId: Men's Clothing",
        hits_per_page: 50,
        analytics_tags: ["mens-clothing"]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"filters\":\"categoryPageId: Men's Clothing\",\"hitsPerPage\":50,\"analyticsTags\":[\"mens-clothing\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # attributesToHighlightOverride
  def test_search_single_index43
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", attributes_to_highlight: ["title", "content"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"attributesToHighlight\":[\"title\",\"content\"]}"),
      JSON.parse(req.body)
    )
  end

  # disableTypoToleranceOnAttributes
  def test_search_single_index44
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", disable_typo_tolerance_on_attributes: ["serial_number"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"disableTypoToleranceOnAttributes\":[\"serial_number\"]}"),
      JSON.parse(req.body)
    )
  end

  # search query
  def test_search_single_index45
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "shirt")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"shirt\"}"), JSON.parse(req.body))
  end

  # search_everything
  def test_search_single_index46
    req = @client.search_single_index_with_http_info("indexName", Algolia::Search::SearchParamsObject.new(query: ""))

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"\"}"), JSON.parse(req.body))
  end

  # api_filtering_range_example
  def test_search_single_index47
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "books", filters: "price:10 TO 20")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"books\",\"filters\":\"price:10 TO 20\"}"), JSON.parse(req.body))
  end

  # similarQuery
  def test_search_single_index48
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        query: "",
        similar_query: "Comedy Drama Crime McDormand Macy Buscemi Stormare Presnell Coen",
        filters: "year:1991 TO 2001"
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"query\":\"\",\"similarQuery\":\"Comedy Drama Crime McDormand Macy Buscemi Stormare Presnell Coen\",\"filters\":\"year:1991 TO 2001\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # override_retrievable_attributes
  def test_search_single_index49
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", attributes_to_retrieve: ["title", "content"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"attributesToRetrieve\":[\"title\",\"content\"]}"),
      JSON.parse(req.body)
    )
  end

  # restrict_searchable_attributes
  def test_search_single_index50
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", restrict_searchable_attributes: ["title", "author"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"restrictSearchableAttributes\":[\"title\",\"author\"]}"),
      JSON.parse(req.body)
    )
  end

  # override_default_relevancy
  def test_search_single_index51
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", relevancy_strictness: 70)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"relevancyStrictness\":70}"), JSON.parse(req.body))
  end

  # apply_filters
  def test_search_single_index52
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        query: "query",
        filters: "(category:Book OR category:Ebook) AND _tags:published"
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"filters\":\"(category:Book OR category:Ebook) AND _tags:published\"}"),
      JSON.parse(req.body)
    )
  end

  # apply_all_filters
  def test_search_single_index53
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        query: "query",
        filters: "available = 1 AND (category:Book OR NOT category:Ebook) AND _tags:published AND publication_date:1441745506 TO 1441755506 AND inStock > 0 AND author:\"John Doe\""
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"query\":\"query\",\"filters\":\"available = 1 AND (category:Book OR NOT category:Ebook) AND _tags:published AND publication_date:1441745506 TO 1441755506 AND inStock > 0 AND author:\\\"John Doe\\\"\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # escape_spaces
  def test_search_single_index54
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", filters: "category:\"Books and Comics\"")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"filters\":\"category:\\\"Books and Comics\\\"\"}"),
      JSON.parse(req.body)
    )
  end

  # escape_keywords
  def test_search_single_index55
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", filters: "keyword:\"OR\"")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"filters\":\"keyword:\\\"OR\\\"\"}"), JSON.parse(req.body))
  end

  # escape_single_quotes
  def test_search_single_index56
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", filters: "content:\"It's a wonderful day\"")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"filters\":\"content:\\\"It's a wonderful day\\\"\"}"),
      JSON.parse(req.body)
    )
  end

  # escape_double_quotes
  def test_search_single_index57
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", filters: "content:\"She said \"Hello World\"")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"filters\":\"content:\\\"She said \\\"Hello World\\\"\"}"),
      JSON.parse(req.body)
    )
  end

  # apply_optional_filters
  def test_search_single_index58
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", optional_filters: ["category:Book", "author:John Doe"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"optionalFilters\":[\"category:Book\",\"author:John Doe\"]}"),
      JSON.parse(req.body)
    )
  end

  # apply_negative_filters
  def test_search_single_index59
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", optional_filters: ["category:Book", "author:-John Doe"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"optionalFilters\":[\"category:Book\",\"author:-John Doe\"]}"),
      JSON.parse(req.body)
    )
  end

  # apply_negative_filters_restaurants
  def test_search_single_index60
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", optional_filters: ["restaurant:-Bert's Inn"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"optionalFilters\":[\"restaurant:-Bert's Inn\"]}"),
      JSON.parse(req.body)
    )
  end

  # apply_numeric_filters
  def test_search_single_index61
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        query: "query",
        numeric_filters: ["price < 1000", ["inStock = 1", "deliveryDate < 1441755506"]]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"query\":\"query\",\"numericFilters\":[\"price < 1000\",[\"inStock = 1\",\"deliveryDate < 1441755506\"]]}"
      ),
      JSON.parse(req.body)
    )
  end

  # apply_tag_filters
  def test_search_single_index62
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", tag_filters: ["SciFi", ["Book", "Movie"]])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"tagFilters\":[\"SciFi\",[\"Book\",\"Movie\"]]}"),
      JSON.parse(req.body)
    )
  end

  # set_sum_or_filters_scores
  def test_search_single_index63
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", sum_or_filters_scores: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"sumOrFiltersScores\":true}"), JSON.parse(req.body))
  end

  # facets_all
  def test_search_single_index64
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", facets: ["*"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"facets\":[\"*\"]}"), JSON.parse(req.body))
  end

  # retrieve_only_some_facets
  def test_search_single_index65
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", facets: ["category", "author"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"facets\":[\"category\",\"author\"]}"), JSON.parse(req.body))
  end

  # override_default_max_values_per_facet
  def test_search_single_index66
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", max_values_per_facet: 20)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"maxValuesPerFacet\":20}"), JSON.parse(req.body))
  end

  # enable_faceting_after_distinct
  def test_search_single_index67
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", faceting_after_distinct: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"facetingAfterDistinct\":true}"), JSON.parse(req.body))
  end

  # sort_facet_values_alphabetically
  def test_search_single_index68
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", sort_facet_values_by: "count")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"sortFacetValuesBy\":\"count\"}"), JSON.parse(req.body))
  end

  # override_attributes_to_snippet
  def test_search_single_index69
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", attributes_to_snippet: ["title", "content:80"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"attributesToSnippet\":[\"title\",\"content:80\"]}"),
      JSON.parse(req.body)
    )
  end

  # override_default_highlight_pre_tag
  def test_search_single_index70
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", highlight_pre_tag: "<strong>")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"highlightPreTag\":\"<strong>\"}"), JSON.parse(req.body))
  end

  # override_default_highlight_post_tag
  def test_search_single_index71
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", highlight_post_tag: "</strong>")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"highlightPostTag\":\"</strong>\"}"), JSON.parse(req.body))
  end

  # override_default_snippet_ellipsis_text
  def test_search_single_index72
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", snippet_ellipsis_text: "")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"snippetEllipsisText\":\"\"}"), JSON.parse(req.body))
  end

  # enable_restrict_highlight_and_snippet_arrays
  def test_search_single_index73
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", restrict_highlight_and_snippet_arrays: false)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"restrictHighlightAndSnippetArrays\":false}"), JSON.parse(req.body))
  end

  # access_page
  def test_search_single_index74
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", page: 0)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"page\":0}"), JSON.parse(req.body))
  end

  # override_default_hits_per_page
  def test_search_single_index75
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", hits_per_page: 10)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"hitsPerPage\":10}"), JSON.parse(req.body))
  end

  # get_nth_hit
  def test_search_single_index76
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", offset: 4)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"offset\":4}"), JSON.parse(req.body))
  end

  # get_n_results
  def test_search_single_index77
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", length: 4)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"length\":4}"), JSON.parse(req.body))
  end

  # override_default_min_word_size_for_one_typo
  def test_search_single_index78
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", min_word_sizefor1_typo: 2)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"minWordSizefor1Typo\":2}"), JSON.parse(req.body))
  end

  # override_default_min_word_size_for_two_typos
  def test_search_single_index79
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", min_word_sizefor2_typos: 2)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"minWordSizefor2Typos\":2}"), JSON.parse(req.body))
  end

  # override_default_typo_tolerance_mode
  def test_search_single_index80
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", typo_tolerance: false)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"typoTolerance\":false}"), JSON.parse(req.body))
  end

  # disable_typos_on_numeric_tokens_at_search_time
  def test_search_single_index81
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", allow_typos_on_numeric_tokens: false)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"allowTyposOnNumericTokens\":false}"), JSON.parse(req.body))
  end

  # search_around_a_position
  def test_search_single_index82
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", around_lat_lng: "40.71, -74.01")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"aroundLatLng\":\"40.71, -74.01\"}"), JSON.parse(req.body))
  end

  # search_around_server_ip
  def test_search_single_index83
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", around_lat_lng_via_ip: true),
      {
        :header_params => {
          "x-forwarded-for" => "94.228.178.246 // should be replaced with the actual IP you would like to search around"
        }
      }
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(
      ({
        :"x-forwarded-for" => "94.228.178.246 // should be replaced with the actual IP you would like to search around"
      }.transform_keys(&:to_s).to_a -
        req.headers.to_a)
        .empty?,
      req.headers.to_s
    )
    assert_equal(JSON.parse("{\"query\":\"query\",\"aroundLatLngViaIP\":true}"), JSON.parse(req.body))
  end

  # set_around_radius
  def test_search_single_index84
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", around_radius: 1000)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"aroundRadius\":1000}"), JSON.parse(req.body))
  end

  # disable_automatic_radius
  def test_search_single_index85
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", around_radius: "all")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"aroundRadius\":\"all\"}"), JSON.parse(req.body))
  end

  # set_geo_search_precision
  def test_search_single_index86
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", around_precision: 100)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"aroundPrecision\":100}"), JSON.parse(req.body))
  end

  # set_geo_search_precision_non_linear
  def test_search_single_index87
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        query: "query",
        around_precision: [
          Algolia::Search::Range.new(from: 0, value: 25),
          Algolia::Search::Range.new(from: 2000, value: 1000)
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"aroundPrecision\":[{\"from\":0,\"value\":25},{\"from\":2000,\"value\":1000}]}"),
      JSON.parse(req.body)
    )
  end

  # set_minimum_geo_search_radius
  def test_search_single_index88
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", minimum_around_radius: 1000)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"minimumAroundRadius\":1000}"), JSON.parse(req.body))
  end

  # search_inside_rectangular_area
  def test_search_single_index89
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        query: "query",
        inside_bounding_box: [[46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625]]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"query\":\"query\",\"insideBoundingBox\":[[46.650828100116044,7.123046875,45.17210966999772,1.009765625]]}"
      ),
      JSON.parse(req.body)
    )
  end

  # search_inside_multiple_rectangular_areas
  def test_search_single_index90
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        query: "query",
        inside_bounding_box: [
          [46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625],
          [49.62625916704081, 4.6181640625, 47.715070300900194, 0.482421875]
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"query\":\"query\",\"insideBoundingBox\":[[46.650828100116044,7.123046875,45.17210966999772,1.009765625],[49.62625916704081,4.6181640625,47.715070300900194,0.482421875]]}"
      ),
      JSON.parse(req.body)
    )
  end

  # search_inside_polygon_area
  def test_search_single_index91
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        query: "query",
        inside_polygon: [
          [46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625]
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"query\":\"query\",\"insidePolygon\":[[46.650828100116044,7.123046875,45.17210966999772,1.009765625,49.62625916704081,4.6181640625]]}"
      ),
      JSON.parse(req.body)
    )
  end

  # search_inside_multiple_polygon_areas
  def test_search_single_index92
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        query: "query",
        inside_polygon: [
          [46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625],
          [
            49.62625916704081,
            4.6181640625,
            47.715070300900194,
            0.482421875,
            45.17210966999772,
            1.009765625,
            50.62626704081,
            4.6181640625
          ]
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"query\":\"query\",\"insidePolygon\":[[46.650828100116044,7.123046875,45.17210966999772,1.009765625,49.62625916704081,4.6181640625],[49.62625916704081,4.6181640625,47.715070300900194,0.482421875,45.17210966999772,1.009765625,50.62626704081,4.6181640625]]}"
      ),
      JSON.parse(req.body)
    )
  end

  # set_querylanguages_override
  def test_search_single_index93
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", ignore_plurals: ["ca", "es"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"ignorePlurals\":[\"ca\",\"es\"]}"), JSON.parse(req.body))
  end

  # set_querylanguages_with_japanese_query
  def test_search_single_index94
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", query_languages: ["ja", "en"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"queryLanguages\":[\"ja\",\"en\"]}"), JSON.parse(req.body))
  end

  # set_natural_languages
  def test_search_single_index95
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "", natural_languages: ["fr"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"\",\"naturalLanguages\":[\"fr\"]}"), JSON.parse(req.body))
  end

  # override_natural_languages_with_query
  def test_search_single_index96
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        query: "",
        natural_languages: ["fr"],
        remove_words_if_no_results: "firstWords"
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"\",\"naturalLanguages\":[\"fr\"],\"removeWordsIfNoResults\":\"firstWords\"}"),
      JSON.parse(req.body)
    )
  end

  # enable_decompound_query_search_time
  def test_search_single_index97
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", decompound_query: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"decompoundQuery\":true}"), JSON.parse(req.body))
  end

  # enable_rules_search_time
  def test_search_single_index98
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", enable_rules: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"enableRules\":true}"), JSON.parse(req.body))
  end

  # set_rule_contexts
  def test_search_single_index99
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", rule_contexts: ["front_end", "website2"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"ruleContexts\":[\"front_end\",\"website2\"]}"),
      JSON.parse(req.body)
    )
  end

  # enable_personalization
  def test_search_single_index100
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", enable_personalization: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"enablePersonalization\":true}"), JSON.parse(req.body))
  end

  # enable_personalization_with_user_token
  def test_search_single_index101
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", enable_personalization: true, user_token: "123456")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"enablePersonalization\":true,\"userToken\":\"123456\"}"),
      JSON.parse(req.body)
    )
  end

  # personalization_impact
  def test_search_single_index102
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", personalization_impact: 20)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"personalizationImpact\":20}"), JSON.parse(req.body))
  end

  # set_user_token
  def test_search_single_index103
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", user_token: "123456")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"userToken\":\"123456\"}"), JSON.parse(req.body))
  end

  # set_user_token_with_personalization
  def test_search_single_index104
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", enable_personalization: true, user_token: "123456")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"enablePersonalization\":true,\"userToken\":\"123456\"}"),
      JSON.parse(req.body)
    )
  end

  # override_default_query_type
  def test_search_single_index105
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", query_type: "prefixAll")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"queryType\":\"prefixAll\"}"), JSON.parse(req.body))
  end

  # override_default_remove_words_if_no_results
  def test_search_single_index106
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", remove_words_if_no_results: "lastWords")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"removeWordsIfNoResults\":\"lastWords\"}"), JSON.parse(req.body))
  end

  # enable_advanced_syntax_search_time
  def test_search_single_index107
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", advanced_syntax: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"advancedSyntax\":true}"), JSON.parse(req.body))
  end

  # overide_default_optional_words
  def test_search_single_index108
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", optional_words: ["toyota", "2020 2021"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"optionalWords\":[\"toyota\",\"2020 2021\"]}"), JSON.parse(req.body))
  end

  # disabling_exact_for_some_attributes_search_time
  def test_search_single_index109
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", disable_exact_on_attributes: ["description"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"disableExactOnAttributes\":[\"description\"]}"),
      JSON.parse(req.body)
    )
  end

  # override_default_exact_single_word_query
  def test_search_single_index110
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", exact_on_single_word_query: "none")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"exactOnSingleWordQuery\":\"none\"}"), JSON.parse(req.body))
  end

  # override_default_aternative_as_exact
  def test_search_single_index111
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", alternatives_as_exact: ["multiWordsSynonym"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"alternativesAsExact\":[\"multiWordsSynonym\"]}"),
      JSON.parse(req.body)
    )
  end

  # enable_advanced_syntax_exact_phrase
  def test_search_single_index112
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        query: "query",
        advanced_syntax: true,
        advanced_syntax_features: ["exactPhrase"]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"advancedSyntax\":true,\"advancedSyntaxFeatures\":[\"exactPhrase\"]}"),
      JSON.parse(req.body)
    )
  end

  # enable_advanced_syntax_exclude_words
  def test_search_single_index113
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        query: "query",
        advanced_syntax: true,
        advanced_syntax_features: ["excludeWords"]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"advancedSyntax\":true,\"advancedSyntaxFeatures\":[\"excludeWords\"]}"),
      JSON.parse(req.body)
    )
  end

  # override_distinct
  def test_search_single_index114
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", distinct: 0)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"distinct\":0}"), JSON.parse(req.body))
  end

  # get_ranking_info
  def test_search_single_index115
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", get_ranking_info: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"getRankingInfo\":true}"), JSON.parse(req.body))
  end

  # disable_click_analytics
  def test_search_single_index116
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", click_analytics: false)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"clickAnalytics\":false}"), JSON.parse(req.body))
  end

  # enable_click_analytics
  def test_search_single_index117
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", click_analytics: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"clickAnalytics\":true}"), JSON.parse(req.body))
  end

  # disable_analytics
  def test_search_single_index118
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", analytics: false)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"analytics\":false}"), JSON.parse(req.body))
  end

  # add_analytics_tags
  def test_search_single_index119
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", analytics_tags: ["front_end", "website2"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"query\",\"analyticsTags\":[\"front_end\",\"website2\"]}"),
      JSON.parse(req.body)
    )
  end

  # disable_synonyms
  def test_search_single_index120
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", synonyms: false)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"synonyms\":false}"), JSON.parse(req.body))
  end

  # override_replace_synonyms_in_highlights
  def test_search_single_index121
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", replace_synonyms_in_highlight: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"replaceSynonymsInHighlight\":true}"), JSON.parse(req.body))
  end

  # override_min_proximity
  def test_search_single_index122
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", min_proximity: 2)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"minProximity\":2}"), JSON.parse(req.body))
  end

  # override_default_field
  def test_search_single_index123
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", response_fields: ["hits", "facets"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"responseFields\":[\"hits\",\"facets\"]}"), JSON.parse(req.body))
  end

  # override_percentile_computation
  def test_search_single_index124
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", percentile_computation: false)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"percentileComputation\":false}"), JSON.parse(req.body))
  end

  # set_ab_test
  def test_search_single_index125
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", enable_ab_test: false)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"enableABTest\":false}"), JSON.parse(req.body))
  end

  # set_enable_re_ranking
  def test_search_single_index126
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query", enable_re_ranking: false)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\",\"enableReRanking\":false}"), JSON.parse(req.body))
  end

  # with algolia user id
  def test_search_single_index127
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "query"),
      {:header_params => {"X-Algolia-User-ID" => "user1234"}}
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"query\"}"), JSON.parse(req.body))
  end

  # mcm with algolia user id
  def test_search_single_index128
    req = @client.search_single_index_with_http_info(
      "playlists",
      Algolia::Search::SearchParamsObject.new(query: "peace"),
      {:header_params => {"X-Algolia-User-ID" => "user42"}}
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/playlists/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"peace\"}"), JSON.parse(req.body))
  end

  # searchSynonyms with minimal parameters
  def test_search_synonyms
    req = @client.search_synonyms_with_http_info("indexName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/synonyms/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # searchSynonyms with all parameters
  def test_search_synonyms1
    req = @client.search_synonyms_with_http_info(
      "indexName",
      Algolia::Search::SearchSynonymsParams.new(query: "myQuery", type: "altcorrection1", page: 10, hits_per_page: 10)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/synonyms/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"myQuery\",\"type\":\"altcorrection1\",\"page\":10,\"hitsPerPage\":10}"),
      JSON.parse(req.body)
    )
  end

  # searchUserIds
  def test_search_user_ids
    req = @client.search_user_ids_with_http_info(
      Algolia::Search::SearchUserIdsParams.new(
        query: "test",
        cluster_name: "theClusterName",
        page: 5,
        hits_per_page: 10
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/clusters/mapping/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"test\",\"clusterName\":\"theClusterName\",\"page\":5,\"hitsPerPage\":10}"),
      JSON.parse(req.body)
    )
  end

  # get setDictionarySettings results with minimal parameters
  def test_set_dictionary_settings
    req = @client.set_dictionary_settings_with_http_info(
      Algolia::Search::DictionarySettingsParams.new(
        disable_standard_entries: Algolia::Search::StandardEntries.new(plurals: {fr: false, en: false, ru: true})
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/dictionaries/*/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"disableStandardEntries\":{\"plurals\":{\"fr\":false,\"en\":false,\"ru\":true}}}"),
      JSON.parse(req.body)
    )
  end

  # get setDictionarySettings results with all parameters
  def test_set_dictionary_settings1
    req = @client.set_dictionary_settings_with_http_info(
      Algolia::Search::DictionarySettingsParams.new(
        disable_standard_entries: Algolia::Search::StandardEntries.new(
          plurals: {fr: false, en: false, ru: true},
          stopwords: {fr: false},
          compounds: {ru: true}
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/dictionaries/*/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"disableStandardEntries\":{\"plurals\":{\"fr\":false,\"en\":false,\"ru\":true},\"stopwords\":{\"fr\":false},\"compounds\":{\"ru\":true}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # minimal parameters
  def test_set_settings
    req = @client.set_settings_with_http_info(
      "cts_e2e_settings",
      Algolia::Search::IndexSettings.new(pagination_limited_to: 10, typo_tolerance: "false"),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/cts_e2e_settings/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"paginationLimitedTo\":10,\"typoTolerance\":\"false\"}"), JSON.parse(req.body))
  end

  # boolean typoTolerance
  def test_set_settings1
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(typo_tolerance: true),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"typoTolerance\":true}"), JSON.parse(req.body))
  end

  # enum typoTolerance
  def test_set_settings2
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(typo_tolerance: "min"),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"typoTolerance\":\"min\"}"), JSON.parse(req.body))
  end

  # ignorePlurals
  def test_set_settings3
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(ignore_plurals: true),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"ignorePlurals\":true}"), JSON.parse(req.body))
  end

  # list of string ignorePlurals
  def test_set_settings4
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(ignore_plurals: ["fr"]),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"ignorePlurals\":[\"fr\"]}"), JSON.parse(req.body))
  end

  # removeStopWords boolean
  def test_set_settings5
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(remove_stop_words: true),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"removeStopWords\":true}"), JSON.parse(req.body))
  end

  # removeStopWords list of string
  def test_set_settings6
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(remove_stop_words: ["fr"]),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"removeStopWords\":[\"fr\"]}"), JSON.parse(req.body))
  end

  # boolean distinct
  def test_set_settings7
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(distinct: true), true)

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"distinct\":true}"), JSON.parse(req.body))
  end

  # integer distinct
  def test_set_settings8
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(distinct: 1), true)

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"distinct\":1}"), JSON.parse(req.body))
  end

  # distinct company
  def test_set_settings9
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(attribute_for_distinct: "company", distinct: true)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeForDistinct\":\"company\",\"distinct\":true}"), JSON.parse(req.body))
  end

  # distinct design
  def test_set_settings10
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(attribute_for_distinct: "design", distinct: true)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeForDistinct\":\"design\",\"distinct\":true}"), JSON.parse(req.body))
  end

  # distinct true
  def test_set_settings11
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(distinct: true))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"distinct\":true}"), JSON.parse(req.body))
  end

  # distinct section
  def test_set_settings12
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(attribute_for_distinct: "section", distinct: true)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeForDistinct\":\"section\",\"distinct\":true}"), JSON.parse(req.body))
  end

  # attributesForFaceting allergens
  def test_set_settings13
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["allergens"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesForFaceting\":[\"allergens\"]}"), JSON.parse(req.body))
  end

  # attributesForFaceting availableIn
  def test_set_settings14
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["color", "availableIn"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesForFaceting\":[\"color\",\"availableIn\"]}"), JSON.parse(req.body))
  end

  # api_attributes_for_faceting
  def test_set_settings15
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["genre", "author"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesForFaceting\":[\"genre\",\"author\"]}"), JSON.parse(req.body))
  end

  # api_attributes_for_faceting_searchable
  def test_set_settings16
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["genre", "searchable(author)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesForFaceting\":[\"genre\",\"searchable(author)\"]}"), JSON.parse(req.body))
  end

  # api_attributes_for_filter_only
  def test_set_settings17
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["filterOnly(genre)", "author"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesForFaceting\":[\"filterOnly(genre)\",\"author\"]}"), JSON.parse(req.body))
  end

  # attributesForFaceting categoryPageId
  def test_set_settings18
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["searchable(categoryPageId)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesForFaceting\":[\"searchable(categoryPageId)\"]}"), JSON.parse(req.body))
  end

  # unretrievableAttributes
  def test_set_settings19
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(unretrievable_attributes: ["visible_by"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"unretrievableAttributes\":[\"visible_by\"]}"), JSON.parse(req.body))
  end

  # attributesForFaceting user restricted data
  def test_set_settings20
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["filterOnly(visible_by)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesForFaceting\":[\"filterOnly(visible_by)\"]}"), JSON.parse(req.body))
  end

  # attributesForFaceting optional filters
  def test_set_settings21
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["can_deliver_quickly", "restaurant"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"attributesForFaceting\":[\"can_deliver_quickly\",\"restaurant\"]}"),
      JSON.parse(req.body)
    )
  end

  # attributesForFaceting redirect index
  def test_set_settings22
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["query_terms"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesForFaceting\":[\"query_terms\"]}"), JSON.parse(req.body))
  end

  # attributesForFaceting multiple consequences
  def test_set_settings23
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["director"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesForFaceting\":[\"director\"]}"), JSON.parse(req.body))
  end

  # attributesForFaceting in-depth optional filters
  def test_set_settings24
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["filterOnly(brand)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesForFaceting\":[\"filterOnly(brand)\"]}"), JSON.parse(req.body))
  end

  # mode neuralSearch
  def test_set_settings25
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(mode: "neuralSearch"))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"mode\":\"neuralSearch\"}"), JSON.parse(req.body))
  end

  # mode keywordSearch
  def test_set_settings26
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(mode: "keywordSearch"))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"mode\":\"keywordSearch\"}"), JSON.parse(req.body))
  end

  # searchableAttributes same priority
  def test_set_settings27
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(searchable_attributes: ["title,comments", "ingredients"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"searchableAttributes\":[\"title,comments\",\"ingredients\"]}"), JSON.parse(req.body))
  end

  # searchableAttributes higher priority
  def test_set_settings28
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(searchable_attributes: ["title", "ingredients"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"searchableAttributes\":[\"title\",\"ingredients\"]}"), JSON.parse(req.body))
  end

  # customRanking retweets
  def test_set_settings29
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(custom_ranking: ["desc(retweets)", "desc(likes)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"customRanking\":[\"desc(retweets)\",\"desc(likes)\"]}"), JSON.parse(req.body))
  end

  # customRanking boosted
  def test_set_settings30
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(custom_ranking: ["desc(boosted)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"customRanking\":[\"desc(boosted)\"]}"), JSON.parse(req.body))
  end

  # customRanking pageviews
  def test_set_settings31
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(custom_ranking: ["desc(pageviews)", "desc(comments)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"customRanking\":[\"desc(pageviews)\",\"desc(comments)\"]}"), JSON.parse(req.body))
  end

  # customRanking applying search parameters for a specific query
  def test_set_settings32
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        custom_ranking: ["desc(nb_airline_liaisons)"],
        attributes_for_faceting: ["city, country"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"customRanking\":[\"desc(nb_airline_liaisons)\"],\"attributesForFaceting\":[\"city, country\"]}"),
      JSON.parse(req.body)
    )
  end

  # customRanking rounded pageviews
  def test_set_settings33
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(custom_ranking: ["desc(rounded_pageviews)", "desc(comments)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"customRanking\":[\"desc(rounded_pageviews)\",\"desc(comments)\"]}"),
      JSON.parse(req.body)
    )
  end

  # customRanking price
  def test_set_settings34
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(custom_ranking: ["desc(price)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"customRanking\":[\"desc(price)\"]}"), JSON.parse(req.body))
  end

  # ranking exhaustive (price)
  def test_set_settings35
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        ranking: ["desc(price)", "typo", "geo", "words", "filters", "proximity", "attribute", "exact", "custom"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"ranking\":[\"desc(price)\",\"typo\",\"geo\",\"words\",\"filters\",\"proximity\",\"attribute\",\"exact\",\"custom\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # ranking exhaustive (is_popular)
  def test_set_settings36
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        ranking: ["desc(is_popular)", "typo", "geo", "words", "filters", "proximity", "attribute", "exact", "custom"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"ranking\":[\"desc(is_popular)\",\"typo\",\"geo\",\"words\",\"filters\",\"proximity\",\"attribute\",\"exact\",\"custom\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # ranking standard replica
  def test_set_settings37
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(ranking: ["desc(post_date_timestamp)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"ranking\":[\"desc(post_date_timestamp)\"]}"), JSON.parse(req.body))
  end

  # ranking virtual replica
  def test_set_settings38
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(custom_ranking: ["desc(post_date_timestamp)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"customRanking\":[\"desc(post_date_timestamp)\"]}"), JSON.parse(req.body))
  end

  # customRanking and ranking sort alphabetically
  def test_set_settings39
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        custom_ranking: ["asc(textual_attribute)"],
        ranking: ["custom", "typo", "geo", "words", "filters", "proximity", "attribute", "exact"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"customRanking\":[\"asc(textual_attribute)\"],\"ranking\":[\"custom\",\"typo\",\"geo\",\"words\",\"filters\",\"proximity\",\"attribute\",\"exact\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # relevancyStrictness
  def test_set_settings40
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(custom_ranking: ["asc(textual_attribute)"], relevancy_strictness: 0)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"customRanking\":[\"asc(textual_attribute)\"],\"relevancyStrictness\":0}"),
      JSON.parse(req.body)
    )
  end

  # create replica index
  def test_set_settings41
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(replicas: ["products_price_desc"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"replicas\":[\"products_price_desc\"]}"), JSON.parse(req.body))
  end

  # create replica index articles
  def test_set_settings42
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(replicas: ["articles_date_desc"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"replicas\":[\"articles_date_desc\"]}"), JSON.parse(req.body))
  end

  # create virtual replica index
  def test_set_settings43
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(replicas: ["virtual(products_price_desc)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"replicas\":[\"virtual(products_price_desc)\"]}"), JSON.parse(req.body))
  end

  # unlink replica index
  def test_set_settings44
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(replicas: [""]))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"replicas\":[\"\"]}"), JSON.parse(req.body))
  end

  # forwardToReplicas
  def test_set_settings45
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(searchable_attributes: ["name", "description"]),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"searchableAttributes\":[\"name\",\"description\"]}"), JSON.parse(req.body))
  end

  # maxValuesPerFacet
  def test_set_settings46
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(max_values_per_facet: 1000)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"maxValuesPerFacet\":1000}"), JSON.parse(req.body))
  end

  # maxFacetHits
  def test_set_settings47
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(max_facet_hits: 100))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"maxFacetHits\":100}"), JSON.parse(req.body))
  end

  # attributesForFaceting complex
  def test_set_settings48
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(
        attributes_for_faceting: ["actor", "filterOnly(category)", "searchable(publisher)"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"attributesForFaceting\":[\"actor\",\"filterOnly(category)\",\"searchable(publisher)\"]}"),
      JSON.parse(req.body)
    )
  end

  # ranking closest dates
  def test_set_settings49
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        ranking: ["asc(date_timestamp)", "typo", "geo", "words", "filters", "proximity", "attribute", "exact", "custom"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"ranking\":[\"asc(date_timestamp)\",\"typo\",\"geo\",\"words\",\"filters\",\"proximity\",\"attribute\",\"exact\",\"custom\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # searchableAttributes item variation
  def test_set_settings50
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(searchable_attributes: ["design", "type", "color"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"searchableAttributes\":[\"design\",\"type\",\"color\"]}"), JSON.parse(req.body))
  end

  # searchableAttributes around location
  def test_set_settings51
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        searchable_attributes: ["name", "country", "city", "iata_code"],
        custom_ranking: ["desc(links_count)"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"searchableAttributes\":[\"name\",\"country\",\"city\",\"iata_code\"],\"customRanking\":[\"desc(links_count)\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # attributesToHighlight
  def test_set_settings52
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(attributes_to_highlight: ["author", "title", "content"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesToHighlight\":[\"author\",\"title\",\"content\"]}"), JSON.parse(req.body))
  end

  # attributesToHighlightStar
  def test_set_settings53
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(attributes_to_highlight: ["*"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesToHighlight\":[\"*\"]}"), JSON.parse(req.body))
  end

  # everything
  def test_set_settings54
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        advanced_syntax: true,
        advanced_syntax_features: ["exactPhrase"],
        allow_compression_of_integer_array: true,
        allow_typos_on_numeric_tokens: true,
        alternatives_as_exact: ["singleWordSynonym"],
        attribute_criteria_computed_by_min_proximity: true,
        attribute_for_distinct: "test",
        attributes_for_faceting: ["algolia"],
        attributes_to_highlight: ["algolia"],
        attributes_to_retrieve: ["algolia"],
        attributes_to_snippet: ["algolia"],
        attributes_to_transliterate: ["algolia"],
        camel_case_attributes: ["algolia"],
        custom_normalization: {algolia: {aloglia: "aglolia"}},
        custom_ranking: ["algolia"],
        decompound_query: false,
        decompounded_attributes: {algolia: "aloglia"},
        disable_exact_on_attributes: ["algolia"],
        disable_prefix_on_attributes: ["algolia"],
        disable_typo_tolerance_on_attributes: ["algolia"],
        disable_typo_tolerance_on_words: ["algolia"],
        distinct: 3,
        enable_personalization: true,
        enable_re_ranking: false,
        enable_rules: true,
        exact_on_single_word_query: "attribute",
        highlight_pre_tag: "<span>",
        highlight_post_tag: "</span>",
        hits_per_page: 10,
        ignore_plurals: false,
        index_languages: ["fr"],
        keep_diacritics_on_characters: "abc",
        max_facet_hits: 20,
        max_values_per_facet: 30,
        min_proximity: 6,
        min_word_sizefor1_typo: 5,
        min_word_sizefor2_typos: 11,
        mode: "neuralSearch",
        numeric_attributes_for_filtering: ["algolia"],
        optional_words: ["myspace"],
        pagination_limited_to: 0,
        query_languages: ["fr"],
        query_type: "prefixLast",
        ranking: ["geo"],
        re_ranking_apply_filter: "mySearch:filters",
        relevancy_strictness: 10,
        remove_stop_words: false,
        remove_words_if_no_results: "lastWords",
        rendering_content: Algolia::Search::RenderingContent.new(
          facet_ordering: Algolia::Search::FacetOrdering.new(
            facets: Algolia::Search::Facets.new(order: ["a", "b"]),
            values: {a: Algolia::Search::Value.new(order: ["b"], sort_remaining_by: "count")}
          )
        ),
        replace_synonyms_in_highlight: true,
        replicas: [""],
        response_fields: ["algolia"],
        restrict_highlight_and_snippet_arrays: true,
        searchable_attributes: ["foo"],
        semantic_search: Algolia::Search::SemanticSearch.new(event_sources: ["foo"]),
        separators_to_index: "bar",
        snippet_ellipsis_text: "---",
        sort_facet_values_by: "date",
        typo_tolerance: false,
        unretrievable_attributes: ["foo"],
        user_data: {:"user" => "data"}
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"advancedSyntax\":true,\"advancedSyntaxFeatures\":[\"exactPhrase\"],\"allowCompressionOfIntegerArray\":true,\"allowTyposOnNumericTokens\":true,\"alternativesAsExact\":[\"singleWordSynonym\"],\"attributeCriteriaComputedByMinProximity\":true,\"attributeForDistinct\":\"test\",\"attributesForFaceting\":[\"algolia\"],\"attributesToHighlight\":[\"algolia\"],\"attributesToRetrieve\":[\"algolia\"],\"attributesToSnippet\":[\"algolia\"],\"attributesToTransliterate\":[\"algolia\"],\"camelCaseAttributes\":[\"algolia\"],\"customNormalization\":{\"algolia\":{\"aloglia\":\"aglolia\"}},\"customRanking\":[\"algolia\"],\"decompoundQuery\":false,\"decompoundedAttributes\":{\"algolia\":\"aloglia\"},\"disableExactOnAttributes\":[\"algolia\"],\"disablePrefixOnAttributes\":[\"algolia\"],\"disableTypoToleranceOnAttributes\":[\"algolia\"],\"disableTypoToleranceOnWords\":[\"algolia\"],\"distinct\":3,\"enablePersonalization\":true,\"enableReRanking\":false,\"enableRules\":true,\"exactOnSingleWordQuery\":\"attribute\",\"highlightPreTag\":\"<span>\",\"highlightPostTag\":\"</span>\",\"hitsPerPage\":10,\"ignorePlurals\":false,\"indexLanguages\":[\"fr\"],\"keepDiacriticsOnCharacters\":\"abc\",\"maxFacetHits\":20,\"maxValuesPerFacet\":30,\"minProximity\":6,\"minWordSizefor1Typo\":5,\"minWordSizefor2Typos\":11,\"mode\":\"neuralSearch\",\"numericAttributesForFiltering\":[\"algolia\"],\"optionalWords\":[\"myspace\"],\"paginationLimitedTo\":0,\"queryLanguages\":[\"fr\"],\"queryType\":\"prefixLast\",\"ranking\":[\"geo\"],\"reRankingApplyFilter\":\"mySearch:filters\",\"relevancyStrictness\":10,\"removeStopWords\":false,\"removeWordsIfNoResults\":\"lastWords\",\"renderingContent\":{\"facetOrdering\":{\"facets\":{\"order\":[\"a\",\"b\"]},\"values\":{\"a\":{\"order\":[\"b\"],\"sortRemainingBy\":\"count\"}}}},\"replaceSynonymsInHighlight\":true,\"replicas\":[\"\"],\"responseFields\":[\"algolia\"],\"restrictHighlightAndSnippetArrays\":true,\"searchableAttributes\":[\"foo\"],\"semanticSearch\":{\"eventSources\":[\"foo\"]},\"separatorsToIndex\":\"bar\",\"snippetEllipsisText\":\"---\",\"sortFacetValuesBy\":\"date\",\"typoTolerance\":false,\"unretrievableAttributes\":[\"foo\"],\"userData\":{\"user\":\"data\"}}"
      ),
      JSON.parse(req.body)
    )
  end

  # searchableAttributesWithCustomRankingsAndAttributesForFaceting
  def test_set_settings55
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        searchable_attributes: ["brand", "name", "categories", "unordered(description)"],
        custom_ranking: ["desc(popularity)"],
        attributes_for_faceting: ["searchable(brand)", "type", "categories", "price"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"searchableAttributes\":[\"brand\",\"name\",\"categories\",\"unordered(description)\"],\"customRanking\":[\"desc(popularity)\"],\"attributesForFaceting\":[\"searchable(brand)\",\"type\",\"categories\",\"price\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # searchableAttributesOrdering
  def test_set_settings56
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(searchable_attributes: ["unordered(title)", "cast"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"searchableAttributes\":[\"unordered(title)\",\"cast\"]}"), JSON.parse(req.body))
  end

  # searchableAttributesProductReferenceSuffixes
  def test_set_settings57
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        searchable_attributes: ["name", "product_reference", "product_reference_suffixes"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"searchableAttributes\":[\"name\",\"product_reference\",\"product_reference_suffixes\"]}"),
      JSON.parse(req.body)
    )
  end

  # queryLanguageAndIgnorePlurals
  def test_set_settings58
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(query_languages: ["en"], ignore_plurals: true)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"queryLanguages\":[\"en\"],\"ignorePlurals\":true}"), JSON.parse(req.body))
  end

  # searchableAttributesInMovies
  def test_set_settings59
    req = @client.set_settings_with_http_info(
      "movies",
      Algolia::Search::IndexSettings.new(searchable_attributes: ["title_eng", "title_fr", "title_es"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/movies/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"searchableAttributes\":[\"title_eng\",\"title_fr\",\"title_es\"]}"),
      JSON.parse(req.body)
    )
  end

  # disablePrefixOnAttributes
  def test_set_settings60
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(disable_prefix_on_attributes: ["serial_number"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"disablePrefixOnAttributes\":[\"serial_number\"]}"), JSON.parse(req.body))
  end

  # disableTypoToleranceOnAttributes
  def test_set_settings61
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(disable_typo_tolerance_on_attributes: ["serial_number"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"disableTypoToleranceOnAttributes\":[\"serial_number\"]}"), JSON.parse(req.body))
  end

  # searchableAttributesSimpleExample
  def test_set_settings62
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(searchable_attributes: ["serial_number"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"searchableAttributes\":[\"serial_number\"]}"), JSON.parse(req.body))
  end

  # searchableAttributesSimpleExampleAlt
  def test_set_settings63
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(searchable_attributes: ["serial_number", "serial_number_suffixes"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"searchableAttributes\":[\"serial_number\",\"serial_number_suffixes\"]}"),
      JSON.parse(req.body)
    )
  end

  # set_searchable_attributes
  def test_set_settings64
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        searchable_attributes: ["title,alternative_title", "author", "unordered(text)", "emails.personal"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"searchableAttributes\":[\"title,alternative_title\",\"author\",\"unordered(text)\",\"emails.personal\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # set_attributes_for_faceting
  def test_set_settings65
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        attributes_for_faceting: [
          "author",
          "filterOnly(isbn)",
          "searchable(edition)",
          "afterDistinct(category)",
          "afterDistinct(searchable(publisher))"
        ]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"attributesForFaceting\":[\"author\",\"filterOnly(isbn)\",\"searchable(edition)\",\"afterDistinct(category)\",\"afterDistinct(searchable(publisher))\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # unretrievable_attributes
  def test_set_settings66
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(unretrievable_attributes: ["total_number_of_sales"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"unretrievableAttributes\":[\"total_number_of_sales\"]}"), JSON.parse(req.body))
  end

  # set_retrievable_attributes
  def test_set_settings67
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(attributes_to_retrieve: ["author", "title", "content"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesToRetrieve\":[\"author\",\"title\",\"content\"]}"), JSON.parse(req.body))
  end

  # set_all_attributes_as_retrievable
  def test_set_settings68
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(attributes_to_retrieve: ["*"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesToRetrieve\":[\"*\"]}"), JSON.parse(req.body))
  end

  # specify_attributes_not_to_retrieve
  def test_set_settings69
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(attributes_to_retrieve: ["*", "-SKU", "-internal_desc"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesToRetrieve\":[\"*\",\"-SKU\",\"-internal_desc\"]}"), JSON.parse(req.body))
  end

  # neural_search
  def test_set_settings70
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(mode: "neuralSearch"))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"mode\":\"neuralSearch\"}"), JSON.parse(req.body))
  end

  # keyword_search
  def test_set_settings71
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(mode: "keywordSearch"))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"mode\":\"keywordSearch\"}"), JSON.parse(req.body))
  end

  # set_default_ranking
  def test_set_settings72
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        ranking: ["typo", "geo", "words", "filters", "attribute", "proximity", "exact", "custom"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"ranking\":[\"typo\",\"geo\",\"words\",\"filters\",\"attribute\",\"proximity\",\"exact\",\"custom\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # set_ranking_by_attribute_asc
  def test_set_settings73
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        ranking: ["asc(price)", "typo", "geo", "words", "filters", "proximity", "attribute", "exact", "custom"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"ranking\":[\"asc(price)\",\"typo\",\"geo\",\"words\",\"filters\",\"proximity\",\"attribute\",\"exact\",\"custom\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # set_ranking_by_attribute_desc
  def test_set_settings74
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        ranking: ["desc(price)", "typo", "geo", "words", "filters", "proximity", "attribute", "exact", "custom"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"ranking\":[\"desc(price)\",\"typo\",\"geo\",\"words\",\"filters\",\"proximity\",\"attribute\",\"exact\",\"custom\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # set_custom_ranking
  def test_set_settings75
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(custom_ranking: ["desc(popularity)", "asc(price)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"customRanking\":[\"desc(popularity)\",\"asc(price)\"]}"), JSON.parse(req.body))
  end

  # set_default_relevancy
  def test_set_settings76
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(relevancy_strictness: 90)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"relevancyStrictness\":90}"), JSON.parse(req.body))
  end

  # set_replicas
  def test_set_settings77
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(replicas: ["name_of_replica_index1", "name_of_replica_index2"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"replicas\":[\"name_of_replica_index1\",\"name_of_replica_index2\"]}"),
      JSON.parse(req.body)
    )
  end

  # set_default_max_values_per_facet
  def test_set_settings78
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(max_values_per_facet: 100)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"maxValuesPerFacet\":100}"), JSON.parse(req.body))
  end

  # set_default_sort_facet_values_by
  def test_set_settings79
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(sort_facet_values_by: "alpha")
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"sortFacetValuesBy\":\"alpha\"}"), JSON.parse(req.body))
  end

  # set_attributes_to_snippet
  def test_set_settings80
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(attributes_to_snippet: ["content:80", "description"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesToSnippet\":[\"content:80\",\"description\"]}"), JSON.parse(req.body))
  end

  # set_all_attributes_to_snippet
  def test_set_settings81
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(attributes_to_snippet: ["*:80"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesToSnippet\":[\"*:80\"]}"), JSON.parse(req.body))
  end

  # set_default_highlight_pre_tag
  def test_set_settings82
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(highlight_pre_tag: "<em>")
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"highlightPreTag\":\"<em>\"}"), JSON.parse(req.body))
  end

  # set_default_highlight_post_tag
  def test_set_settings83
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(highlight_post_tag: "</em>")
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"highlightPostTag\":\"</em>\"}"), JSON.parse(req.body))
  end

  # set_default_snippet_ellipsis_text
  def test_set_settings84
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(snippet_ellipsis_text: "")
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"snippetEllipsisText\":\"\u2026\"}"), JSON.parse(req.body))
  end

  # enable_restrict_highlight_and_snippet_arrays_by_default
  def test_set_settings85
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(restrict_highlight_and_snippet_arrays: true)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"restrictHighlightAndSnippetArrays\":true}"), JSON.parse(req.body))
  end

  # set_default_hits_per_page
  def test_set_settings86
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(hits_per_page: 20))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"hitsPerPage\":20}"), JSON.parse(req.body))
  end

  # set_pagination_limit
  def test_set_settings87
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(pagination_limited_to: 1000)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"paginationLimitedTo\":1000}"), JSON.parse(req.body))
  end

  # set_default_min_word_size_for_one_typo
  def test_set_settings88
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(min_word_sizefor1_typo: 4)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"minWordSizefor1Typo\":4}"), JSON.parse(req.body))
  end

  # set_default_min_word_size_for_two_typos
  def test_set_settings89
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(min_word_sizefor2_typos: 4)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"minWordSizefor2Typos\":4}"), JSON.parse(req.body))
  end

  # set_default_typo_tolerance_mode
  def test_set_settings90
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(typo_tolerance: true))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"typoTolerance\":true}"), JSON.parse(req.body))
  end

  # disable_typos_on_numeric_tokens_by_default
  def test_set_settings91
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(allow_typos_on_numeric_tokens: false)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"allowTyposOnNumericTokens\":false}"), JSON.parse(req.body))
  end

  # disable_typo_tolerance_for_words
  def test_set_settings92
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(disable_typo_tolerance_on_words: ["wheel", "1X2BCD"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"disableTypoToleranceOnWords\":[\"wheel\",\"1X2BCD\"]}"), JSON.parse(req.body))
  end

  # set_separators_to_index
  def test_set_settings93
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(separators_to_index: "+#")
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"separatorsToIndex\":\"+#\"}"), JSON.parse(req.body))
  end

  # set_querylanguage_ignoreplurals
  def test_set_settings94
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(query_languages: ["es"], ignore_plurals: true)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"queryLanguages\":[\"es\"],\"ignorePlurals\":true}"), JSON.parse(req.body))
  end

  # set_attributes_to_transliterate
  def test_set_settings95
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(index_languages: ["ja"], attributes_to_transliterate: ["name", "description"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"indexLanguages\":[\"ja\"],\"attributesToTransliterate\":[\"name\",\"description\"]}"),
      JSON.parse(req.body)
    )
  end

  # set_querylanguage_removestopwords
  def test_set_settings96
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(query_languages: ["es"], remove_stop_words: true)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"queryLanguages\":[\"es\"],\"removeStopWords\":true}"), JSON.parse(req.body))
  end

  # set_camel_case_attributes
  def test_set_settings97
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(camel_case_attributes: ["description"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"camelCaseAttributes\":[\"description\"]}"), JSON.parse(req.body))
  end

  # set_decompounded_attributes
  def test_set_settings98
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(decompounded_attributes: {de: ["name"]})
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"decompoundedAttributes\":{\"de\":[\"name\"]}}"), JSON.parse(req.body))
  end

  # set_decompounded_multiple_attributes
  def test_set_settings99
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        decompounded_attributes: {de: ["name_de", "description_de"], fi: ["name_fi", "description_fi"]}
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"decompoundedAttributes\":{\"de\":[\"name_de\",\"description_de\"],\"fi\":[\"name_fi\",\"description_fi\"]}}"
      ),
      JSON.parse(req.body)
    )
  end

  # set_keep_diacritics_on_characters
  def test_set_settings100
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(keep_diacritics_on_characters: "")
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"keepDiacriticsOnCharacters\":\"\u00F8\u00E9\"}"), JSON.parse(req.body))
  end

  # set_custom_normalization
  def test_set_settings101
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(custom_normalization: {default: {: "ae"}})
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"customNormalization\":{\"default\":{\"\u00E4\":\"ae\"}}}"), JSON.parse(req.body))
  end

  # set_querylanguage_both
  def test_set_settings102
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(query_languages: ["es"], remove_stop_words: true, ignore_plurals: true)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"queryLanguages\":[\"es\"],\"removeStopWords\":true,\"ignorePlurals\":true}"),
      JSON.parse(req.body)
    )
  end

  # set_indexlanguages
  def test_set_settings103
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(index_languages: ["ja"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"indexLanguages\":[\"ja\"]}"), JSON.parse(req.body))
  end

  # enable_decompound_query_by_default
  def test_set_settings104
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(decompound_query: true)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"decompoundQuery\":true}"), JSON.parse(req.body))
  end

  # enable_rules_syntax_by_default
  def test_set_settings105
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(enable_rules: true))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"enableRules\":true}"), JSON.parse(req.body))
  end

  # enable_personalization_settings
  def test_set_settings106
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(enable_personalization: true)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"enablePersonalization\":true}"), JSON.parse(req.body))
  end

  # set_default_query_type
  def test_set_settings107
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(query_type: "prefixLast")
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"queryType\":\"prefixLast\"}"), JSON.parse(req.body))
  end

  # set_default_remove_words_if_no_result
  def test_set_settings108
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(remove_words_if_no_results: "none")
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"removeWordsIfNoResults\":\"none\"}"), JSON.parse(req.body))
  end

  # enable_advanced_syntax_by_default
  def test_set_settings109
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(advanced_syntax: true))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"advancedSyntax\":true}"), JSON.parse(req.body))
  end

  # set_default_optional_words
  def test_set_settings110
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(optional_words: ["blue", "iphone case"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"optionalWords\":[\"blue\",\"iphone case\"]}"), JSON.parse(req.body))
  end

  # disabling_prefix_search_for_some_attributes_by_default
  def test_set_settings111
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(disable_prefix_on_attributes: ["sku"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"disablePrefixOnAttributes\":[\"sku\"]}"), JSON.parse(req.body))
  end

  # disabling_exact_for_some_attributes_by_default
  def test_set_settings112
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(disable_exact_on_attributes: ["description"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"disableExactOnAttributes\":[\"description\"]}"), JSON.parse(req.body))
  end

  # set_default_exact_single_word_query
  def test_set_settings113
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(exact_on_single_word_query: "attribute")
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"exactOnSingleWordQuery\":\"attribute\"}"), JSON.parse(req.body))
  end

  # set_default_aternative_as_exact
  def test_set_settings114
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(alternatives_as_exact: ["ignorePlurals", "singleWordSynonym"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"alternativesAsExact\":[\"ignorePlurals\",\"singleWordSynonym\"]}"),
      JSON.parse(req.body)
    )
  end

  # set_numeric_attributes_for_filtering
  def test_set_settings115
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(numeric_attributes_for_filtering: ["quantity", "popularity"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"numericAttributesForFiltering\":[\"quantity\",\"popularity\"]}"), JSON.parse(req.body))
  end

  # enable_compression_of_integer_array
  def test_set_settings116
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(allow_compression_of_integer_array: true)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"allowCompressionOfIntegerArray\":true}"), JSON.parse(req.body))
  end

  # set_attributes_for_distinct
  def test_set_settings117
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(attribute_for_distinct: "url")
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeForDistinct\":\"url\"}"), JSON.parse(req.body))
  end

  # set_distinct
  def test_set_settings118
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(distinct: 1, attribute_for_distinct: "url")
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"distinct\":1,\"attributeForDistinct\":\"url\"}"), JSON.parse(req.body))
  end

  # set_replace_synonyms_in_highlights
  def test_set_settings119
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(replace_synonyms_in_highlight: false)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"replaceSynonymsInHighlight\":false}"), JSON.parse(req.body))
  end

  # set_min_proximity
  def test_set_settings120
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(min_proximity: 1))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"minProximity\":1}"), JSON.parse(req.body))
  end

  # set_default_field
  def test_set_settings121
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(response_fields: ["hits", "hitsPerPage", "nbPages", "page"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"responseFields\":[\"hits\",\"hitsPerPage\",\"nbPages\",\"page\"]}"),
      JSON.parse(req.body)
    )
  end

  # set_max_facet_hits
  def test_set_settings122
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(max_facet_hits: 10))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"maxFacetHits\":10}"), JSON.parse(req.body))
  end

  # set_attribute_criteria_computed_by_min_proximity
  def test_set_settings123
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(attribute_criteria_computed_by_min_proximity: true)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeCriteriaComputedByMinProximity\":true}"), JSON.parse(req.body))
  end

  # set_user_data
  def test_set_settings124
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        user_data: {:"extraData" => "This is the custom data that you want to store in your index"}
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"userData\":{\"extraData\":\"This is the custom data that you want to store in your index\"}}"),
      JSON.parse(req.body)
    )
  end

  # set_rendering_content
  def test_set_settings125
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        rendering_content: Algolia::Search::RenderingContent.new(
          facet_ordering: Algolia::Search::FacetOrdering.new(
            facets: Algolia::Search::Facets.new(order: ["size", "brand"]),
            values: {
              brand: Algolia::Search::Value.new(order: ["uniqlo"], hide: ["muji"], sort_remaining_by: "count"),
              size: Algolia::Search::Value.new(order: ["S", "M", "L"], sort_remaining_by: "hidden")
            }
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"renderingContent\":{\"facetOrdering\":{\"facets\":{\"order\":[\"size\",\"brand\"]},\"values\":{\"brand\":{\"order\":[\"uniqlo\"],\"hide\":[\"muji\"],\"sortRemainingBy\":\"count\"},\"size\":{\"order\":[\"S\",\"M\",\"L\"],\"sortRemainingBy\":\"hidden\"}}}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # updateApiKey
  def test_update_api_key
    req = @client.update_api_key_with_http_info(
      "ALGOLIA_API_KEY",
      Algolia::Search::ApiKey.new(
        acl: ["search", "addObject"],
        validity: 300,
        max_queries_per_ip_per_hour: 100,
        max_hits_per_query: 20
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/keys/ALGOLIA_API_KEY", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"acl\":[\"search\",\"addObject\"],\"validity\":300,\"maxQueriesPerIPPerHour\":100,\"maxHitsPerQuery\":20}"
      ),
      JSON.parse(req.body)
    )
  end

end
