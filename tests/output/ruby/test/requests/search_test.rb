# Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
require "algolia"
require "test/unit"

class TestSearchClient < Test::Unit::TestCase
  def setup
    @client = Algolia::SearchClient.create(
      "APP_ID",
      "API_KEY",

      {requester: Algolia::Transport::EchoRequester.new}
    )
  end

  # addApiKey
  def test_add_api_key
    req = @client.add_api_key_with_http_info(
      Algolia::Search::ApiKey.new(
        acl: ["search", "addObject"],
        description: "my new api key",
        validity: 300,
        max_queries_per_ip_per_hour: 100,
        max_hits_per_query: 20
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/keys", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"acl\":[\"search\",\"addObject\"],\"description\":\"my new api key\",\"validity\":300,\"maxQueriesPerIPPerHour\":100,\"maxHitsPerQuery\":20}"
      ),
      JSON.parse(req.body)
    )
  end

  # addOrUpdateObject
  def test_add_or_update_object
    req = @client.add_or_update_object_with_http_info("indexName", "uniqueID", {key: "value"})

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/uniqueID", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"key\":\"value\"}"), JSON.parse(req.body))
  end

  # appendSource
  def test_append_source
    req = @client.append_source_with_http_info(
      Algolia::Search::Source.new(source: "theSource", description: "theDescription")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/security/sources/append", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"source\":\"theSource\",\"description\":\"theDescription\"}"), JSON.parse(req.body))
  end

  # simple
  def test_assign_user_id
    req = @client.assign_user_id_with_http_info("user42", Algolia::Search::AssignUserIdParams.new(cluster: "d4242-eu"))

    assert_equal(:post, req.method)
    assert_equal("/1/clusters/mapping", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(
      ({:"x-algolia-user-id" => "user42"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )
    assert_equal(JSON.parse("{\"cluster\":\"d4242-eu\"}"), JSON.parse(req.body))
  end

  # it should not encode the userID
  def test_assign_user_id1
    req = @client.assign_user_id_with_http_info(
      "user id with spaces",
      Algolia::Search::AssignUserIdParams.new(cluster: "cluster with spaces")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/clusters/mapping", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(
      ({:"x-algolia-user-id" => "user id with spaces"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )
    assert_equal(JSON.parse("{\"cluster\":\"cluster with spaces\"}"), JSON.parse(req.body))
  end

  # addObject
  def test_batch
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::BatchWriteParams.new(
        requests: [
          Algolia::Search::BatchRequest.new(action: "addObject", body: {key: "bar", foo: "1"}),
          Algolia::Search::BatchRequest.new(action: "addObject", body: {key: "baz", foo: "2"})
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"action\":\"addObject\",\"body\":{\"key\":\"bar\",\"foo\":\"1\"}},{\"action\":\"addObject\",\"body\":{\"key\":\"baz\",\"foo\":\"2\"}}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # clear
  def test_batch1
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::BatchWriteParams.new(
        requests: [Algolia::Search::BatchRequest.new(action: "clear", body: {key: "value"})]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"clear\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # delete
  def test_batch2
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::BatchWriteParams.new(
        requests: [Algolia::Search::BatchRequest.new(action: "delete", body: {key: "value"})]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"delete\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # deleteObject
  def test_batch3
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::BatchWriteParams.new(
        requests: [Algolia::Search::BatchRequest.new(action: "deleteObject", body: {key: "value"})]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"deleteObject\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # partialUpdateObject
  def test_batch4
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::BatchWriteParams.new(
        requests: [Algolia::Search::BatchRequest.new(action: "partialUpdateObject", body: {key: "value"})]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"partialUpdateObject\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # partialUpdateObjectNoCreate
  def test_batch5
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::BatchWriteParams.new(
        requests: [Algolia::Search::BatchRequest.new(action: "partialUpdateObjectNoCreate", body: {key: "value"})]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"partialUpdateObjectNoCreate\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # updateObject
  def test_batch6
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::BatchWriteParams.new(
        requests: [Algolia::Search::BatchRequest.new(action: "updateObject", body: {key: "value"})]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"updateObject\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # batchAssignUserIds
  def test_batch_assign_user_ids
    req = @client.batch_assign_user_ids_with_http_info(
      "userID",
      Algolia::Search::BatchAssignUserIdsParams.new(cluster: "theCluster", users: ["user1", "user2"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/clusters/mapping/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(
      ({:"x-algolia-user-id" => "userID"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )
    assert_equal(JSON.parse("{\"cluster\":\"theCluster\",\"users\":[\"user1\",\"user2\"]}"), JSON.parse(req.body))
  end

  # replace
  def test_batch_dictionary_entries
    req = @client.batch_dictionary_entries_with_http_info(
      "plurals",
      Algolia::Search::BatchDictionaryEntriesParams.new(
        clear_existing_dictionary_entries: true,
        requests: [
          Algolia::Search::BatchDictionaryEntriesRequest.new(
            action: "addEntry",
            body: Algolia::Search::DictionaryEntry.new(
              algolia_object_id: "1",
              language: "en",
              word: "fancy",
              words: ["believe", "algolia"],
              decomposition: ["trust", "algolia"],
              state: "enabled"
            )
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/dictionaries/plurals/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"clearExistingDictionaryEntries\":true,\"requests\":[{\"action\":\"addEntry\",\"body\":{\"objectID\":\"1\",\"language\":\"en\",\"word\":\"fancy\",\"words\":[\"believe\",\"algolia\"],\"decomposition\":[\"trust\",\"algolia\"],\"state\":\"enabled\"}}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # delete
  def test_batch_dictionary_entries1
    req = @client.batch_dictionary_entries_with_http_info(
      "plurals",
      Algolia::Search::BatchDictionaryEntriesParams.new(
        clear_existing_dictionary_entries: true,
        requests: [
          Algolia::Search::BatchDictionaryEntriesRequest.new(
            action: "deleteEntry",
            body: Algolia::Search::DictionaryEntry.new(algolia_object_id: "1")
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/dictionaries/plurals/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"clearExistingDictionaryEntries\":true,\"requests\":[{\"action\":\"deleteEntry\",\"body\":{\"objectID\":\"1\"}}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # append
  def test_batch_dictionary_entries2
    req = @client.batch_dictionary_entries_with_http_info(
      "stopwords",
      Algolia::Search::BatchDictionaryEntriesParams.new(
        requests: [
          Algolia::Search::BatchDictionaryEntriesRequest.new(
            action: "addEntry",
            body: Algolia::Search::DictionaryEntry.new(algolia_object_id: "1", language: "en", additional: "try me")
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/dictionaries/stopwords/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"action\":\"addEntry\",\"body\":{\"objectID\":\"1\",\"language\":\"en\",\"additional\":\"try me\"}}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # browse with minimal parameters
  def test_browse
    req = @client.browse_with_http_info("cts_e2e_browse")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/cts_e2e_browse/browse", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # browse with search parameters
  def test_browse1
    req = @client.browse_with_http_info(
      "indexName",
      Algolia::Search::BrowseParamsObject.new(query: "myQuery", facet_filters: ["tags:algolia"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/browse", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"myQuery\",\"facetFilters\":[\"tags:algolia\"]}"), JSON.parse(req.body))
  end

  # browse allow a cursor in parameters
  def test_browse2
    req = @client.browse_with_http_info("indexName", Algolia::Search::BrowseParamsObject.new(cursor: "test"))

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/browse", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"cursor\":\"test\"}"), JSON.parse(req.body))
  end

  # clearObjects
  def test_clear_objects
    req = @client.clear_objects_with_http_info("theIndexName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/clear", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
  end

  # clearRules
  def test_clear_rules
    req = @client.clear_rules_with_http_info("indexName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/rules/clear", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
  end

  # clearSynonyms
  def test_clear_synonyms
    req = @client.clear_synonyms_with_http_info("indexName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/synonyms/clear", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
  end

  # allow del method for a custom path with minimal parameters
  def test_custom_delete
    req = @client.custom_delete_with_http_info("test/minimal")

    assert_equal(:delete, req.method)
    assert_equal("/test/minimal", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # allow del method for a custom path with all parameters
  def test_custom_delete1
    req = @client.custom_delete_with_http_info("test/all", {query: "parameters"})

    assert_equal(:delete, req.method)
    assert_equal("/test/all", req.path)
    assert_equal({:"query" => "parameters"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # allow get method for a custom path with minimal parameters
  def test_custom_get
    req = @client.custom_get_with_http_info("test/minimal")

    assert_equal(:get, req.method)
    assert_equal("/test/minimal", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # allow get method for a custom path with all parameters
  def test_custom_get1
    req = @client.custom_get_with_http_info("test/all", {query: "parameters with space"})

    assert_equal(:get, req.method)
    assert_equal("/test/all", req.path)
    assert_equal({:"query" => "parameters%20with%20space"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # requestOptions should be escaped too
  def test_custom_get2
    req = @client.custom_get_with_http_info(
      "test/all",
      {query: "to be overriden"},
      {
        :header_params => JSON.parse("{\"x-header-1\":\"spaces are left alone\"}", :symbolize_names => true),
        :query_params => JSON.parse(
          "{\"query\":\"parameters with space\",\"and an array\":[\"array\",\"with spaces\"]}",
          :symbolize_names => true
        )
      }
    )

    assert_equal(:get, req.method)
    assert_equal("/test/all", req.path)
    assert_equal(
      {:"query" => "parameters%20with%20space", :"and%20an%20array" => "array%2Cwith%20spaces"}.to_a,
      req.query_params.to_a
    )
    assert(
      ({:"x-header-1" => "spaces are left alone"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )

    assert(req.body.nil?, "body is not nil")
  end

  # allow post method for a custom path with minimal parameters
  def test_custom_post
    req = @client.custom_post_with_http_info("test/minimal")

    assert_equal(:post, req.method)
    assert_equal("/test/minimal", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # allow post method for a custom path with all parameters
  def test_custom_post1
    req = @client.custom_post_with_http_info("test/all", {query: "parameters"}, {body: "parameters"})

    assert_equal(:post, req.method)
    assert_equal("/test/all", req.path)
    assert_equal({:"query" => "parameters"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"body\":\"parameters\"}"), JSON.parse(req.body))
  end

  # requestOptions can override default query parameters
  def test_custom_post2
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"query\":\"myQueryParameter\"}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "myQueryParameter"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions merges query parameters with default ones
  def test_custom_post3
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"query2\":\"myQueryParameter\"}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"query2" => "myQueryParameter"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions can override default headers
  def test_custom_post4
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:header_params => JSON.parse("{\"x-algolia-api-key\":\"ALGOLIA_API_KEY\"}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters"}.to_a, req.query_params.to_a)
    assert(
      ({:"x-algolia-api-key" => "ALGOLIA_API_KEY"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions merges headers with default ones
  def test_custom_post5
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:header_params => JSON.parse("{\"x-algolia-api-key\":\"ALGOLIA_API_KEY\"}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters"}.to_a, req.query_params.to_a)
    assert(
      ({:"x-algolia-api-key" => "ALGOLIA_API_KEY"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions queryParameters accepts booleans
  def test_custom_post6
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"isItWorking\":true}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"isItWorking" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions queryParameters accepts integers
  def test_custom_post7
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"myParam\":2}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"myParam" => "2"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions queryParameters accepts list of string
  def test_custom_post8
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"myParam\":[\"b and c\",\"d\"]}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"myParam" => "b%20and%20c%2Cd"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions queryParameters accepts list of booleans
  def test_custom_post9
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"myParam\":[true,true,false]}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"myParam" => "true%2Ctrue%2Cfalse"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions queryParameters accepts list of integers
  def test_custom_post10
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"myParam\":[1,2]}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"myParam" => "1%2C2"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # allow put method for a custom path with minimal parameters
  def test_custom_put
    req = @client.custom_put_with_http_info("test/minimal")

    assert_equal(:put, req.method)
    assert_equal("/test/minimal", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # allow put method for a custom path with all parameters
  def test_custom_put1
    req = @client.custom_put_with_http_info("test/all", {query: "parameters"}, {body: "parameters"})

    assert_equal(:put, req.method)
    assert_equal("/test/all", req.path)
    assert_equal({:"query" => "parameters"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"body\":\"parameters\"}"), JSON.parse(req.body))
  end

  # deleteApiKey
  def test_delete_api_key
    req = @client.delete_api_key_with_http_info("myTestApiKey")

    assert_equal(:delete, req.method)
    assert_equal("/1/keys/myTestApiKey", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # deleteBy
  def test_delete_by
    req = @client.delete_by_with_http_info(
      "theIndexName",
      Algolia::Search::DeleteByParams.new(filters: "brand:brandName")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/deleteByQuery", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"filters\":\"brand:brandName\"}"), JSON.parse(req.body))
  end

  # deleteIndex
  def test_delete_index
    req = @client.delete_index_with_http_info("theIndexName")

    assert_equal(:delete, req.method)
    assert_equal("/1/indexes/theIndexName", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # deleteObject
  def test_delete_object
    req = @client.delete_object_with_http_info("<YOUR_INDEX_NAME>", "uniqueID")

    assert_equal(:delete, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/uniqueID", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # delete rule simple case
  def test_delete_rule
    req = @client.delete_rule_with_http_info("indexName", "id1")

    assert_equal(:delete, req.method)
    assert_equal("/1/indexes/indexName/rules/id1", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # delete rule with simple characters to encode in objectID
  def test_delete_rule1
    req = @client.delete_rule_with_http_info("indexName", "test/with/slash")

    assert_equal(:delete, req.method)
    assert_equal("/1/indexes/indexName/rules/test%2Fwith%2Fslash", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # deleteSource
  def test_delete_source
    req = @client.delete_source_with_http_info("theSource")

    assert_equal(:delete, req.method)
    assert_equal("/1/security/sources/theSource", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # deleteSynonym
  def test_delete_synonym
    req = @client.delete_synonym_with_http_info("indexName", "id1")

    assert_equal(:delete, req.method)
    assert_equal("/1/indexes/indexName/synonyms/id1", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getApiKey
  def test_get_api_key
    req = @client.get_api_key_with_http_info("myTestApiKey")

    assert_equal(:get, req.method)
    assert_equal("/1/keys/myTestApiKey", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getAppTask
  def test_get_app_task
    req = @client.get_app_task_with_http_info(123)

    assert_equal(:get, req.method)
    assert_equal("/1/task/123", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # get getDictionaryLanguages
  def test_get_dictionary_languages
    req = @client.get_dictionary_languages_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/dictionaries/*/languages", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # get getDictionarySettings results
  def test_get_dictionary_settings
    req = @client.get_dictionary_settings_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/dictionaries/*/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getLogs with minimal parameters
  def test_get_logs
    req = @client.get_logs_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/logs", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getLogs with parameters
  def test_get_logs1
    req = @client.get_logs_with_http_info(5, 10, "theIndexName", "all")

    assert_equal(:get, req.method)
    assert_equal("/1/logs", req.path)
    assert_equal(
      {:"offset" => "5", :"length" => "10", :"indexName" => "theIndexName", :"type" => "all"}.to_a,
      req.query_params.to_a
    )
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getObject
  def test_get_object
    req = @client.get_object_with_http_info("theIndexName", "uniqueID", ["attr1", "attr2"])

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/theIndexName/uniqueID", req.path)
    assert_equal({:"attributesToRetrieve" => "attr1%2Cattr2"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # search with a real object
  def test_get_object1
    req = @client.get_object_with_http_info("cts_e2e_browse", "Batman and Robin")

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/cts_e2e_browse/Batman%20and%20Robin", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getObjects
  def test_get_objects
    req = @client.get_objects_with_http_info(
      Algolia::Search::GetObjectsParams.new(
        requests: [
          Algolia::Search::GetObjectsRequest.new(
            attributes_to_retrieve: ["attr1", "attr2"],
            algolia_object_id: "uniqueID",
            index_name: "theIndexName"
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/objects", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"attributesToRetrieve\":[\"attr1\",\"attr2\"],\"objectID\":\"uniqueID\",\"indexName\":\"theIndexName\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # getRule
  def test_get_rule
    req = @client.get_rule_with_http_info("cts_e2e_browse", "qr-1725004648916")

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/cts_e2e_browse/rules/qr-1725004648916", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getSettings
  def test_get_settings
    req = @client.get_settings_with_http_info("cts_e2e_settings")

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/cts_e2e_settings/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getSources
  def test_get_sources
    req = @client.get_sources_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/security/sources", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getSynonym
  def test_get_synonym
    req = @client.get_synonym_with_http_info("indexName", "id1")

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/indexName/synonyms/id1", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getTask
  def test_get_task
    req = @client.get_task_with_http_info("theIndexName", 123)

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/theIndexName/task/123", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getTopUserIds
  def test_get_top_user_ids
    req = @client.get_top_user_ids_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping/top", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getUserId
  def test_get_user_id
    req = @client.get_user_id_with_http_info("uniqueID")

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping/uniqueID", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # hasPendingMappings with minimal parameters
  def test_has_pending_mappings
    req = @client.has_pending_mappings_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping/pending", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # hasPendingMappings with parameters
  def test_has_pending_mappings1
    req = @client.has_pending_mappings_with_http_info(true)

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping/pending", req.path)
    assert_equal({:"getClusters" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listApiKeys
  def test_list_api_keys
    req = @client.list_api_keys_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/keys", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listClusters
  def test_list_clusters
    req = @client.list_clusters_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/clusters", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listIndices with minimal parameters
  def test_list_indices
    req = @client.list_indices_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/indexes", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listIndices with parameters
  def test_list_indices1
    req = @client.list_indices_with_http_info(8, 3)

    assert_equal(:get, req.method)
    assert_equal("/1/indexes", req.path)
    assert_equal({:"page" => "8", :"hitsPerPage" => "3"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listUserIds with minimal parameters
  def test_list_user_ids
    req = @client.list_user_ids_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listUserIds with parameters
  def test_list_user_ids1
    req = @client.list_user_ids_with_http_info(8, 100)

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping", req.path)
    assert_equal({:"page" => "8", :"hitsPerPage" => "100"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # multipleBatch
  def test_multiple_batch
    req = @client.multiple_batch_with_http_info(
      Algolia::Search::BatchParams.new(
        requests: [
          Algolia::Search::MultipleBatchRequest.new(
            action: "addObject",
            body: {key: "value"},
            index_name: "theIndexName"
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"action\":\"addObject\",\"body\":{\"key\":\"value\"},\"indexName\":\"theIndexName\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # scopes
  def test_operation_index
    req = @client.operation_index_with_http_info(
      "<SOURCE_INDEX_NAME>",
      Algolia::Search::OperationIndexParams.new(
        operation: "move",
        destination: "<DESTINATION_INDEX_NAME>",
        scope: ["rules", "settings"]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"operation\":\"move\",\"destination\":\"<DESTINATION_INDEX_NAME>\",\"scope\":[\"rules\",\"settings\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # copy
  def test_operation_index1
    req = @client.operation_index_with_http_info(
      "<SOURCE_INDEX_NAME>",
      Algolia::Search::OperationIndexParams.new(operation: "copy", destination: "<DESTINATION_INDEX_NAME>")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"operation\":\"copy\",\"destination\":\"<DESTINATION_INDEX_NAME>\"}"),
      JSON.parse(req.body)
    )
  end

  # move
  def test_operation_index2
    req = @client.operation_index_with_http_info(
      "<SOURCE_INDEX_NAME>",
      Algolia::Search::OperationIndexParams.new(operation: "move", destination: "<DESTINATION_INDEX_NAME>")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"operation\":\"move\",\"destination\":\"<DESTINATION_INDEX_NAME>\"}"),
      JSON.parse(req.body)
    )
  end

  # Partial update with a new value for a string attribute
  def test_partial_update_object
    req = @client.partial_update_object_with_http_info("theIndexName", "uniqueID", {attributeId: "new value"})

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/uniqueID/partial", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeId\":\"new value\"}"), JSON.parse(req.body))
  end

  # Partial update with a new value for an integer attribute
  def test_partial_update_object1
    req = @client.partial_update_object_with_http_info("theIndexName", "uniqueID", {attributeId: 1})

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/uniqueID/partial", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeId\":1}"), JSON.parse(req.body))
  end

  # Partial update with a new value for a boolean attribute
  def test_partial_update_object2
    req = @client.partial_update_object_with_http_info("theIndexName", "uniqueID", {attributeId: true})

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/uniqueID/partial", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeId\":true}"), JSON.parse(req.body))
  end

  # Partial update with a new value for an array attribute
  def test_partial_update_object3
    req = @client.partial_update_object_with_http_info(
      "theIndexName",
      "uniqueID",
      {attributeId: ["one", "two", "three"]}
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/uniqueID/partial", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeId\":[\"one\",\"two\",\"three\"]}"), JSON.parse(req.body))
  end

  # Partial update with a new value for an object attribute
  def test_partial_update_object4
    req = @client.partial_update_object_with_http_info("theIndexName", "uniqueID", {attributeId: {nested: "value"}})

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/uniqueID/partial", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeId\":{\"nested\":\"value\"}}"), JSON.parse(req.body))
  end

  # with visible_by filter
  def test_partial_update_object5
    req = @client.partial_update_object_with_http_info(
      "theIndexName",
      "uniqueID",
      {visible_by: ["Angela", "group/Finance", "group/Shareholders"]}
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/uniqueID/partial", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"visible_by\":[\"Angela\",\"group/Finance\",\"group/Shareholders\"]}"),
      JSON.parse(req.body)
    )
  end

  # removeUserId
  def test_remove_user_id
    req = @client.remove_user_id_with_http_info("uniqueID")

    assert_equal(:delete, req.method)
    assert_equal("/1/clusters/mapping/uniqueID", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # replaceSources
  def test_replace_sources
    req = @client.replace_sources_with_http_info(
      [Algolia::Search::Source.new(source: "theSource", description: "theDescription")]
    )

    assert_equal(:put, req.method)
    assert_equal("/1/security/sources", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("[{\"source\":\"theSource\",\"description\":\"theDescription\"}]"), JSON.parse(req.body))
  end

  # restoreApiKey
  def test_restore_api_key
    req = @client.restore_api_key_with_http_info("ALGOLIA_API_KEY")

    assert_equal(:post, req.method)
    assert_equal("/1/keys/ALGOLIA_API_KEY/restore", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
  end

  # saveObject
  def test_save_object
    req = @client.save_object_with_http_info("<YOUR_INDEX_NAME>", {objectID: "id", test: "val"})

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"objectID\":\"id\",\"test\":\"val\"}"), JSON.parse(req.body))
  end

  # saveRule with minimal parameters
  def test_save_rule
    req = @client.save_rule_with_http_info(
      "indexName",
      "id1",
      Algolia::Search::Rule.new(
        algolia_object_id: "id1",
        conditions: [Algolia::Search::Condition.new(pattern: "apple", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(filters: "brand:xiaomi")
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/id1", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"id1\",\"conditions\":[{\"pattern\":\"apple\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"filters\":\"brand:xiaomi\"}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # saveRule with all parameters
  def test_save_rule1
    req = @client.save_rule_with_http_info(
      "indexName",
      "id1",
      Algolia::Search::Rule.new(
        algolia_object_id: "id1",
        conditions: [
          Algolia::Search::Condition.new(
            pattern: "apple",
            anchoring: "contains",
            alternatives: false,
            context: "search"
          )
        ],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            filters: "brand:apple",
            query: Algolia::Search::ConsequenceQueryObject.new(
              remove: ["algolia"],
              edits: [
                Algolia::Search::Edit.new(type: "remove", delete: "abc", insert: "cde"),
                Algolia::Search::Edit.new(type: "replace", delete: "abc", insert: "cde")
              ]
            )
          ),
          hide: [Algolia::Search::ConsequenceHide.new(algolia_object_id: "321")],
          filter_promotes: false,
          user_data: {algolia: "aloglia"},
          promote: [
            Algolia::Search::PromoteObjectID.new(algolia_object_id: "abc", position: 3),
            Algolia::Search::PromoteObjectIDs.new(object_ids: ["abc", "def"], position: 1)
          ]
        ),
        description: "test",
        enabled: true,
        validity: [Algolia::Search::TimeRange.new(from: 1656670273, _until: 1656670277)]
      ),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/id1", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"id1\",\"conditions\":[{\"pattern\":\"apple\",\"anchoring\":\"contains\",\"alternatives\":false,\"context\":\"search\"}],\"consequence\":{\"params\":{\"filters\":\"brand:apple\",\"query\":{\"remove\":[\"algolia\"],\"edits\":[{\"type\":\"remove\",\"delete\":\"abc\",\"insert\":\"cde\"},{\"type\":\"replace\",\"delete\":\"abc\",\"insert\":\"cde\"}]}},\"hide\":[{\"objectID\":\"321\"}],\"filterPromotes\":false,\"userData\":{\"algolia\":\"aloglia\"},\"promote\":[{\"objectID\":\"abc\",\"position\":3},{\"objectIDs\":[\"abc\",\"def\"],\"position\":1}]},\"description\":\"test\",\"enabled\":true,\"validity\":[{\"from\":1656670273,\"until\":1656670277}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # b2b catalog
  def test_save_rule2
    req = @client.save_rule_with_http_info(
      "indexName",
      "article-rule",
      Algolia::Search::Rule.new(
        algolia_object_id: "article-rule",
        conditions: [Algolia::Search::Condition.new(pattern: "article", anchoring: "startsWith")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            query: Algolia::Search::ConsequenceQueryObject.new(
              edits: [Algolia::Search::Edit.new(type: "remove", delete: "article")]
            ),
            restrict_searchable_attributes: ["title", "book_id"]
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/article-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"article-rule\",\"conditions\":[{\"pattern\":\"article\",\"anchoring\":\"startsWith\"}],\"consequence\":{\"params\":{\"query\":{\"edits\":[{\"type\":\"remove\",\"delete\":\"article\"}]},\"restrictSearchableAttributes\":[\"title\",\"book_id\"]}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # merchandising and promoting
  def test_save_rule3
    req = @client.save_rule_with_http_info(
      "indexName",
      "director-rule",
      Algolia::Search::Rule.new(
        algolia_object_id: "director-rule",
        conditions: [Algolia::Search::Condition.new(pattern: "{facet:director} director", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            restrict_searchable_attributes: ["title", "book_id"],
            automatic_facet_filters: [Algolia::Search::AutomaticFacetFilter.new(facet: "director")],
            query: Algolia::Search::ConsequenceQueryObject.new(
              edits: [Algolia::Search::Edit.new(type: "remove", delete: "director")]
            )
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/director-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"director-rule\",\"conditions\":[{\"pattern\":\"{facet:director} director\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"restrictSearchableAttributes\":[\"title\",\"book_id\"],\"automaticFacetFilters\":[{\"facet\":\"director\"}],\"query\":{\"edits\":[{\"type\":\"remove\",\"delete\":\"director\"}]}}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # harry potter
  def test_save_rule4
    req = @client.save_rule_with_http_info(
      "indexName",
      "harry-potter-rule",
      Algolia::Search::Rule.new(
        algolia_object_id: "harry-potter-rule",
        conditions: [Algolia::Search::Condition.new(pattern: "harry potter", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(user_data: {promo_content: "20% OFF on all Harry Potter books!"})
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/harry-potter-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"harry-potter-rule\",\"conditions\":[{\"pattern\":\"harry potter\",\"anchoring\":\"contains\"}],\"consequence\":{\"userData\":{\"promo_content\":\"20% OFF on all Harry Potter books!\"}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # merchandising empty query
  def test_save_rule5
    req = @client.save_rule_with_http_info(
      "indexName",
      "clearance-category-filter",
      Algolia::Search::Rule.new(
        algolia_object_id: "clearance-category-filter",
        conditions: [Algolia::Search::Condition.new(pattern: "", anchoring: "is", context: "landing")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(optional_filters: "clearance:true")
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/clearance-category-filter", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"clearance-category-filter\",\"conditions\":[{\"pattern\":\"\",\"anchoring\":\"is\",\"context\":\"landing\"}],\"consequence\":{\"params\":{\"optionalFilters\":\"clearance:true\"}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # redirect
  def test_save_rule6
    req = @client.save_rule_with_http_info(
      "indexName",
      "redirect-help-rule",
      Algolia::Search::Rule.new(
        algolia_object_id: "redirect-help-rule",
        conditions: [Algolia::Search::Condition.new(pattern: "help", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(user_data: {redirect: "https://www.algolia.com/support"})
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/redirect-help-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"redirect-help-rule\",\"conditions\":[{\"pattern\":\"help\",\"anchoring\":\"contains\"}],\"consequence\":{\"userData\":{\"redirect\":\"https://www.algolia.com/support\"}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # promote some results over others
  def test_save_rule7
    req = @client.save_rule_with_http_info(
      "indexName",
      "tomato-fruit",
      Algolia::Search::Rule.new(
        algolia_object_id: "tomato-fruit",
        conditions: [Algolia::Search::Condition.new(pattern: "tomato", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(optional_filters: "food_group:fruit")
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/tomato-fruit", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"tomato-fruit\",\"conditions\":[{\"pattern\":\"tomato\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"optionalFilters\":\"food_group:fruit\"}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # promote several hits
  def test_save_rule8
    req = @client.save_rule_with_http_info(
      "indexName",
      "Promote-Apple-Newest",
      Algolia::Search::Rule.new(
        algolia_object_id: "Promote-Apple-Newest",
        conditions: [Algolia::Search::Condition.new(pattern: "apple", anchoring: "is")],
        consequence: Algolia::Search::Consequence.new(
          promote: [Algolia::Search::PromoteObjectIDs.new(object_ids: ["iPhone-12345", "watch-123"], position: 0)]
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/Promote-Apple-Newest", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"Promote-Apple-Newest\",\"conditions\":[{\"pattern\":\"apple\",\"anchoring\":\"is\"}],\"consequence\":{\"promote\":[{\"objectIDs\":[\"iPhone-12345\",\"watch-123\"],\"position\":0}]}}"
      ),
      JSON.parse(req.body)
    )
  end

  # promote newest release
  def test_save_rule9
    req = @client.save_rule_with_http_info(
      "indexName",
      "Promote-iPhone-X",
      Algolia::Search::Rule.new(
        algolia_object_id: "Promote-iPhone-X",
        conditions: [Algolia::Search::Condition.new(pattern: "iPhone", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          promote: [Algolia::Search::PromoteObjectID.new(algolia_object_id: "iPhone-12345", position: 0)]
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/Promote-iPhone-X", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"Promote-iPhone-X\",\"conditions\":[{\"pattern\":\"iPhone\",\"anchoring\":\"contains\"}],\"consequence\":{\"promote\":[{\"objectID\":\"iPhone-12345\",\"position\":0}]}}"
      ),
      JSON.parse(req.body)
    )
  end

  # promote single item
  def test_save_rule10
    req = @client.save_rule_with_http_info(
      "indexName",
      "promote-harry-potter-box-set",
      Algolia::Search::Rule.new(
        algolia_object_id: "promote-harry-potter-box-set",
        conditions: [Algolia::Search::Condition.new(pattern: "Harry Potter", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          promote: [Algolia::Search::PromoteObjectID.new(algolia_object_id: "HP-12345", position: 0)]
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/promote-harry-potter-box-set", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"promote-harry-potter-box-set\",\"conditions\":[{\"pattern\":\"Harry Potter\",\"anchoring\":\"contains\"}],\"consequence\":{\"promote\":[{\"objectID\":\"HP-12345\",\"position\":0}]}}"
      ),
      JSON.parse(req.body)
    )
  end

  # limit search results
  def test_save_rule11
    req = @client.save_rule_with_http_info(
      "indexName",
      "article-rule",
      Algolia::Search::Rule.new(
        algolia_object_id: "article-rule",
        conditions: [Algolia::Search::Condition.new(pattern: "article", anchoring: "startsWith")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            query: Algolia::Search::ConsequenceQueryObject.new(
              edits: [Algolia::Search::Edit.new(type: "remove", delete: "article")]
            ),
            restrict_searchable_attributes: ["title", "book_id"]
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/article-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"article-rule\",\"conditions\":[{\"pattern\":\"article\",\"anchoring\":\"startsWith\"}],\"consequence\":{\"params\":{\"query\":{\"edits\":[{\"type\":\"remove\",\"delete\":\"article\"}]},\"restrictSearchableAttributes\":[\"title\",\"book_id\"]}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # query match
  def test_save_rule12
    req = @client.save_rule_with_http_info(
      "indexName",
      "tagged-brand-rule",
      Algolia::Search::Rule.new(
        conditions: [
          Algolia::Search::Condition.new(pattern: "brand: {facet:brand}", anchoring: "contains", alternatives: false)
        ],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            automatic_facet_filters: [Algolia::Search::AutomaticFacetFilter.new(facet: "brand")],
            query: Algolia::Search::ConsequenceQueryObject.new(remove: ["brand:", "{facet:brand}"])
          )
        ),
        description: "filter on brand: {brand}",
        algolia_object_id: "tagged-brand-rule"
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/tagged-brand-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"conditions\":[{\"pattern\":\"brand: {facet:brand}\",\"anchoring\":\"contains\",\"alternatives\":false}],\"consequence\":{\"params\":{\"automaticFacetFilters\":[{\"facet\":\"brand\"}],\"query\":{\"remove\":[\"brand:\",\"{facet:brand}\"]}}},\"description\":\"filter on brand: {brand}\",\"objectID\":\"tagged-brand-rule\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # dynamic filtering
  def test_save_rule13
    req = @client.save_rule_with_http_info(
      "indexName",
      "color-facets",
      Algolia::Search::Rule.new(
        algolia_object_id: "color-facets",
        conditions: [Algolia::Search::Condition.new(pattern: "{facet:color}")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            automatic_facet_filters: [Algolia::Search::AutomaticFacetFilter.new(facet: "color")]
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/color-facets", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"color-facets\",\"conditions\":[{\"pattern\":\"{facet:color}\"}],\"consequence\":{\"params\":{\"automaticFacetFilters\":[{\"facet\":\"color\"}]}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # hide hits
  def test_save_rule14
    req = @client.save_rule_with_http_info(
      "indexName",
      "hide-12345",
      Algolia::Search::Rule.new(
        algolia_object_id: "hide-12345",
        conditions: [Algolia::Search::Condition.new(pattern: "cheap", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          hide: [Algolia::Search::ConsequenceHide.new(algolia_object_id: "to-hide-12345")]
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/hide-12345", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"hide-12345\",\"conditions\":[{\"pattern\":\"cheap\",\"anchoring\":\"contains\"}],\"consequence\":{\"hide\":[{\"objectID\":\"to-hide-12345\"}]}}"
      ),
      JSON.parse(req.body)
    )
  end

  # one rule per facet
  def test_save_rule15
    req = @client.save_rule_with_http_info(
      "indexName",
      "red-color",
      Algolia::Search::Rule.new(
        algolia_object_id: "red-color",
        conditions: [Algolia::Search::Condition.new(pattern: "red", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            query: Algolia::Search::ConsequenceQueryObject.new(remove: ["red"]),
            filters: "color:red"
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/red-color", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"red-color\",\"conditions\":[{\"pattern\":\"red\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"query\":{\"remove\":[\"red\"]},\"filters\":\"color:red\"}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # numerical filters
  def test_save_rule16
    req = @client.save_rule_with_http_info(
      "indexName",
      "cheap",
      Algolia::Search::Rule.new(
        algolia_object_id: "cheap",
        conditions: [Algolia::Search::Condition.new(pattern: "cheap", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            query: Algolia::Search::ConsequenceQueryObject.new(remove: ["cheap"]),
            filters: "price < 10"
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/cheap", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"cheap\",\"conditions\":[{\"pattern\":\"cheap\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"query\":{\"remove\":[\"cheap\"]},\"filters\":\"price < 10\"}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # negative filters
  def test_save_rule17
    req = @client.save_rule_with_http_info(
      "indexName",
      "gluten-free-rule",
      Algolia::Search::Rule.new(
        algolia_object_id: "gluten-free-rule",
        conditions: [Algolia::Search::Condition.new(pattern: "gluten-free", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            filters: "NOT allergens:gluten",
            query: Algolia::Search::ConsequenceQueryObject.new(
              edits: [Algolia::Search::Edit.new(type: "remove", delete: "gluten-free")]
            )
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/gluten-free-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"gluten-free-rule\",\"conditions\":[{\"pattern\":\"gluten-free\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"filters\":\"NOT allergens:gluten\",\"query\":{\"edits\":[{\"type\":\"remove\",\"delete\":\"gluten-free\"}]}}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # positive filters
  def test_save_rule18
    req = @client.save_rule_with_http_info(
      "indexName",
      "diet-rule",
      Algolia::Search::Rule.new(
        algolia_object_id: "diet-rule",
        conditions: [Algolia::Search::Condition.new(pattern: "diet", anchoring: "contains")],
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            filters: "'low-carb' OR 'low-fat'",
            query: Algolia::Search::ConsequenceQueryObject.new(
              edits: [Algolia::Search::Edit.new(type: "remove", delete: "diet")]
            )
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/diet-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"diet-rule\",\"conditions\":[{\"pattern\":\"diet\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"filters\":\"'low-carb' OR 'low-fat'\",\"query\":{\"edits\":[{\"type\":\"remove\",\"delete\":\"diet\"}]}}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # conditionless
  def test_save_rule19
    req = @client.save_rule_with_http_info(
      "indexName",
      "diet-rule",
      Algolia::Search::Rule.new(
        algolia_object_id: "diet-rule",
        consequence: Algolia::Search::Consequence.new(
          params: Algolia::Search::ConsequenceParams.new(
            filters: "'low-carb' OR 'low-fat'",
            query: Algolia::Search::ConsequenceQueryObject.new(
              edits: [Algolia::Search::Edit.new(type: "remove", delete: "diet")]
            )
          )
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/diet-rule", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"diet-rule\",\"consequence\":{\"params\":{\"filters\":\"'low-carb' OR 'low-fat'\",\"query\":{\"edits\":[{\"type\":\"remove\",\"delete\":\"diet\"}]}}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # saveRules with minimal parameters
  def test_save_rules
    req = @client.save_rules_with_http_info(
      "<YOUR_INDEX_NAME>",
      [
        Algolia::Search::Rule.new(
          algolia_object_id: "a-rule-id",
          conditions: [Algolia::Search::Condition.new(pattern: "smartphone", anchoring: "contains")],
          consequence: Algolia::Search::Consequence.new(
            params: Algolia::Search::ConsequenceParams.new(filters: "brand:apple")
          )
        ),
        Algolia::Search::Rule.new(
          algolia_object_id: "a-second-rule-id",
          conditions: [Algolia::Search::Condition.new(pattern: "apple", anchoring: "contains")],
          consequence: Algolia::Search::Consequence.new(
            params: Algolia::Search::ConsequenceParams.new(filters: "brand:samsung")
          )
        )
      ],
      false,
      true
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch", req.path)
    assert_equal({:"forwardToReplicas" => "false", :"clearExistingRules" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "[{\"objectID\":\"a-rule-id\",\"conditions\":[{\"pattern\":\"smartphone\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"filters\":\"brand:apple\"}}},{\"objectID\":\"a-second-rule-id\",\"conditions\":[{\"pattern\":\"apple\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"filters\":\"brand:samsung\"}}}]"
      ),
      JSON.parse(req.body)
    )
  end

  # saveRules with all parameters
  def test_save_rules1
    req = @client.save_rules_with_http_info(
      "<YOUR_INDEX_NAME>",
      [
        Algolia::Search::Rule.new(
          algolia_object_id: "id1",
          conditions: [
            Algolia::Search::Condition.new(
              pattern: "apple",
              anchoring: "contains",
              alternatives: false,
              context: "search"
            )
          ],
          consequence: Algolia::Search::Consequence.new(
            params: Algolia::Search::ConsequenceParams.new(
              filters: "brand:apple",
              query: Algolia::Search::ConsequenceQueryObject.new(
                remove: ["algolia"],
                edits: [
                  Algolia::Search::Edit.new(type: "remove", delete: "abc", insert: "cde"),
                  Algolia::Search::Edit.new(type: "replace", delete: "abc", insert: "cde")
                ]
              )
            ),
            hide: [Algolia::Search::ConsequenceHide.new(algolia_object_id: "321")],
            filter_promotes: false,
            user_data: {algolia: "aloglia"},
            promote: [
              Algolia::Search::PromoteObjectID.new(algolia_object_id: "abc", position: 3),
              Algolia::Search::PromoteObjectIDs.new(object_ids: ["abc", "def"], position: 1)
            ]
          ),
          description: "test",
          enabled: true,
          validity: [Algolia::Search::TimeRange.new(from: 1656670273, _until: 1656670277)]
        )
      ],
      true,
      true
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch", req.path)
    assert_equal({:"forwardToReplicas" => "true", :"clearExistingRules" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "[{\"objectID\":\"id1\",\"conditions\":[{\"pattern\":\"apple\",\"anchoring\":\"contains\",\"alternatives\":false,\"context\":\"search\"}],\"consequence\":{\"params\":{\"filters\":\"brand:apple\",\"query\":{\"remove\":[\"algolia\"],\"edits\":[{\"type\":\"remove\",\"delete\":\"abc\",\"insert\":\"cde\"},{\"type\":\"replace\",\"delete\":\"abc\",\"insert\":\"cde\"}]}},\"hide\":[{\"objectID\":\"321\"}],\"filterPromotes\":false,\"userData\":{\"algolia\":\"aloglia\"},\"promote\":[{\"objectID\":\"abc\",\"position\":3},{\"objectIDs\":[\"abc\",\"def\"],\"position\":1}]},\"description\":\"test\",\"enabled\":true,\"validity\":[{\"from\":1656670273,\"until\":1656670277}]}]"
      ),
      JSON.parse(req.body)
    )
  end

  # dynamic filtering
  def test_save_rules2
    req = @client.save_rules_with_http_info(
      "<YOUR_INDEX_NAME>",
      [
        Algolia::Search::Rule.new(
          algolia_object_id: "toaster",
          conditions: [Algolia::Search::Condition.new(pattern: "toaster", anchoring: "contains")],
          consequence: Algolia::Search::Consequence.new(
            params: Algolia::Search::ConsequenceParams.new(
              query: Algolia::Search::ConsequenceQueryObject.new(remove: ["toaster"]),
              filters: "product_type:toaster"
            )
          )
        ),
        Algolia::Search::Rule.new(
          algolia_object_id: "cheap",
          conditions: [Algolia::Search::Condition.new(pattern: "cheap", anchoring: "contains")],
          consequence: Algolia::Search::Consequence.new(
            params: Algolia::Search::ConsequenceParams.new(
              query: Algolia::Search::ConsequenceQueryObject.new(remove: ["cheap"]),
              filters: "price < 15"
            )
          )
        )
      ]
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "[{\"objectID\":\"toaster\",\"conditions\":[{\"pattern\":\"toaster\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"query\":{\"remove\":[\"toaster\"]},\"filters\":\"product_type:toaster\"}}},{\"objectID\":\"cheap\",\"conditions\":[{\"pattern\":\"cheap\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"query\":{\"remove\":[\"cheap\"]},\"filters\":\"price < 15\"}}}]"
      ),
      JSON.parse(req.body)
    )
  end

  # enhance search results
  def test_save_rules3
    req = @client.save_rules_with_http_info(
      "<YOUR_INDEX_NAME>",
      [
        Algolia::Search::Rule.new(
          algolia_object_id: "country",
          conditions: [Algolia::Search::Condition.new(pattern: "{facet:country}", anchoring: "contains")],
          consequence: Algolia::Search::Consequence.new(
            params: Algolia::Search::ConsequenceParams.new(around_lat_lng_via_ip: false)
          )
        ),
        Algolia::Search::Rule.new(
          algolia_object_id: "city",
          conditions: [Algolia::Search::Condition.new(pattern: "{facet:city}", anchoring: "contains")],
          consequence: Algolia::Search::Consequence.new(
            params: Algolia::Search::ConsequenceParams.new(around_lat_lng_via_ip: false)
          )
        )
      ]
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "[{\"objectID\":\"country\",\"conditions\":[{\"pattern\":\"{facet:country}\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"aroundLatLngViaIP\":false}}},{\"objectID\":\"city\",\"conditions\":[{\"pattern\":\"{facet:city}\",\"anchoring\":\"contains\"}],\"consequence\":{\"params\":{\"aroundLatLngViaIP\":false}}}]"
      ),
      JSON.parse(req.body)
    )
  end

  # saveSynonym
  def test_save_synonym
    req = @client.save_synonym_with_http_info(
      "indexName",
      "id1",
      Algolia::Search::SynonymHit.new(algolia_object_id: "id1", type: "synonym", synonyms: ["car", "vehicule", "auto"]),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/synonyms/id1", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"objectID\":\"id1\",\"type\":\"synonym\",\"synonyms\":[\"car\",\"vehicule\",\"auto\"]}"),
      JSON.parse(req.body)
    )
  end

  # saveSynonyms
  def test_save_synonyms
    req = @client.save_synonyms_with_http_info(
      "<YOUR_INDEX_NAME>",
      [
        Algolia::Search::SynonymHit.new(
          algolia_object_id: "id1",
          type: "synonym",
          synonyms: ["car", "vehicule", "auto"]
        ),
        Algolia::Search::SynonymHit.new(
          algolia_object_id: "id2",
          type: "onewaysynonym",
          input: "iphone",
          synonyms: ["ephone", "aphone", "yphone"]
        )
      ],
      true,
      true
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/synonyms/batch", req.path)
    assert_equal({:"forwardToReplicas" => "true", :"replaceExistingSynonyms" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "[{\"objectID\":\"id1\",\"type\":\"synonym\",\"synonyms\":[\"car\",\"vehicule\",\"auto\"]},{\"objectID\":\"id2\",\"type\":\"onewaysynonym\",\"input\":\"iphone\",\"synonyms\":[\"ephone\",\"aphone\",\"yphone\"]}]"
      ),
      JSON.parse(req.body)
    )
  end

  # withHitsPerPage
  def test_search
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(index_name: "<YOUR_INDEX_NAME>", query: "<YOUR_QUERY>", hits_per_page: 50)
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"hitsPerPage\":50}]}"),
      JSON.parse(req.body)
    )
  end

  # filterOnly
  def test_search1
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            index_name: "<YOUR_INDEX_NAME>",
            query: "<YOUR_QUERY>",
            filters: "actor:Scarlett Johansson"
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"filters\":\"actor:Scarlett Johansson\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # filterOr
  def test_search2
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            index_name: "<YOUR_INDEX_NAME>",
            query: "<YOUR_QUERY>",
            filters: "actor:Tom Cruise OR actor:Scarlett Johansson"
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"filters\":\"actor:Tom Cruise OR actor:Scarlett Johansson\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # filterNot
  def test_search3
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            index_name: "<YOUR_INDEX_NAME>",
            query: "<YOUR_QUERY>",
            filters: "NOT actor:Nicolas Cage"
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"filters\":\"NOT actor:Nicolas Cage\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # search for a single hits request with minimal parameters
  def test_search4
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [Algolia::Search::SearchForHits.new(index_name: "cts_e2e_search_empty_index")]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"requests\":[{\"indexName\":\"cts_e2e_search_empty_index\"}]}"), JSON.parse(req.body))
  end

  # search with highlight and snippet results
  def test_search5
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            index_name: "cts_e2e_highlight_snippet_results",
            query: "vim",
            attributes_to_snippet: ["*:20"],
            attributes_to_highlight: ["*"],
            attributes_to_retrieve: ["*"]
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"cts_e2e_highlight_snippet_results\",\"query\":\"vim\",\"attributesToSnippet\":[\"*:20\"],\"attributesToHighlight\":[\"*\"],\"attributesToRetrieve\":[\"*\"]}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # retrieveFacets
  def test_search6
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            index_name: "<YOUR_INDEX_NAME>",
            query: "<YOUR_QUERY>",
            facets: ["author", "genre"]
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"facets\":[\"author\",\"genre\"]}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # retrieveFacetsWildcard
  def test_search7
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(index_name: "<YOUR_INDEX_NAME>", query: "<YOUR_QUERY>", facets: ["*"])
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"facets\":[\"*\"]}]}"),
      JSON.parse(req.body)
    )
  end

  # search for a single facet request with minimal parameters
  def test_search8
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForFacets.new(index_name: "cts_e2e_search_facet", type: "facet", facet: "editor")
        ],
        strategy: "stopIfEnoughMatches"
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"cts_e2e_search_facet\",\"type\":\"facet\",\"facet\":\"editor\"}],\"strategy\":\"stopIfEnoughMatches\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # search for a single hits request with all parameters
  def test_search9
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            index_name: "theIndexName",
            query: "myQuery",
            hits_per_page: 50,
            type: "default"
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"theIndexName\",\"query\":\"myQuery\",\"hitsPerPage\":50,\"type\":\"default\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # search for a single facet request with all parameters
  def test_search10
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForFacets.new(
            index_name: "theIndexName",
            type: "facet",
            facet: "theFacet",
            facet_query: "theFacetQuery",
            query: "theQuery",
            max_facet_hits: 50
          )
        ],
        strategy: "stopIfEnoughMatches"
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"theIndexName\",\"type\":\"facet\",\"facet\":\"theFacet\",\"facetQuery\":\"theFacetQuery\",\"query\":\"theQuery\",\"maxFacetHits\":50}],\"strategy\":\"stopIfEnoughMatches\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # search for multiple mixed requests in multiple indices with minimal parameters
  def test_search11
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(index_name: "theIndexName"),
          Algolia::Search::SearchForFacets.new(index_name: "theIndexName2", type: "facet", facet: "theFacet"),
          Algolia::Search::SearchForHits.new(index_name: "theIndexName", type: "default")
        ],
        strategy: "stopIfEnoughMatches"
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"theIndexName\"},{\"indexName\":\"theIndexName2\",\"type\":\"facet\",\"facet\":\"theFacet\"},{\"indexName\":\"theIndexName\",\"type\":\"default\"}],\"strategy\":\"stopIfEnoughMatches\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # search for multiple mixed requests in multiple indices with all parameters
  def test_search12
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForFacets.new(
            index_name: "theIndexName",
            type: "facet",
            facet: "theFacet",
            facet_query: "theFacetQuery",
            query: "theQuery",
            max_facet_hits: 50
          ),
          Algolia::Search::SearchForHits.new(
            index_name: "theIndexName",
            query: "myQuery",
            hits_per_page: 50,
            type: "default"
          )
        ],
        strategy: "stopIfEnoughMatches"
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"theIndexName\",\"type\":\"facet\",\"facet\":\"theFacet\",\"facetQuery\":\"theFacetQuery\",\"query\":\"theQuery\",\"maxFacetHits\":50},{\"indexName\":\"theIndexName\",\"query\":\"myQuery\",\"hitsPerPage\":50,\"type\":\"default\"}],\"strategy\":\"stopIfEnoughMatches\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # search filters accept all of the possible shapes
  def test_search13
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            index_name: "theIndexName",
            facet_filters: "mySearch:filters",
            re_ranking_apply_filter: "mySearch:filters",
            tag_filters: "mySearch:filters",
            numeric_filters: "mySearch:filters",
            optional_filters: "mySearch:filters"
          ),
          Algolia::Search::SearchForHits.new(
            index_name: "theIndexName",
            facet_filters: ["mySearch:filters", ["mySearch:filters", ["mySearch:filters"]]],
            re_ranking_apply_filter: ["mySearch:filters", ["mySearch:filters"]],
            tag_filters: ["mySearch:filters", ["mySearch:filters"]],
            numeric_filters: ["mySearch:filters", ["mySearch:filters"]],
            optional_filters: ["mySearch:filters", ["mySearch:filters"]]
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"theIndexName\",\"facetFilters\":\"mySearch:filters\",\"reRankingApplyFilter\":\"mySearch:filters\",\"tagFilters\":\"mySearch:filters\",\"numericFilters\":\"mySearch:filters\",\"optionalFilters\":\"mySearch:filters\"},{\"indexName\":\"theIndexName\",\"facetFilters\":[\"mySearch:filters\",[\"mySearch:filters\",[\"mySearch:filters\"]]],\"reRankingApplyFilter\":[\"mySearch:filters\",[\"mySearch:filters\"]],\"tagFilters\":[\"mySearch:filters\",[\"mySearch:filters\"]],\"numericFilters\":[\"mySearch:filters\",[\"mySearch:filters\"]],\"optionalFilters\":[\"mySearch:filters\",[\"mySearch:filters\"]]}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # search filters end to end
  def test_search14
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            index_name: "cts_e2e_search_facet",
            filters: "editor:'visual studio' OR editor:neovim"
          ),
          Algolia::Search::SearchForHits.new(
            index_name: "cts_e2e_search_facet",
            facet_filters: ["editor:'visual studio'", "editor:neovim"]
          ),
          Algolia::Search::SearchForHits.new(
            index_name: "cts_e2e_search_facet",
            facet_filters: ["editor:'visual studio'", ["editor:neovim"]]
          ),
          Algolia::Search::SearchForHits.new(
            index_name: "cts_e2e_search_facet",
            facet_filters: ["editor:'visual studio'", ["editor:neovim", ["editor:goland"]]]
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"cts_e2e_search_facet\",\"filters\":\"editor:'visual studio' OR editor:neovim\"},{\"indexName\":\"cts_e2e_search_facet\",\"facetFilters\":[\"editor:'visual studio'\",\"editor:neovim\"]},{\"indexName\":\"cts_e2e_search_facet\",\"facetFilters\":[\"editor:'visual studio'\",[\"editor:neovim\"]]},{\"indexName\":\"cts_e2e_search_facet\",\"facetFilters\":[\"editor:'visual studio'\",[\"editor:neovim\",[\"editor:goland\"]]]}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # search with all search parameters
  def test_search15
    req = @client.search_with_http_info(
      Algolia::Search::SearchMethodParams.new(
        requests: [
          Algolia::Search::SearchForHits.new(
            advanced_syntax: true,
            advanced_syntax_features: ["exactPhrase"],
            allow_typos_on_numeric_tokens: true,
            alternatives_as_exact: ["multiWordsSynonym"],
            analytics: true,
            analytics_tags: [""],
            around_lat_lng: "",
            around_lat_lng_via_ip: true,
            around_precision: 0,
            around_radius: "all",
            attribute_criteria_computed_by_min_proximity: true,
            attributes_to_highlight: [""],
            attributes_to_retrieve: [""],
            attributes_to_snippet: [""],
            click_analytics: true,
            decompound_query: true,
            disable_exact_on_attributes: [""],
            disable_typo_tolerance_on_attributes: [""],
            distinct: 0,
            enable_ab_test: true,
            enable_personalization: true,
            enable_re_ranking: true,
            enable_rules: true,
            exact_on_single_word_query: "attribute",
            facet_filters: [""],
            faceting_after_distinct: true,
            facets: [""],
            filters: "",
            get_ranking_info: true,
            highlight_post_tag: "",
            highlight_pre_tag: "",
            hits_per_page: 1,
            ignore_plurals: false,
            index_name: "theIndexName",
            inside_bounding_box: [[47.3165, 4.9665, 47.3424, 5.0201], [40.9234, 2.1185, 38.643, 1.9916]],
            inside_polygon: [
              [47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9],
              [40.9234, 2.1185, 38.643, 1.9916, 39.2587, 2.0104]
            ],
            length: 1,
            max_values_per_facet: 0,
            min_proximity: 1,
            min_word_sizefor1_typo: 0,
            min_word_sizefor2_typos: 0,
            minimum_around_radius: 1,
            natural_languages: ["fr"],
            numeric_filters: [""],
            offset: 0,
            optional_filters: [""],
            optional_words: [""],
            page: 0,
            percentile_computation: true,
            personalization_impact: 0,
            query: "",
            query_languages: ["fr"],
            query_type: "prefixAll",
            ranking: [""],
            re_ranking_apply_filter: [""],
            relevancy_strictness: 0,
            remove_stop_words: true,
            remove_words_if_no_results: "allOptional",
            rendering_content: Algolia::Search::RenderingContent.new(
              facet_ordering: Algolia::Search::FacetOrdering.new(
                facets: Algolia::Search::Facets.new(order: ["a", "b"]),
                values: {a: Algolia::Search::Value.new(order: ["b"], sort_remaining_by: "count")}
              )
            ),
            replace_synonyms_in_highlight: true,
            response_fields: [""],
            restrict_highlight_and_snippet_arrays: true,
            restrict_searchable_attributes: [""],
            rule_contexts: [""],
            similar_query: "",
            snippet_ellipsis_text: "",
            sort_facet_values_by: "",
            sum_or_filters_scores: true,
            synonyms: true,
            tag_filters: [""],
            type: "default",
            typo_tolerance: "min",
            user_token: ""
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"advancedSyntax\":true,\"advancedSyntaxFeatures\":[\"exactPhrase\"],\"allowTyposOnNumericTokens\":true,\"alternativesAsExact\":[\"multiWordsSynonym\"],\"analytics\":true,\"analyticsTags\":[\"\"],\"aroundLatLng\":\"\",\"aroundLatLngViaIP\":true,\"aroundPrecision\":0,\"aroundRadius\":\"all\",\"attributeCriteriaComputedByMinProximity\":true,\"attributesToHighlight\":[\"\"],\"attributesToRetrieve\":[\"\"],\"attributesToSnippet\":[\"\"],\"clickAnalytics\":true,\"decompoundQuery\":true,\"disableExactOnAttributes\":[\"\"],\"disableTypoToleranceOnAttributes\":[\"\"],\"distinct\":0,\"enableABTest\":true,\"enablePersonalization\":true,\"enableReRanking\":true,\"enableRules\":true,\"exactOnSingleWordQuery\":\"attribute\",\"facetFilters\":[\"\"],\"facetingAfterDistinct\":true,\"facets\":[\"\"],\"filters\":\"\",\"getRankingInfo\":true,\"highlightPostTag\":\"\",\"highlightPreTag\":\"\",\"hitsPerPage\":1,\"ignorePlurals\":false,\"indexName\":\"theIndexName\",\"insideBoundingBox\":[[47.3165,4.9665,47.3424,5.0201],[40.9234,2.1185,38.643,1.9916]],\"insidePolygon\":[[47.3165,4.9665,47.3424,5.0201,47.32,4.9],[40.9234,2.1185,38.643,1.9916,39.2587,2.0104]],\"length\":1,\"maxValuesPerFacet\":0,\"minProximity\":1,\"minWordSizefor1Typo\":0,\"minWordSizefor2Typos\":0,\"minimumAroundRadius\":1,\"naturalLanguages\":[\"fr\"],\"numericFilters\":[\"\"],\"offset\":0,\"optionalFilters\":[\"\"],\"optionalWords\":[\"\"],\"page\":0,\"percentileComputation\":true,\"personalizationImpact\":0,\"query\":\"\",\"queryLanguages\":[\"fr\"],\"queryType\":\"prefixAll\",\"ranking\":[\"\"],\"reRankingApplyFilter\":[\"\"],\"relevancyStrictness\":0,\"removeStopWords\":true,\"removeWordsIfNoResults\":\"allOptional\",\"renderingContent\":{\"facetOrdering\":{\"facets\":{\"order\":[\"a\",\"b\"]},\"values\":{\"a\":{\"order\":[\"b\"],\"sortRemainingBy\":\"count\"}}}},\"replaceSynonymsInHighlight\":true,\"responseFields\":[\"\"],\"restrictHighlightAndSnippetArrays\":true,\"restrictSearchableAttributes\":[\"\"],\"ruleContexts\":[\"\"],\"similarQuery\":\"\",\"snippetEllipsisText\":\"\",\"sortFacetValuesBy\":\"\",\"sumOrFiltersScores\":true,\"synonyms\":true,\"tagFilters\":[\"\"],\"type\":\"default\",\"typoTolerance\":\"min\",\"userToken\":\"\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # get searchDictionaryEntries results with minimal parameters
  def test_search_dictionary_entries
    req = @client.search_dictionary_entries_with_http_info(
      "stopwords",
      Algolia::Search::SearchDictionaryEntriesParams.new(query: "about")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/dictionaries/stopwords/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"about\"}"), JSON.parse(req.body))
  end

  # get searchDictionaryEntries results with all parameters
  def test_search_dictionary_entries1
    req = @client.search_dictionary_entries_with_http_info(
      "compounds",
      Algolia::Search::SearchDictionaryEntriesParams.new(query: "foo", page: 4, hits_per_page: 2, language: "fr")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/dictionaries/compounds/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"foo\",\"page\":4,\"hitsPerPage\":2,\"language\":\"fr\"}"),
      JSON.parse(req.body)
    )
  end

  # get searchForFacetValues results with minimal parameters
  def test_search_for_facet_values
    req = @client.search_for_facet_values_with_http_info("indexName", "facetName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/facets/facetName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # get searchForFacetValues results with all parameters
  def test_search_for_facet_values1
    req = @client.search_for_facet_values_with_http_info(
      "indexName",
      "facetName",
      Algolia::Search::SearchForFacetValuesRequest.new(
        params: "query=foo&facetFilters=['bar']",
        facet_query: "foo",
        max_facet_hits: 42
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/facets/facetName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"params\":\"query=foo&facetFilters=['bar']\",\"facetQuery\":\"foo\",\"maxFacetHits\":42}"),
      JSON.parse(req.body)
    )
  end

  # searchRules
  def test_search_rules
    req = @client.search_rules_with_http_info("cts_e2e_browse", Algolia::Search::SearchRulesParams.new(query: "zorro"))

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/cts_e2e_browse/rules/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"zorro\"}"), JSON.parse(req.body))
  end

  # search with minimal parameters
  def test_search_single_index
    req = @client.search_single_index_with_http_info("indexName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # search with special characters in indexName
  def test_search_single_index1
    req = @client.search_single_index_with_http_info("cts_e2e_space in index")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/cts_e2e_space%20in%20index/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # search with searchParams
  def test_search_single_index2
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "myQuery", facet_filters: ["tags:algolia"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"myQuery\",\"facetFilters\":[\"tags:algolia\"]}"), JSON.parse(req.body))
  end

  # single search retrieve snippets
  def test_search_single_index3
    req = @client.search_single_index_with_http_info(
      "cts_e2e_browse",
      Algolia::Search::SearchParamsObject.new(
        query: "batman mask of the phantasm",
        attributes_to_retrieve: ["*"],
        attributes_to_snippet: ["*:20"]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/cts_e2e_browse/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"query\":\"batman mask of the phantasm\",\"attributesToRetrieve\":[\"*\"],\"attributesToSnippet\":[\"*:20\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # query
  def test_search_single_index4
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(query: "phone")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"phone\"}"), JSON.parse(req.body))
  end

  # filters
  def test_search_single_index5
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(filters: "country:US AND price.gross < 2.0")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"filters\":\"country:US AND price.gross < 2.0\"}"), JSON.parse(req.body))
  end

  # distinct
  def test_search_single_index6
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(distinct: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"distinct\":true}"), JSON.parse(req.body))
  end

  # filtersNumeric
  def test_search_single_index7
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(filters: "price < 10")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"filters\":\"price < 10\"}"), JSON.parse(req.body))
  end

  # filtersTimestamp
  def test_search_single_index8
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(filters: "NOT date_timestamp:1514764800 TO 1546300799")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"filters\":\"NOT date_timestamp:1514764800 TO 1546300799\"}"), JSON.parse(req.body))
  end

  # filtersSumOrFiltersScoresFalse
  def test_search_single_index9
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        filters: "(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)",
        sum_or_filters_scores: false
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"filters\":\"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\",\"sumOrFiltersScores\":false}"
      ),
      JSON.parse(req.body)
    )
  end

  # filtersSumOrFiltersScoresTrue
  def test_search_single_index10
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        filters: "(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)",
        sum_or_filters_scores: true
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"filters\":\"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\",\"sumOrFiltersScores\":true}"
      ),
      JSON.parse(req.body)
    )
  end

  # filtersStephenKing
  def test_search_single_index11
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(filters: "author:\"Stephen King\"")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"filters\":\"author:\\\"Stephen King\\\"\"}"), JSON.parse(req.body))
  end

  # filtersNotTags
  def test_search_single_index12
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(filters: "NOT _tags:non-fiction")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"filters\":\"NOT _tags:non-fiction\"}"), JSON.parse(req.body))
  end

  # facetFiltersList
  def test_search_single_index13
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        facet_filters: ["publisher:Penguin", ["author:Stephen King", "genre:Horror"]]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"facetFilters\":[\"publisher:Penguin\",[\"author:Stephen King\",\"genre:Horror\"]]}"),
      JSON.parse(req.body)
    )
  end

  # facetFiltersNeg
  def test_search_single_index14
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(facet_filters: "category:-Ebook")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facetFilters\":\"category:-Ebook\"}"), JSON.parse(req.body))
  end

  # filtersAndFacetFilters
  def test_search_single_index15
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        filters: "(author:\"Stephen King\" OR genre:\"Horror\")",
        facet_filters: ["publisher:Penguin"]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"filters\":\"(author:\\\"Stephen King\\\" OR genre:\\\"Horror\\\")\",\"facetFilters\":[\"publisher:Penguin\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # aroundLatLng
  def test_search_single_index16
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(around_lat_lng: "40.71, -74.01")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"aroundLatLng\":\"40.71, -74.01\"}"), JSON.parse(req.body))
  end

  # aroundLatLngViaIP
  def test_search_single_index17
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(around_lat_lng_via_ip: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"aroundLatLngViaIP\":true}"), JSON.parse(req.body))
  end

  # aroundRadius
  def test_search_single_index18
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(around_lat_lng: "40.71, -74.01", around_radius: 1000000)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"aroundLatLng\":\"40.71, -74.01\",\"aroundRadius\":1000000}"), JSON.parse(req.body))
  end

  # insideBoundingBox
  def test_search_single_index19
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        inside_bounding_box: [[49.067996905313834, 65.73828125, 25.905859247243498, 128.8046875]]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"insideBoundingBox\":[[49.067996905313834,65.73828125,25.905859247243498,128.8046875]]}"),
      JSON.parse(req.body)
    )
  end

  # insidePolygon
  def test_search_single_index20
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        inside_polygon: [
          [
            42.01,
            -124.31,
            48.835509470063045,
            -124.40453125000005,
            45.01082951668149,
            -65.95726562500005,
            31.247243545293433,
            -81.06578125000004,
            25.924152577235226,
            -97.68234374999997,
            32.300311895879545,
            -117.54828125
          ]
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"insidePolygon\":[[42.01,-124.31,48.835509470063045,-124.40453125000005,45.01082951668149,-65.95726562500005,31.247243545293433,-81.06578125000004,25.924152577235226,-97.68234374999997,32.300311895879545,-117.54828125]]}"
      ),
      JSON.parse(req.body)
    )
  end

  # insidePolygon
  def test_search_single_index21
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        inside_polygon: [
          [
            42.01,
            -124.31,
            48.835509470063045,
            -124.40453125000005,
            45.01082951668149,
            -65.95726562500005,
            31.247243545293433,
            -81.06578125000004,
            25.924152577235226,
            -97.68234374999997,
            32.300311895879545,
            -117.54828125
          ]
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"insidePolygon\":[[42.01,-124.31,48.835509470063045,-124.40453125000005,45.01082951668149,-65.95726562500005,31.247243545293433,-81.06578125000004,25.924152577235226,-97.68234374999997,32.300311895879545,-117.54828125]]}"
      ),
      JSON.parse(req.body)
    )
  end

  # optionalFilters
  def test_search_single_index22
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(optional_filters: ["can_deliver_quickly:true"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"optionalFilters\":[\"can_deliver_quickly:true\"]}"), JSON.parse(req.body))
  end

  # optionalFiltersMany
  def test_search_single_index23
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        optional_filters: ["brand:Apple<score=3>", "brand:Samsung<score=2>", "brand:-Huawei"]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"optionalFilters\":[\"brand:Apple<score=3>\",\"brand:Samsung<score=2>\",\"brand:-Huawei\"]}"),
      JSON.parse(req.body)
    )
  end

  # optionalFiltersSimple
  def test_search_single_index24
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(optional_filters: ["brand:Apple<score=2>", "type:tablet"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"optionalFilters\":[\"brand:Apple<score=2>\",\"type:tablet\"]}"), JSON.parse(req.body))
  end

  # restrictSearchableAttributes
  def test_search_single_index25
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(restrict_searchable_attributes: ["title_fr"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"restrictSearchableAttributes\":[\"title_fr\"]}"), JSON.parse(req.body))
  end

  # getRankingInfo
  def test_search_single_index26
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(get_ranking_info: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"getRankingInfo\":true}"), JSON.parse(req.body))
  end

  # clickAnalytics
  def test_search_single_index27
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(click_analytics: true)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"clickAnalytics\":true}"), JSON.parse(req.body))
  end

  # clickAnalyticsUserToken
  def test_search_single_index28
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(click_analytics: true, user_token: "user-1")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"clickAnalytics\":true,\"userToken\":\"user-1\"}"), JSON.parse(req.body))
  end

  # enablePersonalization
  def test_search_single_index29
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(enable_personalization: true, user_token: "user-1")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"enablePersonalization\":true,\"userToken\":\"user-1\"}"), JSON.parse(req.body))
  end

  # userToken
  def test_search_single_index30
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(user_token: "user-1")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"userToken\":\"user-1\"}"), JSON.parse(req.body))
  end

  # analyticsTag
  def test_search_single_index31
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(analytics_tags: ["YOUR_ANALYTICS_TAG"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"analyticsTags\":[\"YOUR_ANALYTICS_TAG\"]}"), JSON.parse(req.body))
  end

  # facetFiltersUsers
  def test_search_single_index32
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(facet_filters: ["user:user42", "user:public"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facetFilters\":[\"user:user42\",\"user:public\"]}"), JSON.parse(req.body))
  end

  # buildTheQuery
  def test_search_single_index33
    req = @client.search_single_index_with_http_info(
      "indexName",
      Algolia::Search::SearchParamsObject.new(
        filters: "categoryPageId: Men's Clothing",
        hits_per_page: 50,
        analytics_tags: ["mens-clothing"]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"filters\":\"categoryPageId: Men's Clothing\",\"hitsPerPage\":50,\"analyticsTags\":[\"mens-clothing\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # searchSynonyms with minimal parameters
  def test_search_synonyms
    req = @client.search_synonyms_with_http_info("indexName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/synonyms/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # searchSynonyms with all parameters
  def test_search_synonyms1
    req = @client.search_synonyms_with_http_info(
      "indexName",
      Algolia::Search::SearchSynonymsParams.new(query: "myQuery", type: "altcorrection1", page: 10, hits_per_page: 10)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/synonyms/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"myQuery\",\"type\":\"altcorrection1\",\"page\":10,\"hitsPerPage\":10}"),
      JSON.parse(req.body)
    )
  end

  # searchUserIds
  def test_search_user_ids
    req = @client.search_user_ids_with_http_info(
      Algolia::Search::SearchUserIdsParams.new(
        query: "test",
        cluster_name: "theClusterName",
        page: 5,
        hits_per_page: 10
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/clusters/mapping/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"test\",\"clusterName\":\"theClusterName\",\"page\":5,\"hitsPerPage\":10}"),
      JSON.parse(req.body)
    )
  end

  # get setDictionarySettings results with minimal parameters
  def test_set_dictionary_settings
    req = @client.set_dictionary_settings_with_http_info(
      Algolia::Search::DictionarySettingsParams.new(
        disable_standard_entries: Algolia::Search::StandardEntries.new(plurals: {fr: false, en: false, ru: true})
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/dictionaries/*/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"disableStandardEntries\":{\"plurals\":{\"fr\":false,\"en\":false,\"ru\":true}}}"),
      JSON.parse(req.body)
    )
  end

  # get setDictionarySettings results with all parameters
  def test_set_dictionary_settings1
    req = @client.set_dictionary_settings_with_http_info(
      Algolia::Search::DictionarySettingsParams.new(
        disable_standard_entries: Algolia::Search::StandardEntries.new(
          plurals: {fr: false, en: false, ru: true},
          stopwords: {fr: false},
          compounds: {ru: true}
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/dictionaries/*/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"disableStandardEntries\":{\"plurals\":{\"fr\":false,\"en\":false,\"ru\":true},\"stopwords\":{\"fr\":false},\"compounds\":{\"ru\":true}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # minimal parameters
  def test_set_settings
    req = @client.set_settings_with_http_info(
      "cts_e2e_settings",
      Algolia::Search::IndexSettings.new(pagination_limited_to: 10),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/cts_e2e_settings/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"paginationLimitedTo\":10}"), JSON.parse(req.body))
  end

  # boolean typoTolerance
  def test_set_settings1
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(typo_tolerance: true),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"typoTolerance\":true}"), JSON.parse(req.body))
  end

  # enum typoTolerance
  def test_set_settings2
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(typo_tolerance: "min"),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"typoTolerance\":\"min\"}"), JSON.parse(req.body))
  end

  # ignorePlurals
  def test_set_settings3
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(ignore_plurals: true),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"ignorePlurals\":true}"), JSON.parse(req.body))
  end

  # list of string ignorePlurals
  def test_set_settings4
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(ignore_plurals: ["fr"]),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"ignorePlurals\":[\"fr\"]}"), JSON.parse(req.body))
  end

  # removeStopWords boolean
  def test_set_settings5
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(remove_stop_words: true),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"removeStopWords\":true}"), JSON.parse(req.body))
  end

  # removeStopWords list of string
  def test_set_settings6
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(remove_stop_words: ["fr"]),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"removeStopWords\":[\"fr\"]}"), JSON.parse(req.body))
  end

  # boolean distinct
  def test_set_settings7
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(distinct: true), true)

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"distinct\":true}"), JSON.parse(req.body))
  end

  # integer distinct
  def test_set_settings8
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(distinct: 1), true)

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"distinct\":1}"), JSON.parse(req.body))
  end

  # distinct company
  def test_set_settings9
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(attribute_for_distinct: "company", distinct: true)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeForDistinct\":\"company\",\"distinct\":true}"), JSON.parse(req.body))
  end

  # distinct design
  def test_set_settings10
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(attribute_for_distinct: "design", distinct: true)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeForDistinct\":\"design\",\"distinct\":true}"), JSON.parse(req.body))
  end

  # distinct true
  def test_set_settings11
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(distinct: true))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"distinct\":true}"), JSON.parse(req.body))
  end

  # distinct section
  def test_set_settings12
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(attribute_for_distinct: "section", distinct: true)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributeForDistinct\":\"section\",\"distinct\":true}"), JSON.parse(req.body))
  end

  # attributesForFaceting allergens
  def test_set_settings13
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["allergens"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesForFaceting\":[\"allergens\"]}"), JSON.parse(req.body))
  end

  # attributesForFaceting categoryPageId
  def test_set_settings14
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["searchable(categoryPageId)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesForFaceting\":[\"searchable(categoryPageId)\"]}"), JSON.parse(req.body))
  end

  # unretrievableAttributes
  def test_set_settings15
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(unretrievable_attributes: ["visible_by"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"unretrievableAttributes\":[\"visible_by\"]}"), JSON.parse(req.body))
  end

  # attributesForFaceting user restricted data
  def test_set_settings16
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["filterOnly(visible_by)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesForFaceting\":[\"filterOnly(visible_by)\"]}"), JSON.parse(req.body))
  end

  # attributesForFaceting optional filters
  def test_set_settings17
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["can_deliver_quickly", "restaurant"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"attributesForFaceting\":[\"can_deliver_quickly\",\"restaurant\"]}"),
      JSON.parse(req.body)
    )
  end

  # attributesForFaceting redirect index
  def test_set_settings18
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["query_terms"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesForFaceting\":[\"query_terms\"]}"), JSON.parse(req.body))
  end

  # attributesForFaceting multiple consequences
  def test_set_settings19
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["director"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesForFaceting\":[\"director\"]}"), JSON.parse(req.body))
  end

  # attributesForFaceting in-depth optional filters
  def test_set_settings20
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(attributes_for_faceting: ["filterOnly(brand)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"attributesForFaceting\":[\"filterOnly(brand)\"]}"), JSON.parse(req.body))
  end

  # mode neuralSearch
  def test_set_settings21
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(mode: "neuralSearch"))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"mode\":\"neuralSearch\"}"), JSON.parse(req.body))
  end

  # mode keywordSearch
  def test_set_settings22
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(mode: "keywordSearch"))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"mode\":\"keywordSearch\"}"), JSON.parse(req.body))
  end

  # searchableAttributes same priority
  def test_set_settings23
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(searchable_attributes: ["title,comments", "ingredients"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"searchableAttributes\":[\"title,comments\",\"ingredients\"]}"), JSON.parse(req.body))
  end

  # searchableAttributes higher priority
  def test_set_settings24
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(searchable_attributes: ["title", "ingredients"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"searchableAttributes\":[\"title\",\"ingredients\"]}"), JSON.parse(req.body))
  end

  # customRanking retweets
  def test_set_settings25
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(custom_ranking: ["desc(retweets)", "desc(likes)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"customRanking\":[\"desc(retweets)\",\"desc(likes)\"]}"), JSON.parse(req.body))
  end

  # customRanking boosted
  def test_set_settings26
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(custom_ranking: ["desc(boosted)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"customRanking\":[\"desc(boosted)\"]}"), JSON.parse(req.body))
  end

  # customRanking pageviews
  def test_set_settings27
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(custom_ranking: ["desc(pageviews)", "desc(comments)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"customRanking\":[\"desc(pageviews)\",\"desc(comments)\"]}"), JSON.parse(req.body))
  end

  # customRanking applying search parameters for a specific query
  def test_set_settings28
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        custom_ranking: ["desc(nb_airline_liaisons)"],
        attributes_for_faceting: ["city, country"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"customRanking\":[\"desc(nb_airline_liaisons)\"],\"attributesForFaceting\":[\"city, country\"]}"),
      JSON.parse(req.body)
    )
  end

  # customRanking rounded pageviews
  def test_set_settings29
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(custom_ranking: ["desc(rounded_pageviews)", "desc(comments)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"customRanking\":[\"desc(rounded_pageviews)\",\"desc(comments)\"]}"),
      JSON.parse(req.body)
    )
  end

  # customRanking price
  def test_set_settings30
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(custom_ranking: ["desc(price)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"customRanking\":[\"desc(price)\"]}"), JSON.parse(req.body))
  end

  # ranking exhaustive
  def test_set_settings31
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        ranking: ["desc(price)", "typo", "geo", "words", "filters", "proximity", "attribute", "exact", "custom"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"ranking\":[\"desc(price)\",\"typo\",\"geo\",\"words\",\"filters\",\"proximity\",\"attribute\",\"exact\",\"custom\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # ranking standard replica
  def test_set_settings32
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(ranking: ["desc(post_date_timestamp)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"ranking\":[\"desc(post_date_timestamp)\"]}"), JSON.parse(req.body))
  end

  # ranking virtual replica
  def test_set_settings33
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(custom_ranking: ["desc(post_date_timestamp)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"customRanking\":[\"desc(post_date_timestamp)\"]}"), JSON.parse(req.body))
  end

  # customRanking and ranking sort alphabetically
  def test_set_settings34
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        custom_ranking: ["asc(textual_attribute)"],
        ranking: ["custom", "typo", "geo", "words", "filters", "proximity", "attribute", "exact"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"customRanking\":[\"asc(textual_attribute)\"],\"ranking\":[\"custom\",\"typo\",\"geo\",\"words\",\"filters\",\"proximity\",\"attribute\",\"exact\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # relevancyStrictness
  def test_set_settings35
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(custom_ranking: ["asc(textual_attribute)"], relevancy_strictness: 0)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"customRanking\":[\"asc(textual_attribute)\"],\"relevancyStrictness\":0}"),
      JSON.parse(req.body)
    )
  end

  # create replica index
  def test_set_settings36
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(replicas: ["products_price_desc"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"replicas\":[\"products_price_desc\"]}"), JSON.parse(req.body))
  end

  # unlink replica index
  def test_set_settings37
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(replicas: [""]))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"replicas\":[\"\"]}"), JSON.parse(req.body))
  end

  # forwardToReplicas
  def test_set_settings38
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(searchable_attributes: ["name", "description"]),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"searchableAttributes\":[\"name\",\"description\"]}"), JSON.parse(req.body))
  end

  # maxValuesPerFacet
  def test_set_settings39
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(max_values_per_facet: 1000)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"maxValuesPerFacet\":1000}"), JSON.parse(req.body))
  end

  # maxFacetHits
  def test_set_settings40
    req = @client.set_settings_with_http_info("theIndexName", Algolia::Search::IndexSettings.new(max_facet_hits: 1000))

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"maxFacetHits\":1000}"), JSON.parse(req.body))
  end

  # attributesForFaceting complex
  def test_set_settings41
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      Algolia::Search::IndexSettings.new(
        attributes_for_faceting: ["actor", "filterOnly(category)", "searchable(publisher)"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"attributesForFaceting\":[\"actor\",\"filterOnly(category)\",\"searchable(publisher)\"]}"),
      JSON.parse(req.body)
    )
  end

  # ranking closest dates
  def test_set_settings42
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        ranking: ["asc(date_timestamp)", "typo", "geo", "words", "filters", "proximity", "attribute", "exact", "custom"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"ranking\":[\"asc(date_timestamp)\",\"typo\",\"geo\",\"words\",\"filters\",\"proximity\",\"attribute\",\"exact\",\"custom\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # searchableAttributes item variation
  def test_set_settings43
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(searchable_attributes: ["design", "type", "color"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"searchableAttributes\":[\"design\",\"type\",\"color\"]}"), JSON.parse(req.body))
  end

  # searchableAttributes around location
  def test_set_settings44
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        searchable_attributes: ["name", "country", "code", "iata_code"],
        custom_ranking: ["desc(links_count)"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"searchableAttributes\":[\"name\",\"country\",\"code\",\"iata_code\"],\"customRanking\":[\"desc(links_count)\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # searchableAttributes around location
  def test_set_settings45
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        searchable_attributes: ["name", "country", "code", "iata_code"],
        custom_ranking: ["desc(links_count)"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"searchableAttributes\":[\"name\",\"country\",\"code\",\"iata_code\"],\"customRanking\":[\"desc(links_count)\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # disableTypoToleranceOnAttributes
  def test_set_settings46
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(disable_typo_tolerance_on_attributes: ["serial_number"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"disableTypoToleranceOnAttributes\":[\"serial_number\"]}"), JSON.parse(req.body))
  end

  # everything
  def test_set_settings47
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        advanced_syntax: true,
        advanced_syntax_features: ["exactPhrase"],
        allow_compression_of_integer_array: true,
        allow_typos_on_numeric_tokens: true,
        alternatives_as_exact: ["singleWordSynonym"],
        attribute_criteria_computed_by_min_proximity: true,
        attribute_for_distinct: "test",
        attributes_for_faceting: ["algolia"],
        attributes_to_highlight: ["algolia"],
        attributes_to_retrieve: ["algolia"],
        attributes_to_snippet: ["algolia"],
        attributes_to_transliterate: ["algolia"],
        camel_case_attributes: ["algolia"],
        custom_normalization: {algolia: {aloglia: "aglolia"}},
        custom_ranking: ["algolia"],
        decompound_query: false,
        decompounded_attributes: {algolia: "aloglia"},
        disable_exact_on_attributes: ["algolia"],
        disable_prefix_on_attributes: ["algolia"],
        disable_typo_tolerance_on_attributes: ["algolia"],
        disable_typo_tolerance_on_words: ["algolia"],
        distinct: 3,
        enable_personalization: true,
        enable_re_ranking: false,
        enable_rules: true,
        exact_on_single_word_query: "attribute",
        highlight_pre_tag: "<span>",
        highlight_post_tag: "</span>",
        hits_per_page: 10,
        ignore_plurals: false,
        index_languages: ["fr"],
        keep_diacritics_on_characters: "abc",
        max_facet_hits: 20,
        max_values_per_facet: 30,
        min_proximity: 6,
        min_word_sizefor1_typo: 5,
        min_word_sizefor2_typos: 11,
        mode: "neuralSearch",
        numeric_attributes_for_filtering: ["algolia"],
        optional_words: ["myspace"],
        pagination_limited_to: 0,
        query_languages: ["fr"],
        query_type: "prefixLast",
        ranking: ["geo"],
        re_ranking_apply_filter: "mySearch:filters",
        relevancy_strictness: 10,
        remove_stop_words: false,
        remove_words_if_no_results: "lastWords",
        rendering_content: Algolia::Search::RenderingContent.new(
          facet_ordering: Algolia::Search::FacetOrdering.new(
            facets: Algolia::Search::Facets.new(order: ["a", "b"]),
            values: {a: Algolia::Search::Value.new(order: ["b"], sort_remaining_by: "count")}
          )
        ),
        replace_synonyms_in_highlight: true,
        replicas: [""],
        response_fields: ["algolia"],
        restrict_highlight_and_snippet_arrays: true,
        searchable_attributes: ["foo"],
        semantic_search: Algolia::Search::SemanticSearch.new(event_sources: ["foo"]),
        separators_to_index: "bar",
        snippet_ellipsis_text: "---",
        sort_facet_values_by: "date",
        typo_tolerance: false,
        unretrievable_attributes: ["foo"],
        user_data: {user: "data"}
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"advancedSyntax\":true,\"advancedSyntaxFeatures\":[\"exactPhrase\"],\"allowCompressionOfIntegerArray\":true,\"allowTyposOnNumericTokens\":true,\"alternativesAsExact\":[\"singleWordSynonym\"],\"attributeCriteriaComputedByMinProximity\":true,\"attributeForDistinct\":\"test\",\"attributesForFaceting\":[\"algolia\"],\"attributesToHighlight\":[\"algolia\"],\"attributesToRetrieve\":[\"algolia\"],\"attributesToSnippet\":[\"algolia\"],\"attributesToTransliterate\":[\"algolia\"],\"camelCaseAttributes\":[\"algolia\"],\"customNormalization\":{\"algolia\":{\"aloglia\":\"aglolia\"}},\"customRanking\":[\"algolia\"],\"decompoundQuery\":false,\"decompoundedAttributes\":{\"algolia\":\"aloglia\"},\"disableExactOnAttributes\":[\"algolia\"],\"disablePrefixOnAttributes\":[\"algolia\"],\"disableTypoToleranceOnAttributes\":[\"algolia\"],\"disableTypoToleranceOnWords\":[\"algolia\"],\"distinct\":3,\"enablePersonalization\":true,\"enableReRanking\":false,\"enableRules\":true,\"exactOnSingleWordQuery\":\"attribute\",\"highlightPreTag\":\"<span>\",\"highlightPostTag\":\"</span>\",\"hitsPerPage\":10,\"ignorePlurals\":false,\"indexLanguages\":[\"fr\"],\"keepDiacriticsOnCharacters\":\"abc\",\"maxFacetHits\":20,\"maxValuesPerFacet\":30,\"minProximity\":6,\"minWordSizefor1Typo\":5,\"minWordSizefor2Typos\":11,\"mode\":\"neuralSearch\",\"numericAttributesForFiltering\":[\"algolia\"],\"optionalWords\":[\"myspace\"],\"paginationLimitedTo\":0,\"queryLanguages\":[\"fr\"],\"queryType\":\"prefixLast\",\"ranking\":[\"geo\"],\"reRankingApplyFilter\":\"mySearch:filters\",\"relevancyStrictness\":10,\"removeStopWords\":false,\"removeWordsIfNoResults\":\"lastWords\",\"renderingContent\":{\"facetOrdering\":{\"facets\":{\"order\":[\"a\",\"b\"]},\"values\":{\"a\":{\"order\":[\"b\"],\"sortRemainingBy\":\"count\"}}}},\"replaceSynonymsInHighlight\":true,\"replicas\":[\"\"],\"responseFields\":[\"algolia\"],\"restrictHighlightAndSnippetArrays\":true,\"searchableAttributes\":[\"foo\"],\"semanticSearch\":{\"eventSources\":[\"foo\"]},\"separatorsToIndex\":\"bar\",\"snippetEllipsisText\":\"---\",\"sortFacetValuesBy\":\"date\",\"typoTolerance\":false,\"unretrievableAttributes\":[\"foo\"],\"userData\":{\"user\":\"data\"}}"
      ),
      JSON.parse(req.body)
    )
  end

  # searchableAttributesWithCustomRankingsAndAttributesForFaceting
  def test_set_settings48
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        searchable_attributes: ["brand", "name", "categories", "unordered(description)"],
        custom_ranking: ["desc(popularity)"],
        attributes_for_faceting: ["searchable(brand)", "type", "categories", "price"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"searchableAttributes\":[\"brand\",\"name\",\"categories\",\"unordered(description)\"],\"customRanking\":[\"desc(popularity)\"],\"attributesForFaceting\":[\"searchable(brand)\",\"type\",\"categories\",\"price\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # searchableAttributesProductReferenceSuffixes
  def test_set_settings49
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(
        searchable_attributes: ["name", "product_reference", "product_reference_suffixes"]
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"searchableAttributes\":[\"name\",\"product_reference\",\"product_reference_suffixes\"]}"),
      JSON.parse(req.body)
    )
  end

  # queryLanguageAndIgnorePlurals
  def test_set_settings50
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(query_languages: ["en"], ignore_plurals: true)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"queryLanguages\":[\"en\"],\"ignorePlurals\":true}"), JSON.parse(req.body))
  end

  # searchableAttributesInMovies
  def test_set_settings51
    req = @client.set_settings_with_http_info(
      "movies",
      Algolia::Search::IndexSettings.new(searchable_attributes: ["title_eng", "title_fr", "title_es"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/movies/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"searchableAttributes\":[\"title_eng\",\"title_fr\",\"title_es\"]}"),
      JSON.parse(req.body)
    )
  end

  # disablePrefixOnAttributes
  def test_set_settings52
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(disable_prefix_on_attributes: ["serial_number"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"disablePrefixOnAttributes\":[\"serial_number\"]}"), JSON.parse(req.body))
  end

  # disableTypoToleranceOnAttributes
  def test_set_settings53
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(disable_typo_tolerance_on_attributes: ["serial_number"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"disableTypoToleranceOnAttributes\":[\"serial_number\"]}"), JSON.parse(req.body))
  end

  # searchableAttributesSimpleExample
  def test_set_settings54
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(searchable_attributes: ["serial_number"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"searchableAttributes\":[\"serial_number\"]}"), JSON.parse(req.body))
  end

  # searchableAttributesSimpleExampleAlt
  def test_set_settings55
    req = @client.set_settings_with_http_info(
      "theIndexName",
      Algolia::Search::IndexSettings.new(searchable_attributes: ["serial_number", "serial_number_suffixes"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"searchableAttributes\":[\"serial_number\",\"serial_number_suffixes\"]}"),
      JSON.parse(req.body)
    )
  end

  # updateApiKey
  def test_update_api_key
    req = @client.update_api_key_with_http_info(
      "ALGOLIA_API_KEY",
      Algolia::Search::ApiKey.new(
        acl: ["search", "addObject"],
        validity: 300,
        max_queries_per_ip_per_hour: 100,
        max_hits_per_query: 20
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/keys/ALGOLIA_API_KEY", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"acl\":[\"search\",\"addObject\"],\"validity\":300,\"maxQueriesPerIPPerHour\":100,\"maxHitsPerQuery\":20}"
      ),
      JSON.parse(req.body)
    )
  end

end
