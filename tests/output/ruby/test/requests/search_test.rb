# Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
require "algolia"
require "test/unit"

class TestSearchClient < Test::Unit::TestCase
  include Algolia::Search
  def setup
    @client = Algolia::SearchClient.create(
      "APP_ID",
      "API_KEY",

      {requester: Algolia::Transport::EchoRequester.new}
    )
  end

  # addApiKey
  def test_add_api_key
    req = @client.add_api_key_with_http_info(
      ApiKey.new(
        acl: ["search", "addObject"],
        description: "my new api key",
        validity: 300,
        max_queries_per_ip_per_hour: 100,
        max_hits_per_query: 20
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/keys", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"acl\":[\"search\",\"addObject\"],\"description\":\"my new api key\",\"validity\":300,\"maxQueriesPerIPPerHour\":100,\"maxHitsPerQuery\":20}"
      ),
      JSON.parse(req.body)
    )
  end

  # addOrUpdateObject
  def test_add_or_update_object
    req = @client.add_or_update_object_with_http_info("indexName", "uniqueID", {key: "value"})

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/uniqueID", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"key\":\"value\"}"), JSON.parse(req.body))
  end

  # appendSource
  def test_append_source
    req = @client.append_source_with_http_info(Source.new(source: "theSource", description: "theDescription"))

    assert_equal(:post, req.method)
    assert_equal("/1/security/sources/append", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"source\":\"theSource\",\"description\":\"theDescription\"}"), JSON.parse(req.body))
  end

  # assignUserId
  def test_assign_user_id
    req = @client.assign_user_id_with_http_info("userID", AssignUserIdParams.new(cluster: "theCluster"))

    assert_equal(:post, req.method)
    assert_equal("/1/clusters/mapping", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(
      ({:"x-algolia-user-id" => "userID"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )
    assert_equal(JSON.parse("{\"cluster\":\"theCluster\"}"), JSON.parse(req.body))
  end

  # it should not encode the userID
  def test_assign_user_id1
    req = @client.assign_user_id_with_http_info(
      "user id with spaces",
      AssignUserIdParams.new(cluster: "cluster with spaces")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/clusters/mapping", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(
      ({:"x-algolia-user-id" => "user id with spaces"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )
    assert_equal(JSON.parse("{\"cluster\":\"cluster with spaces\"}"), JSON.parse(req.body))
  end

  # addObject
  def test_batch
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      BatchWriteParams.new(
        requests: [
          BatchRequest.new(action: "addObject", body: {key: "bar", foo: "1"}),
          BatchRequest.new(action: "addObject", body: {key: "baz", foo: "2"})
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"action\":\"addObject\",\"body\":{\"key\":\"bar\",\"foo\":\"1\"}},{\"action\":\"addObject\",\"body\":{\"key\":\"baz\",\"foo\":\"2\"}}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # clear
  def test_batch1
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      BatchWriteParams.new(requests: [BatchRequest.new(action: "clear", body: {key: "value"})])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"clear\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # delete
  def test_batch2
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      BatchWriteParams.new(requests: [BatchRequest.new(action: "delete", body: {key: "value"})])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"delete\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # deleteObject
  def test_batch3
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      BatchWriteParams.new(requests: [BatchRequest.new(action: "deleteObject", body: {key: "value"})])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"deleteObject\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # partialUpdateObject
  def test_batch4
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      BatchWriteParams.new(requests: [BatchRequest.new(action: "partialUpdateObject", body: {key: "value"})])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"partialUpdateObject\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # partialUpdateObjectNoCreate
  def test_batch5
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      BatchWriteParams.new(requests: [BatchRequest.new(action: "partialUpdateObjectNoCreate", body: {key: "value"})])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"partialUpdateObjectNoCreate\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # updateObject
  def test_batch6
    req = @client.batch_with_http_info(
      "<YOUR_INDEX_NAME>",
      BatchWriteParams.new(requests: [BatchRequest.new(action: "updateObject", body: {key: "value"})])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"action\":\"updateObject\",\"body\":{\"key\":\"value\"}}]}"),
      JSON.parse(req.body)
    )
  end

  # batchAssignUserIds
  def test_batch_assign_user_ids
    req = @client.batch_assign_user_ids_with_http_info(
      "userID",
      BatchAssignUserIdsParams.new(cluster: "theCluster", users: ["user1", "user2"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/clusters/mapping/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(
      ({:"x-algolia-user-id" => "userID"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )
    assert_equal(JSON.parse("{\"cluster\":\"theCluster\",\"users\":[\"user1\",\"user2\"]}"), JSON.parse(req.body))
  end

  # replace
  def test_batch_dictionary_entries
    req = @client.batch_dictionary_entries_with_http_info(
      "plurals",
      BatchDictionaryEntriesParams.new(
        clear_existing_dictionary_entries: true,
        requests: [
          BatchDictionaryEntriesRequest.new(
            action: "addEntry",
            body: DictionaryEntry.new(
              object_id: "1",
              language: "en",
              word: "fancy",
              words: ["believe", "algolia"],
              decomposition: ["trust", "algolia"],
              state: "enabled"
            )
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/dictionaries/plurals/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"clearExistingDictionaryEntries\":true,\"requests\":[{\"action\":\"addEntry\",\"body\":{\"objectID\":\"1\",\"language\":\"en\",\"word\":\"fancy\",\"words\":[\"believe\",\"algolia\"],\"decomposition\":[\"trust\",\"algolia\"],\"state\":\"enabled\"}}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # delete
  def test_batch_dictionary_entries1
    req = @client.batch_dictionary_entries_with_http_info(
      "plurals",
      BatchDictionaryEntriesParams.new(
        clear_existing_dictionary_entries: true,
        requests: [
          BatchDictionaryEntriesRequest.new(
            action: "deleteEntry",
            body: DictionaryEntry.new(
              object_id: "1",
              language: "en",
              word: "fancy",
              words: ["believe", "algolia"],
              decomposition: ["trust", "algolia"],
              state: "enabled"
            )
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/dictionaries/plurals/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"clearExistingDictionaryEntries\":true,\"requests\":[{\"action\":\"deleteEntry\",\"body\":{\"objectID\":\"1\",\"language\":\"en\",\"word\":\"fancy\",\"words\":[\"believe\",\"algolia\"],\"decomposition\":[\"trust\",\"algolia\"],\"state\":\"enabled\"}}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # append
  def test_batch_dictionary_entries2
    req = @client.batch_dictionary_entries_with_http_info(
      "stopwords",
      BatchDictionaryEntriesParams.new(
        requests: [
          BatchDictionaryEntriesRequest.new(
            action: "addEntry",
            body: DictionaryEntry.new(object_id: "1", language: "en", additional: "try me")
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/dictionaries/stopwords/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"action\":\"addEntry\",\"body\":{\"objectID\":\"1\",\"language\":\"en\",\"additional\":\"try me\"}}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # browse with minimal parameters
  def test_browse
    req = @client.browse_with_http_info("cts_e2e_browse")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/cts_e2e_browse/browse", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # browse with search parameters
  def test_browse1
    req = @client.browse_with_http_info(
      "indexName",
      BrowseParamsObject.new(query: "myQuery", facet_filters: ["tags:algolia"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/browse", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"myQuery\",\"facetFilters\":[\"tags:algolia\"]}"), JSON.parse(req.body))
  end

  # browse allow a cursor in parameters
  def test_browse2
    req = @client.browse_with_http_info("indexName", BrowseParamsObject.new(cursor: "test"))

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/browse", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"cursor\":\"test\"}"), JSON.parse(req.body))
  end

  # clearObjects
  def test_clear_objects
    req = @client.clear_objects_with_http_info("theIndexName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/clear", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
  end

  # clearRules
  def test_clear_rules
    req = @client.clear_rules_with_http_info("indexName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/rules/clear", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
  end

  # clearSynonyms
  def test_clear_synonyms
    req = @client.clear_synonyms_with_http_info("indexName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/synonyms/clear", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
  end

  # allow del method for a custom path with minimal parameters
  def test_custom_delete
    req = @client.custom_delete_with_http_info("test/minimal")

    assert_equal(:delete, req.method)
    assert_equal("/test/minimal", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # allow del method for a custom path with all parameters
  def test_custom_delete1
    req = @client.custom_delete_with_http_info("test/all", {query: "parameters"})

    assert_equal(:delete, req.method)
    assert_equal("/test/all", req.path)
    assert_equal({:"query" => "parameters"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # allow get method for a custom path with minimal parameters
  def test_custom_get
    req = @client.custom_get_with_http_info("test/minimal")

    assert_equal(:get, req.method)
    assert_equal("/test/minimal", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # allow get method for a custom path with all parameters
  def test_custom_get1
    req = @client.custom_get_with_http_info("test/all", {query: "parameters with space"})

    assert_equal(:get, req.method)
    assert_equal("/test/all", req.path)
    assert_equal({:"query" => "parameters%20with%20space"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # requestOptions should be escaped too
  def test_custom_get2
    req = @client.custom_get_with_http_info(
      "test/all",
      {query: "to be overriden"},
      {
        :header_params => JSON.parse("{\"x-header-1\":\"spaces are left alone\"}", :symbolize_names => true),
        :query_params => JSON.parse(
          "{\"query\":\"parameters with space\",\"and an array\":[\"array\",\"with spaces\"]}",
          :symbolize_names => true
        )
      }
    )

    assert_equal(:get, req.method)
    assert_equal("/test/all", req.path)
    assert_equal(
      {:"query" => "parameters%20with%20space", :"and%20an%20array" => "array%2Cwith%20spaces"}.to_a,
      req.query_params.to_a
    )
    assert(
      ({:"x-header-1" => "spaces are left alone"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )

    assert(req.body.nil?, "body is not nil")
  end

  # allow post method for a custom path with minimal parameters
  def test_custom_post
    req = @client.custom_post_with_http_info("test/minimal")

    assert_equal(:post, req.method)
    assert_equal("/test/minimal", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # allow post method for a custom path with all parameters
  def test_custom_post1
    req = @client.custom_post_with_http_info("test/all", {query: "parameters"}, {body: "parameters"})

    assert_equal(:post, req.method)
    assert_equal("/test/all", req.path)
    assert_equal({:"query" => "parameters"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"body\":\"parameters\"}"), JSON.parse(req.body))
  end

  # requestOptions can override default query parameters
  def test_custom_post2
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"query\":\"myQueryParameter\"}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "myQueryParameter"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions merges query parameters with default ones
  def test_custom_post3
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"query2\":\"myQueryParameter\"}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"query2" => "myQueryParameter"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions can override default headers
  def test_custom_post4
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:header_params => JSON.parse("{\"x-algolia-api-key\":\"myApiKey\"}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters"}.to_a, req.query_params.to_a)
    assert(
      ({:"x-algolia-api-key" => "myApiKey"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions merges headers with default ones
  def test_custom_post5
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:header_params => JSON.parse("{\"x-algolia-api-key\":\"myApiKey\"}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters"}.to_a, req.query_params.to_a)
    assert(
      ({:"x-algolia-api-key" => "myApiKey"}.transform_keys(&:to_s).to_a - req.headers.to_a).empty?,
      req.headers.to_s
    )
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions queryParameters accepts booleans
  def test_custom_post6
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"isItWorking\":true}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"isItWorking" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions queryParameters accepts integers
  def test_custom_post7
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"myParam\":2}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"myParam" => "2"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions queryParameters accepts list of string
  def test_custom_post8
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"myParam\":[\"b and c\",\"d\"]}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"myParam" => "b%20and%20c%2Cd"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions queryParameters accepts list of booleans
  def test_custom_post9
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"myParam\":[true,true,false]}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"myParam" => "true%2Ctrue%2Cfalse"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # requestOptions queryParameters accepts list of integers
  def test_custom_post10
    req = @client.custom_post_with_http_info(
      "test/requestOptions",
      {query: "parameters"},
      {facet: "filters"},
      {:query_params => JSON.parse("{\"myParam\":[1,2]}", :symbolize_names => true)}
    )

    assert_equal(:post, req.method)
    assert_equal("/test/requestOptions", req.path)
    assert_equal({:"query" => "parameters", :"myParam" => "1%2C2"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"facet\":\"filters\"}"), JSON.parse(req.body))
  end

  # allow put method for a custom path with minimal parameters
  def test_custom_put
    req = @client.custom_put_with_http_info("test/minimal")

    assert_equal(:put, req.method)
    assert_equal("/test/minimal", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # allow put method for a custom path with all parameters
  def test_custom_put1
    req = @client.custom_put_with_http_info("test/all", {query: "parameters"}, {body: "parameters"})

    assert_equal(:put, req.method)
    assert_equal("/test/all", req.path)
    assert_equal({:"query" => "parameters"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"body\":\"parameters\"}"), JSON.parse(req.body))
  end

  # deleteApiKey
  def test_delete_api_key
    req = @client.delete_api_key_with_http_info("myTestApiKey")

    assert_equal(:delete, req.method)
    assert_equal("/1/keys/myTestApiKey", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # deleteBy
  def test_delete_by
    req = @client.delete_by_with_http_info("theIndexName", DeleteByParams.new(filters: "brand:brandName"))

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/deleteByQuery", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"filters\":\"brand:brandName\"}"), JSON.parse(req.body))
  end

  # deleteIndex
  def test_delete_index
    req = @client.delete_index_with_http_info("theIndexName")

    assert_equal(:delete, req.method)
    assert_equal("/1/indexes/theIndexName", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # deleteObject
  def test_delete_object
    req = @client.delete_object_with_http_info("<YOUR_INDEX_NAME>", "uniqueID")

    assert_equal(:delete, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/uniqueID", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # delete rule simple case
  def test_delete_rule
    req = @client.delete_rule_with_http_info("indexName", "id1")

    assert_equal(:delete, req.method)
    assert_equal("/1/indexes/indexName/rules/id1", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # delete rule with simple characters to encode in objectID
  def test_delete_rule1
    req = @client.delete_rule_with_http_info("indexName", "test/with/slash")

    assert_equal(:delete, req.method)
    assert_equal("/1/indexes/indexName/rules/test%2Fwith%2Fslash", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # deleteSource
  def test_delete_source
    req = @client.delete_source_with_http_info("theSource")

    assert_equal(:delete, req.method)
    assert_equal("/1/security/sources/theSource", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # deleteSynonym
  def test_delete_synonym
    req = @client.delete_synonym_with_http_info("indexName", "id1")

    assert_equal(:delete, req.method)
    assert_equal("/1/indexes/indexName/synonyms/id1", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getApiKey
  def test_get_api_key
    req = @client.get_api_key_with_http_info("myTestApiKey")

    assert_equal(:get, req.method)
    assert_equal("/1/keys/myTestApiKey", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getAppTask
  def test_get_app_task
    req = @client.get_app_task_with_http_info(123)

    assert_equal(:get, req.method)
    assert_equal("/1/task/123", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # get getDictionaryLanguages
  def test_get_dictionary_languages
    req = @client.get_dictionary_languages_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/dictionaries/*/languages", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # get getDictionarySettings results
  def test_get_dictionary_settings
    req = @client.get_dictionary_settings_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/dictionaries/*/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getLogs with minimal parameters
  def test_get_logs
    req = @client.get_logs_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/logs", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getLogs with parameters
  def test_get_logs1
    req = @client.get_logs_with_http_info(5, 10, "theIndexName", "all")

    assert_equal(:get, req.method)
    assert_equal("/1/logs", req.path)
    assert_equal(
      {:"offset" => "5", :"length" => "10", :"indexName" => "theIndexName", :"type" => "all"}.to_a,
      req.query_params.to_a
    )
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getObject
  def test_get_object
    req = @client.get_object_with_http_info("theIndexName", "uniqueID", ["attr1", "attr2"])

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/theIndexName/uniqueID", req.path)
    assert_equal({:"attributesToRetrieve" => "attr1%2Cattr2"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getObjects
  def test_get_objects
    req = @client.get_objects_with_http_info(
      GetObjectsParams.new(
        requests: [
          GetObjectsRequest.new(
            attributes_to_retrieve: ["attr1", "attr2"],
            object_id: "uniqueID",
            index_name: "theIndexName"
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/objects", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"attributesToRetrieve\":[\"attr1\",\"attr2\"],\"objectID\":\"uniqueID\",\"indexName\":\"theIndexName\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # getRule
  def test_get_rule
    req = @client.get_rule_with_http_info("indexName", "id1")

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/indexName/rules/id1", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getSettings
  def test_get_settings
    req = @client.get_settings_with_http_info("cts_e2e_settings")

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/cts_e2e_settings/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getSources
  def test_get_sources
    req = @client.get_sources_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/security/sources", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getSynonym
  def test_get_synonym
    req = @client.get_synonym_with_http_info("indexName", "id1")

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/indexName/synonyms/id1", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getTask
  def test_get_task
    req = @client.get_task_with_http_info("theIndexName", 123)

    assert_equal(:get, req.method)
    assert_equal("/1/indexes/theIndexName/task/123", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getTopUserIds
  def test_get_top_user_ids
    req = @client.get_top_user_ids_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping/top", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # getUserId
  def test_get_user_id
    req = @client.get_user_id_with_http_info("uniqueID")

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping/uniqueID", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # hasPendingMappings with minimal parameters
  def test_has_pending_mappings
    req = @client.has_pending_mappings_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping/pending", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # hasPendingMappings with parameters
  def test_has_pending_mappings1
    req = @client.has_pending_mappings_with_http_info(true)

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping/pending", req.path)
    assert_equal({:"getClusters" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listApiKeys
  def test_list_api_keys
    req = @client.list_api_keys_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/keys", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listClusters
  def test_list_clusters
    req = @client.list_clusters_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/clusters", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listIndices with minimal parameters
  def test_list_indices
    req = @client.list_indices_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/indexes", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listIndices with parameters
  def test_list_indices1
    req = @client.list_indices_with_http_info(8, 3)

    assert_equal(:get, req.method)
    assert_equal("/1/indexes", req.path)
    assert_equal({:"page" => "8", :"hitsPerPage" => "3"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listUserIds with minimal parameters
  def test_list_user_ids
    req = @client.list_user_ids_with_http_info

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # listUserIds with parameters
  def test_list_user_ids1
    req = @client.list_user_ids_with_http_info(8, 100)

    assert_equal(:get, req.method)
    assert_equal("/1/clusters/mapping", req.path)
    assert_equal({:"page" => "8", :"hitsPerPage" => "100"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # multipleBatch
  def test_multiple_batch
    req = @client.multiple_batch_with_http_info(
      BatchParams.new(
        requests: [MultipleBatchRequest.new(action: "addObject", body: {key: "value"}, index_name: "theIndexName")]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/batch", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"action\":\"addObject\",\"body\":{\"key\":\"value\"},\"indexName\":\"theIndexName\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # scopes
  def test_operation_index
    req = @client.operation_index_with_http_info(
      "<SOURCE_INDEX_NAME>",
      OperationIndexParams.new(operation: "move", destination: "<DESTINATION_INDEX_NAME>", scope: ["rules", "settings"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"operation\":\"move\",\"destination\":\"<DESTINATION_INDEX_NAME>\",\"scope\":[\"rules\",\"settings\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # copy
  def test_operation_index1
    req = @client.operation_index_with_http_info(
      "<SOURCE_INDEX_NAME>",
      OperationIndexParams.new(operation: "copy", destination: "<DESTINATION_INDEX_NAME>")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"operation\":\"copy\",\"destination\":\"<DESTINATION_INDEX_NAME>\"}"),
      JSON.parse(req.body)
    )
  end

  # move
  def test_operation_index2
    req = @client.operation_index_with_http_info(
      "<SOURCE_INDEX_NAME>",
      OperationIndexParams.new(operation: "move", destination: "<DESTINATION_INDEX_NAME>")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"operation\":\"move\",\"destination\":\"<DESTINATION_INDEX_NAME>\"}"),
      JSON.parse(req.body)
    )
  end

  # partialUpdateObject
  def test_partial_update_object
    req = @client.partial_update_object_with_http_info(
      "theIndexName",
      "uniqueID",
      {id1: "test", id2: BuiltInOperation.new(_operation: "AddUnique", value: "test2")},
      true
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/theIndexName/uniqueID/partial", req.path)
    assert_equal({:"createIfNotExists" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"id1\":\"test\",\"id2\":{\"_operation\":\"AddUnique\",\"value\":\"test2\"}}"),
      JSON.parse(req.body)
    )
  end

  # removeUserId
  def test_remove_user_id
    req = @client.remove_user_id_with_http_info("uniqueID")

    assert_equal(:delete, req.method)
    assert_equal("/1/clusters/mapping/uniqueID", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)

    assert(req.body.nil?, "body is not nil")
  end

  # replaceSources
  def test_replace_sources
    req = @client.replace_sources_with_http_info([Source.new(source: "theSource", description: "theDescription")])

    assert_equal(:put, req.method)
    assert_equal("/1/security/sources", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("[{\"source\":\"theSource\",\"description\":\"theDescription\"}]"), JSON.parse(req.body))
  end

  # restoreApiKey
  def test_restore_api_key
    req = @client.restore_api_key_with_http_info("myApiKey")

    assert_equal(:post, req.method)
    assert_equal("/1/keys/myApiKey/restore", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
  end

  # saveObject
  def test_save_object
    req = @client.save_object_with_http_info("<YOUR_INDEX_NAME>", {objectID: "id", test: "val"})

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"objectID\":\"id\",\"test\":\"val\"}"), JSON.parse(req.body))
  end

  # saveRule with minimal parameters
  def test_save_rule
    req = @client.save_rule_with_http_info(
      "indexName",
      "id1",
      Rule.new(object_id: "id1", conditions: [Condition.new(pattern: "apple", anchoring: "contains")])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/id1", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"objectID\":\"id1\",\"conditions\":[{\"pattern\":\"apple\",\"anchoring\":\"contains\"}]}"),
      JSON.parse(req.body)
    )
  end

  # saveRule with all parameters
  def test_save_rule1
    req = @client.save_rule_with_http_info(
      "indexName",
      "id1",
      Rule.new(
        object_id: "id1",
        conditions: [Condition.new(pattern: "apple", anchoring: "contains", alternatives: false, context: "search")],
        consequence: Consequence.new(
          params: ConsequenceParams.new(
            filters: "brand:apple",
            query: ConsequenceQueryObject.new(
              remove: ["algolia"],
              edits: [
                Edit.new(type: "remove", delete: "abc", insert: "cde"),
                Edit.new(type: "replace", delete: "abc", insert: "cde")
              ]
            )
          ),
          hide: [ConsequenceHide.new(object_id: "321")],
          filter_promotes: false,
          user_data: {:"algolia" => "aloglia"},
          promote: [
            PromoteObjectID.new(object_id: "abc", position: 3),
            PromoteObjectIDs.new(object_ids: ["abc", "def"], position: 1)
          ]
        ),
        description: "test",
        enabled: true,
        validity: [TimeRange.new(from: 1656670273, _until: 1656670277)]
      ),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/rules/id1", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"objectID\":\"id1\",\"conditions\":[{\"pattern\":\"apple\",\"anchoring\":\"contains\",\"alternatives\":false,\"context\":\"search\"}],\"consequence\":{\"params\":{\"filters\":\"brand:apple\",\"query\":{\"remove\":[\"algolia\"],\"edits\":[{\"type\":\"remove\",\"delete\":\"abc\",\"insert\":\"cde\"},{\"type\":\"replace\",\"delete\":\"abc\",\"insert\":\"cde\"}]}},\"hide\":[{\"objectID\":\"321\"}],\"filterPromotes\":false,\"userData\":{\"algolia\":\"aloglia\"},\"promote\":[{\"objectID\":\"abc\",\"position\":3},{\"objectIDs\":[\"abc\",\"def\"],\"position\":1}]},\"description\":\"test\",\"enabled\":true,\"validity\":[{\"from\":1656670273,\"until\":1656670277}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # saveRules with minimal parameters
  def test_save_rules
    req = @client.save_rules_with_http_info(
      "<YOUR_INDEX_NAME>",
      [
        Rule.new(object_id: "a-rule-id", conditions: [Condition.new(pattern: "smartphone", anchoring: "contains")]),
        Rule.new(object_id: "a-second-rule-id", conditions: [Condition.new(pattern: "apple", anchoring: "contains")])
      ],
      false,
      true
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch", req.path)
    assert_equal({:"forwardToReplicas" => "false", :"clearExistingRules" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "[{\"objectID\":\"a-rule-id\",\"conditions\":[{\"pattern\":\"smartphone\",\"anchoring\":\"contains\"}]},{\"objectID\":\"a-second-rule-id\",\"conditions\":[{\"pattern\":\"apple\",\"anchoring\":\"contains\"}]}]"
      ),
      JSON.parse(req.body)
    )
  end

  # saveRules with all parameters
  def test_save_rules1
    req = @client.save_rules_with_http_info(
      "<YOUR_INDEX_NAME>",
      [
        Rule.new(
          object_id: "id1",
          conditions: [Condition.new(pattern: "apple", anchoring: "contains", alternatives: false, context: "search")],
          consequence: Consequence.new(
            params: ConsequenceParams.new(
              filters: "brand:apple",
              query: ConsequenceQueryObject.new(
                remove: ["algolia"],
                edits: [
                  Edit.new(type: "remove", delete: "abc", insert: "cde"),
                  Edit.new(type: "replace", delete: "abc", insert: "cde")
                ]
              )
            ),
            hide: [ConsequenceHide.new(object_id: "321")],
            filter_promotes: false,
            user_data: {:"algolia" => "aloglia"},
            promote: [
              PromoteObjectID.new(object_id: "abc", position: 3),
              PromoteObjectIDs.new(object_ids: ["abc", "def"], position: 1)
            ]
          ),
          description: "test",
          enabled: true,
          validity: [TimeRange.new(from: 1656670273, _until: 1656670277)]
        )
      ],
      true,
      true
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch", req.path)
    assert_equal({:"forwardToReplicas" => "true", :"clearExistingRules" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "[{\"objectID\":\"id1\",\"conditions\":[{\"pattern\":\"apple\",\"anchoring\":\"contains\",\"alternatives\":false,\"context\":\"search\"}],\"consequence\":{\"params\":{\"filters\":\"brand:apple\",\"query\":{\"remove\":[\"algolia\"],\"edits\":[{\"type\":\"remove\",\"delete\":\"abc\",\"insert\":\"cde\"},{\"type\":\"replace\",\"delete\":\"abc\",\"insert\":\"cde\"}]}},\"hide\":[{\"objectID\":\"321\"}],\"filterPromotes\":false,\"userData\":{\"algolia\":\"aloglia\"},\"promote\":[{\"objectID\":\"abc\",\"position\":3},{\"objectIDs\":[\"abc\",\"def\"],\"position\":1}]},\"description\":\"test\",\"enabled\":true,\"validity\":[{\"from\":1656670273,\"until\":1656670277}]}]"
      ),
      JSON.parse(req.body)
    )
  end

  # saveSynonym
  def test_save_synonym
    req = @client.save_synonym_with_http_info(
      "indexName",
      "id1",
      SynonymHit.new(object_id: "id1", type: "synonym", synonyms: ["car", "vehicule", "auto"]),
      true
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/indexName/synonyms/id1", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"objectID\":\"id1\",\"type\":\"synonym\",\"synonyms\":[\"car\",\"vehicule\",\"auto\"]}"),
      JSON.parse(req.body)
    )
  end

  # saveSynonyms
  def test_save_synonyms
    req = @client.save_synonyms_with_http_info(
      "<YOUR_INDEX_NAME>",
      [
        SynonymHit.new(object_id: "id1", type: "synonym", synonyms: ["car", "vehicule", "auto"]),
        SynonymHit.new(
          object_id: "id2",
          type: "onewaysynonym",
          input: "iphone",
          synonyms: ["ephone", "aphone", "yphone"]
        )
      ],
      true,
      true
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/synonyms/batch", req.path)
    assert_equal({:"forwardToReplicas" => "true", :"replaceExistingSynonyms" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "[{\"objectID\":\"id1\",\"type\":\"synonym\",\"synonyms\":[\"car\",\"vehicule\",\"auto\"]},{\"objectID\":\"id2\",\"type\":\"onewaysynonym\",\"input\":\"iphone\",\"synonyms\":[\"ephone\",\"aphone\",\"yphone\"]}]"
      ),
      JSON.parse(req.body)
    )
  end

  # withHitsPerPage
  def test_search
    req = @client.search_with_http_info(
      SearchMethodParams.new(
        requests: [SearchForHits.new(index_name: "<YOUR_INDEX_NAME>", query: "<YOUR_QUERY>", hits_per_page: 50)]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"hitsPerPage\":50}]}"),
      JSON.parse(req.body)
    )
  end

  # filterOnly
  def test_search1
    req = @client.search_with_http_info(
      SearchMethodParams.new(
        requests: [
          SearchForHits.new(index_name: "<YOUR_INDEX_NAME>", query: "<YOUR_QUERY>", filters: "actor:Scarlett Johansson")
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"filters\":\"actor:Scarlett Johansson\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # filterOr
  def test_search2
    req = @client.search_with_http_info(
      SearchMethodParams.new(
        requests: [
          SearchForHits.new(
            index_name: "<YOUR_INDEX_NAME>",
            query: "<YOUR_QUERY>",
            filters: "actor:Tom Cruise OR actor:Scarlett Johansson"
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"filters\":\"actor:Tom Cruise OR actor:Scarlett Johansson\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # filterNot
  def test_search3
    req = @client.search_with_http_info(
      SearchMethodParams.new(
        requests: [
          SearchForHits.new(index_name: "<YOUR_INDEX_NAME>", query: "<YOUR_QUERY>", filters: "NOT actor:Nicolas Cage")
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"filters\":\"NOT actor:Nicolas Cage\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # search for a single hits request with minimal parameters
  def test_search4
    req = @client.search_with_http_info(
      SearchMethodParams.new(requests: [SearchForHits.new(index_name: "cts_e2e_search_empty_index")])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"requests\":[{\"indexName\":\"cts_e2e_search_empty_index\"}]}"), JSON.parse(req.body))
  end

  # retrieveFacets
  def test_search5
    req = @client.search_with_http_info(
      SearchMethodParams.new(
        requests: [
          SearchForHits.new(index_name: "<YOUR_INDEX_NAME>", query: "<YOUR_QUERY>", facets: ["author", "genre"])
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"facets\":[\"author\",\"genre\"]}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # retrieveFacetsWildcard
  def test_search6
    req = @client.search_with_http_info(
      SearchMethodParams.new(
        requests: [SearchForHits.new(index_name: "<YOUR_INDEX_NAME>", query: "<YOUR_QUERY>", facets: ["*"])]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"requests\":[{\"indexName\":\"<YOUR_INDEX_NAME>\",\"query\":\"<YOUR_QUERY>\",\"facets\":[\"*\"]}]}"),
      JSON.parse(req.body)
    )
  end

  # search for a single facet request with minimal parameters
  def test_search7
    req = @client.search_with_http_info(
      SearchMethodParams.new(
        requests: [SearchForFacets.new(index_name: "cts_e2e_search_facet", type: "facet", facet: "editor")],
        strategy: "stopIfEnoughMatches"
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"cts_e2e_search_facet\",\"type\":\"facet\",\"facet\":\"editor\"}],\"strategy\":\"stopIfEnoughMatches\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # search for a single hits request with all parameters
  def test_search8
    req = @client.search_with_http_info(
      SearchMethodParams.new(
        requests: [SearchForHits.new(index_name: "theIndexName", query: "myQuery", hits_per_page: 50, type: "default")]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"theIndexName\",\"query\":\"myQuery\",\"hitsPerPage\":50,\"type\":\"default\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # search for a single facet request with all parameters
  def test_search9
    req = @client.search_with_http_info(
      SearchMethodParams.new(
        requests: [
          SearchForFacets.new(
            index_name: "theIndexName",
            type: "facet",
            facet: "theFacet",
            facet_query: "theFacetQuery",
            query: "theQuery",
            max_facet_hits: 50
          )
        ],
        strategy: "stopIfEnoughMatches"
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"theIndexName\",\"type\":\"facet\",\"facet\":\"theFacet\",\"facetQuery\":\"theFacetQuery\",\"query\":\"theQuery\",\"maxFacetHits\":50}],\"strategy\":\"stopIfEnoughMatches\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # search for multiple mixed requests in multiple indices with minimal parameters
  def test_search10
    req = @client.search_with_http_info(
      SearchMethodParams.new(
        requests: [
          SearchForHits.new(index_name: "theIndexName"),
          SearchForFacets.new(index_name: "theIndexName2", type: "facet", facet: "theFacet"),
          SearchForHits.new(index_name: "theIndexName", type: "default")
        ],
        strategy: "stopIfEnoughMatches"
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"theIndexName\"},{\"indexName\":\"theIndexName2\",\"type\":\"facet\",\"facet\":\"theFacet\"},{\"indexName\":\"theIndexName\",\"type\":\"default\"}],\"strategy\":\"stopIfEnoughMatches\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # search for multiple mixed requests in multiple indices with all parameters
  def test_search11
    req = @client.search_with_http_info(
      SearchMethodParams.new(
        requests: [
          SearchForFacets.new(
            index_name: "theIndexName",
            type: "facet",
            facet: "theFacet",
            facet_query: "theFacetQuery",
            query: "theQuery",
            max_facet_hits: 50
          ),
          SearchForHits.new(index_name: "theIndexName", query: "myQuery", hits_per_page: 50, type: "default")
        ],
        strategy: "stopIfEnoughMatches"
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"theIndexName\",\"type\":\"facet\",\"facet\":\"theFacet\",\"facetQuery\":\"theFacetQuery\",\"query\":\"theQuery\",\"maxFacetHits\":50},{\"indexName\":\"theIndexName\",\"query\":\"myQuery\",\"hitsPerPage\":50,\"type\":\"default\"}],\"strategy\":\"stopIfEnoughMatches\"}"
      ),
      JSON.parse(req.body)
    )
  end

  # search filters accept all of the possible shapes
  def test_search12
    req = @client.search_with_http_info(
      SearchMethodParams.new(
        requests: [
          SearchForHits.new(
            index_name: "theIndexName",
            facet_filters: "mySearch:filters",
            re_ranking_apply_filter: "mySearch:filters",
            tag_filters: "mySearch:filters",
            numeric_filters: "mySearch:filters",
            optional_filters: "mySearch:filters"
          ),
          SearchForHits.new(
            index_name: "theIndexName",
            facet_filters: ["mySearch:filters", ["mySearch:filters", ["mySearch:filters"]]],
            re_ranking_apply_filter: ["mySearch:filters", ["mySearch:filters"]],
            tag_filters: ["mySearch:filters", ["mySearch:filters"]],
            numeric_filters: ["mySearch:filters", ["mySearch:filters"]],
            optional_filters: ["mySearch:filters", ["mySearch:filters"]]
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"theIndexName\",\"facetFilters\":\"mySearch:filters\",\"reRankingApplyFilter\":\"mySearch:filters\",\"tagFilters\":\"mySearch:filters\",\"numericFilters\":\"mySearch:filters\",\"optionalFilters\":\"mySearch:filters\"},{\"indexName\":\"theIndexName\",\"facetFilters\":[\"mySearch:filters\",[\"mySearch:filters\",[\"mySearch:filters\"]]],\"reRankingApplyFilter\":[\"mySearch:filters\",[\"mySearch:filters\"]],\"tagFilters\":[\"mySearch:filters\",[\"mySearch:filters\"]],\"numericFilters\":[\"mySearch:filters\",[\"mySearch:filters\"]],\"optionalFilters\":[\"mySearch:filters\",[\"mySearch:filters\"]]}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # search filters end to end
  def test_search13
    req = @client.search_with_http_info(
      SearchMethodParams.new(
        requests: [
          SearchForHits.new(index_name: "cts_e2e_search_facet", filters: "editor:'visual studio' OR editor:neovim"),
          SearchForHits.new(
            index_name: "cts_e2e_search_facet",
            facet_filters: ["editor:'visual studio'", "editor:neovim"]
          ),
          SearchForHits.new(
            index_name: "cts_e2e_search_facet",
            facet_filters: ["editor:'visual studio'", ["editor:neovim"]]
          ),
          SearchForHits.new(
            index_name: "cts_e2e_search_facet",
            facet_filters: ["editor:'visual studio'", ["editor:neovim", ["editor:goland"]]]
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"indexName\":\"cts_e2e_search_facet\",\"filters\":\"editor:'visual studio' OR editor:neovim\"},{\"indexName\":\"cts_e2e_search_facet\",\"facetFilters\":[\"editor:'visual studio'\",\"editor:neovim\"]},{\"indexName\":\"cts_e2e_search_facet\",\"facetFilters\":[\"editor:'visual studio'\",[\"editor:neovim\"]]},{\"indexName\":\"cts_e2e_search_facet\",\"facetFilters\":[\"editor:'visual studio'\",[\"editor:neovim\",[\"editor:goland\"]]]}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # search with all search parameters
  def test_search14
    req = @client.search_with_http_info(
      SearchMethodParams.new(
        requests: [
          SearchForHits.new(
            advanced_syntax: true,
            advanced_syntax_features: ["exactPhrase"],
            allow_typos_on_numeric_tokens: true,
            alternatives_as_exact: ["multiWordsSynonym"],
            analytics: true,
            analytics_tags: [""],
            around_lat_lng: "",
            around_lat_lng_via_ip: true,
            around_precision: 0,
            around_radius: "all",
            attribute_criteria_computed_by_min_proximity: true,
            attributes_to_highlight: [""],
            attributes_to_retrieve: [""],
            attributes_to_snippet: [""],
            click_analytics: true,
            custom_ranking: [""],
            decompound_query: true,
            disable_exact_on_attributes: [""],
            disable_typo_tolerance_on_attributes: [""],
            distinct: 0,
            enable_ab_test: true,
            enable_personalization: true,
            enable_re_ranking: true,
            enable_rules: true,
            exact_on_single_word_query: "attribute",
            facet_filters: [""],
            faceting_after_distinct: true,
            facets: [""],
            filters: "",
            get_ranking_info: true,
            highlight_post_tag: "",
            highlight_pre_tag: "",
            hits_per_page: 1,
            ignore_plurals: false,
            index_name: "theIndexName",
            inside_bounding_box: [[47.3165, 4.9665, 47.3424, 5.0201], [40.9234, 2.1185, 38.643, 1.9916]],
            inside_polygon: [
              [47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9],
              [40.9234, 2.1185, 38.643, 1.9916, 39.2587, 2.0104]
            ],
            keep_diacritics_on_characters: "",
            length: 1,
            max_values_per_facet: 0,
            min_proximity: 1,
            min_word_sizefor1_typo: 0,
            min_word_sizefor2_typos: 0,
            minimum_around_radius: 1,
            natural_languages: ["fr"],
            numeric_filters: [""],
            offset: 0,
            optional_filters: [""],
            optional_words: [""],
            page: 0,
            percentile_computation: true,
            personalization_impact: 0,
            query: "",
            query_languages: ["fr"],
            query_type: "prefixAll",
            ranking: [""],
            re_ranking_apply_filter: [""],
            relevancy_strictness: 0,
            remove_stop_words: true,
            remove_words_if_no_results: "allOptional",
            rendering_content: RenderingContent.new(
              facet_ordering: FacetOrdering.new(
                facets: Facets.new(order: ["a", "b"]),
                values: {a: Value.new(order: ["b"], sort_remaining_by: "count")}
              )
            ),
            replace_synonyms_in_highlight: true,
            response_fields: [""],
            restrict_highlight_and_snippet_arrays: true,
            restrict_searchable_attributes: [""],
            rule_contexts: [""],
            similar_query: "",
            snippet_ellipsis_text: "",
            sort_facet_values_by: "",
            sum_or_filters_scores: true,
            synonyms: true,
            tag_filters: [""],
            type: "default",
            typo_tolerance: "min",
            user_token: ""
          )
        ]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/*/queries", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"requests\":[{\"advancedSyntax\":true,\"advancedSyntaxFeatures\":[\"exactPhrase\"],\"allowTyposOnNumericTokens\":true,\"alternativesAsExact\":[\"multiWordsSynonym\"],\"analytics\":true,\"analyticsTags\":[\"\"],\"aroundLatLng\":\"\",\"aroundLatLngViaIP\":true,\"aroundPrecision\":0,\"aroundRadius\":\"all\",\"attributeCriteriaComputedByMinProximity\":true,\"attributesToHighlight\":[\"\"],\"attributesToRetrieve\":[\"\"],\"attributesToSnippet\":[\"\"],\"clickAnalytics\":true,\"customRanking\":[\"\"],\"decompoundQuery\":true,\"disableExactOnAttributes\":[\"\"],\"disableTypoToleranceOnAttributes\":[\"\"],\"distinct\":0,\"enableABTest\":true,\"enablePersonalization\":true,\"enableReRanking\":true,\"enableRules\":true,\"exactOnSingleWordQuery\":\"attribute\",\"facetFilters\":[\"\"],\"facetingAfterDistinct\":true,\"facets\":[\"\"],\"filters\":\"\",\"getRankingInfo\":true,\"highlightPostTag\":\"\",\"highlightPreTag\":\"\",\"hitsPerPage\":1,\"ignorePlurals\":false,\"indexName\":\"theIndexName\",\"insideBoundingBox\":[[47.3165,4.9665,47.3424,5.0201],[40.9234,2.1185,38.643,1.9916]],\"insidePolygon\":[[47.3165,4.9665,47.3424,5.0201,47.32,4.9],[40.9234,2.1185,38.643,1.9916,39.2587,2.0104]],\"keepDiacriticsOnCharacters\":\"\",\"length\":1,\"maxValuesPerFacet\":0,\"minProximity\":1,\"minWordSizefor1Typo\":0,\"minWordSizefor2Typos\":0,\"minimumAroundRadius\":1,\"naturalLanguages\":[\"fr\"],\"numericFilters\":[\"\"],\"offset\":0,\"optionalFilters\":[\"\"],\"optionalWords\":[\"\"],\"page\":0,\"percentileComputation\":true,\"personalizationImpact\":0,\"query\":\"\",\"queryLanguages\":[\"fr\"],\"queryType\":\"prefixAll\",\"ranking\":[\"\"],\"reRankingApplyFilter\":[\"\"],\"relevancyStrictness\":0,\"removeStopWords\":true,\"removeWordsIfNoResults\":\"allOptional\",\"renderingContent\":{\"facetOrdering\":{\"facets\":{\"order\":[\"a\",\"b\"]},\"values\":{\"a\":{\"order\":[\"b\"],\"sortRemainingBy\":\"count\"}}}},\"replaceSynonymsInHighlight\":true,\"responseFields\":[\"\"],\"restrictHighlightAndSnippetArrays\":true,\"restrictSearchableAttributes\":[\"\"],\"ruleContexts\":[\"\"],\"similarQuery\":\"\",\"snippetEllipsisText\":\"\",\"sortFacetValuesBy\":\"\",\"sumOrFiltersScores\":true,\"synonyms\":true,\"tagFilters\":[\"\"],\"type\":\"default\",\"typoTolerance\":\"min\",\"userToken\":\"\"}]}"
      ),
      JSON.parse(req.body)
    )
  end

  # get searchDictionaryEntries results with minimal parameters
  def test_search_dictionary_entries
    req = @client.search_dictionary_entries_with_http_info(
      "stopwords",
      SearchDictionaryEntriesParams.new(query: "about")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/dictionaries/stopwords/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"about\"}"), JSON.parse(req.body))
  end

  # get searchDictionaryEntries results with all parameters
  def test_search_dictionary_entries1
    req = @client.search_dictionary_entries_with_http_info(
      "compounds",
      SearchDictionaryEntriesParams.new(query: "foo", page: 4, hits_per_page: 2, language: "fr")
    )

    assert_equal(:post, req.method)
    assert_equal("/1/dictionaries/compounds/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"foo\",\"page\":4,\"hitsPerPage\":2,\"language\":\"fr\"}"),
      JSON.parse(req.body)
    )
  end

  # get searchForFacetValues results with minimal parameters
  def test_search_for_facet_values
    req = @client.search_for_facet_values_with_http_info("indexName", "facetName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/facets/facetName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # get searchForFacetValues results with all parameters
  def test_search_for_facet_values1
    req = @client.search_for_facet_values_with_http_info(
      "indexName",
      "facetName",
      SearchForFacetValuesRequest.new(params: "query=foo&facetFilters=['bar']", facet_query: "foo", max_facet_hits: 42)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/facets/facetName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"params\":\"query=foo&facetFilters=['bar']\",\"facetQuery\":\"foo\",\"maxFacetHits\":42}"),
      JSON.parse(req.body)
    )
  end

  # searchRules
  def test_search_rules
    req = @client.search_rules_with_http_info("indexName", SearchRulesParams.new(query: "something"))

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/rules/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"something\"}"), JSON.parse(req.body))
  end

  # search with minimal parameters
  def test_search_single_index
    req = @client.search_single_index_with_http_info("indexName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # search with special characters in indexName
  def test_search_single_index1
    req = @client.search_single_index_with_http_info("cts_e2e_space in index")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/cts_e2e_space%20in%20index/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # search with searchParams
  def test_search_single_index2
    req = @client.search_single_index_with_http_info(
      "indexName",
      SearchParamsObject.new(query: "myQuery", facet_filters: ["tags:algolia"])
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"query\":\"myQuery\",\"facetFilters\":[\"tags:algolia\"]}"), JSON.parse(req.body))
  end

  # single search retrieve snippets
  def test_search_single_index3
    req = @client.search_single_index_with_http_info(
      "cts_e2e_browse",
      SearchParamsObject.new(
        query: "batman mask of the phantasm",
        attributes_to_retrieve: ["*"],
        attributes_to_snippet: ["*:20"]
      )
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/cts_e2e_browse/query", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"query\":\"batman mask of the phantasm\",\"attributesToRetrieve\":[\"*\"],\"attributesToSnippet\":[\"*:20\"]}"
      ),
      JSON.parse(req.body)
    )
  end

  # searchSynonyms with minimal parameters
  def test_search_synonyms
    req = @client.search_synonyms_with_http_info("indexName")

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/synonyms/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{}"), JSON.parse(req.body))
  end

  # searchSynonyms with all parameters
  def test_search_synonyms1
    req = @client.search_synonyms_with_http_info(
      "indexName",
      SearchSynonymsParams.new(query: "myQuery", type: "altcorrection1", page: 10, hits_per_page: 10)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/indexes/indexName/synonyms/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"myQuery\",\"type\":\"altcorrection1\",\"page\":10,\"hitsPerPage\":10}"),
      JSON.parse(req.body)
    )
  end

  # searchUserIds
  def test_search_user_ids
    req = @client.search_user_ids_with_http_info(
      SearchUserIdsParams.new(query: "test", cluster_name: "theClusterName", page: 5, hits_per_page: 10)
    )

    assert_equal(:post, req.method)
    assert_equal("/1/clusters/mapping/search", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"query\":\"test\",\"clusterName\":\"theClusterName\",\"page\":5,\"hitsPerPage\":10}"),
      JSON.parse(req.body)
    )
  end

  # get setDictionarySettings results with minimal parameters
  def test_set_dictionary_settings
    req = @client.set_dictionary_settings_with_http_info(
      DictionarySettingsParams.new(
        disable_standard_entries: StandardEntries.new(plurals: {fr: false, en: false, ru: true})
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/dictionaries/*/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"disableStandardEntries\":{\"plurals\":{\"fr\":false,\"en\":false,\"ru\":true}}}"),
      JSON.parse(req.body)
    )
  end

  # get setDictionarySettings results with all parameters
  def test_set_dictionary_settings1
    req = @client.set_dictionary_settings_with_http_info(
      DictionarySettingsParams.new(
        disable_standard_entries: StandardEntries.new(
          plurals: {fr: false, en: false, ru: true},
          stopwords: {fr: false},
          compounds: {ru: true}
        )
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/dictionaries/*/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"disableStandardEntries\":{\"plurals\":{\"fr\":false,\"en\":false,\"ru\":true},\"stopwords\":{\"fr\":false},\"compounds\":{\"ru\":true}}}"
      ),
      JSON.parse(req.body)
    )
  end

  # setSettingsAttributesForFaceting
  def test_set_settings
    req = @client.set_settings_with_http_info(
      "<YOUR_INDEX_NAME>",
      IndexSettings.new(attributes_for_faceting: ["actor", "filterOnly(category)", "searchable(publisher)"])
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/%3CYOUR_INDEX_NAME%3E/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse("{\"attributesForFaceting\":[\"actor\",\"filterOnly(category)\",\"searchable(publisher)\"]}"),
      JSON.parse(req.body)
    )
  end

  # setSettings with minimal parameters
  def test_set_settings1
    req = @client.set_settings_with_http_info("cts_e2e_settings", IndexSettings.new(pagination_limited_to: 10), true)

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/cts_e2e_settings/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"paginationLimitedTo\":10}"), JSON.parse(req.body))
  end

  # setSettings allow boolean `typoTolerance`
  def test_set_settings2
    req = @client.set_settings_with_http_info("theIndexName", IndexSettings.new(typo_tolerance: true), true)

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"typoTolerance\":true}"), JSON.parse(req.body))
  end

  # setSettings allow enum `typoTolerance`
  def test_set_settings3
    req = @client.set_settings_with_http_info("theIndexName", IndexSettings.new(typo_tolerance: "min"), true)

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"typoTolerance\":\"min\"}"), JSON.parse(req.body))
  end

  # setSettings allow boolean `ignorePlurals`
  def test_set_settings4
    req = @client.set_settings_with_http_info("theIndexName", IndexSettings.new(ignore_plurals: true), true)

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"ignorePlurals\":true}"), JSON.parse(req.body))
  end

  # setSettings allow list of string `ignorePlurals`
  def test_set_settings5
    req = @client.set_settings_with_http_info("theIndexName", IndexSettings.new(ignore_plurals: ["fr"]), true)

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"ignorePlurals\":[\"fr\"]}"), JSON.parse(req.body))
  end

  # setSettings allow boolean `removeStopWords`
  def test_set_settings6
    req = @client.set_settings_with_http_info("theIndexName", IndexSettings.new(remove_stop_words: true), true)

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"removeStopWords\":true}"), JSON.parse(req.body))
  end

  # setSettings allow list of string `removeStopWords`
  def test_set_settings7
    req = @client.set_settings_with_http_info("theIndexName", IndexSettings.new(remove_stop_words: ["fr"]), true)

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"removeStopWords\":[\"fr\"]}"), JSON.parse(req.body))
  end

  # setSettings allow boolean `distinct`
  def test_set_settings8
    req = @client.set_settings_with_http_info("theIndexName", IndexSettings.new(distinct: true), true)

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"distinct\":true}"), JSON.parse(req.body))
  end

  # setSettings allow integers for `distinct`
  def test_set_settings9
    req = @client.set_settings_with_http_info("theIndexName", IndexSettings.new(distinct: 1), true)

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({:"forwardToReplicas" => "true"}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(JSON.parse("{\"distinct\":1}"), JSON.parse(req.body))
  end

  # setSettings allow all `indexSettings`
  def test_set_settings10
    req = @client.set_settings_with_http_info(
      "theIndexName",
      IndexSettings.new(
        advanced_syntax: true,
        advanced_syntax_features: ["exactPhrase"],
        allow_compression_of_integer_array: true,
        allow_typos_on_numeric_tokens: true,
        alternatives_as_exact: ["singleWordSynonym"],
        attribute_criteria_computed_by_min_proximity: true,
        attribute_for_distinct: "test",
        attributes_for_faceting: ["algolia"],
        attributes_to_highlight: ["algolia"],
        attributes_to_retrieve: ["algolia"],
        attributes_to_snippet: ["algolia"],
        attributes_to_transliterate: ["algolia"],
        camel_case_attributes: ["algolia"],
        custom_normalization: {algolia: {aloglia: "aglolia"}},
        custom_ranking: ["algolia"],
        decompound_query: false,
        decompounded_attributes: {algolia: "aloglia"},
        disable_exact_on_attributes: ["algolia"],
        disable_prefix_on_attributes: ["algolia"],
        disable_typo_tolerance_on_attributes: ["algolia"],
        disable_typo_tolerance_on_words: ["algolia"],
        distinct: 3,
        enable_personalization: true,
        enable_re_ranking: false,
        enable_rules: true,
        exact_on_single_word_query: "attribute",
        highlight_pre_tag: "<span>",
        highlight_post_tag: "</span>",
        hits_per_page: 10,
        ignore_plurals: false,
        index_languages: ["fr"],
        keep_diacritics_on_characters: "abc",
        max_facet_hits: 20,
        max_values_per_facet: 30,
        min_proximity: 6,
        min_word_sizefor1_typo: 5,
        min_word_sizefor2_typos: 11,
        mode: "neuralSearch",
        numeric_attributes_for_filtering: ["algolia"],
        optional_words: ["myspace"],
        pagination_limited_to: 0,
        query_languages: ["fr"],
        query_type: "prefixLast",
        ranking: ["geo"],
        re_ranking_apply_filter: "mySearch:filters",
        relevancy_strictness: 10,
        remove_stop_words: false,
        remove_words_if_no_results: "lastWords",
        rendering_content: RenderingContent.new(
          facet_ordering: FacetOrdering.new(
            facets: Facets.new(order: ["a", "b"]),
            values: {a: Value.new(order: ["b"], sort_remaining_by: "count")}
          )
        ),
        replace_synonyms_in_highlight: true,
        replicas: [""],
        response_fields: ["algolia"],
        restrict_highlight_and_snippet_arrays: true,
        searchable_attributes: ["foo"],
        semantic_search: SemanticSearch.new(event_sources: ["foo"]),
        separators_to_index: "bar",
        snippet_ellipsis_text: "---",
        sort_facet_values_by: "date",
        typo_tolerance: false,
        unretrievable_attributes: ["foo"],
        user_data: {user: "data"}
      )
    )

    assert_equal(:put, req.method)
    assert_equal("/1/indexes/theIndexName/settings", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"advancedSyntax\":true,\"advancedSyntaxFeatures\":[\"exactPhrase\"],\"allowCompressionOfIntegerArray\":true,\"allowTyposOnNumericTokens\":true,\"alternativesAsExact\":[\"singleWordSynonym\"],\"attributeCriteriaComputedByMinProximity\":true,\"attributeForDistinct\":\"test\",\"attributesForFaceting\":[\"algolia\"],\"attributesToHighlight\":[\"algolia\"],\"attributesToRetrieve\":[\"algolia\"],\"attributesToSnippet\":[\"algolia\"],\"attributesToTransliterate\":[\"algolia\"],\"camelCaseAttributes\":[\"algolia\"],\"customNormalization\":{\"algolia\":{\"aloglia\":\"aglolia\"}},\"customRanking\":[\"algolia\"],\"decompoundQuery\":false,\"decompoundedAttributes\":{\"algolia\":\"aloglia\"},\"disableExactOnAttributes\":[\"algolia\"],\"disablePrefixOnAttributes\":[\"algolia\"],\"disableTypoToleranceOnAttributes\":[\"algolia\"],\"disableTypoToleranceOnWords\":[\"algolia\"],\"distinct\":3,\"enablePersonalization\":true,\"enableReRanking\":false,\"enableRules\":true,\"exactOnSingleWordQuery\":\"attribute\",\"highlightPreTag\":\"<span>\",\"highlightPostTag\":\"</span>\",\"hitsPerPage\":10,\"ignorePlurals\":false,\"indexLanguages\":[\"fr\"],\"keepDiacriticsOnCharacters\":\"abc\",\"maxFacetHits\":20,\"maxValuesPerFacet\":30,\"minProximity\":6,\"minWordSizefor1Typo\":5,\"minWordSizefor2Typos\":11,\"mode\":\"neuralSearch\",\"numericAttributesForFiltering\":[\"algolia\"],\"optionalWords\":[\"myspace\"],\"paginationLimitedTo\":0,\"queryLanguages\":[\"fr\"],\"queryType\":\"prefixLast\",\"ranking\":[\"geo\"],\"reRankingApplyFilter\":\"mySearch:filters\",\"relevancyStrictness\":10,\"removeStopWords\":false,\"removeWordsIfNoResults\":\"lastWords\",\"renderingContent\":{\"facetOrdering\":{\"facets\":{\"order\":[\"a\",\"b\"]},\"values\":{\"a\":{\"order\":[\"b\"],\"sortRemainingBy\":\"count\"}}}},\"replaceSynonymsInHighlight\":true,\"replicas\":[\"\"],\"responseFields\":[\"algolia\"],\"restrictHighlightAndSnippetArrays\":true,\"searchableAttributes\":[\"foo\"],\"semanticSearch\":{\"eventSources\":[\"foo\"]},\"separatorsToIndex\":\"bar\",\"snippetEllipsisText\":\"---\",\"sortFacetValuesBy\":\"date\",\"typoTolerance\":false,\"unretrievableAttributes\":[\"foo\"],\"userData\":{\"user\":\"data\"}}"
      ),
      JSON.parse(req.body)
    )
  end

  # updateApiKey
  def test_update_api_key
    req = @client.update_api_key_with_http_info(
      "myApiKey",
      ApiKey.new(acl: ["search", "addObject"], validity: 300, max_queries_per_ip_per_hour: 100, max_hits_per_query: 20)
    )

    assert_equal(:put, req.method)
    assert_equal("/1/keys/myApiKey", req.path)
    assert_equal({}.to_a, req.query_params.to_a)
    assert(({}.to_a - req.headers.to_a).empty?, req.headers.to_s)
    assert_equal(
      JSON.parse(
        "{\"acl\":[\"search\",\"addObject\"],\"validity\":300,\"maxQueriesPerIPPerHour\":100,\"maxHitsPerQuery\":20}"
      ),
      JSON.parse(req.body)
    )
  end

end
