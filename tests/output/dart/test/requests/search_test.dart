// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
import 'package:algolia_client_search/algolia_client_search.dart';
import 'package:algolia_test/algolia_test.dart';
import 'package:test/test.dart';

void main() {
  // addApiKey
  test(
    'addApiKey',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.addApiKey(
        apiKey: ApiKey(
          acl: [
            Acl.fromJson("search"),
            Acl.fromJson("addObject"),
          ],
          description: "my new api key",
          validity: 300,
          maxQueriesPerIPPerHour: 100,
          maxHitsPerQuery: 20,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/keys');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"acl":["search","addObject"],"description":"my new api key","validity":300,"maxQueriesPerIPPerHour":100,"maxHitsPerQuery":20}""");
      },
    ),
  );

  // addOrUpdateObject
  test(
    'addOrUpdateObject',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.addOrUpdateObject(
        indexName: "indexName",
        objectID: "uniqueID",
        body: {
          'key': "value",
        },
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/uniqueID');
        expect(request.method, 'put');
        expectBody(request.body, """{"key":"value"}""");
      },
    ),
  );

  // appendSource
  test(
    'appendSource',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.appendSource(
        source: Source(
          source: "theSource",
          description: "theDescription",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/security/sources/append');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"source":"theSource","description":"theDescription"}""");
      },
    ),
  );

  // assignUserId
  test(
    'simple',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.assignUserId(
        xAlgoliaUserID: "user42",
        assignUserIdParams: AssignUserIdParams(
          cluster: "d4242-eu",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/clusters/mapping');
        expect(request.method, 'post');
        expectHeaders(request.headers, """{"x-algolia-user-id":"user42"}""");
        expectBody(request.body, """{"cluster":"d4242-eu"}""");
      },
    ),
  );

  // assignUserId
  test(
    'it should not encode the userID',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.assignUserId(
        xAlgoliaUserID: "user id with spaces",
        assignUserIdParams: AssignUserIdParams(
          cluster: "cluster with spaces",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/clusters/mapping');
        expect(request.method, 'post');
        expectHeaders(
            request.headers, """{"x-algolia-user-id":"user id with spaces"}""");
        expectBody(request.body, """{"cluster":"cluster with spaces"}""");
      },
    ),
  );

  // batch
  test(
    'addObject',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.batch(
        indexName: "<YOUR_INDEX_NAME>",
        batchWriteParams: BatchWriteParams(
          requests: [
            BatchRequest(
              action: Action.fromJson("addObject"),
              body: {
                'key': "bar",
                'foo': "1",
              },
            ),
            BatchRequest(
              action: Action.fromJson("addObject"),
              body: {
                'key': "baz",
                'foo': "2",
              },
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/batch');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"action":"addObject","body":{"key":"bar","foo":"1"}},{"action":"addObject","body":{"key":"baz","foo":"2"}}]}""");
      },
    ),
  );

  // batch
  test(
    'clear',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.batch(
        indexName: "<YOUR_INDEX_NAME>",
        batchWriteParams: BatchWriteParams(
          requests: [
            BatchRequest(
              action: Action.fromJson("clear"),
              body: {
                'key': "value",
              },
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/batch');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"action":"clear","body":{"key":"value"}}]}""");
      },
    ),
  );

  // batch
  test(
    'delete',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.batch(
        indexName: "<YOUR_INDEX_NAME>",
        batchWriteParams: BatchWriteParams(
          requests: [
            BatchRequest(
              action: Action.fromJson("delete"),
              body: {
                'key': "value",
              },
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/batch');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"action":"delete","body":{"key":"value"}}]}""");
      },
    ),
  );

  // batch
  test(
    'deleteObject',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.batch(
        indexName: "<YOUR_INDEX_NAME>",
        batchWriteParams: BatchWriteParams(
          requests: [
            BatchRequest(
              action: Action.fromJson("deleteObject"),
              body: {
                'key': "value",
              },
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/batch');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"action":"deleteObject","body":{"key":"value"}}]}""");
      },
    ),
  );

  // batch
  test(
    'partialUpdateObject',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.batch(
        indexName: "<YOUR_INDEX_NAME>",
        batchWriteParams: BatchWriteParams(
          requests: [
            BatchRequest(
              action: Action.fromJson("partialUpdateObject"),
              body: {
                'key': "value",
              },
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/batch');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"action":"partialUpdateObject","body":{"key":"value"}}]}""");
      },
    ),
  );

  // batch
  test(
    'partialUpdateObjectNoCreate',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.batch(
        indexName: "<YOUR_INDEX_NAME>",
        batchWriteParams: BatchWriteParams(
          requests: [
            BatchRequest(
              action: Action.fromJson("partialUpdateObjectNoCreate"),
              body: {
                'key': "value",
              },
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/batch');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"action":"partialUpdateObjectNoCreate","body":{"key":"value"}}]}""");
      },
    ),
  );

  // batch
  test(
    'updateObject',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.batch(
        indexName: "<YOUR_INDEX_NAME>",
        batchWriteParams: BatchWriteParams(
          requests: [
            BatchRequest(
              action: Action.fromJson("updateObject"),
              body: {
                'key': "value",
              },
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/batch');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"action":"updateObject","body":{"key":"value"}}]}""");
      },
    ),
  );

  // batchAssignUserIds
  test(
    'batchAssignUserIds',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.batchAssignUserIds(
        xAlgoliaUserID: "userID",
        batchAssignUserIdsParams: BatchAssignUserIdsParams(
          cluster: "theCluster",
          users: [
            "user1",
            "user2",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/clusters/mapping/batch');
        expect(request.method, 'post');
        expectHeaders(request.headers, """{"x-algolia-user-id":"userID"}""");
        expectBody(request.body,
            """{"cluster":"theCluster","users":["user1","user2"]}""");
      },
    ),
  );

  // batchDictionaryEntries
  test(
    'replace',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.batchDictionaryEntries(
        dictionaryName: DictionaryType.fromJson("plurals"),
        batchDictionaryEntriesParams: BatchDictionaryEntriesParams(
          clearExistingDictionaryEntries: true,
          requests: [
            BatchDictionaryEntriesRequest(
              action: DictionaryAction.fromJson("addEntry"),
              body: DictionaryEntry(
                objectID: "1",
                language: SupportedLanguage.fromJson("en"),
                word: "fancy",
                words: [
                  "believe",
                  "algolia",
                ],
                decomposition: [
                  "trust",
                  "algolia",
                ],
                state: DictionaryEntryState.fromJson("enabled"),
              ),
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/dictionaries/plurals/batch');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"clearExistingDictionaryEntries":true,"requests":[{"action":"addEntry","body":{"objectID":"1","language":"en","word":"fancy","words":["believe","algolia"],"decomposition":["trust","algolia"],"state":"enabled"}}]}""");
      },
    ),
  );

  // batchDictionaryEntries
  test(
    'delete',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.batchDictionaryEntries(
        dictionaryName: DictionaryType.fromJson("plurals"),
        batchDictionaryEntriesParams: BatchDictionaryEntriesParams(
          clearExistingDictionaryEntries: true,
          requests: [
            BatchDictionaryEntriesRequest(
              action: DictionaryAction.fromJson("deleteEntry"),
              body: DictionaryEntry(
                objectID: "1",
              ),
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/dictionaries/plurals/batch');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"clearExistingDictionaryEntries":true,"requests":[{"action":"deleteEntry","body":{"objectID":"1"}}]}""");
      },
    ),
  );

  // batchDictionaryEntries
  test(
    'append',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.batchDictionaryEntries(
        dictionaryName: DictionaryType.fromJson("stopwords"),
        batchDictionaryEntriesParams: BatchDictionaryEntriesParams(
          requests: [
            BatchDictionaryEntriesRequest(
              action: DictionaryAction.fromJson("addEntry"),
              body: DictionaryEntry(
                objectID: "1",
                language: SupportedLanguage.fromJson("en"),
                additionalProperties: {'additional': 'try me'},
              ),
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/dictionaries/stopwords/batch');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"action":"addEntry","body":{"objectID":"1","language":"en","additional":"try me"}}]}""");
      },
    ),
  );

  // browse
  test(
    'browse with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.browse(
        indexName: "cts_e2e_browse",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/cts_e2e_browse/browse');
        expect(request.method, 'post');
        expectBody(request.body, """{}""");
      },
    ),
  );

  // browse
  test(
    'browse with search parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.browse(
        indexName: "indexName",
        browseParams: BrowseParamsObject(
          query: "myQuery",
          facetFilters: [
            "tags:algolia",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/browse');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"query":"myQuery","facetFilters":["tags:algolia"]}""");
      },
    ),
  );

  // browse
  test(
    'browse allow a cursor in parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.browse(
        indexName: "indexName",
        browseParams: BrowseParamsObject(
          cursor: "test",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/browse');
        expect(request.method, 'post');
        expectBody(request.body, """{"cursor":"test"}""");
      },
    ),
  );

  // clearObjects
  test(
    'clearObjects',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.clearObjects(
        indexName: "theIndexName",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/clear');
        expect(request.method, 'post');
        expect(request.body, {});
      },
    ),
  );

  // clearRules
  test(
    'clearRules',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.clearRules(
        indexName: "indexName",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/rules/clear');
        expect(request.method, 'post');
        expect(request.body, {});
      },
    ),
  );

  // clearSynonyms
  test(
    'clearSynonyms',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.clearSynonyms(
        indexName: "indexName",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/synonyms/clear');
        expect(request.method, 'post');
        expect(request.body, {});
      },
    ),
  );

  // customDelete
  test(
    'allow del method for a custom path with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customDelete(
        path: "test/minimal",
      ),
      intercept: (request) {
        expectPath(request.path, '/test/minimal');
        expect(request.method, 'delete');
        expect(request.body, null);
      },
    ),
  );

  // customDelete
  test(
    'allow del method for a custom path with all parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customDelete(
        path: "test/all",
        parameters: {
          'query': "parameters",
        },
      ),
      intercept: (request) {
        expectPath(request.path, '/test/all');
        expect(request.method, 'delete');
        expectParams(request.queryParameters, """{"query":"parameters"}""");
        expect(request.body, null);
      },
    ),
  );

  // customGet
  test(
    'allow get method for a custom path with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customGet(
        path: "test/minimal",
      ),
      intercept: (request) {
        expectPath(request.path, '/test/minimal');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // customGet
  test(
    'allow get method for a custom path with all parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customGet(
        path: "test/all",
        parameters: {
          'query': "parameters with space",
        },
      ),
      intercept: (request) {
        expectPath(request.path, '/test/all');
        expect(request.method, 'get');
        expectParams(request.queryParameters,
            """{"query":"parameters%20with%20space"}""");
        expect(request.body, null);
      },
    ),
  );

  // customGet
  test(
    'requestOptions should be escaped too',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customGet(
        path: "test/all",
        parameters: {
          'query': "to be overriden",
        },
        requestOptions: RequestOptions(
          headers: {
            'x-header-1': 'spaces are left alone',
          },
          urlParameters: {
            'query': "parameters with space",
            'and an array': [
              "array",
              "with spaces",
            ],
          },
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/test/all');
        expect(request.method, 'get');
        expectHeaders(
            request.headers, """{"x-header-1":"spaces are left alone"}""");
        expectParams(request.queryParameters,
            """{"query":"parameters%20with%20space","and%20an%20array":"array%2Cwith%20spaces"}""");
        expect(request.body, null);
      },
    ),
  );

  // customPost
  test(
    'allow post method for a custom path with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customPost(
        path: "test/minimal",
      ),
      intercept: (request) {
        expectPath(request.path, '/test/minimal');
        expect(request.method, 'post');
        expectBody(request.body, """{}""");
      },
    ),
  );

  // customPost
  test(
    'allow post method for a custom path with all parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customPost(
        path: "test/all",
        parameters: {
          'query': "parameters",
        },
        body: {
          'body': "parameters",
        },
      ),
      intercept: (request) {
        expectPath(request.path, '/test/all');
        expect(request.method, 'post');
        expectParams(request.queryParameters, """{"query":"parameters"}""");
        expectBody(request.body, """{"body":"parameters"}""");
      },
    ),
  );

  // customPost
  test(
    'requestOptions can override default query parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customPost(
        path: "test/requestOptions",
        parameters: {
          'query': "parameters",
        },
        body: {
          'facet': "filters",
        },
        requestOptions: RequestOptions(
          urlParameters: {
            'query': "myQueryParameter",
          },
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/test/requestOptions');
        expect(request.method, 'post');
        expectParams(
            request.queryParameters, """{"query":"myQueryParameter"}""");
        expectBody(request.body, """{"facet":"filters"}""");
      },
    ),
  );

  // customPost
  test(
    'requestOptions merges query parameters with default ones',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customPost(
        path: "test/requestOptions",
        parameters: {
          'query': "parameters",
        },
        body: {
          'facet': "filters",
        },
        requestOptions: RequestOptions(
          urlParameters: {
            'query2': "myQueryParameter",
          },
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/test/requestOptions');
        expect(request.method, 'post');
        expectParams(request.queryParameters,
            """{"query":"parameters","query2":"myQueryParameter"}""");
        expectBody(request.body, """{"facet":"filters"}""");
      },
    ),
  );

  // customPost
  test(
    'requestOptions can override default headers',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customPost(
        path: "test/requestOptions",
        parameters: {
          'query': "parameters",
        },
        body: {
          'facet': "filters",
        },
        requestOptions: RequestOptions(
          headers: {
            'x-algolia-api-key': 'ALGOLIA_API_KEY',
          },
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/test/requestOptions');
        expect(request.method, 'post');
        expectHeaders(
            request.headers, """{"x-algolia-api-key":"ALGOLIA_API_KEY"}""");
        expectParams(request.queryParameters, """{"query":"parameters"}""");
        expectBody(request.body, """{"facet":"filters"}""");
      },
    ),
  );

  // customPost
  test(
    'requestOptions merges headers with default ones',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customPost(
        path: "test/requestOptions",
        parameters: {
          'query': "parameters",
        },
        body: {
          'facet': "filters",
        },
        requestOptions: RequestOptions(
          headers: {
            'x-algolia-api-key': 'ALGOLIA_API_KEY',
          },
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/test/requestOptions');
        expect(request.method, 'post');
        expectHeaders(
            request.headers, """{"x-algolia-api-key":"ALGOLIA_API_KEY"}""");
        expectParams(request.queryParameters, """{"query":"parameters"}""");
        expectBody(request.body, """{"facet":"filters"}""");
      },
    ),
  );

  // customPost
  test(
    'requestOptions queryParameters accepts booleans',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customPost(
        path: "test/requestOptions",
        parameters: {
          'query': "parameters",
        },
        body: {
          'facet': "filters",
        },
        requestOptions: RequestOptions(
          urlParameters: {
            'isItWorking': true,
          },
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/test/requestOptions');
        expect(request.method, 'post');
        expectParams(request.queryParameters,
            """{"query":"parameters","isItWorking":"true"}""");
        expectBody(request.body, """{"facet":"filters"}""");
      },
    ),
  );

  // customPost
  test(
    'requestOptions queryParameters accepts integers',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customPost(
        path: "test/requestOptions",
        parameters: {
          'query': "parameters",
        },
        body: {
          'facet': "filters",
        },
        requestOptions: RequestOptions(
          urlParameters: {
            'myParam': 2,
          },
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/test/requestOptions');
        expect(request.method, 'post');
        expectParams(request.queryParameters,
            """{"query":"parameters","myParam":"2"}""");
        expectBody(request.body, """{"facet":"filters"}""");
      },
    ),
  );

  // customPost
  test(
    'requestOptions queryParameters accepts list of string',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customPost(
        path: "test/requestOptions",
        parameters: {
          'query': "parameters",
        },
        body: {
          'facet': "filters",
        },
        requestOptions: RequestOptions(
          urlParameters: {
            'myParam': [
              "b and c",
              "d",
            ],
          },
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/test/requestOptions');
        expect(request.method, 'post');
        expectParams(request.queryParameters,
            """{"query":"parameters","myParam":"b%20and%20c%2Cd"}""");
        expectBody(request.body, """{"facet":"filters"}""");
      },
    ),
  );

  // customPost
  test(
    'requestOptions queryParameters accepts list of booleans',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customPost(
        path: "test/requestOptions",
        parameters: {
          'query': "parameters",
        },
        body: {
          'facet': "filters",
        },
        requestOptions: RequestOptions(
          urlParameters: {
            'myParam': [
              true,
              true,
              false,
            ],
          },
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/test/requestOptions');
        expect(request.method, 'post');
        expectParams(request.queryParameters,
            """{"query":"parameters","myParam":"true%2Ctrue%2Cfalse"}""");
        expectBody(request.body, """{"facet":"filters"}""");
      },
    ),
  );

  // customPost
  test(
    'requestOptions queryParameters accepts list of integers',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customPost(
        path: "test/requestOptions",
        parameters: {
          'query': "parameters",
        },
        body: {
          'facet': "filters",
        },
        requestOptions: RequestOptions(
          urlParameters: {
            'myParam': [
              1,
              2,
            ],
          },
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/test/requestOptions');
        expect(request.method, 'post');
        expectParams(request.queryParameters,
            """{"query":"parameters","myParam":"1%2C2"}""");
        expectBody(request.body, """{"facet":"filters"}""");
      },
    ),
  );

  // customPut
  test(
    'allow put method for a custom path with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customPut(
        path: "test/minimal",
      ),
      intercept: (request) {
        expectPath(request.path, '/test/minimal');
        expect(request.method, 'put');
        expectBody(request.body, """{}""");
      },
    ),
  );

  // customPut
  test(
    'allow put method for a custom path with all parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.customPut(
        path: "test/all",
        parameters: {
          'query': "parameters",
        },
        body: {
          'body': "parameters",
        },
      ),
      intercept: (request) {
        expectPath(request.path, '/test/all');
        expect(request.method, 'put');
        expectParams(request.queryParameters, """{"query":"parameters"}""");
        expectBody(request.body, """{"body":"parameters"}""");
      },
    ),
  );

  // deleteApiKey
  test(
    'deleteApiKey',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.deleteApiKey(
        key: "myTestApiKey",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/keys/myTestApiKey');
        expect(request.method, 'delete');
        expect(request.body, null);
      },
    ),
  );

  // deleteBy
  test(
    'deleteBy',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.deleteBy(
        indexName: "theIndexName",
        deleteByParams: DeleteByParams(
          filters: "brand:brandName",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/deleteByQuery');
        expect(request.method, 'post');
        expectBody(request.body, """{"filters":"brand:brandName"}""");
      },
    ),
  );

  // deleteIndex
  test(
    'deleteIndex',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.deleteIndex(
        indexName: "theIndexName",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName');
        expect(request.method, 'delete');
        expect(request.body, null);
      },
    ),
  );

  // deleteObject
  test(
    'deleteObject',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.deleteObject(
        indexName: "<YOUR_INDEX_NAME>",
        objectID: "uniqueID",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/uniqueID');
        expect(request.method, 'delete');
        expect(request.body, null);
      },
    ),
  );

  // deleteRule
  test(
    'delete rule simple case',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.deleteRule(
        indexName: "indexName",
        objectID: "id1",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/rules/id1');
        expect(request.method, 'delete');
        expect(request.body, null);
      },
    ),
  );

  // deleteRule
  test(
    'delete rule with simple characters to encode in objectID',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.deleteRule(
        indexName: "indexName",
        objectID: "test/with/slash",
      ),
      intercept: (request) {
        expectPath(
            request.path, '/1/indexes/indexName/rules/test%2Fwith%2Fslash');
        expect(request.method, 'delete');
        expect(request.body, null);
      },
    ),
  );

  // deleteSource
  test(
    'deleteSource',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.deleteSource(
        source: "theSource",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/security/sources/theSource');
        expect(request.method, 'delete');
        expect(request.body, null);
      },
    ),
  );

  // deleteSynonym
  test(
    'deleteSynonym',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.deleteSynonym(
        indexName: "indexName",
        objectID: "id1",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/synonyms/id1');
        expect(request.method, 'delete');
        expect(request.body, null);
      },
    ),
  );

  // getApiKey
  test(
    'getApiKey',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.getApiKey(
        key: "myTestApiKey",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/keys/myTestApiKey');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // getAppTask
  test(
    'getAppTask',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.getAppTask(
        taskID: 123,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/task/123');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // getDictionaryLanguages
  test(
    'get getDictionaryLanguages',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.getDictionaryLanguages(),
      intercept: (request) {
        expectPath(request.path, '/1/dictionaries/*/languages');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // getDictionarySettings
  test(
    'get getDictionarySettings results',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.getDictionarySettings(),
      intercept: (request) {
        expectPath(request.path, '/1/dictionaries/*/settings');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // getLogs
  test(
    'getLogs with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.getLogs(),
      intercept: (request) {
        expectPath(request.path, '/1/logs');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // getLogs
  test(
    'getLogs with parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.getLogs(
        offset: 5,
        length: 10,
        indexName: "theIndexName",
        type: LogType.fromJson("all"),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/logs');
        expect(request.method, 'get');
        expectParams(request.queryParameters,
            """{"offset":"5","length":"10","indexName":"theIndexName","type":"all"}""");
        expect(request.body, null);
      },
    ),
  );

  // getObject
  test(
    'getObject',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.getObject(
        indexName: "theIndexName",
        objectID: "uniqueID",
        attributesToRetrieve: [
          "attr1",
          "attr2",
        ],
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/uniqueID');
        expect(request.method, 'get');
        expectParams(request.queryParameters,
            """{"attributesToRetrieve":"attr1%2Cattr2"}""");
        expect(request.body, null);
      },
    ),
  );

  // getObject
  test(
    'search with a real object',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.getObject(
        indexName: "cts_e2e_browse",
        objectID: "Batman and Robin",
      ),
      intercept: (request) {
        expectPath(
            request.path, '/1/indexes/cts_e2e_browse/Batman%20and%20Robin');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // getObjects
  test(
    'getObjects',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.getObjects(
        getObjectsParams: GetObjectsParams(
          requests: [
            GetObjectsRequest(
              attributesToRetrieve: [
                "attr1",
                "attr2",
              ],
              objectID: "uniqueID",
              indexName: "theIndexName",
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/objects');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"attributesToRetrieve":["attr1","attr2"],"objectID":"uniqueID","indexName":"theIndexName"}]}""");
      },
    ),
  );

  // getRule
  test(
    'getRule',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.getRule(
        indexName: "cts_e2e_browse",
        objectID: "qr-1725004648916",
      ),
      intercept: (request) {
        expectPath(
            request.path, '/1/indexes/cts_e2e_browse/rules/qr-1725004648916');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // getSettings
  test(
    'getSettings',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.getSettings(
        indexName: "cts_e2e_settings",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/cts_e2e_settings/settings');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // getSources
  test(
    'getSources',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.getSources(),
      intercept: (request) {
        expectPath(request.path, '/1/security/sources');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // getSynonym
  test(
    'getSynonym',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.getSynonym(
        indexName: "indexName",
        objectID: "id1",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/synonyms/id1');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // getTask
  test(
    'getTask',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.getTask(
        indexName: "theIndexName",
        taskID: 123,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/task/123');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // getTopUserIds
  test(
    'getTopUserIds',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.getTopUserIds(),
      intercept: (request) {
        expectPath(request.path, '/1/clusters/mapping/top');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // getUserId
  test(
    'getUserId',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.getUserId(
        userID: "uniqueID",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/clusters/mapping/uniqueID');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // hasPendingMappings
  test(
    'hasPendingMappings with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.hasPendingMappings(),
      intercept: (request) {
        expectPath(request.path, '/1/clusters/mapping/pending');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // hasPendingMappings
  test(
    'hasPendingMappings with parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.hasPendingMappings(
        getClusters: true,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/clusters/mapping/pending');
        expect(request.method, 'get');
        expectParams(request.queryParameters, """{"getClusters":"true"}""");
        expect(request.body, null);
      },
    ),
  );

  // listApiKeys
  test(
    'listApiKeys',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.listApiKeys(),
      intercept: (request) {
        expectPath(request.path, '/1/keys');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // listClusters
  test(
    'listClusters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.listClusters(),
      intercept: (request) {
        expectPath(request.path, '/1/clusters');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // listIndices
  test(
    'listIndices with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.listIndices(),
      intercept: (request) {
        expectPath(request.path, '/1/indexes');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // listIndices
  test(
    'listIndices with parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.listIndices(
        page: 8,
        hitsPerPage: 3,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes');
        expect(request.method, 'get');
        expectParams(
            request.queryParameters, """{"page":"8","hitsPerPage":"3"}""");
        expect(request.body, null);
      },
    ),
  );

  // listUserIds
  test(
    'listUserIds with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.listUserIds(),
      intercept: (request) {
        expectPath(request.path, '/1/clusters/mapping');
        expect(request.method, 'get');
        expect(request.body, null);
      },
    ),
  );

  // listUserIds
  test(
    'listUserIds with parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.listUserIds(
        page: 8,
        hitsPerPage: 100,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/clusters/mapping');
        expect(request.method, 'get');
        expectParams(
            request.queryParameters, """{"page":"8","hitsPerPage":"100"}""");
        expect(request.body, null);
      },
    ),
  );

  // multipleBatch
  test(
    'multipleBatch',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.multipleBatch(
        batchParams: BatchParams(
          requests: [
            MultipleBatchRequest(
              action: Action.fromJson("addObject"),
              body: {
                'key': "value",
              },
              indexName: "theIndexName",
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/batch');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"action":"addObject","body":{"key":"value"},"indexName":"theIndexName"}]}""");
      },
    ),
  );

  // operationIndex
  test(
    'scopes',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.operationIndex(
        indexName: "<SOURCE_INDEX_NAME>",
        operationIndexParams: OperationIndexParams(
          operation: OperationType.fromJson("move"),
          destination: "<DESTINATION_INDEX_NAME>",
          scope: [
            ScopeType.fromJson("rules"),
            ScopeType.fromJson("settings"),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(
            request.path, '/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"operation":"move","destination":"<DESTINATION_INDEX_NAME>","scope":["rules","settings"]}""");
      },
    ),
  );

  // operationIndex
  test(
    'copy',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.operationIndex(
        indexName: "<SOURCE_INDEX_NAME>",
        operationIndexParams: OperationIndexParams(
          operation: OperationType.fromJson("copy"),
          destination: "<DESTINATION_INDEX_NAME>",
        ),
      ),
      intercept: (request) {
        expectPath(
            request.path, '/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"operation":"copy","destination":"<DESTINATION_INDEX_NAME>"}""");
      },
    ),
  );

  // operationIndex
  test(
    'move',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.operationIndex(
        indexName: "<SOURCE_INDEX_NAME>",
        operationIndexParams: OperationIndexParams(
          operation: OperationType.fromJson("move"),
          destination: "<DESTINATION_INDEX_NAME>",
        ),
      ),
      intercept: (request) {
        expectPath(
            request.path, '/1/indexes/%3CSOURCE_INDEX_NAME%3E/operation');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"operation":"move","destination":"<DESTINATION_INDEX_NAME>"}""");
      },
    ),
  );

  // partialUpdateObject
  test(
    'Partial update with a new value for a string attribute',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.partialUpdateObject(
        indexName: "theIndexName",
        objectID: "uniqueID",
        attributesToUpdate: {
          'attributeId': "new value",
        },
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/uniqueID/partial');
        expect(request.method, 'post');
        expectBody(request.body, """{"attributeId":"new value"}""");
      },
    ),
  );

  // partialUpdateObject
  test(
    'Partial update with a new value for an integer attribute',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.partialUpdateObject(
        indexName: "theIndexName",
        objectID: "uniqueID",
        attributesToUpdate: {
          'attributeId': 1,
        },
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/uniqueID/partial');
        expect(request.method, 'post');
        expectBody(request.body, """{"attributeId":1}""");
      },
    ),
  );

  // partialUpdateObject
  test(
    'Partial update with a new value for a boolean attribute',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.partialUpdateObject(
        indexName: "theIndexName",
        objectID: "uniqueID",
        attributesToUpdate: {
          'attributeId': true,
        },
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/uniqueID/partial');
        expect(request.method, 'post');
        expectBody(request.body, """{"attributeId":true}""");
      },
    ),
  );

  // partialUpdateObject
  test(
    'Partial update with a new value for an array attribute',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.partialUpdateObject(
        indexName: "theIndexName",
        objectID: "uniqueID",
        attributesToUpdate: {
          'attributeId': [
            "one",
            "two",
            "three",
          ],
        },
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/uniqueID/partial');
        expect(request.method, 'post');
        expectBody(request.body, """{"attributeId":["one","two","three"]}""");
      },
    ),
  );

  // partialUpdateObject
  test(
    'Partial update with a new value for an object attribute',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.partialUpdateObject(
        indexName: "theIndexName",
        objectID: "uniqueID",
        attributesToUpdate: {
          'attributeId': {
            'nested': "value",
          },
        },
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/uniqueID/partial');
        expect(request.method, 'post');
        expectBody(request.body, """{"attributeId":{"nested":"value"}}""");
      },
    ),
  );

  // partialUpdateObject
  test(
    'with visible_by filter',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.partialUpdateObject(
        indexName: "theIndexName",
        objectID: "uniqueID",
        attributesToUpdate: {
          'visible_by': [
            "Angela",
            "group/Finance",
            "group/Shareholders",
          ],
        },
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/uniqueID/partial');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"visible_by":["Angela","group/Finance","group/Shareholders"]}""");
      },
    ),
  );

  // removeUserId
  test(
    'removeUserId',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.removeUserId(
        userID: "uniqueID",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/clusters/mapping/uniqueID');
        expect(request.method, 'delete');
        expect(request.body, null);
      },
    ),
  );

  // replaceSources
  test(
    'replaceSources',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.replaceSources(
        source: [
          Source(
            source: "theSource",
            description: "theDescription",
          ),
        ],
      ),
      intercept: (request) {
        expectPath(request.path, '/1/security/sources');
        expect(request.method, 'put');
        expectBody(request.body,
            """[{"source":"theSource","description":"theDescription"}]""");
      },
    ),
  );

  // restoreApiKey
  test(
    'restoreApiKey',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.restoreApiKey(
        key: "ALGOLIA_API_KEY",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/keys/ALGOLIA_API_KEY/restore');
        expect(request.method, 'post');
        expect(request.body, {});
      },
    ),
  );

  // saveObject
  test(
    'saveObject',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveObject(
        indexName: "<YOUR_INDEX_NAME>",
        body: {
          'objectID': "id",
          'test': "val",
        },
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E');
        expect(request.method, 'post');
        expectBody(request.body, """{"objectID":"id","test":"val"}""");
      },
    ),
  );

  // saveRule
  test(
    'saveRule with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "id1",
        rule: Rule(
          objectID: "id1",
          conditions: [
            Condition(
              pattern: "apple",
              anchoring: Anchoring.fromJson("contains"),
            ),
          ],
          consequence: Consequence(
            params: ConsequenceParams(
              filters: "brand:xiaomi",
            ),
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/rules/id1');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains"}],"consequence":{"params":{"filters":"brand:xiaomi"}}}""");
      },
    ),
  );

  // saveRule
  test(
    'saveRule with all parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "id1",
        rule: Rule(
          objectID: "id1",
          conditions: [
            Condition(
              pattern: "apple",
              anchoring: Anchoring.fromJson("contains"),
              alternatives: false,
              context: "search",
            ),
          ],
          consequence: Consequence(
            params: ConsequenceParams(
              filters: "brand:apple",
              query: ConsequenceQueryObject(
                remove: [
                  "algolia",
                ],
                edits: [
                  Edit(
                    type: EditType.fromJson("remove"),
                    delete: "abc",
                    insert: "cde",
                  ),
                  Edit(
                    type: EditType.fromJson("replace"),
                    delete: "abc",
                    insert: "cde",
                  ),
                ],
              ),
            ),
            hide: [
              ConsequenceHide(
                objectID: "321",
              ),
            ],
            filterPromotes: false,
            userData: {
              'algolia': 'aloglia',
            },
            promote: [
              PromoteObjectID(
                objectID: "abc",
                position: 3,
              ),
              PromoteObjectIDs(
                objectIDs: [
                  "abc",
                  "def",
                ],
                position: 1,
              ),
            ],
          ),
          description: "test",
          enabled: true,
          validity: [
            TimeRange(
              from: 1656670273,
              until: 1656670277,
            ),
          ],
        ),
        forwardToReplicas: true,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/rules/id1');
        expect(request.method, 'put');
        expectParams(
            request.queryParameters, """{"forwardToReplicas":"true"}""");
        expectBody(request.body,
            """{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains","alternatives":false,"context":"search"}],"consequence":{"params":{"filters":"brand:apple","query":{"remove":["algolia"],"edits":[{"type":"remove","delete":"abc","insert":"cde"},{"type":"replace","delete":"abc","insert":"cde"}]}},"hide":[{"objectID":"321"}],"filterPromotes":false,"userData":{"algolia":"aloglia"},"promote":[{"objectID":"abc","position":3},{"objectIDs":["abc","def"],"position":1}]},"description":"test","enabled":true,"validity":[{"from":1656670273,"until":1656670277}]}""");
      },
    ),
  );

  // saveRule
  test(
    'b2b catalog',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "article-rule",
        rule: Rule(
          objectID: "article-rule",
          conditions: [
            Condition(
              pattern: "article",
              anchoring: Anchoring.fromJson("startsWith"),
            ),
          ],
          consequence: Consequence(
            params: ConsequenceParams(
              query: ConsequenceQueryObject(
                edits: [
                  Edit(
                    type: EditType.fromJson("remove"),
                    delete: "article",
                  ),
                ],
              ),
              restrictSearchableAttributes: [
                "title",
                "book_id",
              ],
            ),
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/rules/article-rule');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"article-rule","conditions":[{"pattern":"article","anchoring":"startsWith"}],"consequence":{"params":{"query":{"edits":[{"type":"remove","delete":"article"}]},"restrictSearchableAttributes":["title","book_id"]}}}""");
      },
    ),
  );

  // saveRule
  test(
    'merchandising and promoting',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "director-rule",
        rule: Rule(
          objectID: "director-rule",
          conditions: [
            Condition(
              pattern: "{facet:director} director",
              anchoring: Anchoring.fromJson("contains"),
            ),
          ],
          consequence: Consequence(
            params: ConsequenceParams(
              restrictSearchableAttributes: [
                "title",
                "book_id",
              ],
              automaticFacetFilters: [
                AutomaticFacetFilter(
                  facet: "director",
                ),
              ],
              query: ConsequenceQueryObject(
                edits: [
                  Edit(
                    type: EditType.fromJson("remove"),
                    delete: "director",
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/rules/director-rule');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"director-rule","conditions":[{"pattern":"{facet:director} director","anchoring":"contains"}],"consequence":{"params":{"restrictSearchableAttributes":["title","book_id"],"automaticFacetFilters":[{"facet":"director"}],"query":{"edits":[{"type":"remove","delete":"director"}]}}}}""");
      },
    ),
  );

  // saveRule
  test(
    'harry potter',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "harry-potter-rule",
        rule: Rule(
          objectID: "harry-potter-rule",
          conditions: [
            Condition(
              pattern: "harry potter",
              anchoring: Anchoring.fromJson("contains"),
            ),
          ],
          consequence: Consequence(
            userData: {
              'promo_content': '20% OFF on all Harry Potter books!',
            },
          ),
        ),
      ),
      intercept: (request) {
        expectPath(
            request.path, '/1/indexes/indexName/rules/harry-potter-rule');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"harry-potter-rule","conditions":[{"pattern":"harry potter","anchoring":"contains"}],"consequence":{"userData":{"promo_content":"20% OFF on all Harry Potter books!"}}}""");
      },
    ),
  );

  // saveRule
  test(
    'merchandising empty query',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "clearance-category-filter",
        rule: Rule(
          objectID: "clearance-category-filter",
          conditions: [
            Condition(
              pattern: "",
              anchoring: Anchoring.fromJson("is"),
              context: "landing",
            ),
          ],
          consequence: Consequence(
            params: ConsequenceParams(
              optionalFilters: "clearance:true",
            ),
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path,
            '/1/indexes/indexName/rules/clearance-category-filter');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"clearance-category-filter","conditions":[{"pattern":"","anchoring":"is","context":"landing"}],"consequence":{"params":{"optionalFilters":"clearance:true"}}}""");
      },
    ),
  );

  // saveRule
  test(
    'redirect',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "redirect-help-rule",
        rule: Rule(
          objectID: "redirect-help-rule",
          conditions: [
            Condition(
              pattern: "help",
              anchoring: Anchoring.fromJson("contains"),
            ),
          ],
          consequence: Consequence(
            userData: {
              'redirect': 'https://www.algolia.com/support',
            },
          ),
        ),
      ),
      intercept: (request) {
        expectPath(
            request.path, '/1/indexes/indexName/rules/redirect-help-rule');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"redirect-help-rule","conditions":[{"pattern":"help","anchoring":"contains"}],"consequence":{"userData":{"redirect":"https://www.algolia.com/support"}}}""");
      },
    ),
  );

  // saveRule
  test(
    'promote some results over others',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "tomato-fruit",
        rule: Rule(
          objectID: "tomato-fruit",
          conditions: [
            Condition(
              pattern: "tomato",
              anchoring: Anchoring.fromJson("contains"),
            ),
          ],
          consequence: Consequence(
            params: ConsequenceParams(
              optionalFilters: "food_group:fruit",
            ),
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/rules/tomato-fruit');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"tomato-fruit","conditions":[{"pattern":"tomato","anchoring":"contains"}],"consequence":{"params":{"optionalFilters":"food_group:fruit"}}}""");
      },
    ),
  );

  // saveRule
  test(
    'promote several hits',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "Promote-Apple-Newest",
        rule: Rule(
          objectID: "Promote-Apple-Newest",
          conditions: [
            Condition(
              pattern: "apple",
              anchoring: Anchoring.fromJson("is"),
            ),
          ],
          consequence: Consequence(
            promote: [
              PromoteObjectIDs(
                objectIDs: [
                  "iPhone-12345",
                  "watch-123",
                ],
                position: 0,
              ),
            ],
          ),
        ),
      ),
      intercept: (request) {
        expectPath(
            request.path, '/1/indexes/indexName/rules/Promote-Apple-Newest');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"Promote-Apple-Newest","conditions":[{"pattern":"apple","anchoring":"is"}],"consequence":{"promote":[{"objectIDs":["iPhone-12345","watch-123"],"position":0}]}}""");
      },
    ),
  );

  // saveRule
  test(
    'promote newest release',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "Promote-iPhone-X",
        rule: Rule(
          objectID: "Promote-iPhone-X",
          conditions: [
            Condition(
              pattern: "iPhone",
              anchoring: Anchoring.fromJson("contains"),
            ),
          ],
          consequence: Consequence(
            promote: [
              PromoteObjectID(
                objectID: "iPhone-12345",
                position: 0,
              ),
            ],
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/rules/Promote-iPhone-X');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"Promote-iPhone-X","conditions":[{"pattern":"iPhone","anchoring":"contains"}],"consequence":{"promote":[{"objectID":"iPhone-12345","position":0}]}}""");
      },
    ),
  );

  // saveRule
  test(
    'promote single item',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "promote-harry-potter-box-set",
        rule: Rule(
          objectID: "promote-harry-potter-box-set",
          conditions: [
            Condition(
              pattern: "Harry Potter",
              anchoring: Anchoring.fromJson("contains"),
            ),
          ],
          consequence: Consequence(
            promote: [
              PromoteObjectID(
                objectID: "HP-12345",
                position: 0,
              ),
            ],
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path,
            '/1/indexes/indexName/rules/promote-harry-potter-box-set');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"promote-harry-potter-box-set","conditions":[{"pattern":"Harry Potter","anchoring":"contains"}],"consequence":{"promote":[{"objectID":"HP-12345","position":0}]}}""");
      },
    ),
  );

  // saveRule
  test(
    'limit search results',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "article-rule",
        rule: Rule(
          objectID: "article-rule",
          conditions: [
            Condition(
              pattern: "article",
              anchoring: Anchoring.fromJson("startsWith"),
            ),
          ],
          consequence: Consequence(
            params: ConsequenceParams(
              query: ConsequenceQueryObject(
                edits: [
                  Edit(
                    type: EditType.fromJson("remove"),
                    delete: "article",
                  ),
                ],
              ),
              restrictSearchableAttributes: [
                "title",
                "book_id",
              ],
            ),
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/rules/article-rule');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"article-rule","conditions":[{"pattern":"article","anchoring":"startsWith"}],"consequence":{"params":{"query":{"edits":[{"type":"remove","delete":"article"}]},"restrictSearchableAttributes":["title","book_id"]}}}""");
      },
    ),
  );

  // saveRule
  test(
    'query match',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "tagged-brand-rule",
        rule: Rule(
          conditions: [
            Condition(
              pattern: "brand: {facet:brand}",
              anchoring: Anchoring.fromJson("contains"),
              alternatives: false,
            ),
          ],
          consequence: Consequence(
            params: ConsequenceParams(
              automaticFacetFilters: [
                AutomaticFacetFilter(
                  facet: "brand",
                ),
              ],
              query: ConsequenceQueryObject(
                remove: [
                  "brand:",
                  "{facet:brand}",
                ],
              ),
            ),
          ),
          description: "filter on brand: {brand}",
          objectID: "tagged-brand-rule",
        ),
      ),
      intercept: (request) {
        expectPath(
            request.path, '/1/indexes/indexName/rules/tagged-brand-rule');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"conditions":[{"pattern":"brand: {facet:brand}","anchoring":"contains","alternatives":false}],"consequence":{"params":{"automaticFacetFilters":[{"facet":"brand"}],"query":{"remove":["brand:","{facet:brand}"]}}},"description":"filter on brand: {brand}","objectID":"tagged-brand-rule"}""");
      },
    ),
  );

  // saveRule
  test(
    'dynamic filtering',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "color-facets",
        rule: Rule(
          objectID: "color-facets",
          conditions: [
            Condition(
              pattern: "{facet:color}",
            ),
          ],
          consequence: Consequence(
            params: ConsequenceParams(
              automaticFacetFilters: [
                AutomaticFacetFilter(
                  facet: "color",
                ),
              ],
            ),
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/rules/color-facets');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"color-facets","conditions":[{"pattern":"{facet:color}"}],"consequence":{"params":{"automaticFacetFilters":[{"facet":"color"}]}}}""");
      },
    ),
  );

  // saveRule
  test(
    'hide hits',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "hide-12345",
        rule: Rule(
          objectID: "hide-12345",
          conditions: [
            Condition(
              pattern: "cheap",
              anchoring: Anchoring.fromJson("contains"),
            ),
          ],
          consequence: Consequence(
            hide: [
              ConsequenceHide(
                objectID: "to-hide-12345",
              ),
            ],
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/rules/hide-12345');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"hide-12345","conditions":[{"pattern":"cheap","anchoring":"contains"}],"consequence":{"hide":[{"objectID":"to-hide-12345"}]}}""");
      },
    ),
  );

  // saveRule
  test(
    'one rule per facet',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "red-color",
        rule: Rule(
          objectID: "red-color",
          conditions: [
            Condition(
              pattern: "red",
              anchoring: Anchoring.fromJson("contains"),
            ),
          ],
          consequence: Consequence(
            params: ConsequenceParams(
              query: ConsequenceQueryObject(
                remove: [
                  "red",
                ],
              ),
              filters: "color:red",
            ),
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/rules/red-color');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"red-color","conditions":[{"pattern":"red","anchoring":"contains"}],"consequence":{"params":{"query":{"remove":["red"]},"filters":"color:red"}}}""");
      },
    ),
  );

  // saveRule
  test(
    'numerical filters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "cheap",
        rule: Rule(
          objectID: "cheap",
          conditions: [
            Condition(
              pattern: "cheap",
              anchoring: Anchoring.fromJson("contains"),
            ),
          ],
          consequence: Consequence(
            params: ConsequenceParams(
              query: ConsequenceQueryObject(
                remove: [
                  "cheap",
                ],
              ),
              filters: "price < 10",
            ),
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/rules/cheap');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"cheap","conditions":[{"pattern":"cheap","anchoring":"contains"}],"consequence":{"params":{"query":{"remove":["cheap"]},"filters":"price < 10"}}}""");
      },
    ),
  );

  // saveRule
  test(
    'negative filters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "gluten-free-rule",
        rule: Rule(
          objectID: "gluten-free-rule",
          conditions: [
            Condition(
              pattern: "gluten-free",
              anchoring: Anchoring.fromJson("contains"),
            ),
          ],
          consequence: Consequence(
            params: ConsequenceParams(
              filters: "NOT allergens:gluten",
              query: ConsequenceQueryObject(
                edits: [
                  Edit(
                    type: EditType.fromJson("remove"),
                    delete: "gluten-free",
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/rules/gluten-free-rule');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"gluten-free-rule","conditions":[{"pattern":"gluten-free","anchoring":"contains"}],"consequence":{"params":{"filters":"NOT allergens:gluten","query":{"edits":[{"type":"remove","delete":"gluten-free"}]}}}}""");
      },
    ),
  );

  // saveRule
  test(
    'positive filters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "diet-rule",
        rule: Rule(
          objectID: "diet-rule",
          conditions: [
            Condition(
              pattern: "diet",
              anchoring: Anchoring.fromJson("contains"),
            ),
          ],
          consequence: Consequence(
            params: ConsequenceParams(
              filters: "'low-carb' OR 'low-fat'",
              query: ConsequenceQueryObject(
                edits: [
                  Edit(
                    type: EditType.fromJson("remove"),
                    delete: "diet",
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/rules/diet-rule');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"diet-rule","conditions":[{"pattern":"diet","anchoring":"contains"}],"consequence":{"params":{"filters":"'low-carb' OR 'low-fat'","query":{"edits":[{"type":"remove","delete":"diet"}]}}}}""");
      },
    ),
  );

  // saveRule
  test(
    'conditionless',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRule(
        indexName: "indexName",
        objectID: "diet-rule",
        rule: Rule(
          objectID: "diet-rule",
          consequence: Consequence(
            params: ConsequenceParams(
              filters: "'low-carb' OR 'low-fat'",
              query: ConsequenceQueryObject(
                edits: [
                  Edit(
                    type: EditType.fromJson("remove"),
                    delete: "diet",
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/rules/diet-rule');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"objectID":"diet-rule","consequence":{"params":{"filters":"'low-carb' OR 'low-fat'","query":{"edits":[{"type":"remove","delete":"diet"}]}}}}""");
      },
    ),
  );

  // saveRules
  test(
    'saveRules with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRules(
        indexName: "<YOUR_INDEX_NAME>",
        rules: [
          Rule(
            objectID: "a-rule-id",
            conditions: [
              Condition(
                pattern: "smartphone",
                anchoring: Anchoring.fromJson("contains"),
              ),
            ],
            consequence: Consequence(
              params: ConsequenceParams(
                filters: "brand:apple",
              ),
            ),
          ),
          Rule(
            objectID: "a-second-rule-id",
            conditions: [
              Condition(
                pattern: "apple",
                anchoring: Anchoring.fromJson("contains"),
              ),
            ],
            consequence: Consequence(
              params: ConsequenceParams(
                filters: "brand:samsung",
              ),
            ),
          ),
        ],
        forwardToReplicas: false,
        clearExistingRules: true,
      ),
      intercept: (request) {
        expectPath(
            request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch');
        expect(request.method, 'post');
        expectParams(request.queryParameters,
            """{"forwardToReplicas":"false","clearExistingRules":"true"}""");
        expectBody(request.body,
            """[{"objectID":"a-rule-id","conditions":[{"pattern":"smartphone","anchoring":"contains"}],"consequence":{"params":{"filters":"brand:apple"}}},{"objectID":"a-second-rule-id","conditions":[{"pattern":"apple","anchoring":"contains"}],"consequence":{"params":{"filters":"brand:samsung"}}}]""");
      },
    ),
  );

  // saveRules
  test(
    'saveRules with all parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRules(
        indexName: "<YOUR_INDEX_NAME>",
        rules: [
          Rule(
            objectID: "id1",
            conditions: [
              Condition(
                pattern: "apple",
                anchoring: Anchoring.fromJson("contains"),
                alternatives: false,
                context: "search",
              ),
            ],
            consequence: Consequence(
              params: ConsequenceParams(
                filters: "brand:apple",
                query: ConsequenceQueryObject(
                  remove: [
                    "algolia",
                  ],
                  edits: [
                    Edit(
                      type: EditType.fromJson("remove"),
                      delete: "abc",
                      insert: "cde",
                    ),
                    Edit(
                      type: EditType.fromJson("replace"),
                      delete: "abc",
                      insert: "cde",
                    ),
                  ],
                ),
              ),
              hide: [
                ConsequenceHide(
                  objectID: "321",
                ),
              ],
              filterPromotes: false,
              userData: {
                'algolia': 'aloglia',
              },
              promote: [
                PromoteObjectID(
                  objectID: "abc",
                  position: 3,
                ),
                PromoteObjectIDs(
                  objectIDs: [
                    "abc",
                    "def",
                  ],
                  position: 1,
                ),
              ],
            ),
            description: "test",
            enabled: true,
            validity: [
              TimeRange(
                from: 1656670273,
                until: 1656670277,
              ),
            ],
          ),
        ],
        forwardToReplicas: true,
        clearExistingRules: true,
      ),
      intercept: (request) {
        expectPath(
            request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch');
        expect(request.method, 'post');
        expectParams(request.queryParameters,
            """{"forwardToReplicas":"true","clearExistingRules":"true"}""");
        expectBody(request.body,
            """[{"objectID":"id1","conditions":[{"pattern":"apple","anchoring":"contains","alternatives":false,"context":"search"}],"consequence":{"params":{"filters":"brand:apple","query":{"remove":["algolia"],"edits":[{"type":"remove","delete":"abc","insert":"cde"},{"type":"replace","delete":"abc","insert":"cde"}]}},"hide":[{"objectID":"321"}],"filterPromotes":false,"userData":{"algolia":"aloglia"},"promote":[{"objectID":"abc","position":3},{"objectIDs":["abc","def"],"position":1}]},"description":"test","enabled":true,"validity":[{"from":1656670273,"until":1656670277}]}]""");
      },
    ),
  );

  // saveRules
  test(
    'dynamic filtering',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRules(
        indexName: "<YOUR_INDEX_NAME>",
        rules: [
          Rule(
            objectID: "toaster",
            conditions: [
              Condition(
                pattern: "toaster",
                anchoring: Anchoring.fromJson("contains"),
              ),
            ],
            consequence: Consequence(
              params: ConsequenceParams(
                query: ConsequenceQueryObject(
                  remove: [
                    "toaster",
                  ],
                ),
                filters: "product_type:toaster",
              ),
            ),
          ),
          Rule(
            objectID: "cheap",
            conditions: [
              Condition(
                pattern: "cheap",
                anchoring: Anchoring.fromJson("contains"),
              ),
            ],
            consequence: Consequence(
              params: ConsequenceParams(
                query: ConsequenceQueryObject(
                  remove: [
                    "cheap",
                  ],
                ),
                filters: "price < 15",
              ),
            ),
          ),
        ],
      ),
      intercept: (request) {
        expectPath(
            request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch');
        expect(request.method, 'post');
        expectBody(request.body,
            """[{"objectID":"toaster","conditions":[{"pattern":"toaster","anchoring":"contains"}],"consequence":{"params":{"query":{"remove":["toaster"]},"filters":"product_type:toaster"}}},{"objectID":"cheap","conditions":[{"pattern":"cheap","anchoring":"contains"}],"consequence":{"params":{"query":{"remove":["cheap"]},"filters":"price < 15"}}}]""");
      },
    ),
  );

  // saveRules
  test(
    'enhance search results',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveRules(
        indexName: "<YOUR_INDEX_NAME>",
        rules: [
          Rule(
            objectID: "country",
            conditions: [
              Condition(
                pattern: "{facet:country}",
                anchoring: Anchoring.fromJson("contains"),
              ),
            ],
            consequence: Consequence(
              params: ConsequenceParams(
                aroundLatLngViaIP: false,
              ),
            ),
          ),
          Rule(
            objectID: "city",
            conditions: [
              Condition(
                pattern: "{facet:city}",
                anchoring: Anchoring.fromJson("contains"),
              ),
            ],
            consequence: Consequence(
              params: ConsequenceParams(
                aroundLatLngViaIP: false,
              ),
            ),
          ),
        ],
      ),
      intercept: (request) {
        expectPath(
            request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/rules/batch');
        expect(request.method, 'post');
        expectBody(request.body,
            """[{"objectID":"country","conditions":[{"pattern":"{facet:country}","anchoring":"contains"}],"consequence":{"params":{"aroundLatLngViaIP":false}}},{"objectID":"city","conditions":[{"pattern":"{facet:city}","anchoring":"contains"}],"consequence":{"params":{"aroundLatLngViaIP":false}}}]""");
      },
    ),
  );

  // saveSynonym
  test(
    'saveSynonym',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveSynonym(
        indexName: "indexName",
        objectID: "id1",
        synonymHit: SynonymHit(
          objectID: "id1",
          type: SynonymType.fromJson("synonym"),
          synonyms: [
            "car",
            "vehicule",
            "auto",
          ],
        ),
        forwardToReplicas: true,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/synonyms/id1');
        expect(request.method, 'put');
        expectParams(
            request.queryParameters, """{"forwardToReplicas":"true"}""");
        expectBody(request.body,
            """{"objectID":"id1","type":"synonym","synonyms":["car","vehicule","auto"]}""");
      },
    ),
  );

  // saveSynonyms
  test(
    'saveSynonyms',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.saveSynonyms(
        indexName: "<YOUR_INDEX_NAME>",
        synonymHit: [
          SynonymHit(
            objectID: "id1",
            type: SynonymType.fromJson("synonym"),
            synonyms: [
              "car",
              "vehicule",
              "auto",
            ],
          ),
          SynonymHit(
            objectID: "id2",
            type: SynonymType.fromJson("onewaysynonym"),
            input: "iphone",
            synonyms: [
              "ephone",
              "aphone",
              "yphone",
            ],
          ),
        ],
        forwardToReplicas: true,
        replaceExistingSynonyms: true,
      ),
      intercept: (request) {
        expectPath(
            request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/synonyms/batch');
        expect(request.method, 'post');
        expectParams(request.queryParameters,
            """{"forwardToReplicas":"true","replaceExistingSynonyms":"true"}""");
        expectBody(request.body,
            """[{"objectID":"id1","type":"synonym","synonyms":["car","vehicule","auto"]},{"objectID":"id2","type":"onewaysynonym","input":"iphone","synonyms":["ephone","aphone","yphone"]}]""");
      },
    ),
  );

  // search
  test(
    'withHitsPerPage',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.search(
        searchMethodParams: SearchMethodParams(
          requests: [
            SearchForHits(
              indexName: "<YOUR_INDEX_NAME>",
              query: "<YOUR_QUERY>",
              hitsPerPage: 50,
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/queries');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","hitsPerPage":50}]}""");
      },
    ),
  );

  // search
  test(
    'filterOnly',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.search(
        searchMethodParams: SearchMethodParams(
          requests: [
            SearchForHits(
              indexName: "<YOUR_INDEX_NAME>",
              query: "<YOUR_QUERY>",
              filters: "actor:Scarlett Johansson",
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/queries');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"actor:Scarlett Johansson"}]}""");
      },
    ),
  );

  // search
  test(
    'filterOr',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.search(
        searchMethodParams: SearchMethodParams(
          requests: [
            SearchForHits(
              indexName: "<YOUR_INDEX_NAME>",
              query: "<YOUR_QUERY>",
              filters: "actor:Tom Cruise OR actor:Scarlett Johansson",
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/queries');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"actor:Tom Cruise OR actor:Scarlett Johansson"}]}""");
      },
    ),
  );

  // search
  test(
    'filterNot',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.search(
        searchMethodParams: SearchMethodParams(
          requests: [
            SearchForHits(
              indexName: "<YOUR_INDEX_NAME>",
              query: "<YOUR_QUERY>",
              filters: "NOT actor:Nicolas Cage",
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/queries');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","filters":"NOT actor:Nicolas Cage"}]}""");
      },
    ),
  );

  // search
  test(
    'search for a single hits request with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.search(
        searchMethodParams: SearchMethodParams(
          requests: [
            SearchForHits(
              indexName: "cts_e2e_search_empty_index",
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/queries');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"indexName":"cts_e2e_search_empty_index"}]}""");
      },
    ),
  );

  // search
  test(
    'search with highlight and snippet results',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.search(
        searchMethodParams: SearchMethodParams(
          requests: [
            SearchForHits(
              indexName: "cts_e2e_highlight_snippet_results",
              query: "vim",
              attributesToSnippet: [
                "*:20",
              ],
              attributesToHighlight: [
                "*",
              ],
              attributesToRetrieve: [
                "*",
              ],
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/queries');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"indexName":"cts_e2e_highlight_snippet_results","query":"vim","attributesToSnippet":["*:20"],"attributesToHighlight":["*"],"attributesToRetrieve":["*"]}]}""");
      },
    ),
  );

  // search
  test(
    'retrieveFacets',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.search(
        searchMethodParams: SearchMethodParams(
          requests: [
            SearchForHits(
              indexName: "<YOUR_INDEX_NAME>",
              query: "<YOUR_QUERY>",
              facets: [
                "author",
                "genre",
              ],
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/queries');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","facets":["author","genre"]}]}""");
      },
    ),
  );

  // search
  test(
    'retrieveFacetsWildcard',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.search(
        searchMethodParams: SearchMethodParams(
          requests: [
            SearchForHits(
              indexName: "<YOUR_INDEX_NAME>",
              query: "<YOUR_QUERY>",
              facets: [
                "*",
              ],
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/queries');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"indexName":"<YOUR_INDEX_NAME>","query":"<YOUR_QUERY>","facets":["*"]}]}""");
      },
    ),
  );

  // search
  test(
    'search for a single facet request with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.search(
        searchMethodParams: SearchMethodParams(
          requests: [
            SearchForFacets(
              indexName: "cts_e2e_search_facet",
              type: SearchTypeFacet.fromJson("facet"),
              facet: "editor",
            ),
          ],
          strategy: SearchStrategy.fromJson("stopIfEnoughMatches"),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/queries');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"indexName":"cts_e2e_search_facet","type":"facet","facet":"editor"}],"strategy":"stopIfEnoughMatches"}""");
      },
    ),
  );

  // search
  test(
    'search for a single hits request with all parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.search(
        searchMethodParams: SearchMethodParams(
          requests: [
            SearchForHits(
              indexName: "theIndexName",
              query: "myQuery",
              hitsPerPage: 50,
              type: SearchTypeDefault.fromJson("default"),
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/queries');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"indexName":"theIndexName","query":"myQuery","hitsPerPage":50,"type":"default"}]}""");
      },
    ),
  );

  // search
  test(
    'search for a single facet request with all parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.search(
        searchMethodParams: SearchMethodParams(
          requests: [
            SearchForFacets(
              indexName: "theIndexName",
              type: SearchTypeFacet.fromJson("facet"),
              facet: "theFacet",
              facetQuery: "theFacetQuery",
              query: "theQuery",
              maxFacetHits: 50,
            ),
          ],
          strategy: SearchStrategy.fromJson("stopIfEnoughMatches"),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/queries');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"indexName":"theIndexName","type":"facet","facet":"theFacet","facetQuery":"theFacetQuery","query":"theQuery","maxFacetHits":50}],"strategy":"stopIfEnoughMatches"}""");
      },
    ),
  );

  // search
  test(
    'search for multiple mixed requests in multiple indices with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.search(
        searchMethodParams: SearchMethodParams(
          requests: [
            SearchForHits(
              indexName: "theIndexName",
            ),
            SearchForFacets(
              indexName: "theIndexName2",
              type: SearchTypeFacet.fromJson("facet"),
              facet: "theFacet",
            ),
            SearchForHits(
              indexName: "theIndexName",
              type: SearchTypeDefault.fromJson("default"),
            ),
          ],
          strategy: SearchStrategy.fromJson("stopIfEnoughMatches"),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/queries');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"indexName":"theIndexName"},{"indexName":"theIndexName2","type":"facet","facet":"theFacet"},{"indexName":"theIndexName","type":"default"}],"strategy":"stopIfEnoughMatches"}""");
      },
    ),
  );

  // search
  test(
    'search for multiple mixed requests in multiple indices with all parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.search(
        searchMethodParams: SearchMethodParams(
          requests: [
            SearchForFacets(
              indexName: "theIndexName",
              type: SearchTypeFacet.fromJson("facet"),
              facet: "theFacet",
              facetQuery: "theFacetQuery",
              query: "theQuery",
              maxFacetHits: 50,
            ),
            SearchForHits(
              indexName: "theIndexName",
              query: "myQuery",
              hitsPerPage: 50,
              type: SearchTypeDefault.fromJson("default"),
            ),
          ],
          strategy: SearchStrategy.fromJson("stopIfEnoughMatches"),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/queries');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"indexName":"theIndexName","type":"facet","facet":"theFacet","facetQuery":"theFacetQuery","query":"theQuery","maxFacetHits":50},{"indexName":"theIndexName","query":"myQuery","hitsPerPage":50,"type":"default"}],"strategy":"stopIfEnoughMatches"}""");
      },
    ),
  );

  // search
  test(
    'search filters accept all of the possible shapes',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.search(
        searchMethodParams: SearchMethodParams(
          requests: [
            SearchForHits(
              indexName: "theIndexName",
              facetFilters: "mySearch:filters",
              reRankingApplyFilter: "mySearch:filters",
              tagFilters: "mySearch:filters",
              numericFilters: "mySearch:filters",
              optionalFilters: "mySearch:filters",
            ),
            SearchForHits(
              indexName: "theIndexName",
              facetFilters: [
                "mySearch:filters",
                [
                  "mySearch:filters",
                  [
                    "mySearch:filters",
                  ],
                ],
              ],
              reRankingApplyFilter: [
                "mySearch:filters",
                [
                  "mySearch:filters",
                ],
              ],
              tagFilters: [
                "mySearch:filters",
                [
                  "mySearch:filters",
                ],
              ],
              numericFilters: [
                "mySearch:filters",
                [
                  "mySearch:filters",
                ],
              ],
              optionalFilters: [
                "mySearch:filters",
                [
                  "mySearch:filters",
                ],
              ],
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/queries');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"indexName":"theIndexName","facetFilters":"mySearch:filters","reRankingApplyFilter":"mySearch:filters","tagFilters":"mySearch:filters","numericFilters":"mySearch:filters","optionalFilters":"mySearch:filters"},{"indexName":"theIndexName","facetFilters":["mySearch:filters",["mySearch:filters",["mySearch:filters"]]],"reRankingApplyFilter":["mySearch:filters",["mySearch:filters"]],"tagFilters":["mySearch:filters",["mySearch:filters"]],"numericFilters":["mySearch:filters",["mySearch:filters"]],"optionalFilters":["mySearch:filters",["mySearch:filters"]]}]}""");
      },
    ),
  );

  // search
  test(
    'search filters end to end',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.search(
        searchMethodParams: SearchMethodParams(
          requests: [
            SearchForHits(
              indexName: "cts_e2e_search_facet",
              filters: "editor:'visual studio' OR editor:neovim",
            ),
            SearchForHits(
              indexName: "cts_e2e_search_facet",
              facetFilters: [
                "editor:'visual studio'",
                "editor:neovim",
              ],
            ),
            SearchForHits(
              indexName: "cts_e2e_search_facet",
              facetFilters: [
                "editor:'visual studio'",
                [
                  "editor:neovim",
                ],
              ],
            ),
            SearchForHits(
              indexName: "cts_e2e_search_facet",
              facetFilters: [
                "editor:'visual studio'",
                [
                  "editor:neovim",
                  [
                    "editor:goland",
                  ],
                ],
              ],
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/queries');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"indexName":"cts_e2e_search_facet","filters":"editor:'visual studio' OR editor:neovim"},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'","editor:neovim"]},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'",["editor:neovim"]]},{"indexName":"cts_e2e_search_facet","facetFilters":["editor:'visual studio'",["editor:neovim",["editor:goland"]]]}]}""");
      },
    ),
  );

  // search
  test(
    'search with all search parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.search(
        searchMethodParams: SearchMethodParams(
          requests: [
            SearchForHits(
              advancedSyntax: true,
              advancedSyntaxFeatures: [
                AdvancedSyntaxFeatures.fromJson("exactPhrase"),
              ],
              allowTyposOnNumericTokens: true,
              alternativesAsExact: [
                AlternativesAsExact.fromJson("multiWordsSynonym"),
              ],
              analytics: true,
              analyticsTags: [
                "",
              ],
              aroundLatLng: "",
              aroundLatLngViaIP: true,
              aroundPrecision: 0,
              aroundRadius: AroundRadiusAll.fromJson("all"),
              attributeCriteriaComputedByMinProximity: true,
              attributesToHighlight: [
                "",
              ],
              attributesToRetrieve: [
                "",
              ],
              attributesToSnippet: [
                "",
              ],
              clickAnalytics: true,
              decompoundQuery: true,
              disableExactOnAttributes: [
                "",
              ],
              disableTypoToleranceOnAttributes: [
                "",
              ],
              distinct: 0,
              enableABTest: true,
              enablePersonalization: true,
              enableReRanking: true,
              enableRules: true,
              exactOnSingleWordQuery:
                  ExactOnSingleWordQuery.fromJson("attribute"),
              facetFilters: [
                "",
              ],
              facetingAfterDistinct: true,
              facets: [
                "",
              ],
              filters: "",
              getRankingInfo: true,
              highlightPostTag: "",
              highlightPreTag: "",
              hitsPerPage: 1,
              ignorePlurals: false,
              indexName: "theIndexName",
              insideBoundingBox: [
                [
                  47.3165,
                  4.9665,
                  47.3424,
                  5.0201,
                ],
                [
                  40.9234,
                  2.1185,
                  38.643,
                  1.9916,
                ],
              ],
              insidePolygon: [
                [
                  47.3165,
                  4.9665,
                  47.3424,
                  5.0201,
                  47.32,
                  4.9,
                ],
                [
                  40.9234,
                  2.1185,
                  38.643,
                  1.9916,
                  39.2587,
                  2.0104,
                ],
              ],
              length: 1,
              maxValuesPerFacet: 0,
              minProximity: 1,
              minWordSizefor1Typo: 0,
              minWordSizefor2Typos: 0,
              minimumAroundRadius: 1,
              naturalLanguages: [
                SupportedLanguage.fromJson("fr"),
              ],
              numericFilters: [
                "",
              ],
              offset: 0,
              optionalFilters: [
                "",
              ],
              optionalWords: [
                "",
              ],
              page: 0,
              percentileComputation: true,
              personalizationImpact: 0,
              query: "",
              queryLanguages: [
                SupportedLanguage.fromJson("fr"),
              ],
              queryType: QueryType.fromJson("prefixAll"),
              ranking: [
                "",
              ],
              reRankingApplyFilter: [
                "",
              ],
              relevancyStrictness: 0,
              removeStopWords: true,
              removeWordsIfNoResults:
                  RemoveWordsIfNoResults.fromJson("allOptional"),
              renderingContent: RenderingContent(
                facetOrdering: FacetOrdering(
                  facets: Facets(
                    order: [
                      "a",
                      "b",
                    ],
                  ),
                  values: {
                    'a': Value(
                      order: [
                        "b",
                      ],
                      sortRemainingBy: SortRemainingBy.fromJson("count"),
                    ),
                  },
                ),
              ),
              replaceSynonymsInHighlight: true,
              responseFields: [
                "",
              ],
              restrictHighlightAndSnippetArrays: true,
              restrictSearchableAttributes: [
                "",
              ],
              ruleContexts: [
                "",
              ],
              similarQuery: "",
              snippetEllipsisText: "",
              sortFacetValuesBy: "",
              sumOrFiltersScores: true,
              synonyms: true,
              tagFilters: [
                "",
              ],
              type: SearchTypeDefault.fromJson("default"),
              typoTolerance: TypoToleranceEnum.fromJson("min"),
              userToken: "",
            ),
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/*/queries');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"requests":[{"advancedSyntax":true,"advancedSyntaxFeatures":["exactPhrase"],"allowTyposOnNumericTokens":true,"alternativesAsExact":["multiWordsSynonym"],"analytics":true,"analyticsTags":[""],"aroundLatLng":"","aroundLatLngViaIP":true,"aroundPrecision":0,"aroundRadius":"all","attributeCriteriaComputedByMinProximity":true,"attributesToHighlight":[""],"attributesToRetrieve":[""],"attributesToSnippet":[""],"clickAnalytics":true,"decompoundQuery":true,"disableExactOnAttributes":[""],"disableTypoToleranceOnAttributes":[""],"distinct":0,"enableABTest":true,"enablePersonalization":true,"enableReRanking":true,"enableRules":true,"exactOnSingleWordQuery":"attribute","facetFilters":[""],"facetingAfterDistinct":true,"facets":[""],"filters":"","getRankingInfo":true,"highlightPostTag":"","highlightPreTag":"","hitsPerPage":1,"ignorePlurals":false,"indexName":"theIndexName","insideBoundingBox":[[47.3165,4.9665,47.3424,5.0201],[40.9234,2.1185,38.643,1.9916]],"insidePolygon":[[47.3165,4.9665,47.3424,5.0201,47.32,4.9],[40.9234,2.1185,38.643,1.9916,39.2587,2.0104]],"length":1,"maxValuesPerFacet":0,"minProximity":1,"minWordSizefor1Typo":0,"minWordSizefor2Typos":0,"minimumAroundRadius":1,"naturalLanguages":["fr"],"numericFilters":[""],"offset":0,"optionalFilters":[""],"optionalWords":[""],"page":0,"percentileComputation":true,"personalizationImpact":0,"query":"","queryLanguages":["fr"],"queryType":"prefixAll","ranking":[""],"reRankingApplyFilter":[""],"relevancyStrictness":0,"removeStopWords":true,"removeWordsIfNoResults":"allOptional","renderingContent":{"facetOrdering":{"facets":{"order":["a","b"]},"values":{"a":{"order":["b"],"sortRemainingBy":"count"}}}},"replaceSynonymsInHighlight":true,"responseFields":[""],"restrictHighlightAndSnippetArrays":true,"restrictSearchableAttributes":[""],"ruleContexts":[""],"similarQuery":"","snippetEllipsisText":"","sortFacetValuesBy":"","sumOrFiltersScores":true,"synonyms":true,"tagFilters":[""],"type":"default","typoTolerance":"min","userToken":""}]}""");
      },
    ),
  );

  // searchDictionaryEntries
  test(
    'get searchDictionaryEntries results with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchDictionaryEntries(
        dictionaryName: DictionaryType.fromJson("stopwords"),
        searchDictionaryEntriesParams: SearchDictionaryEntriesParams(
          query: "about",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/dictionaries/stopwords/search');
        expect(request.method, 'post');
        expectBody(request.body, """{"query":"about"}""");
      },
    ),
  );

  // searchDictionaryEntries
  test(
    'get searchDictionaryEntries results with all parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchDictionaryEntries(
        dictionaryName: DictionaryType.fromJson("compounds"),
        searchDictionaryEntriesParams: SearchDictionaryEntriesParams(
          query: "foo",
          page: 4,
          hitsPerPage: 2,
          language: SupportedLanguage.fromJson("fr"),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/dictionaries/compounds/search');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"query":"foo","page":4,"hitsPerPage":2,"language":"fr"}""");
      },
    ),
  );

  // searchForFacetValues
  test(
    'get searchForFacetValues results with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchForFacetValues(
        indexName: "indexName",
        facetName: "facetName",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/facets/facetName/query');
        expect(request.method, 'post');
        expectBody(request.body, """{}""");
      },
    ),
  );

  // searchForFacetValues
  test(
    'get searchForFacetValues results with all parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchForFacetValues(
        indexName: "indexName",
        facetName: "facetName",
        searchForFacetValuesRequest: SearchForFacetValuesRequest(
          params: "query=foo&facetFilters=['bar']",
          facetQuery: "foo",
          maxFacetHits: 42,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/facets/facetName/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"params":"query=foo&facetFilters=['bar']","facetQuery":"foo","maxFacetHits":42}""");
      },
    ),
  );

  // searchRules
  test(
    'searchRules',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchRules(
        indexName: "cts_e2e_browse",
        searchRulesParams: SearchRulesParams(
          query: "zorro",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/cts_e2e_browse/rules/search');
        expect(request.method, 'post');
        expectBody(request.body, """{"query":"zorro"}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'search with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body, """{}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'search with special characters in indexName',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "cts_e2e_space in index",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/cts_e2e_space%20in%20index/query');
        expect(request.method, 'post');
        expectBody(request.body, """{}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'search with searchParams',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          query: "myQuery",
          facetFilters: [
            "tags:algolia",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"query":"myQuery","facetFilters":["tags:algolia"]}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'single search retrieve snippets',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "cts_e2e_browse",
        searchParams: SearchParamsObject(
          query: "batman mask of the phantasm",
          attributesToRetrieve: [
            "*",
          ],
          attributesToSnippet: [
            "*:20",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/cts_e2e_browse/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"query":"batman mask of the phantasm","attributesToRetrieve":["*"],"attributesToSnippet":["*:20"]}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'query',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          query: "phone",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body, """{"query":"phone"}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'filters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          filters: "country:US AND price.gross < 2.0",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(
            request.body, """{"filters":"country:US AND price.gross < 2.0"}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'distinct',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          distinct: true,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body, """{"distinct":true}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'filtersNumeric',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          filters: "price < 10",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body, """{"filters":"price < 10"}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'filtersTimestamp',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          filters: "NOT date_timestamp:1514764800 TO 1546300799",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"filters":"NOT date_timestamp:1514764800 TO 1546300799"}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'filtersSumOrFiltersScoresFalse',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          filters:
              "(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)",
          sumOrFiltersScores: false,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"filters":"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)","sumOrFiltersScores":false}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'filtersSumOrFiltersScoresTrue',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          filters:
              "(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)",
          sumOrFiltersScores: true,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"filters":"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)","sumOrFiltersScores":true}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'filtersStephenKing',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          filters: "author:\"Stephen King\"",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body, """{"filters":"author:\\"Stephen King\\""}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'filtersNotTags',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          filters: "NOT _tags:non-fiction",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body, """{"filters":"NOT _tags:non-fiction"}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'facetFiltersList',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          facetFilters: [
            "publisher:Penguin",
            [
              "author:Stephen King",
              "genre:Horror",
            ],
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"facetFilters":["publisher:Penguin",["author:Stephen King","genre:Horror"]]}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'facetFiltersNeg',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          facetFilters: "category:-Ebook",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body, """{"facetFilters":"category:-Ebook"}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'filtersAndFacetFilters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          filters: "(author:\"Stephen King\" OR genre:\"Horror\")",
          facetFilters: [
            "publisher:Penguin",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"filters":"(author:\\"Stephen King\\" OR genre:\\"Horror\\")","facetFilters":["publisher:Penguin"]}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'aroundLatLng',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          aroundLatLng: "40.71, -74.01",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body, """{"aroundLatLng":"40.71, -74.01"}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'aroundLatLngViaIP',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          aroundLatLngViaIP: true,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body, """{"aroundLatLngViaIP":true}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'aroundRadius',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          aroundLatLng: "40.71, -74.01",
          aroundRadius: 1000000,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"aroundLatLng":"40.71, -74.01","aroundRadius":1000000}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'insideBoundingBox',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          insideBoundingBox: [
            [
              49.067996905313834,
              65.73828125,
              25.905859247243498,
              128.8046875,
            ],
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"insideBoundingBox":[[49.067996905313834,65.73828125,25.905859247243498,128.8046875]]}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'insidePolygon',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          insidePolygon: [
            [
              42.01,
              -124.31,
              48.835509470063045,
              -124.40453125000005,
              45.01082951668149,
              -65.95726562500005,
              31.247243545293433,
              -81.06578125000004,
              25.924152577235226,
              -97.68234374999997,
              32.300311895879545,
              -117.54828125,
            ],
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"insidePolygon":[[42.01,-124.31,48.835509470063045,-124.40453125000005,45.01082951668149,-65.95726562500005,31.247243545293433,-81.06578125000004,25.924152577235226,-97.68234374999997,32.300311895879545,-117.54828125]]}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'insidePolygon',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          insidePolygon: [
            [
              42.01,
              -124.31,
              48.835509470063045,
              -124.40453125000005,
              45.01082951668149,
              -65.95726562500005,
              31.247243545293433,
              -81.06578125000004,
              25.924152577235226,
              -97.68234374999997,
              32.300311895879545,
              -117.54828125,
            ],
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"insidePolygon":[[42.01,-124.31,48.835509470063045,-124.40453125000005,45.01082951668149,-65.95726562500005,31.247243545293433,-81.06578125000004,25.924152577235226,-97.68234374999997,32.300311895879545,-117.54828125]]}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'optionalFilters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          optionalFilters: [
            "can_deliver_quickly:true",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"optionalFilters":["can_deliver_quickly:true"]}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'optionalFiltersMany',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          optionalFilters: [
            "brand:Apple<score=3>",
            "brand:Samsung<score=2>",
            "brand:-Huawei",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"optionalFilters":["brand:Apple<score=3>","brand:Samsung<score=2>","brand:-Huawei"]}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'optionalFiltersSimple',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          optionalFilters: [
            "brand:Apple<score=2>",
            "type:tablet",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"optionalFilters":["brand:Apple<score=2>","type:tablet"]}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'restrictSearchableAttributes',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          restrictSearchableAttributes: [
            "title_fr",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(
            request.body, """{"restrictSearchableAttributes":["title_fr"]}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'getRankingInfo',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          getRankingInfo: true,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body, """{"getRankingInfo":true}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'clickAnalytics',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          clickAnalytics: true,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body, """{"clickAnalytics":true}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'clickAnalyticsUserToken',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          clickAnalytics: true,
          userToken: "user-1",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(
            request.body, """{"clickAnalytics":true,"userToken":"user-1"}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'enablePersonalization',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          enablePersonalization: true,
          userToken: "user-1",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"enablePersonalization":true,"userToken":"user-1"}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'userToken',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          userToken: "user-1",
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body, """{"userToken":"user-1"}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'analyticsTag',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          analyticsTags: [
            "YOUR_ANALYTICS_TAG",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(
            request.body, """{"analyticsTags":["YOUR_ANALYTICS_TAG"]}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'facetFiltersUsers',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          facetFilters: [
            "user:user42",
            "user:public",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(
            request.body, """{"facetFilters":["user:user42","user:public"]}""");
      },
    ),
  );

  // searchSingleIndex
  test(
    'buildTheQuery',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSingleIndex(
        indexName: "indexName",
        searchParams: SearchParamsObject(
          filters: "categoryPageId: Men's Clothing",
          hitsPerPage: 50,
          analyticsTags: [
            "mens-clothing",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/query');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"filters":"categoryPageId: Men's Clothing","hitsPerPage":50,"analyticsTags":["mens-clothing"]}""");
      },
    ),
  );

  // searchSynonyms
  test(
    'searchSynonyms with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSynonyms(
        indexName: "indexName",
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/synonyms/search');
        expect(request.method, 'post');
        expectBody(request.body, """{}""");
      },
    ),
  );

  // searchSynonyms
  test(
    'searchSynonyms with all parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchSynonyms(
        indexName: "indexName",
        searchSynonymsParams: SearchSynonymsParams(
          query: "myQuery",
          type: SynonymType.fromJson("altcorrection1"),
          page: 10,
          hitsPerPage: 10,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/indexName/synonyms/search');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"query":"myQuery","type":"altcorrection1","page":10,"hitsPerPage":10}""");
      },
    ),
  );

  // searchUserIds
  test(
    'searchUserIds',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.searchUserIds(
        searchUserIdsParams: SearchUserIdsParams(
          query: "test",
          clusterName: "theClusterName",
          page: 5,
          hitsPerPage: 10,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/clusters/mapping/search');
        expect(request.method, 'post');
        expectBody(request.body,
            """{"query":"test","clusterName":"theClusterName","page":5,"hitsPerPage":10}""");
      },
    ),
  );

  // setDictionarySettings
  test(
    'get setDictionarySettings results with minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setDictionarySettings(
        dictionarySettingsParams: DictionarySettingsParams(
          disableStandardEntries: StandardEntries(
            plurals: {
              'fr': false,
              'en': false,
              'ru': true,
            },
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/dictionaries/*/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"disableStandardEntries":{"plurals":{"fr":false,"en":false,"ru":true}}}""");
      },
    ),
  );

  // setDictionarySettings
  test(
    'get setDictionarySettings results with all parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setDictionarySettings(
        dictionarySettingsParams: DictionarySettingsParams(
          disableStandardEntries: StandardEntries(
            plurals: {
              'fr': false,
              'en': false,
              'ru': true,
            },
            stopwords: {
              'fr': false,
            },
            compounds: {
              'ru': true,
            },
          ),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/dictionaries/*/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"disableStandardEntries":{"plurals":{"fr":false,"en":false,"ru":true},"stopwords":{"fr":false},"compounds":{"ru":true}}}""");
      },
    ),
  );

  // setSettings
  test(
    'minimal parameters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "cts_e2e_settings",
        indexSettings: IndexSettings(
          paginationLimitedTo: 10,
        ),
        forwardToReplicas: true,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/cts_e2e_settings/settings');
        expect(request.method, 'put');
        expectParams(
            request.queryParameters, """{"forwardToReplicas":"true"}""");
        expectBody(request.body, """{"paginationLimitedTo":10}""");
      },
    ),
  );

  // setSettings
  test(
    'boolean typoTolerance',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          typoTolerance: true,
        ),
        forwardToReplicas: true,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectParams(
            request.queryParameters, """{"forwardToReplicas":"true"}""");
        expectBody(request.body, """{"typoTolerance":true}""");
      },
    ),
  );

  // setSettings
  test(
    'enum typoTolerance',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          typoTolerance: TypoToleranceEnum.fromJson("min"),
        ),
        forwardToReplicas: true,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectParams(
            request.queryParameters, """{"forwardToReplicas":"true"}""");
        expectBody(request.body, """{"typoTolerance":"min"}""");
      },
    ),
  );

  // setSettings
  test(
    'ignorePlurals',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          ignorePlurals: true,
        ),
        forwardToReplicas: true,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectParams(
            request.queryParameters, """{"forwardToReplicas":"true"}""");
        expectBody(request.body, """{"ignorePlurals":true}""");
      },
    ),
  );

  // setSettings
  test(
    'list of string ignorePlurals',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          ignorePlurals: [
            SupportedLanguage.fromJson("fr"),
          ],
        ),
        forwardToReplicas: true,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectParams(
            request.queryParameters, """{"forwardToReplicas":"true"}""");
        expectBody(request.body, """{"ignorePlurals":["fr"]}""");
      },
    ),
  );

  // setSettings
  test(
    'removeStopWords boolean',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          removeStopWords: true,
        ),
        forwardToReplicas: true,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectParams(
            request.queryParameters, """{"forwardToReplicas":"true"}""");
        expectBody(request.body, """{"removeStopWords":true}""");
      },
    ),
  );

  // setSettings
  test(
    'removeStopWords list of string',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          removeStopWords: [
            SupportedLanguage.fromJson("fr"),
          ],
        ),
        forwardToReplicas: true,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectParams(
            request.queryParameters, """{"forwardToReplicas":"true"}""");
        expectBody(request.body, """{"removeStopWords":["fr"]}""");
      },
    ),
  );

  // setSettings
  test(
    'boolean distinct',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          distinct: true,
        ),
        forwardToReplicas: true,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectParams(
            request.queryParameters, """{"forwardToReplicas":"true"}""");
        expectBody(request.body, """{"distinct":true}""");
      },
    ),
  );

  // setSettings
  test(
    'integer distinct',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          distinct: 1,
        ),
        forwardToReplicas: true,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectParams(
            request.queryParameters, """{"forwardToReplicas":"true"}""");
        expectBody(request.body, """{"distinct":1}""");
      },
    ),
  );

  // setSettings
  test(
    'distinct company',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          attributeForDistinct: "company",
          distinct: true,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"attributeForDistinct":"company","distinct":true}""");
      },
    ),
  );

  // setSettings
  test(
    'distinct design',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          attributeForDistinct: "design",
          distinct: true,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"attributeForDistinct":"design","distinct":true}""");
      },
    ),
  );

  // setSettings
  test(
    'distinct true',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          distinct: true,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body, """{"distinct":true}""");
      },
    ),
  );

  // setSettings
  test(
    'distinct section',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          attributeForDistinct: "section",
          distinct: true,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"attributeForDistinct":"section","distinct":true}""");
      },
    ),
  );

  // setSettings
  test(
    'attributesForFaceting allergens',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "<YOUR_INDEX_NAME>",
        indexSettings: IndexSettings(
          attributesForFaceting: [
            "allergens",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/settings');
        expect(request.method, 'put');
        expectBody(request.body, """{"attributesForFaceting":["allergens"]}""");
      },
    ),
  );

  // setSettings
  test(
    'attributesForFaceting categoryPageId',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "<YOUR_INDEX_NAME>",
        indexSettings: IndexSettings(
          attributesForFaceting: [
            "searchable(categoryPageId)",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"attributesForFaceting":["searchable(categoryPageId)"]}""");
      },
    ),
  );

  // setSettings
  test(
    'unretrievableAttributes',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "<YOUR_INDEX_NAME>",
        indexSettings: IndexSettings(
          unretrievableAttributes: [
            "visible_by",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/settings');
        expect(request.method, 'put');
        expectBody(
            request.body, """{"unretrievableAttributes":["visible_by"]}""");
      },
    ),
  );

  // setSettings
  test(
    'attributesForFaceting user restricted data',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "<YOUR_INDEX_NAME>",
        indexSettings: IndexSettings(
          attributesForFaceting: [
            "filterOnly(visible_by)",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"attributesForFaceting":["filterOnly(visible_by)"]}""");
      },
    ),
  );

  // setSettings
  test(
    'attributesForFaceting optional filters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "<YOUR_INDEX_NAME>",
        indexSettings: IndexSettings(
          attributesForFaceting: [
            "can_deliver_quickly",
            "restaurant",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"attributesForFaceting":["can_deliver_quickly","restaurant"]}""");
      },
    ),
  );

  // setSettings
  test(
    'attributesForFaceting redirect index',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "<YOUR_INDEX_NAME>",
        indexSettings: IndexSettings(
          attributesForFaceting: [
            "query_terms",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/settings');
        expect(request.method, 'put');
        expectBody(
            request.body, """{"attributesForFaceting":["query_terms"]}""");
      },
    ),
  );

  // setSettings
  test(
    'attributesForFaceting multiple consequences',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "<YOUR_INDEX_NAME>",
        indexSettings: IndexSettings(
          attributesForFaceting: [
            "director",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/settings');
        expect(request.method, 'put');
        expectBody(request.body, """{"attributesForFaceting":["director"]}""");
      },
    ),
  );

  // setSettings
  test(
    'attributesForFaceting in-depth optional filters',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "<YOUR_INDEX_NAME>",
        indexSettings: IndexSettings(
          attributesForFaceting: [
            "filterOnly(brand)",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"attributesForFaceting":["filterOnly(brand)"]}""");
      },
    ),
  );

  // setSettings
  test(
    'mode neuralSearch',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          mode: Mode.fromJson("neuralSearch"),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body, """{"mode":"neuralSearch"}""");
      },
    ),
  );

  // setSettings
  test(
    'mode keywordSearch',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          mode: Mode.fromJson("keywordSearch"),
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body, """{"mode":"keywordSearch"}""");
      },
    ),
  );

  // setSettings
  test(
    'searchableAttributes same priority',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          searchableAttributes: [
            "title,comments",
            "ingredients",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"searchableAttributes":["title,comments","ingredients"]}""");
      },
    ),
  );

  // setSettings
  test(
    'searchableAttributes higher priority',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          searchableAttributes: [
            "title",
            "ingredients",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"searchableAttributes":["title","ingredients"]}""");
      },
    ),
  );

  // setSettings
  test(
    'customRanking retweets',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          customRanking: [
            "desc(retweets)",
            "desc(likes)",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"customRanking":["desc(retweets)","desc(likes)"]}""");
      },
    ),
  );

  // setSettings
  test(
    'customRanking boosted',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          customRanking: [
            "desc(boosted)",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body, """{"customRanking":["desc(boosted)"]}""");
      },
    ),
  );

  // setSettings
  test(
    'customRanking pageviews',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          customRanking: [
            "desc(pageviews)",
            "desc(comments)",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"customRanking":["desc(pageviews)","desc(comments)"]}""");
      },
    ),
  );

  // setSettings
  test(
    'customRanking applying search parameters for a specific query',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          customRanking: [
            "desc(nb_airline_liaisons)",
          ],
          attributesForFaceting: [
            "city, country",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"customRanking":["desc(nb_airline_liaisons)"],"attributesForFaceting":["city, country"]}""");
      },
    ),
  );

  // setSettings
  test(
    'customRanking rounded pageviews',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          customRanking: [
            "desc(rounded_pageviews)",
            "desc(comments)",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"customRanking":["desc(rounded_pageviews)","desc(comments)"]}""");
      },
    ),
  );

  // setSettings
  test(
    'customRanking price',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          customRanking: [
            "desc(price)",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body, """{"customRanking":["desc(price)"]}""");
      },
    ),
  );

  // setSettings
  test(
    'ranking exhaustive',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          ranking: [
            "desc(price)",
            "typo",
            "geo",
            "words",
            "filters",
            "proximity",
            "attribute",
            "exact",
            "custom",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"ranking":["desc(price)","typo","geo","words","filters","proximity","attribute","exact","custom"]}""");
      },
    ),
  );

  // setSettings
  test(
    'ranking standard replica',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          ranking: [
            "desc(post_date_timestamp)",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(
            request.body, """{"ranking":["desc(post_date_timestamp)"]}""");
      },
    ),
  );

  // setSettings
  test(
    'ranking virtual replica',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          customRanking: [
            "desc(post_date_timestamp)",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"customRanking":["desc(post_date_timestamp)"]}""");
      },
    ),
  );

  // setSettings
  test(
    'customRanking and ranking sort alphabetically',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          customRanking: [
            "asc(textual_attribute)",
          ],
          ranking: [
            "custom",
            "typo",
            "geo",
            "words",
            "filters",
            "proximity",
            "attribute",
            "exact",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"customRanking":["asc(textual_attribute)"],"ranking":["custom","typo","geo","words","filters","proximity","attribute","exact"]}""");
      },
    ),
  );

  // setSettings
  test(
    'relevancyStrictness',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          customRanking: [
            "asc(textual_attribute)",
          ],
          relevancyStrictness: 0,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"customRanking":["asc(textual_attribute)"],"relevancyStrictness":0}""");
      },
    ),
  );

  // setSettings
  test(
    'create replica index',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          replicas: [
            "products_price_desc",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body, """{"replicas":["products_price_desc"]}""");
      },
    ),
  );

  // setSettings
  test(
    'unlink replica index',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          replicas: [
            "",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body, """{"replicas":[""]}""");
      },
    ),
  );

  // setSettings
  test(
    'forwardToReplicas',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          searchableAttributes: [
            "name",
            "description",
          ],
        ),
        forwardToReplicas: true,
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectParams(
            request.queryParameters, """{"forwardToReplicas":"true"}""");
        expectBody(request.body,
            """{"searchableAttributes":["name","description"]}""");
      },
    ),
  );

  // setSettings
  test(
    'maxValuesPerFacet',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          maxValuesPerFacet: 1000,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body, """{"maxValuesPerFacet":1000}""");
      },
    ),
  );

  // setSettings
  test(
    'maxFacetHits',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          maxFacetHits: 1000,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body, """{"maxFacetHits":1000}""");
      },
    ),
  );

  // setSettings
  test(
    'attributesForFaceting complex',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "<YOUR_INDEX_NAME>",
        indexSettings: IndexSettings(
          attributesForFaceting: [
            "actor",
            "filterOnly(category)",
            "searchable(publisher)",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/%3CYOUR_INDEX_NAME%3E/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"attributesForFaceting":["actor","filterOnly(category)","searchable(publisher)"]}""");
      },
    ),
  );

  // setSettings
  test(
    'ranking closest dates',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          ranking: [
            "asc(date_timestamp)",
            "typo",
            "geo",
            "words",
            "filters",
            "proximity",
            "attribute",
            "exact",
            "custom",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"ranking":["asc(date_timestamp)","typo","geo","words","filters","proximity","attribute","exact","custom"]}""");
      },
    ),
  );

  // setSettings
  test(
    'searchableAttributes item variation',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          searchableAttributes: [
            "design",
            "type",
            "color",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"searchableAttributes":["design","type","color"]}""");
      },
    ),
  );

  // setSettings
  test(
    'searchableAttributes around location',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          searchableAttributes: [
            "name",
            "country",
            "code",
            "iata_code",
          ],
          customRanking: [
            "desc(links_count)",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"searchableAttributes":["name","country","code","iata_code"],"customRanking":["desc(links_count)"]}""");
      },
    ),
  );

  // setSettings
  test(
    'searchableAttributes around location',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          searchableAttributes: [
            "name",
            "country",
            "code",
            "iata_code",
          ],
          customRanking: [
            "desc(links_count)",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"searchableAttributes":["name","country","code","iata_code"],"customRanking":["desc(links_count)"]}""");
      },
    ),
  );

  // setSettings
  test(
    'disableTypoToleranceOnAttributes',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          disableTypoToleranceOnAttributes: [
            "serial_number",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"disableTypoToleranceOnAttributes":["serial_number"]}""");
      },
    ),
  );

  // setSettings
  test(
    'everything',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          advancedSyntax: true,
          advancedSyntaxFeatures: [
            AdvancedSyntaxFeatures.fromJson("exactPhrase"),
          ],
          allowCompressionOfIntegerArray: true,
          allowTyposOnNumericTokens: true,
          alternativesAsExact: [
            AlternativesAsExact.fromJson("singleWordSynonym"),
          ],
          attributeCriteriaComputedByMinProximity: true,
          attributeForDistinct: "test",
          attributesForFaceting: [
            "algolia",
          ],
          attributesToHighlight: [
            "algolia",
          ],
          attributesToRetrieve: [
            "algolia",
          ],
          attributesToSnippet: [
            "algolia",
          ],
          attributesToTransliterate: [
            "algolia",
          ],
          camelCaseAttributes: [
            "algolia",
          ],
          customNormalization: {
            'algolia': {
              'aloglia': "aglolia",
            },
          },
          customRanking: [
            "algolia",
          ],
          decompoundQuery: false,
          decompoundedAttributes: {
            'algolia': "aloglia",
          },
          disableExactOnAttributes: [
            "algolia",
          ],
          disablePrefixOnAttributes: [
            "algolia",
          ],
          disableTypoToleranceOnAttributes: [
            "algolia",
          ],
          disableTypoToleranceOnWords: [
            "algolia",
          ],
          distinct: 3,
          enablePersonalization: true,
          enableReRanking: false,
          enableRules: true,
          exactOnSingleWordQuery: ExactOnSingleWordQuery.fromJson("attribute"),
          highlightPreTag: "<span>",
          highlightPostTag: "</span>",
          hitsPerPage: 10,
          ignorePlurals: false,
          indexLanguages: [
            SupportedLanguage.fromJson("fr"),
          ],
          keepDiacriticsOnCharacters: "abc",
          maxFacetHits: 20,
          maxValuesPerFacet: 30,
          minProximity: 6,
          minWordSizefor1Typo: 5,
          minWordSizefor2Typos: 11,
          mode: Mode.fromJson("neuralSearch"),
          numericAttributesForFiltering: [
            "algolia",
          ],
          optionalWords: [
            "myspace",
          ],
          paginationLimitedTo: 0,
          queryLanguages: [
            SupportedLanguage.fromJson("fr"),
          ],
          queryType: QueryType.fromJson("prefixLast"),
          ranking: [
            "geo",
          ],
          reRankingApplyFilter: "mySearch:filters",
          relevancyStrictness: 10,
          removeStopWords: false,
          removeWordsIfNoResults: RemoveWordsIfNoResults.fromJson("lastWords"),
          renderingContent: RenderingContent(
            facetOrdering: FacetOrdering(
              facets: Facets(
                order: [
                  "a",
                  "b",
                ],
              ),
              values: {
                'a': Value(
                  order: [
                    "b",
                  ],
                  sortRemainingBy: SortRemainingBy.fromJson("count"),
                ),
              },
            ),
          ),
          replaceSynonymsInHighlight: true,
          replicas: [
            "",
          ],
          responseFields: [
            "algolia",
          ],
          restrictHighlightAndSnippetArrays: true,
          searchableAttributes: [
            "foo",
          ],
          semanticSearch: SemanticSearch(
            eventSources: [
              "foo",
            ],
          ),
          separatorsToIndex: "bar",
          snippetEllipsisText: "---",
          sortFacetValuesBy: "date",
          typoTolerance: false,
          unretrievableAttributes: [
            "foo",
          ],
          userData: {
            'user': "data",
          },
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"advancedSyntax":true,"advancedSyntaxFeatures":["exactPhrase"],"allowCompressionOfIntegerArray":true,"allowTyposOnNumericTokens":true,"alternativesAsExact":["singleWordSynonym"],"attributeCriteriaComputedByMinProximity":true,"attributeForDistinct":"test","attributesForFaceting":["algolia"],"attributesToHighlight":["algolia"],"attributesToRetrieve":["algolia"],"attributesToSnippet":["algolia"],"attributesToTransliterate":["algolia"],"camelCaseAttributes":["algolia"],"customNormalization":{"algolia":{"aloglia":"aglolia"}},"customRanking":["algolia"],"decompoundQuery":false,"decompoundedAttributes":{"algolia":"aloglia"},"disableExactOnAttributes":["algolia"],"disablePrefixOnAttributes":["algolia"],"disableTypoToleranceOnAttributes":["algolia"],"disableTypoToleranceOnWords":["algolia"],"distinct":3,"enablePersonalization":true,"enableReRanking":false,"enableRules":true,"exactOnSingleWordQuery":"attribute","highlightPreTag":"<span>","highlightPostTag":"</span>","hitsPerPage":10,"ignorePlurals":false,"indexLanguages":["fr"],"keepDiacriticsOnCharacters":"abc","maxFacetHits":20,"maxValuesPerFacet":30,"minProximity":6,"minWordSizefor1Typo":5,"minWordSizefor2Typos":11,"mode":"neuralSearch","numericAttributesForFiltering":["algolia"],"optionalWords":["myspace"],"paginationLimitedTo":0,"queryLanguages":["fr"],"queryType":"prefixLast","ranking":["geo"],"reRankingApplyFilter":"mySearch:filters","relevancyStrictness":10,"removeStopWords":false,"removeWordsIfNoResults":"lastWords","renderingContent":{"facetOrdering":{"facets":{"order":["a","b"]},"values":{"a":{"order":["b"],"sortRemainingBy":"count"}}}},"replaceSynonymsInHighlight":true,"replicas":[""],"responseFields":["algolia"],"restrictHighlightAndSnippetArrays":true,"searchableAttributes":["foo"],"semanticSearch":{"eventSources":["foo"]},"separatorsToIndex":"bar","snippetEllipsisText":"---","sortFacetValuesBy":"date","typoTolerance":false,"unretrievableAttributes":["foo"],"userData":{"user":"data"}}""");
      },
    ),
  );

  // setSettings
  test(
    'searchableAttributesWithCustomRankingsAndAttributesForFaceting',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          searchableAttributes: [
            "brand",
            "name",
            "categories",
            "unordered(description)",
          ],
          customRanking: [
            "desc(popularity)",
          ],
          attributesForFaceting: [
            "searchable(brand)",
            "type",
            "categories",
            "price",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"searchableAttributes":["brand","name","categories","unordered(description)"],"customRanking":["desc(popularity)"],"attributesForFaceting":["searchable(brand)","type","categories","price"]}""");
      },
    ),
  );

  // setSettings
  test(
    'searchableAttributesProductReferenceSuffixes',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          searchableAttributes: [
            "name",
            "product_reference",
            "product_reference_suffixes",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"searchableAttributes":["name","product_reference","product_reference_suffixes"]}""");
      },
    ),
  );

  // setSettings
  test(
    'queryLanguageAndIgnorePlurals',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          queryLanguages: [
            SupportedLanguage.fromJson("en"),
          ],
          ignorePlurals: true,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(
            request.body, """{"queryLanguages":["en"],"ignorePlurals":true}""");
      },
    ),
  );

  // setSettings
  test(
    'searchableAttributesInMovies',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "movies",
        indexSettings: IndexSettings(
          searchableAttributes: [
            "title_eng",
            "title_fr",
            "title_es",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/movies/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"searchableAttributes":["title_eng","title_fr","title_es"]}""");
      },
    ),
  );

  // setSettings
  test(
    'disablePrefixOnAttributes',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          disablePrefixOnAttributes: [
            "serial_number",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"disablePrefixOnAttributes":["serial_number"]}""");
      },
    ),
  );

  // setSettings
  test(
    'disableTypoToleranceOnAttributes',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          disableTypoToleranceOnAttributes: [
            "serial_number",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"disableTypoToleranceOnAttributes":["serial_number"]}""");
      },
    ),
  );

  // setSettings
  test(
    'searchableAttributesSimpleExample',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          searchableAttributes: [
            "serial_number",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(
            request.body, """{"searchableAttributes":["serial_number"]}""");
      },
    ),
  );

  // setSettings
  test(
    'searchableAttributesSimpleExampleAlt',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.setSettings(
        indexName: "theIndexName",
        indexSettings: IndexSettings(
          searchableAttributes: [
            "serial_number",
            "serial_number_suffixes",
          ],
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/indexes/theIndexName/settings');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"searchableAttributes":["serial_number","serial_number_suffixes"]}""");
      },
    ),
  );

  // updateApiKey
  test(
    'updateApiKey',
    () => runTest(
      builder: (requester) => SearchClient(
        appId: 'appId',
        apiKey: 'apiKey',
        options: ClientOptions(requester: requester),
      ),
      call: (client) => client.updateApiKey(
        key: "ALGOLIA_API_KEY",
        apiKey: ApiKey(
          acl: [
            Acl.fromJson("search"),
            Acl.fromJson("addObject"),
          ],
          validity: 300,
          maxQueriesPerIPPerHour: 100,
          maxHitsPerQuery: 20,
        ),
      ),
      intercept: (request) {
        expectPath(request.path, '/1/keys/ALGOLIA_API_KEY');
        expect(request.method, 'put');
        expectBody(request.body,
            """{"acl":["search","addObject"],"validity":300,"maxQueriesPerIPPerHour":100,"maxHitsPerQuery":20}""");
      },
    ),
  );
}
