{
  "csharp": {
    "import": {
      "default": "using Algolia.Search.Clients;\nusing Algolia.Search.Http;\nusing Algolia.Search.Models.Search;"
    },
    "addApiKey": {
      "minimal": "var response = await client.AddApiKeyAsync(\n  new ApiKey\n  {\n    Acl = new List<Acl> { Enum.Parse<Acl>(\"Search\"), Enum.Parse<Acl>(\"AddObject\") },\n    Description = \"my new api key\",\n  }\n);",
      "all": "var response = await client.AddApiKeyAsync(\n  new ApiKey\n  {\n    Acl = new List<Acl> { Enum.Parse<Acl>(\"Search\"), Enum.Parse<Acl>(\"AddObject\") },\n    Description = \"my new api key\",\n    Validity = 300,\n    MaxQueriesPerIPPerHour = 100,\n    MaxHitsPerQuery = 20,\n  }\n);"
    },
    "addOrUpdateObject": {
      "default": "var response = await client.AddOrUpdateObjectAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new Dictionary<string, string> { { \"key\", \"value\" } }\n);"
    },
    "appendSource": {
      "default": "var response = await client.AppendSourceAsync(\n  new Source { VarSource = \"theSource\", Description = \"theDescription\" }\n);"
    },
    "assignUserId": {
      "simple": "var response = await client.AssignUserIdAsync(\n  \"user42\",\n  new AssignUserIdParams { Cluster = \"d4242-eu\" }\n);",
      "it should not encode the userID": "var response = await client.AssignUserIdAsync(\n  \"user id with spaces\",\n  new AssignUserIdParams { Cluster = \"cluster with spaces\" }\n);"
    },
    "batch": {
      "addObject": "var response = await client.BatchAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams\n  {\n    Requests = new List<BatchRequest>\n    {\n      new BatchRequest\n      {\n        Action = Enum.Parse<Action>(\"AddObject\"),\n        Body = new Dictionary<string, string> { { \"key\", \"bar\" }, { \"foo\", \"1\" } },\n      },\n      new BatchRequest\n      {\n        Action = Enum.Parse<Action>(\"AddObject\"),\n        Body = new Dictionary<string, string> { { \"key\", \"baz\" }, { \"foo\", \"2\" } },\n      },\n    },\n  }\n);",
      "clear": "var response = await client.BatchAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams\n  {\n    Requests = new List<BatchRequest>\n    {\n      new BatchRequest\n      {\n        Action = Enum.Parse<Action>(\"Clear\"),\n        Body = new Dictionary<string, string> { { \"key\", \"value\" } },\n      },\n    },\n  }\n);",
      "delete": "var response = await client.BatchAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams\n  {\n    Requests = new List<BatchRequest>\n    {\n      new BatchRequest\n      {\n        Action = Enum.Parse<Action>(\"Delete\"),\n        Body = new Dictionary<string, string> { { \"key\", \"value\" } },\n      },\n    },\n  }\n);",
      "deleteObject": "var response = await client.BatchAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams\n  {\n    Requests = new List<BatchRequest>\n    {\n      new BatchRequest\n      {\n        Action = Enum.Parse<Action>(\"DeleteObject\"),\n        Body = new Dictionary<string, string> { { \"key\", \"value\" } },\n      },\n    },\n  }\n);",
      "partialUpdateObject": "var response = await client.BatchAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams\n  {\n    Requests = new List<BatchRequest>\n    {\n      new BatchRequest\n      {\n        Action = Enum.Parse<Action>(\"PartialUpdateObject\"),\n        Body = new Dictionary<string, string> { { \"key\", \"value\" } },\n      },\n    },\n  }\n);",
      "partialUpdateObjectNoCreate": "var response = await client.BatchAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams\n  {\n    Requests = new List<BatchRequest>\n    {\n      new BatchRequest\n      {\n        Action = Enum.Parse<Action>(\"PartialUpdateObjectNoCreate\"),\n        Body = new Dictionary<string, string> { { \"key\", \"value\" } },\n      },\n    },\n  }\n);",
      "updateObject": "var response = await client.BatchAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams\n  {\n    Requests = new List<BatchRequest>\n    {\n      new BatchRequest\n      {\n        Action = Enum.Parse<Action>(\"UpdateObject\"),\n        Body = new Dictionary<string, string> { { \"key\", \"value\" } },\n      },\n    },\n  }\n);"
    },
    "batchAssignUserIds": {
      "default": "var response = await client.BatchAssignUserIdsAsync(\n  \"userID\",\n  new BatchAssignUserIdsParams\n  {\n    Cluster = \"theCluster\",\n    Users = new List<string> { \"user1\", \"user2\" },\n  }\n);"
    },
    "batchDictionaryEntries": {
      "replace": "var response = await client.BatchDictionaryEntriesAsync(\n  Enum.Parse<DictionaryType>(\"Plurals\"),\n  new BatchDictionaryEntriesParams\n  {\n    ClearExistingDictionaryEntries = true,\n    Requests = new List<BatchDictionaryEntriesRequest>\n    {\n      new BatchDictionaryEntriesRequest\n      {\n        Action = Enum.Parse<DictionaryAction>(\"AddEntry\"),\n        Body = new DictionaryEntry\n        {\n          ObjectID = \"1\",\n          Language = Enum.Parse<SupportedLanguage>(\"En\"),\n          Word = \"fancy\",\n          Words = new List<string> { \"believe\", \"algolia\" },\n          Decomposition = new List<string> { \"trust\", \"algolia\" },\n          State = Enum.Parse<DictionaryEntryState>(\"Enabled\"),\n        },\n      },\n    },\n  }\n);",
      "delete": "var response = await client.BatchDictionaryEntriesAsync(\n  Enum.Parse<DictionaryType>(\"Plurals\"),\n  new BatchDictionaryEntriesParams\n  {\n    ClearExistingDictionaryEntries = true,\n    Requests = new List<BatchDictionaryEntriesRequest>\n    {\n      new BatchDictionaryEntriesRequest\n      {\n        Action = Enum.Parse<DictionaryAction>(\"DeleteEntry\"),\n        Body = new DictionaryEntry { ObjectID = \"1\" },\n      },\n    },\n  }\n);",
      "append": "var response = await client.BatchDictionaryEntriesAsync(\n  Enum.Parse<DictionaryType>(\"Stopwords\"),\n  new BatchDictionaryEntriesParams\n  {\n    Requests = new List<BatchDictionaryEntriesRequest>\n    {\n      new BatchDictionaryEntriesRequest\n      {\n        Action = Enum.Parse<DictionaryAction>(\"AddEntry\"),\n        Body = new DictionaryEntry\n        {\n          ObjectID = \"1\",\n          Language = Enum.Parse<SupportedLanguage>(\"En\"),\n          AdditionalProperties = new Dictionary<string, object> { { \"additional\", \"try me\" } },\n        },\n      },\n    },\n  }\n);"
    },
    "browse": {
      "browse with minimal parameters": "var response = await client.BrowseAsync<Hit>(\"<YOUR_INDEX_NAME>\");",
      "browse with search parameters": "var response = await client.BrowseAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new BrowseParams(\n    new BrowseParamsObject\n    {\n      Query = \"myQuery\",\n      FacetFilters = new FacetFilters(\n        new List<FacetFilters> { new FacetFilters(\"tags:algolia\") }\n      ),\n    }\n  )\n);",
      "browse allow a cursor in parameters": "var response = await client.BrowseAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new BrowseParams(new BrowseParamsObject { Cursor = \"test\" })\n);"
    },
    "clearObjects": {
      "default": "var response = await client.ClearObjectsAsync(\"<YOUR_INDEX_NAME>\");"
    },
    "clearRules": {
      "default": "var response = await client.ClearRulesAsync(\"<YOUR_INDEX_NAME>\");"
    },
    "clearSynonyms": {
      "default": "var response = await client.ClearSynonymsAsync(\"<YOUR_INDEX_NAME>\");"
    },
    "customDelete": {
      "allow del method for a custom path with minimal parameters": "var response = await client.CustomDeleteAsync(\"test/minimal\");",
      "allow del method for a custom path with all parameters": "var response = await client.CustomDeleteAsync(\n  \"test/all\",\n  new Dictionary<string, object> { { \"query\", \"parameters\" } }\n);"
    },
    "customGet": {
      "allow get method for a custom path with minimal parameters": "var response = await client.CustomGetAsync(\"test/minimal\");",
      "allow get method for a custom path with all parameters": "var response = await client.CustomGetAsync(\n  \"test/all\",\n  new Dictionary<string, object> { { \"query\", \"parameters with space\" } }\n);",
      "requestOptions should be escaped too": "var response = await client.CustomGetAsync(\n  \"test/all\",\n  new Dictionary<string, object> { { \"query\", \"to be overriden\" } },\n  new RequestOptionBuilder()\n    .AddExtraQueryParameters(\"query\", \"parameters with space\")\n    .AddExtraQueryParameters(\"and an array\", new List<object> { \"array\", \"with spaces\" })\n    .AddExtraHeader(\"x-header-1\", \"spaces are left alone\")\n    .Build()\n);"
    },
    "customPost": {
      "allow post method for a custom path with minimal parameters": "var response = await client.CustomPostAsync(\"test/minimal\");",
      "allow post method for a custom path with all parameters": "var response = await client.CustomPostAsync(\n  \"test/all\",\n  new Dictionary<string, object> { { \"query\", \"parameters\" } },\n  new Dictionary<string, string> { { \"body\", \"parameters\" } }\n);",
      "requestOptions can override default query parameters": "var response = await client.CustomPostAsync(\n  \"test/requestOptions\",\n  new Dictionary<string, object> { { \"query\", \"parameters\" } },\n  new Dictionary<string, string> { { \"facet\", \"filters\" } },\n  new RequestOptionBuilder().AddExtraQueryParameters(\"query\", \"myQueryParameter\").Build()\n);",
      "requestOptions merges query parameters with default ones": "var response = await client.CustomPostAsync(\n  \"test/requestOptions\",\n  new Dictionary<string, object> { { \"query\", \"parameters\" } },\n  new Dictionary<string, string> { { \"facet\", \"filters\" } },\n  new RequestOptionBuilder().AddExtraQueryParameters(\"query2\", \"myQueryParameter\").Build()\n);",
      "requestOptions can override default headers": "var response = await client.CustomPostAsync(\n  \"test/requestOptions\",\n  new Dictionary<string, object> { { \"query\", \"parameters\" } },\n  new Dictionary<string, string> { { \"facet\", \"filters\" } },\n  new RequestOptionBuilder().AddExtraHeader(\"x-algolia-api-key\", \"ALGOLIA_API_KEY\").Build()\n);",
      "requestOptions merges headers with default ones": "var response = await client.CustomPostAsync(\n  \"test/requestOptions\",\n  new Dictionary<string, object> { { \"query\", \"parameters\" } },\n  new Dictionary<string, string> { { \"facet\", \"filters\" } },\n  new RequestOptionBuilder().AddExtraHeader(\"x-algolia-api-key\", \"ALGOLIA_API_KEY\").Build()\n);",
      "requestOptions queryParameters accepts booleans": "var response = await client.CustomPostAsync(\n  \"test/requestOptions\",\n  new Dictionary<string, object> { { \"query\", \"parameters\" } },\n  new Dictionary<string, string> { { \"facet\", \"filters\" } },\n  new RequestOptionBuilder().AddExtraQueryParameters(\"isItWorking\", true).Build()\n);",
      "requestOptions queryParameters accepts integers": "var response = await client.CustomPostAsync(\n  \"test/requestOptions\",\n  new Dictionary<string, object> { { \"query\", \"parameters\" } },\n  new Dictionary<string, string> { { \"facet\", \"filters\" } },\n  new RequestOptionBuilder().AddExtraQueryParameters(\"myParam\", 2).Build()\n);",
      "requestOptions queryParameters accepts list of string": "var response = await client.CustomPostAsync(\n  \"test/requestOptions\",\n  new Dictionary<string, object> { { \"query\", \"parameters\" } },\n  new Dictionary<string, string> { { \"facet\", \"filters\" } },\n  new RequestOptionBuilder()\n    .AddExtraQueryParameters(\"myParam\", new List<object> { \"b and c\", \"d\" })\n    .Build()\n);",
      "requestOptions queryParameters accepts list of booleans": "var response = await client.CustomPostAsync(\n  \"test/requestOptions\",\n  new Dictionary<string, object> { { \"query\", \"parameters\" } },\n  new Dictionary<string, string> { { \"facet\", \"filters\" } },\n  new RequestOptionBuilder()\n    .AddExtraQueryParameters(\"myParam\", new List<object> { true, true, false })\n    .Build()\n);",
      "requestOptions queryParameters accepts list of integers": "var response = await client.CustomPostAsync(\n  \"test/requestOptions\",\n  new Dictionary<string, object> { { \"query\", \"parameters\" } },\n  new Dictionary<string, string> { { \"facet\", \"filters\" } },\n  new RequestOptionBuilder()\n    .AddExtraQueryParameters(\"myParam\", new List<object> { 1, 2 })\n    .Build()\n);"
    },
    "customPut": {
      "allow put method for a custom path with minimal parameters": "var response = await client.CustomPutAsync(\"test/minimal\");",
      "allow put method for a custom path with all parameters": "var response = await client.CustomPutAsync(\n  \"test/all\",\n  new Dictionary<string, object> { { \"query\", \"parameters\" } },\n  new Dictionary<string, string> { { \"body\", \"parameters\" } }\n);"
    },
    "deleteApiKey": {
      "default": "var response = await client.DeleteApiKeyAsync(\"myTestApiKey\");"
    },
    "deleteBy": {
      "default": "var response = await client.DeleteByAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new DeleteByParams { Filters = \"brand:brandName\" }\n);"
    },
    "deleteIndex": {
      "default": "var response = await client.DeleteIndexAsync(\"<YOUR_INDEX_NAME>\");"
    },
    "deleteObject": {
      "default": "var response = await client.DeleteObjectAsync(\"<YOUR_INDEX_NAME>\", \"uniqueID\");"
    },
    "deleteObjects": {
      "default": "var response = await client.DeleteObjectsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<string> { \"1\", \"2\" }\n);"
    },
    "deleteRule": {
      "delete rule simple case": "var response = await client.DeleteRuleAsync(\"<YOUR_INDEX_NAME>\", \"id1\");",
      "delete rule with simple characters to encode in objectID": "var response = await client.DeleteRuleAsync(\"<YOUR_INDEX_NAME>\", \"test/with/slash\");"
    },
    "deleteSource": {
      "default": "var response = await client.DeleteSourceAsync(\"theSource\");"
    },
    "deleteSynonym": {
      "default": "var response = await client.DeleteSynonymAsync(\"<YOUR_INDEX_NAME>\", \"id1\");"
    },
    "generateSecuredApiKey": {
      "api key basic": "var response = client.GenerateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  new SecuredApiKeyRestrictions\n  {\n    ValidUntil = 2524604400L,\n    RestrictIndices = new List<string> { \"Movies\" },\n  }\n);",
      "with searchParams": "var response = client.GenerateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  new SecuredApiKeyRestrictions\n  {\n    ValidUntil = 2524604400L,\n    RestrictIndices = new List<string> { \"Movies\", \"cts_e2e_settings\" },\n    RestrictSources = \"192.168.1.0/24\",\n    Filters = \"category:Book OR category:Ebook AND _tags:published\",\n    UserToken = \"user123\",\n    SearchParams = new SearchParamsObject\n    {\n      Query = \"batman\",\n      TypoTolerance = new TypoTolerance(Enum.Parse<TypoToleranceEnum>(\"Strict\")),\n      AroundRadius = new AroundRadius(Enum.Parse<AroundRadiusAll>(\"All\")),\n      Mode = Enum.Parse<Mode>(\"NeuralSearch\"),\n      HitsPerPage = 10,\n      OptionalWords = new OptionalWords(new List<string> { \"one\", \"two\" }),\n    },\n  }\n);",
      "with filters": "var response = client.GenerateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  new SecuredApiKeyRestrictions\n  {\n    Filters = \"user:user42 AND user:public AND (visible_by:John OR visible_by:group/Finance)\",\n  }\n);",
      "with visible_by filter": "var response = client.GenerateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  new SecuredApiKeyRestrictions { Filters = \"visible_by:group/Finance\" }\n);",
      "with userID": "var response = client.GenerateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  new SecuredApiKeyRestrictions { UserToken = \"user42\" }\n);",
      "mcm with filters": "var response = client.GenerateSecuredApiKey(\n  \"YourSearchOnlyApiKey\",\n  new SecuredApiKeyRestrictions { Filters = \"user:user42 AND user:public\" }\n);",
      "mcm with user token": "var response = client.GenerateSecuredApiKey(\n  \"YourSearchOnlyApiKey\",\n  new SecuredApiKeyRestrictions { UserToken = \"user42\" }\n);"
    },
    "getApiKey": {
      "default": "var response = await client.GetApiKeyAsync(\"myTestApiKey\");"
    },
    "getAppTask": {
      "default": "var response = await client.GetAppTaskAsync(123L);"
    },
    "getDictionaryLanguages": {
      "default": "var response = await client.GetDictionaryLanguagesAsync();"
    },
    "getDictionarySettings": {
      "default": "var response = await client.GetDictionarySettingsAsync();"
    },
    "getLogs": {
      "getLogs with minimal parameters": "var response = await client.GetLogsAsync();",
      "getLogs with parameters": "var response = await client.GetLogsAsync(\n  5,\n  10,\n  \"<YOUR_INDEX_NAME>\",\n  Enum.Parse<LogType>(\"All\")\n);"
    },
    "getObject": {
      "getObject": "var response = await client.GetObjectAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new List<string> { \"attr1\", \"attr2\" }\n);",
      "search with a real object": "var response = await client.GetObjectAsync(\"<YOUR_INDEX_NAME>\", \"Batman and Robin\");"
    },
    "getObjects": {
      "by ID": "var response = await client.GetObjectsAsync<Hit>(\n  new GetObjectsParams\n  {\n    Requests = new List<GetObjectsRequest>\n    {\n      new GetObjectsRequest { ObjectID = \"uniqueID\", IndexName = \"<YOUR_INDEX_NAME>\" },\n    },\n  }\n);",
      "multiple IDs": "var response = await client.GetObjectsAsync<Hit>(\n  new GetObjectsParams\n  {\n    Requests = new List<GetObjectsRequest>\n    {\n      new GetObjectsRequest { ObjectID = \"uniqueID1\", IndexName = \"<YOUR_INDEX_NAME>\" },\n      new GetObjectsRequest { ObjectID = \"uniqueID2\", IndexName = \"<YOUR_INDEX_NAME>\" },\n    },\n  }\n);",
      "with attributesToRetrieve": "var response = await client.GetObjectsAsync<Hit>(\n  new GetObjectsParams\n  {\n    Requests = new List<GetObjectsRequest>\n    {\n      new GetObjectsRequest\n      {\n        AttributesToRetrieve = new List<string> { \"attr1\", \"attr2\" },\n        ObjectID = \"uniqueID\",\n        IndexName = \"<YOUR_INDEX_NAME>\",\n      },\n    },\n  }\n);"
    },
    "getRule": {
      "default": "var response = await client.GetRuleAsync(\"<YOUR_INDEX_NAME>\", \"qr-1725004648916\");"
    },
    "getSettings": {
      "default": "var response = await client.GetSettingsAsync(\"<YOUR_INDEX_NAME>\");"
    },
    "getSources": {
      "default": "var response = await client.GetSourcesAsync();"
    },
    "getSynonym": {
      "default": "var response = await client.GetSynonymAsync(\"<YOUR_INDEX_NAME>\", \"id1\");"
    },
    "getTask": {
      "default": "var response = await client.GetTaskAsync(\"<YOUR_INDEX_NAME>\", 123L);"
    },
    "getTopUserIds": {
      "default": "var response = await client.GetTopUserIdsAsync();"
    },
    "getUserId": {
      "default": "var response = await client.GetUserIdAsync(\"uniqueID\");"
    },
    "hasPendingMappings": {
      "hasPendingMappings with minimal parameters": "var response = await client.HasPendingMappingsAsync();",
      "hasPendingMappings with parameters": "var response = await client.HasPendingMappingsAsync(true);"
    },
    "indexExists": {
      "indexExists": "var response = await client.IndexExistsAsync(\"<YOUR_INDEX_NAME>\");",
      "indexNotExists": "var response = await client.IndexExistsAsync(\"<YOUR_INDEX_NAME>\");",
      "indexExistsWithError": "var response = await client.IndexExistsAsync(\"<YOUR_INDEX_NAME>\");"
    },
    "listApiKeys": {
      "default": "var response = await client.ListApiKeysAsync();"
    },
    "listClusters": {
      "default": "var response = await client.ListClustersAsync();"
    },
    "listIndices": {
      "listIndices with minimal parameters": "var response = await client.ListIndicesAsync();",
      "listIndices with parameters": "var response = await client.ListIndicesAsync(8, 3);"
    },
    "listUserIds": {
      "listUserIds with minimal parameters": "var response = await client.ListUserIdsAsync();",
      "listUserIds with parameters": "var response = await client.ListUserIdsAsync(8, 100);"
    },
    "multipleBatch": {
      "default": "var response = await client.MultipleBatchAsync(\n  new BatchParams\n  {\n    Requests = new List<MultipleBatchRequest>\n    {\n      new MultipleBatchRequest\n      {\n        Action = Enum.Parse<Action>(\"AddObject\"),\n        Body = new Dictionary<string, string> { { \"key\", \"value\" } },\n        IndexName = \"<YOUR_INDEX_NAME>\",\n      },\n    },\n  }\n);"
    },
    "operationIndex": {
      "scopes": "var response = await client.OperationIndexAsync(\n  \"<SOURCE_INDEX_NAME>\",\n  new OperationIndexParams\n  {\n    Operation = Enum.Parse<OperationType>(\"Move\"),\n    Destination = \"<DESTINATION_INDEX_NAME>\",\n    Scope = new List<ScopeType>\n    {\n      Enum.Parse<ScopeType>(\"Rules\"),\n      Enum.Parse<ScopeType>(\"Settings\"),\n    },\n  }\n);",
      "copy": "var response = await client.OperationIndexAsync(\n  \"<SOURCE_INDEX_NAME>\",\n  new OperationIndexParams\n  {\n    Operation = Enum.Parse<OperationType>(\"Copy\"),\n    Destination = \"<DESTINATION_INDEX_NAME>\",\n  }\n);",
      "move": "var response = await client.OperationIndexAsync(\n  \"<SOURCE_INDEX_NAME>\",\n  new OperationIndexParams\n  {\n    Operation = Enum.Parse<OperationType>(\"Move\"),\n    Destination = \"<DESTINATION_INDEX_NAME>\",\n  }\n);"
    },
    "partialUpdateObject": {
      "Partial update with a new value for a string attribute": "var response = await client.PartialUpdateObjectAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new Dictionary<string, string> { { \"attributeId\", \"new value\" } }\n);",
      "Partial update with a new value for an integer attribute": "var response = await client.PartialUpdateObjectAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new Dictionary<string, int> { { \"attributeId\", 1 } }\n);",
      "Partial update with a new value for a boolean attribute": "var response = await client.PartialUpdateObjectAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new Dictionary<string, Boolean> { { \"attributeId\", true } }\n);",
      "Partial update with a new value for an array attribute": "var response = await client.PartialUpdateObjectAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new Dictionary<string, List<string>>\n  {\n    {\n      \"attributeId\",\n      new List<string> { \"one\", \"two\", \"three\" }\n    },\n  }\n);",
      "Partial update with a new value for an object attribute": "var response = await client.PartialUpdateObjectAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new Dictionary<string, Object>\n  {\n    {\n      \"attributeId\",\n      new Dictionary<string, string> { { \"nested\", \"value\" } }\n    },\n  }\n);",
      "with visible_by filter": "var response = await client.PartialUpdateObjectAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new Dictionary<string, List<string>>\n  {\n    {\n      \"visible_by\",\n      new List<string> { \"Angela\", \"group/Finance\", \"group/Shareholders\" }\n    },\n  }\n);",
      "add men pant": "var response = await client.PartialUpdateObjectAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"productId\",\n  new Dictionary<string, Object>\n  {\n    {\n      \"categoryPageId\",\n      new Dictionary<string, string>\n      {\n        { \"_operation\", \"Add\" },\n        { \"value\", \"men-clothing-pants\" },\n      }\n    },\n  }\n);",
      "remove men pant": "var response = await client.PartialUpdateObjectAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"productId\",\n  new Dictionary<string, Object>\n  {\n    {\n      \"categoryPageId\",\n      new Dictionary<string, string>\n      {\n        { \"_operation\", \"Remove\" },\n        { \"value\", \"men-clothing-pants\" },\n      }\n    },\n  }\n);"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "var response = await client.PartialUpdateObjectsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Object>\n  {\n    new Dictionary<string, string> { { \"objectID\", \"1\" }, { \"name\", \"Adam\" } },\n    new Dictionary<string, string> { { \"objectID\", \"2\" }, { \"name\", \"Benoit\" } },\n  },\n  true\n);",
      "call partialUpdateObjects with createIfNotExists=false": "var response = await client.PartialUpdateObjectsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Object>\n  {\n    new Dictionary<string, string> { { \"objectID\", \"3\" }, { \"name\", \"Cyril\" } },\n    new Dictionary<string, string> { { \"objectID\", \"4\" }, { \"name\", \"David\" } },\n  },\n  false\n);"
    },
    "removeUserId": {
      "default": "var response = await client.RemoveUserIdAsync(\"uniqueID\");"
    },
    "replaceAllObjects": {
      "call replaceAllObjects without error": "var response = await client.ReplaceAllObjectsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Object>\n  {\n    new Dictionary<string, string> { { \"objectID\", \"1\" }, { \"name\", \"Adam\" } },\n    new Dictionary<string, string> { { \"objectID\", \"2\" }, { \"name\", \"Benoit\" } },\n    new Dictionary<string, string> { { \"objectID\", \"3\" }, { \"name\", \"Cyril\" } },\n    new Dictionary<string, string> { { \"objectID\", \"4\" }, { \"name\", \"David\" } },\n    new Dictionary<string, string> { { \"objectID\", \"5\" }, { \"name\", \"Eva\" } },\n    new Dictionary<string, string> { { \"objectID\", \"6\" }, { \"name\", \"Fiona\" } },\n    new Dictionary<string, string> { { \"objectID\", \"7\" }, { \"name\", \"Gael\" } },\n    new Dictionary<string, string> { { \"objectID\", \"8\" }, { \"name\", \"Hugo\" } },\n    new Dictionary<string, string> { { \"objectID\", \"9\" }, { \"name\", \"Igor\" } },\n    new Dictionary<string, string> { { \"objectID\", \"10\" }, { \"name\", \"Julia\" } },\n  },\n  3\n);",
      "call replaceAllObjects with partial scopes": "var response = await client.ReplaceAllObjectsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Object>\n  {\n    new Dictionary<string, string> { { \"objectID\", \"1\" }, { \"name\", \"Adam\" } },\n    new Dictionary<string, string> { { \"objectID\", \"2\" }, { \"name\", \"Benoit\" } },\n  },\n  77,\n  new List<ScopeType> { Enum.Parse<ScopeType>(\"Settings\"), Enum.Parse<ScopeType>(\"Synonyms\") }\n);",
      "replaceAllObjects should cleanup on failure": "var response = await client.ReplaceAllObjectsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Object>\n  {\n    new Dictionary<string, string> { { \"objectID\", \"fine\" }, { \"body\", \"small obj\" } },\n    new Dictionary<string, string>\n    {\n      { \"objectID\", \"toolarge\" },\n      { \"body\", \"something bigger than 10KB\" },\n    },\n  }\n);"
    },
    "replaceSources": {
      "default": "var response = await client.ReplaceSourcesAsync(\n  new List<Source>\n  {\n    new Source { VarSource = \"theSource\", Description = \"theDescription\" },\n  }\n);"
    },
    "restoreApiKey": {
      "default": "var response = await client.RestoreApiKeyAsync(\"ALGOLIA_API_KEY\");"
    },
    "saveObject": {
      "default": "var response = await client.SaveObjectAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new Dictionary<string, string>\n  {\n    { \"name\", \"Black T-shirt\" },\n    { \"color\", \"#000000||black\" },\n    { \"availableIn\", \"https://source.unsplash.com/100x100/?paris||Paris\" },\n    { \"objectID\", \"myID\" },\n  }\n);"
    },
    "saveObjects": {
      "call saveObjects without error": "var response = await client.SaveObjectsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Object>\n  {\n    new Dictionary<string, string> { { \"objectID\", \"1\" }, { \"name\", \"Adam\" } },\n    new Dictionary<string, string> { { \"objectID\", \"2\" }, { \"name\", \"Benoit\" } },\n  }\n);",
      "saveObjects should report errors": "var response = await client.SaveObjectsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Object>\n  {\n    new Dictionary<string, string> { { \"objectID\", \"1\" }, { \"name\", \"Adam\" } },\n    new Dictionary<string, string> { { \"objectID\", \"2\" }, { \"name\", \"Benoit\" } },\n  }\n);",
      "saveObjectsPlaylist": "var response = await client.SaveObjectsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Object>\n  {\n    new Dictionary<string, string>\n    {\n      { \"objectID\", \"1\" },\n      { \"visibility\", \"public\" },\n      { \"name\", \"Hot 100 Billboard Charts\" },\n      { \"playlistId\", \"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\" },\n      { \"createdAt\", \"1500240452\" },\n    },\n  }\n);",
      "saveObjectsPublicUser": "var response = await client.SaveObjectsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Object>\n  {\n    new Dictionary<string, string>\n    {\n      { \"objectID\", \"1\" },\n      { \"visibility\", \"public\" },\n      { \"name\", \"Hot 100 Billboard Charts\" },\n      { \"playlistId\", \"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\" },\n      { \"createdAt\", \"1500240452\" },\n    },\n  },\n  false,\n  1000,\n  new RequestOptionBuilder().AddExtraHeader(\"X-Algolia-User-ID\", \"*\").Build()\n);"
    },
    "saveRule": {
      "saveRule with minimal parameters": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"id1\",\n  new Rule\n  {\n    ObjectID = \"id1\",\n    Conditions = new List<Condition>\n    {\n      new Condition { Pattern = \"apple\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n    },\n    Consequence = new Consequence\n    {\n      Params = new ConsequenceParams { Filters = \"brand:xiaomi\" },\n    },\n  }\n);",
      "saveRule with all parameters": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"id1\",\n  new Rule\n  {\n    ObjectID = \"id1\",\n    Conditions = new List<Condition>\n    {\n      new Condition\n      {\n        Pattern = \"apple\",\n        Anchoring = Enum.Parse<Anchoring>(\"Contains\"),\n        Alternatives = false,\n        Context = \"search\",\n      },\n    },\n    Consequence = new Consequence\n    {\n      Params = new ConsequenceParams\n      {\n        Filters = \"brand:apple\",\n        Query = new ConsequenceQuery(\n          new ConsequenceQueryObject\n          {\n            Remove = new List<string> { \"algolia\" },\n            Edits = new List<Edit>\n            {\n              new Edit\n              {\n                Type = Enum.Parse<EditType>(\"Remove\"),\n                Delete = \"abc\",\n                Insert = \"cde\",\n              },\n              new Edit\n              {\n                Type = Enum.Parse<EditType>(\"Replace\"),\n                Delete = \"abc\",\n                Insert = \"cde\",\n              },\n            },\n          }\n        ),\n      },\n      Hide = new List<ConsequenceHide> { new ConsequenceHide { ObjectID = \"321\" } },\n      FilterPromotes = false,\n      UserData = new Dictionary<string, string> { { \"algolia\", \"aloglia\" } },\n      Promote = new List<Promote>\n      {\n        new Promote(new PromoteObjectID { ObjectID = \"abc\", Position = 3 }),\n        new Promote(\n          new PromoteObjectIDs\n          {\n            ObjectIDs = new List<string> { \"abc\", \"def\" },\n            Position = 1,\n          }\n        ),\n      },\n    },\n    Description = \"test\",\n    Enabled = true,\n    Validity = new List<TimeRange>\n    {\n      new TimeRange { From = 1656670273L, Until = 1656670277L },\n    },\n  },\n  true\n);",
      "b2b catalog": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"article-rule\",\n  new Rule\n  {\n    ObjectID = \"article-rule\",\n    Conditions = new List<Condition>\n    {\n      new Condition { Pattern = \"article\", Anchoring = Enum.Parse<Anchoring>(\"StartsWith\") },\n    },\n    Consequence = new Consequence\n    {\n      Params = new ConsequenceParams\n      {\n        Query = new ConsequenceQuery(\n          new ConsequenceQueryObject\n          {\n            Edits = new List<Edit>\n            {\n              new Edit { Type = Enum.Parse<EditType>(\"Remove\"), Delete = \"article\" },\n            },\n          }\n        ),\n        RestrictSearchableAttributes = new List<string> { \"title\", \"book_id\" },\n      },\n    },\n  }\n);",
      "merchandising and promoting": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"director-rule\",\n  new Rule\n  {\n    ObjectID = \"director-rule\",\n    Conditions = new List<Condition>\n    {\n      new Condition\n      {\n        Pattern = \"{facet:director} director\",\n        Anchoring = Enum.Parse<Anchoring>(\"Contains\"),\n      },\n    },\n    Consequence = new Consequence\n    {\n      Params = new ConsequenceParams\n      {\n        RestrictSearchableAttributes = new List<string> { \"title\", \"book_id\" },\n        AutomaticFacetFilters = new AutomaticFacetFilters(\n          new List<AutomaticFacetFilter> { new AutomaticFacetFilter { Facet = \"director\" } }\n        ),\n        Query = new ConsequenceQuery(\n          new ConsequenceQueryObject\n          {\n            Edits = new List<Edit>\n            {\n              new Edit { Type = Enum.Parse<EditType>(\"Remove\"), Delete = \"director\" },\n            },\n          }\n        ),\n      },\n    },\n  }\n);",
      "harry potter": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"harry-potter-rule\",\n  new Rule\n  {\n    ObjectID = \"harry-potter-rule\",\n    Conditions = new List<Condition>\n    {\n      new Condition { Pattern = \"harry potter\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n    },\n    Consequence = new Consequence\n    {\n      UserData = new Dictionary<string, string>\n      {\n        { \"promo_content\", \"20% OFF on all Harry Potter books!\" },\n      },\n    },\n  }\n);",
      "merchandising empty query": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"clearance-category-filter\",\n  new Rule\n  {\n    ObjectID = \"clearance-category-filter\",\n    Conditions = new List<Condition>\n    {\n      new Condition\n      {\n        Pattern = \"\",\n        Anchoring = Enum.Parse<Anchoring>(\"Is\"),\n        Context = \"landing\",\n      },\n    },\n    Consequence = new Consequence\n    {\n      Params = new ConsequenceParams\n      {\n        OptionalFilters = new OptionalFilters(\"clearance:true\"),\n      },\n    },\n  }\n);",
      "redirect": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"redirect-help-rule\",\n  new Rule\n  {\n    ObjectID = \"redirect-help-rule\",\n    Conditions = new List<Condition>\n    {\n      new Condition { Pattern = \"help\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n    },\n    Consequence = new Consequence\n    {\n      UserData = new Dictionary<string, string>\n      {\n        { \"redirect\", \"https://www.algolia.com/support\" },\n      },\n    },\n  }\n);",
      "promote some results over others": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"tomato-fruit\",\n  new Rule\n  {\n    ObjectID = \"tomato-fruit\",\n    Conditions = new List<Condition>\n    {\n      new Condition { Pattern = \"tomato\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n    },\n    Consequence = new Consequence\n    {\n      Params = new ConsequenceParams\n      {\n        OptionalFilters = new OptionalFilters(\"food_group:fruit\"),\n      },\n    },\n  }\n);",
      "promote several hits": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"Promote-Apple-Newest\",\n  new Rule\n  {\n    ObjectID = \"Promote-Apple-Newest\",\n    Conditions = new List<Condition>\n    {\n      new Condition { Pattern = \"apple\", Anchoring = Enum.Parse<Anchoring>(\"Is\") },\n    },\n    Consequence = new Consequence\n    {\n      Promote = new List<Promote>\n      {\n        new Promote(\n          new PromoteObjectIDs\n          {\n            ObjectIDs = new List<string> { \"iPhone-12345\", \"watch-123\" },\n            Position = 0,\n          }\n        ),\n      },\n    },\n  }\n);",
      "promote newest release": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"Promote-iPhone-X\",\n  new Rule\n  {\n    ObjectID = \"Promote-iPhone-X\",\n    Conditions = new List<Condition>\n    {\n      new Condition { Pattern = \"iPhone\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n    },\n    Consequence = new Consequence\n    {\n      Promote = new List<Promote>\n      {\n        new Promote(new PromoteObjectID { ObjectID = \"iPhone-12345\", Position = 0 }),\n      },\n    },\n  }\n);",
      "promote single item": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"promote-harry-potter-box-set\",\n  new Rule\n  {\n    ObjectID = \"promote-harry-potter-box-set\",\n    Conditions = new List<Condition>\n    {\n      new Condition { Pattern = \"Harry Potter\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n    },\n    Consequence = new Consequence\n    {\n      Promote = new List<Promote>\n      {\n        new Promote(new PromoteObjectID { ObjectID = \"HP-12345\", Position = 0 }),\n      },\n    },\n  }\n);",
      "limit search results": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"article-rule\",\n  new Rule\n  {\n    ObjectID = \"article-rule\",\n    Conditions = new List<Condition>\n    {\n      new Condition { Pattern = \"article\", Anchoring = Enum.Parse<Anchoring>(\"StartsWith\") },\n    },\n    Consequence = new Consequence\n    {\n      Params = new ConsequenceParams\n      {\n        Query = new ConsequenceQuery(\n          new ConsequenceQueryObject\n          {\n            Edits = new List<Edit>\n            {\n              new Edit { Type = Enum.Parse<EditType>(\"Remove\"), Delete = \"article\" },\n            },\n          }\n        ),\n        RestrictSearchableAttributes = new List<string> { \"title\", \"book_id\" },\n      },\n    },\n  }\n);",
      "query match": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"tagged-brand-rule\",\n  new Rule\n  {\n    Conditions = new List<Condition>\n    {\n      new Condition\n      {\n        Pattern = \"brand: {facet:brand}\",\n        Anchoring = Enum.Parse<Anchoring>(\"Contains\"),\n        Alternatives = false,\n      },\n    },\n    Consequence = new Consequence\n    {\n      Params = new ConsequenceParams\n      {\n        AutomaticFacetFilters = new AutomaticFacetFilters(\n          new List<AutomaticFacetFilter> { new AutomaticFacetFilter { Facet = \"brand\" } }\n        ),\n        Query = new ConsequenceQuery(\n          new ConsequenceQueryObject\n          {\n            Remove = new List<string> { \"brand:\", \"{facet:brand}\" },\n          }\n        ),\n      },\n    },\n    Description = \"filter on brand: {brand}\",\n    ObjectID = \"tagged-brand-rule\",\n  }\n);",
      "dynamic filtering": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"color-facets\",\n  new Rule\n  {\n    ObjectID = \"color-facets\",\n    Conditions = new List<Condition> { new Condition { Pattern = \"{facet:color}\" } },\n    Consequence = new Consequence\n    {\n      Params = new ConsequenceParams\n      {\n        AutomaticFacetFilters = new AutomaticFacetFilters(\n          new List<AutomaticFacetFilter> { new AutomaticFacetFilter { Facet = \"color\" } }\n        ),\n      },\n    },\n  }\n);",
      "hide hits": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"hide-12345\",\n  new Rule\n  {\n    ObjectID = \"hide-12345\",\n    Conditions = new List<Condition>\n    {\n      new Condition { Pattern = \"cheap\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n    },\n    Consequence = new Consequence\n    {\n      Hide = new List<ConsequenceHide> { new ConsequenceHide { ObjectID = \"to-hide-12345\" } },\n    },\n  }\n);",
      "one rule per facet": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"red-color\",\n  new Rule\n  {\n    ObjectID = \"red-color\",\n    Conditions = new List<Condition>\n    {\n      new Condition { Pattern = \"red\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n    },\n    Consequence = new Consequence\n    {\n      Params = new ConsequenceParams\n      {\n        Query = new ConsequenceQuery(\n          new ConsequenceQueryObject { Remove = new List<string> { \"red\" } }\n        ),\n        Filters = \"color:red\",\n      },\n    },\n  }\n);",
      "numerical filters": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"cheap\",\n  new Rule\n  {\n    ObjectID = \"cheap\",\n    Conditions = new List<Condition>\n    {\n      new Condition { Pattern = \"cheap\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n    },\n    Consequence = new Consequence\n    {\n      Params = new ConsequenceParams\n      {\n        Query = new ConsequenceQuery(\n          new ConsequenceQueryObject { Remove = new List<string> { \"cheap\" } }\n        ),\n        Filters = \"price < 10\",\n      },\n    },\n  }\n);",
      "negative filters": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"gluten-free-rule\",\n  new Rule\n  {\n    ObjectID = \"gluten-free-rule\",\n    Conditions = new List<Condition>\n    {\n      new Condition { Pattern = \"gluten-free\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n    },\n    Consequence = new Consequence\n    {\n      Params = new ConsequenceParams\n      {\n        Filters = \"NOT allergens:gluten\",\n        Query = new ConsequenceQuery(\n          new ConsequenceQueryObject\n          {\n            Edits = new List<Edit>\n            {\n              new Edit { Type = Enum.Parse<EditType>(\"Remove\"), Delete = \"gluten-free\" },\n            },\n          }\n        ),\n      },\n    },\n  }\n);",
      "positive filters": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"diet-rule\",\n  new Rule\n  {\n    ObjectID = \"diet-rule\",\n    Conditions = new List<Condition>\n    {\n      new Condition { Pattern = \"diet\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n    },\n    Consequence = new Consequence\n    {\n      Params = new ConsequenceParams\n      {\n        Filters = \"'low-carb' OR 'low-fat'\",\n        Query = new ConsequenceQuery(\n          new ConsequenceQueryObject\n          {\n            Edits = new List<Edit>\n            {\n              new Edit { Type = Enum.Parse<EditType>(\"Remove\"), Delete = \"diet\" },\n            },\n          }\n        ),\n      },\n    },\n  }\n);",
      "conditionless": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"diet-rule\",\n  new Rule\n  {\n    ObjectID = \"diet-rule\",\n    Consequence = new Consequence\n    {\n      Params = new ConsequenceParams\n      {\n        Filters = \"'low-carb' OR 'low-fat'\",\n        Query = new ConsequenceQuery(\n          new ConsequenceQueryObject\n          {\n            Edits = new List<Edit>\n            {\n              new Edit { Type = Enum.Parse<EditType>(\"Remove\"), Delete = \"diet\" },\n            },\n          }\n        ),\n      },\n    },\n  }\n);",
      "contextual": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"a-rule-id\",\n  new Rule\n  {\n    ObjectID = \"a-rule-id\",\n    Conditions = new List<Condition> { new Condition { Context = \"mobile\" } },\n    Consequence = new Consequence\n    {\n      Params = new ConsequenceParams { Filters = \"release_date >= 1577836800\" },\n    },\n  }\n);",
      "saveRule always active rule": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"a-rule-id\",\n  new Rule\n  {\n    ObjectID = \"a-rule-id\",\n    Consequence = new Consequence\n    {\n      Params = new ConsequenceParams { AroundRadius = new AroundRadius(1000) },\n    },\n    Validity = new List<TimeRange>\n    {\n      new TimeRange { From = 1577836800L, Until = 1577836800L },\n    },\n  }\n);"
    },
    "saveRules": {
      "saveRules with minimal parameters": "var response = await client.SaveRulesAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Rule>\n  {\n    new Rule\n    {\n      ObjectID = \"a-rule-id\",\n      Conditions = new List<Condition>\n      {\n        new Condition { Pattern = \"smartphone\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n      },\n      Consequence = new Consequence\n      {\n        Params = new ConsequenceParams { Filters = \"brand:apple\" },\n      },\n    },\n    new Rule\n    {\n      ObjectID = \"a-second-rule-id\",\n      Conditions = new List<Condition>\n      {\n        new Condition { Pattern = \"apple\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n      },\n      Consequence = new Consequence\n      {\n        Params = new ConsequenceParams { Filters = \"brand:samsung\" },\n      },\n    },\n  },\n  false,\n  true\n);",
      "saveRules with all parameters": "var response = await client.SaveRulesAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Rule>\n  {\n    new Rule\n    {\n      ObjectID = \"id1\",\n      Conditions = new List<Condition>\n      {\n        new Condition\n        {\n          Pattern = \"apple\",\n          Anchoring = Enum.Parse<Anchoring>(\"Contains\"),\n          Alternatives = false,\n          Context = \"search\",\n        },\n      },\n      Consequence = new Consequence\n      {\n        Params = new ConsequenceParams\n        {\n          Filters = \"brand:apple\",\n          Query = new ConsequenceQuery(\n            new ConsequenceQueryObject\n            {\n              Remove = new List<string> { \"algolia\" },\n              Edits = new List<Edit>\n              {\n                new Edit\n                {\n                  Type = Enum.Parse<EditType>(\"Remove\"),\n                  Delete = \"abc\",\n                  Insert = \"cde\",\n                },\n                new Edit\n                {\n                  Type = Enum.Parse<EditType>(\"Replace\"),\n                  Delete = \"abc\",\n                  Insert = \"cde\",\n                },\n              },\n            }\n          ),\n        },\n        Hide = new List<ConsequenceHide> { new ConsequenceHide { ObjectID = \"321\" } },\n        FilterPromotes = false,\n        UserData = new Dictionary<string, string> { { \"algolia\", \"aloglia\" } },\n        Promote = new List<Promote>\n        {\n          new Promote(new PromoteObjectID { ObjectID = \"abc\", Position = 3 }),\n          new Promote(\n            new PromoteObjectIDs\n            {\n              ObjectIDs = new List<string> { \"abc\", \"def\" },\n              Position = 1,\n            }\n          ),\n        },\n      },\n      Description = \"test\",\n      Enabled = true,\n      Validity = new List<TimeRange>\n      {\n        new TimeRange { From = 1656670273L, Until = 1656670277L },\n      },\n    },\n  },\n  true,\n  true\n);",
      "dynamic filtering": "var response = await client.SaveRulesAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Rule>\n  {\n    new Rule\n    {\n      ObjectID = \"toaster\",\n      Conditions = new List<Condition>\n      {\n        new Condition { Pattern = \"toaster\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n      },\n      Consequence = new Consequence\n      {\n        Params = new ConsequenceParams\n        {\n          Query = new ConsequenceQuery(\n            new ConsequenceQueryObject { Remove = new List<string> { \"toaster\" } }\n          ),\n          Filters = \"product_type:toaster\",\n        },\n      },\n    },\n    new Rule\n    {\n      ObjectID = \"cheap\",\n      Conditions = new List<Condition>\n      {\n        new Condition { Pattern = \"cheap\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n      },\n      Consequence = new Consequence\n      {\n        Params = new ConsequenceParams\n        {\n          Query = new ConsequenceQuery(\n            new ConsequenceQueryObject { Remove = new List<string> { \"cheap\" } }\n          ),\n          Filters = \"price < 15\",\n        },\n      },\n    },\n  }\n);",
      "enhance search results": "var response = await client.SaveRulesAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Rule>\n  {\n    new Rule\n    {\n      ObjectID = \"country\",\n      Conditions = new List<Condition>\n      {\n        new Condition\n        {\n          Pattern = \"{facet:country}\",\n          Anchoring = Enum.Parse<Anchoring>(\"Contains\"),\n        },\n      },\n      Consequence = new Consequence\n      {\n        Params = new ConsequenceParams { AroundLatLngViaIP = false },\n      },\n    },\n    new Rule\n    {\n      ObjectID = \"city\",\n      Conditions = new List<Condition>\n      {\n        new Condition\n        {\n          Pattern = \"{facet:city}\",\n          Anchoring = Enum.Parse<Anchoring>(\"Contains\"),\n        },\n      },\n      Consequence = new Consequence\n      {\n        Params = new ConsequenceParams { AroundLatLngViaIP = false },\n      },\n    },\n  }\n);"
    },
    "saveSynonym": {
      "default": "var response = await client.SaveSynonymAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"id1\",\n  new SynonymHit\n  {\n    ObjectID = \"id1\",\n    Type = Enum.Parse<SynonymType>(\"Synonym\"),\n    Synonyms = new List<string> { \"car\", \"vehicule\", \"auto\" },\n  },\n  true\n);"
    },
    "saveSynonyms": {
      "default": "var response = await client.SaveSynonymsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<SynonymHit>\n  {\n    new SynonymHit\n    {\n      ObjectID = \"id1\",\n      Type = Enum.Parse<SynonymType>(\"Synonym\"),\n      Synonyms = new List<string> { \"car\", \"vehicule\", \"auto\" },\n    },\n    new SynonymHit\n    {\n      ObjectID = \"id2\",\n      Type = Enum.Parse<SynonymType>(\"Onewaysynonym\"),\n      Input = \"iphone\",\n      Synonyms = new List<string> { \"ephone\", \"aphone\", \"yphone\" },\n    },\n  },\n  true,\n  true\n);"
    },
    "search": {
      "withHitsPerPage": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Query = \"<YOUR_QUERY>\",\n          HitsPerPage = 50,\n        }\n      ),\n    },\n  }\n);",
      "filterOnly": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Query = \"<YOUR_QUERY>\",\n          Filters = \"actor:Scarlett Johansson\",\n        }\n      ),\n    },\n  }\n);",
      "filterOr": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Query = \"<YOUR_QUERY>\",\n          Filters = \"actor:Tom Cruise OR actor:Scarlett Johansson\",\n        }\n      ),\n    },\n  }\n);",
      "filterNot": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Query = \"<YOUR_QUERY>\",\n          Filters = \"NOT actor:Nicolas Cage\",\n        }\n      ),\n    },\n  }\n);",
      "search for a single hits request with minimal parameters": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(new SearchForHits { IndexName = \"<YOUR_INDEX_NAME>\" }),\n    },\n  }\n);",
      "search with highlight and snippet results": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Query = \"vim\",\n          AttributesToSnippet = new List<string> { \"*:20\" },\n          AttributesToHighlight = new List<string> { \"*\" },\n          AttributesToRetrieve = new List<string> { \"*\" },\n        }\n      ),\n    },\n  }\n);",
      "retrieveFacets": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Query = \"<YOUR_QUERY>\",\n          Facets = new List<string> { \"author\", \"genre\" },\n        }\n      ),\n    },\n  }\n);",
      "retrieveFacetsWildcard": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Query = \"<YOUR_QUERY>\",\n          Facets = new List<string> { \"*\" },\n        }\n      ),\n    },\n  }\n);",
      "search for a single facet request with minimal parameters": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForFacets\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Type = Enum.Parse<SearchTypeFacet>(\"Facet\"),\n          Facet = \"editor\",\n        }\n      ),\n    },\n    Strategy = Enum.Parse<SearchStrategy>(\"StopIfEnoughMatches\"),\n  }\n);",
      "search for a single hits request with all parameters": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Query = \"myQuery\",\n          HitsPerPage = 50,\n          Type = Enum.Parse<SearchTypeDefault>(\"Default\"),\n        }\n      ),\n    },\n  }\n);",
      "search for a single facet request with all parameters": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForFacets\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Type = Enum.Parse<SearchTypeFacet>(\"Facet\"),\n          Facet = \"theFacet\",\n          FacetQuery = \"theFacetQuery\",\n          Query = \"theQuery\",\n          MaxFacetHits = 50,\n        }\n      ),\n    },\n    Strategy = Enum.Parse<SearchStrategy>(\"StopIfEnoughMatches\"),\n  }\n);",
      "search for multiple mixed requests in multiple indices with minimal parameters": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(new SearchForHits { IndexName = \"<YOUR_INDEX_NAME>\" }),\n      new SearchQuery(\n        new SearchForFacets\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Type = Enum.Parse<SearchTypeFacet>(\"Facet\"),\n          Facet = \"theFacet\",\n        }\n      ),\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Type = Enum.Parse<SearchTypeDefault>(\"Default\"),\n        }\n      ),\n    },\n    Strategy = Enum.Parse<SearchStrategy>(\"StopIfEnoughMatches\"),\n  }\n);",
      "search for multiple mixed requests in multiple indices with all parameters": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForFacets\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Type = Enum.Parse<SearchTypeFacet>(\"Facet\"),\n          Facet = \"theFacet\",\n          FacetQuery = \"theFacetQuery\",\n          Query = \"theQuery\",\n          MaxFacetHits = 50,\n        }\n      ),\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Query = \"myQuery\",\n          HitsPerPage = 50,\n          Type = Enum.Parse<SearchTypeDefault>(\"Default\"),\n        }\n      ),\n    },\n    Strategy = Enum.Parse<SearchStrategy>(\"StopIfEnoughMatches\"),\n  }\n);",
      "search filters accept all of the possible shapes": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          FacetFilters = new FacetFilters(\"mySearch:filters\"),\n          ReRankingApplyFilter = new ReRankingApplyFilter(\"mySearch:filters\"),\n          TagFilters = new TagFilters(\"mySearch:filters\"),\n          NumericFilters = new NumericFilters(\"mySearch:filters\"),\n          OptionalFilters = new OptionalFilters(\"mySearch:filters\"),\n        }\n      ),\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          FacetFilters = new FacetFilters(\n            new List<FacetFilters>\n            {\n              new FacetFilters(\"mySearch:filters\"),\n              new FacetFilters(\n                new List<FacetFilters>\n                {\n                  new FacetFilters(\"mySearch:filters\"),\n                  new FacetFilters(\n                    new List<FacetFilters> { new FacetFilters(\"mySearch:filters\") }\n                  ),\n                }\n              ),\n            }\n          ),\n          ReRankingApplyFilter = new ReRankingApplyFilter(\n            new List<ReRankingApplyFilter>\n            {\n              new ReRankingApplyFilter(\"mySearch:filters\"),\n              new ReRankingApplyFilter(\n                new List<ReRankingApplyFilter> { new ReRankingApplyFilter(\"mySearch:filters\") }\n              ),\n            }\n          ),\n          TagFilters = new TagFilters(\n            new List<TagFilters>\n            {\n              new TagFilters(\"mySearch:filters\"),\n              new TagFilters(new List<TagFilters> { new TagFilters(\"mySearch:filters\") }),\n            }\n          ),\n          NumericFilters = new NumericFilters(\n            new List<NumericFilters>\n            {\n              new NumericFilters(\"mySearch:filters\"),\n              new NumericFilters(\n                new List<NumericFilters> { new NumericFilters(\"mySearch:filters\") }\n              ),\n            }\n          ),\n          OptionalFilters = new OptionalFilters(\n            new List<OptionalFilters>\n            {\n              new OptionalFilters(\"mySearch:filters\"),\n              new OptionalFilters(\n                new List<OptionalFilters> { new OptionalFilters(\"mySearch:filters\") }\n              ),\n            }\n          ),\n        }\n      ),\n    },\n  }\n);",
      "search filters end to end": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Filters = \"editor:'visual studio' OR editor:neovim\",\n        }\n      ),\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          FacetFilters = new FacetFilters(\n            new List<FacetFilters>\n            {\n              new FacetFilters(\"editor:'visual studio'\"),\n              new FacetFilters(\"editor:neovim\"),\n            }\n          ),\n        }\n      ),\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          FacetFilters = new FacetFilters(\n            new List<FacetFilters>\n            {\n              new FacetFilters(\"editor:'visual studio'\"),\n              new FacetFilters(new List<FacetFilters> { new FacetFilters(\"editor:neovim\") }),\n            }\n          ),\n        }\n      ),\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          FacetFilters = new FacetFilters(\n            new List<FacetFilters>\n            {\n              new FacetFilters(\"editor:'visual studio'\"),\n              new FacetFilters(\n                new List<FacetFilters>\n                {\n                  new FacetFilters(\"editor:neovim\"),\n                  new FacetFilters(\n                    new List<FacetFilters> { new FacetFilters(\"editor:goland\") }\n                  ),\n                }\n              ),\n            }\n          ),\n        }\n      ),\n    },\n  }\n);",
      "search with all search parameters": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          AdvancedSyntax = true,\n          AdvancedSyntaxFeatures = new List<AdvancedSyntaxFeatures>\n          {\n            Enum.Parse<AdvancedSyntaxFeatures>(\"ExactPhrase\"),\n          },\n          AllowTyposOnNumericTokens = true,\n          AlternativesAsExact = new List<AlternativesAsExact>\n          {\n            Enum.Parse<AlternativesAsExact>(\"MultiWordsSynonym\"),\n          },\n          Analytics = true,\n          AnalyticsTags = new List<string> { \"\" },\n          AroundLatLng = \"\",\n          AroundLatLngViaIP = true,\n          AroundPrecision = new AroundPrecision(0),\n          AroundRadius = new AroundRadius(Enum.Parse<AroundRadiusAll>(\"All\")),\n          AttributeCriteriaComputedByMinProximity = true,\n          AttributesToHighlight = new List<string> { \"\" },\n          AttributesToRetrieve = new List<string> { \"\" },\n          AttributesToSnippet = new List<string> { \"\" },\n          ClickAnalytics = true,\n          DecompoundQuery = true,\n          DisableExactOnAttributes = new List<string> { \"\" },\n          DisableTypoToleranceOnAttributes = new List<string> { \"\" },\n          Distinct = new Distinct(0),\n          EnableABTest = true,\n          EnablePersonalization = true,\n          EnableReRanking = true,\n          EnableRules = true,\n          ExactOnSingleWordQuery = Enum.Parse<ExactOnSingleWordQuery>(\"Attribute\"),\n          FacetFilters = new FacetFilters(new List<FacetFilters> { new FacetFilters(\"\") }),\n          FacetingAfterDistinct = true,\n          Facets = new List<string> { \"\" },\n          Filters = \"\",\n          GetRankingInfo = true,\n          HighlightPostTag = \"\",\n          HighlightPreTag = \"\",\n          HitsPerPage = 1,\n          IgnorePlurals = new IgnorePlurals(false),\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          InsideBoundingBox = new InsideBoundingBox(\n            new List<List<Double>>\n            {\n              new List<Double> { 47.3165, 4.9665, 47.3424, 5.0201 },\n              new List<Double> { 40.9234, 2.1185, 38.643, 1.9916 },\n            }\n          ),\n          InsidePolygon = new List<List<Double>>\n          {\n            new List<Double> { 47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9 },\n            new List<Double> { 40.9234, 2.1185, 38.643, 1.9916, 39.2587, 2.0104 },\n          },\n          Length = 1,\n          MaxValuesPerFacet = 0,\n          MinProximity = 1,\n          MinWordSizefor1Typo = 0,\n          MinWordSizefor2Typos = 0,\n          MinimumAroundRadius = 1,\n          NaturalLanguages = new List<SupportedLanguage>\n          {\n            Enum.Parse<SupportedLanguage>(\"Fr\"),\n          },\n          NumericFilters = new NumericFilters(\n            new List<NumericFilters> { new NumericFilters(\"\") }\n          ),\n          Offset = 0,\n          OptionalFilters = new OptionalFilters(\n            new List<OptionalFilters> { new OptionalFilters(\"\") }\n          ),\n          OptionalWords = new OptionalWords(new List<string> { \"\" }),\n          Page = 0,\n          PercentileComputation = true,\n          PersonalizationImpact = 0,\n          Query = \"\",\n          QueryLanguages = new List<SupportedLanguage> { Enum.Parse<SupportedLanguage>(\"Fr\") },\n          QueryType = Enum.Parse<QueryType>(\"PrefixAll\"),\n          Ranking = new List<string> { \"\" },\n          ReRankingApplyFilter = new ReRankingApplyFilter(\n            new List<ReRankingApplyFilter> { new ReRankingApplyFilter(\"\") }\n          ),\n          RelevancyStrictness = 0,\n          RemoveStopWords = new RemoveStopWords(true),\n          RemoveWordsIfNoResults = Enum.Parse<RemoveWordsIfNoResults>(\"AllOptional\"),\n          RenderingContent = new RenderingContent\n          {\n            FacetOrdering = new FacetOrdering\n            {\n              Facets = new Facets\n              {\n                Order = new List<string> { \"a\", \"b\" },\n              },\n              Values = new Dictionary<string, Value>\n              {\n                {\n                  \"a\",\n                  new Value\n                  {\n                    Order = new List<string> { \"b\" },\n                    SortRemainingBy = Enum.Parse<SortRemainingBy>(\"Count\"),\n                  }\n                },\n              },\n            },\n          },\n          ReplaceSynonymsInHighlight = true,\n          ResponseFields = new List<string> { \"\" },\n          RestrictHighlightAndSnippetArrays = true,\n          RestrictSearchableAttributes = new List<string> { \"\" },\n          RuleContexts = new List<string> { \"\" },\n          SimilarQuery = \"\",\n          SnippetEllipsisText = \"\",\n          SortFacetValuesBy = \"\",\n          SumOrFiltersScores = true,\n          Synonyms = true,\n          TagFilters = new TagFilters(new List<TagFilters> { new TagFilters(\"\") }),\n          Type = Enum.Parse<SearchTypeDefault>(\"Default\"),\n          TypoTolerance = new TypoTolerance(Enum.Parse<TypoToleranceEnum>(\"Min\")),\n          UserToken = \"\",\n        }\n      ),\n    },\n  }\n);"
    },
    "searchDictionaryEntries": {
      "get searchDictionaryEntries results with minimal parameters": "var response = await client.SearchDictionaryEntriesAsync(\n  Enum.Parse<DictionaryType>(\"Stopwords\"),\n  new SearchDictionaryEntriesParams { Query = \"about\" }\n);",
      "get searchDictionaryEntries results with all parameters": "var response = await client.SearchDictionaryEntriesAsync(\n  Enum.Parse<DictionaryType>(\"Compounds\"),\n  new SearchDictionaryEntriesParams\n  {\n    Query = \"foo\",\n    Page = 4,\n    HitsPerPage = 2,\n    Language = Enum.Parse<SupportedLanguage>(\"Fr\"),\n  }\n);"
    },
    "searchForFacetValues": {
      "get searchForFacetValues results with minimal parameters": "var response = await client.SearchForFacetValuesAsync(\"<YOUR_INDEX_NAME>\", \"facetName\");",
      "get searchForFacetValues results with all parameters": "var response = await client.SearchForFacetValuesAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"facetName\",\n  new SearchForFacetValuesRequest\n  {\n    Params = \"query=foo&facetFilters=['bar']\",\n    FacetQuery = \"foo\",\n    MaxFacetHits = 42,\n  }\n);",
      "facetName and facetQuery": "var response = await client.SearchForFacetValuesAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"author\",\n  new SearchForFacetValuesRequest { FacetQuery = \"stephen\" }\n);"
    },
    "searchRules": {
      "default": "var response = await client.SearchRulesAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchRulesParams { Query = \"zorro\" }\n);"
    },
    "searchSingleIndex": {
      "search with minimal parameters": "var response = await client.SearchSingleIndexAsync<Hit>(\"<YOUR_INDEX_NAME>\");",
      "search with special characters in indexName": "var response = await client.SearchSingleIndexAsync<Hit>(\"<YOUR_INDEX_NAME>\");",
      "search with searchParams": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"myQuery\",\n      FacetFilters = new FacetFilters(\n        new List<FacetFilters> { new FacetFilters(\"tags:algolia\") }\n      ),\n    }\n  )\n);",
      "single search retrieve snippets": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"batman mask of the phantasm\",\n      AttributesToRetrieve = new List<string> { \"*\" },\n      AttributesToSnippet = new List<string> { \"*:20\" },\n    }\n  )\n);",
      "query": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"phone\" })\n);",
      "filters": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Filters = \"country:US AND price.gross < 2.0\" })\n);",
      "filters for stores": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"ben\",\n      Filters = \"categories:politics AND store:Gibert Joseph Saint-Michel\",\n    }\n  )\n);",
      "filters boolean": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Filters = \"is_available:true\" })\n);",
      "distinct": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Distinct = new Distinct(true) })\n);",
      "filtersNumeric": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Filters = \"price < 10\" })\n);",
      "filtersTimestamp": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject { Filters = \"NOT date_timestamp:1514764800 TO 1546300799\" }\n  )\n);",
      "filtersSumOrFiltersScoresFalse": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Filters =\n        \"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\",\n      SumOrFiltersScores = false,\n    }\n  )\n);",
      "filtersSumOrFiltersScoresTrue": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Filters =\n        \"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\",\n      SumOrFiltersScores = true,\n    }\n  )\n);",
      "filtersStephenKing": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Filters = \"author:\\\"Stephen King\\\"\" })\n);",
      "filtersNotTags": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"harry\", Filters = \"_tags:non-fiction\" })\n);",
      "facetFiltersList": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      FacetFilters = new FacetFilters(\n        new List<FacetFilters>\n        {\n          new FacetFilters(\"publisher:Penguin\"),\n          new FacetFilters(\n            new List<FacetFilters>\n            {\n              new FacetFilters(\"author:Stephen King\"),\n              new FacetFilters(\"genre:Horror\"),\n            }\n          ),\n        }\n      ),\n    }\n  )\n);",
      "facetFiltersBook": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      FacetFilters = new FacetFilters(\n        new List<FacetFilters> { new FacetFilters(\"category:Book\") }\n      ),\n    }\n  )\n);",
      "facetFiltersAND": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      FacetFilters = new FacetFilters(\n        new List<FacetFilters>\n        {\n          new FacetFilters(\"category:Book\"),\n          new FacetFilters(\"author:John Doe\"),\n        }\n      ),\n    }\n  )\n);",
      "facetFiltersOR": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      FacetFilters = new FacetFilters(\n        new List<FacetFilters>\n        {\n          new FacetFilters(\n            new List<FacetFilters>\n            {\n              new FacetFilters(\"category:Book\"),\n              new FacetFilters(\"author:John Doe\"),\n            }\n          ),\n        }\n      ),\n    }\n  )\n);",
      "facetFiltersCombined": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      FacetFilters = new FacetFilters(\n        new List<FacetFilters>\n        {\n          new FacetFilters(\"author:John Doe\"),\n          new FacetFilters(\n            new List<FacetFilters>\n            {\n              new FacetFilters(\"category:Book\"),\n              new FacetFilters(\"category:Movie\"),\n            }\n          ),\n        }\n      ),\n    }\n  )\n);",
      "facetFiltersNeg": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject { FacetFilters = new FacetFilters(\"category:-Ebook\") }\n  )\n);",
      "filtersAndFacetFilters": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Filters = \"(author:\\\"Stephen King\\\" OR genre:\\\"Horror\\\")\",\n      FacetFilters = new FacetFilters(\n        new List<FacetFilters> { new FacetFilters(\"publisher:Penguin\") }\n      ),\n    }\n  )\n);",
      "facet author genre": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Facets = new List<string> { \"author\", \"genre\" },\n    }\n  )\n);",
      "facet wildcard": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Facets = new List<string> { \"*\" } })\n);",
      "maxValuesPerFacet": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { MaxValuesPerFacet = 1000 })\n);",
      "aroundLatLng": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { AroundLatLng = \"40.71, -74.01\" })\n);",
      "aroundLatLngViaIP": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { AroundLatLngViaIP = true })\n);",
      "aroundRadius": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      AroundLatLng = \"40.71, -74.01\",\n      AroundRadius = new AroundRadius(1000000),\n    }\n  )\n);",
      "insideBoundingBox": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      InsideBoundingBox = new InsideBoundingBox(\n        new List<List<Double>>\n        {\n          new List<Double> { 49.067996905313834, 65.73828125, 25.905859247243498, 128.8046875 },\n        }\n      ),\n    }\n  )\n);",
      "insidePolygon": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      InsidePolygon = new List<List<Double>>\n      {\n        new List<Double>\n        {\n          42.01,\n          -124.31,\n          48.835509470063045,\n          -124.40453125000005,\n          45.01082951668149,\n          -65.95726562500005,\n          31.247243545293433,\n          -81.06578125000004,\n          25.924152577235226,\n          -97.68234374999997,\n          32.300311895879545,\n          -117.54828125,\n        },\n      },\n    }\n  )\n);",
      "optionalFilters": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      OptionalFilters = new OptionalFilters(\n        new List<OptionalFilters> { new OptionalFilters(\"can_deliver_quickly:true\") }\n      ),\n    }\n  )\n);",
      "optionalFiltersMany": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      OptionalFilters = new OptionalFilters(\n        new List<OptionalFilters>\n        {\n          new OptionalFilters(\"brand:Apple<score=3>\"),\n          new OptionalFilters(\"brand:Samsung<score=2>\"),\n          new OptionalFilters(\"brand:-Huawei\"),\n        }\n      ),\n    }\n  )\n);",
      "optionalFiltersSimple": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      OptionalFilters = new OptionalFilters(\n        new List<OptionalFilters>\n        {\n          new OptionalFilters(\"brand:Apple<score=2>\"),\n          new OptionalFilters(\"type:tablet\"),\n        }\n      ),\n    }\n  )\n);",
      "restrictSearchableAttributes": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject { RestrictSearchableAttributes = new List<string> { \"title_fr\" } }\n  )\n);",
      "getRankingInfo": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { GetRankingInfo = true })\n);",
      "clickAnalytics": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { ClickAnalytics = true })\n);",
      "clickAnalyticsUserToken": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { ClickAnalytics = true, UserToken = \"user-1\" })\n);",
      "enablePersonalization": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject { EnablePersonalization = true, UserToken = \"user-1\" }\n  )\n);",
      "userToken": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { UserToken = \"user-1\" })\n);",
      "userToken1234": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", UserToken = \"user-1234\" })\n);",
      "analyticsTag": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject { AnalyticsTags = new List<string> { \"YOUR_ANALYTICS_TAG\" } }\n  )\n);",
      "facetFiltersUsers": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      FacetFilters = new FacetFilters(\n        new List<FacetFilters>\n        {\n          new FacetFilters(\"user:user42\"),\n          new FacetFilters(\"user:public\"),\n        }\n      ),\n    }\n  )\n);",
      "buildTheQuery": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Filters = \"categoryPageId: Men's Clothing\",\n      HitsPerPage = 50,\n      AnalyticsTags = new List<string> { \"mens-clothing\" },\n    }\n  )\n);",
      "attributesToHighlightOverride": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      AttributesToHighlight = new List<string> { \"title\", \"content\" },\n    }\n  )\n);",
      "disableTypoToleranceOnAttributes": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      DisableTypoToleranceOnAttributes = new List<string> { \"serial_number\" },\n    }\n  )\n);",
      "search_a_query": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"\",\n      SimilarQuery = \"Comedy Drama Crime McDormand Macy Buscemi Stormare Presnell Coen\",\n      Filters = \"year:1991 TO 2001\",\n    }\n  )\n);",
      "search_everything": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"\" })\n);",
      "api_filtering_range_example": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"books\", Filters = \"price:10 TO 20\" })\n);",
      "override_retrievable_attributes": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      AttributesToRetrieve = new List<string> { \"title\", \"content\" },\n    }\n  )\n);",
      "restrict_searchable_attributes": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      RestrictSearchableAttributes = new List<string> { \"title\", \"author\" },\n    }\n  )\n);",
      "override_default_relevancy": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", RelevancyStrictness = 70 })\n);",
      "apply_filters": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", SumOrFiltersScores = true })\n);",
      "apply_all_filters": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      Filters =\n        \"available = 1 AND (category:Book OR NOT category:Ebook) AND _tags:published AND publication_date:1441745506 TO 1441755506 AND inStock > 0 AND author:\\\"John Doe\\\"\",\n    }\n  )\n);",
      "escape_spaces": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject { Query = \"query\", Filters = \"category:\\\"Books and Comics\\\"\" }\n  )\n);",
      "escape_keywords": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", Filters = \"keyword:\\\"OR\\\"\" })\n);",
      "escape_single_quotes": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject { Query = \"query\", Filters = \"content:\\\"It's a wonderful day\\\"\" }\n  )\n);",
      "escape_double_quotes": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject { Query = \"query\", Filters = \"content:\\\"She said \\\"Hello World\\\"\" }\n  )\n);",
      "apply_negative_filters": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      OptionalFilters = new OptionalFilters(\n        new List<OptionalFilters>\n        {\n          new OptionalFilters(\"category:Book\"),\n          new OptionalFilters(\"author:-John Doe\"),\n        }\n      ),\n    }\n  )\n);",
      "apply_negative_filters_restaurants": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      OptionalFilters = new OptionalFilters(\n        new List<OptionalFilters> { new OptionalFilters(\"restaurant:-Bert's Inn\") }\n      ),\n    }\n  )\n);",
      "apply_numeric_filters": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      NumericFilters = new NumericFilters(\n        new List<NumericFilters>\n        {\n          new NumericFilters(\"price < 1000\"),\n          new NumericFilters(\n            new List<NumericFilters>\n            {\n              new NumericFilters(\"inStock = 1\"),\n              new NumericFilters(\"deliveryDate < 1441755506\"),\n            }\n          ),\n        }\n      ),\n    }\n  )\n);",
      "apply_tag_filters": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      TagFilters = new TagFilters(\n        new List<TagFilters>\n        {\n          new TagFilters(\"SciFi\"),\n          new TagFilters(\n            new List<TagFilters> { new TagFilters(\"Book\"), new TagFilters(\"Movie\") }\n          ),\n        }\n      ),\n    }\n  )\n);",
      "facets_all": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      Facets = new List<string> { \"*\" },\n    }\n  )\n);",
      "retrieve_only_some_facets": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      Facets = new List<string> { \"category\", \"author\" },\n    }\n  )\n);",
      "override_default_max_values_per_facet": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", MaxValuesPerFacet = 20 })\n);",
      "enable_faceting_after_distinct": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", FacetingAfterDistinct = true })\n);",
      "sort_facet_values_alphabetically": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", SortFacetValuesBy = \"count\" })\n);",
      "override_attributes_to_snippet": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      AttributesToSnippet = new List<string> { \"title\", \"content:80\" },\n    }\n  )\n);",
      "override_default_highlight_pre_tag": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", HighlightPreTag = \"<strong>\" })\n);",
      "override_default_highlight_post_tag": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", HighlightPostTag = \"</strong>\" })\n);",
      "override_default_snippet_ellipsis_text": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", SnippetEllipsisText = \"\" })\n);",
      "enable_restrict_highlight_and_snippet_arrays": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject { Query = \"query\", RestrictHighlightAndSnippetArrays = false }\n  )\n);",
      "access_page": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", Page = 0 })\n);",
      "override_default_hits_per_page": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", HitsPerPage = 10 })\n);",
      "get_nth_hit": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", Offset = 4 })\n);",
      "get_n_results": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", Length = 4 })\n);",
      "override_default_min_word_size_for_one_typo": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", MinWordSizefor1Typo = 2 })\n);",
      "override_default_min_word_size_for_two_typos": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", MinWordSizefor2Typos = 2 })\n);",
      "override_default_typo_tolerance_mode": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject { Query = \"query\", TypoTolerance = new TypoTolerance(false) }\n  )\n);",
      "disable_typos_on_numeric_tokens_at_search_time": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject { Query = \"query\", AllowTyposOnNumericTokens = false }\n  )\n);",
      "search_around_a_position": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", AroundLatLng = \"40.71, -74.01\" })\n);",
      "search_around_server_ip": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", AroundLatLngViaIP = true }),\n  new RequestOptionBuilder()\n    .AddExtraHeader(\n      \"x-forwarded-for\",\n      \"94.228.178.246 // should be replaced with the actual IP you would like to search around\"\n    )\n    .Build()\n);",
      "set_around_radius": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject { Query = \"query\", AroundRadius = new AroundRadius(1000) }\n  )\n);",
      "disable_automatic_radius": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      AroundRadius = new AroundRadius(Enum.Parse<AroundRadiusAll>(\"All\")),\n    }\n  )\n);",
      "set_geo_search_precision": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject { Query = \"query\", AroundPrecision = new AroundPrecision(100) }\n  )\n);",
      "set_geo_search_precision_non_linear": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      AroundPrecision = new AroundPrecision(\n        new List<Range>\n        {\n          new Range { From = 0, Value = 25 },\n          new Range { From = 2000, Value = 1000 },\n        }\n      ),\n    }\n  )\n);",
      "set_minimum_geo_search_radius": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", MinimumAroundRadius = 1000 })\n);",
      "search_inside_rectangular_area": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      InsideBoundingBox = new InsideBoundingBox(\n        new List<List<Double>>\n        {\n          new List<Double> { 46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625 },\n        }\n      ),\n    }\n  )\n);",
      "search_inside_multiple_rectangular_areas": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      InsideBoundingBox = new InsideBoundingBox(\n        new List<List<Double>>\n        {\n          new List<Double> { 46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625 },\n          new List<Double> { 49.62625916704081, 4.6181640625, 47.715070300900194, 0.482421875 },\n        }\n      ),\n    }\n  )\n);",
      "search_inside_polygon_area": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      InsidePolygon = new List<List<Double>>\n      {\n        new List<Double>\n        {\n          46.650828100116044,\n          7.123046875,\n          45.17210966999772,\n          1.009765625,\n          49.62625916704081,\n          4.6181640625,\n        },\n      },\n    }\n  )\n);",
      "search_inside_multiple_polygon_areas": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      InsidePolygon = new List<List<Double>>\n      {\n        new List<Double>\n        {\n          46.650828100116044,\n          7.123046875,\n          45.17210966999772,\n          1.009765625,\n          49.62625916704081,\n          4.6181640625,\n        },\n        new List<Double>\n        {\n          49.62625916704081,\n          4.6181640625,\n          47.715070300900194,\n          0.482421875,\n          45.17210966999772,\n          1.009765625,\n          50.62626704081,\n          4.6181640625,\n        },\n      },\n    }\n  )\n);",
      "set_querylanguages_override": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      RemoveStopWords = new RemoveStopWords(\n        new List<SupportedLanguage>\n        {\n          Enum.Parse<SupportedLanguage>(\"Ca\"),\n          Enum.Parse<SupportedLanguage>(\"Es\"),\n        }\n      ),\n    }\n  )\n);",
      "set_querylanguages_with_japanese_query": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      QueryLanguages = new List<SupportedLanguage>\n      {\n        Enum.Parse<SupportedLanguage>(\"Ja\"),\n        Enum.Parse<SupportedLanguage>(\"En\"),\n      },\n    }\n  )\n);",
      "set_natural_languages": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"\",\n      NaturalLanguages = new List<SupportedLanguage> { Enum.Parse<SupportedLanguage>(\"Fr\") },\n    }\n  )\n);",
      "override_natural_languages_with_query": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"\",\n      NaturalLanguages = new List<SupportedLanguage> { Enum.Parse<SupportedLanguage>(\"Fr\") },\n      RemoveWordsIfNoResults = Enum.Parse<RemoveWordsIfNoResults>(\"FirstWords\"),\n    }\n  )\n);",
      "enable_decompound_query_search_time": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", DecompoundQuery = true })\n);",
      "enable_rules_search_time": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", EnableRules = true })\n);",
      "set_rule_contexts": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      RuleContexts = new List<string> { \"front_end\", \"website2\" },\n    }\n  )\n);",
      "enable_personalization": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", EnablePersonalization = true })\n);",
      "enable_personalization_with_user_token": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      EnablePersonalization = true,\n      UserToken = \"123456\",\n    }\n  )\n);",
      "personalization_impact": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", PersonalizationImpact = 20 })\n);",
      "set_user_token": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", UserToken = \"123456\" })\n);",
      "set_user_token_with_personalization": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      EnablePersonalization = true,\n      UserToken = \"123456\",\n    }\n  )\n);",
      "override_default_query_type": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject { Query = \"query\", QueryType = Enum.Parse<QueryType>(\"PrefixAll\") }\n  )\n);",
      "override_default_remove_words_if_no_results": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      RemoveWordsIfNoResults = Enum.Parse<RemoveWordsIfNoResults>(\"LastWords\"),\n    }\n  )\n);",
      "enable_advanced_syntax_search_time": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", AdvancedSyntax = true })\n);",
      "overide_default_optional_words": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      OptionalWords = new OptionalWords(new List<string> { \"toyota\", \"2020 2021\" }),\n    }\n  )\n);",
      "disabling_exact_for_some_attributes_search_time": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      DisableExactOnAttributes = new List<string> { \"description\" },\n    }\n  )\n);",
      "override_default_exact_single_word_query": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      ExactOnSingleWordQuery = Enum.Parse<ExactOnSingleWordQuery>(\"None\"),\n    }\n  )\n);",
      "override_default_aternative_as_exact": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      AlternativesAsExact = new List<AlternativesAsExact>\n      {\n        Enum.Parse<AlternativesAsExact>(\"MultiWordsSynonym\"),\n      },\n    }\n  )\n);",
      "enable_advanced_syntax_exact_phrase": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      AdvancedSyntax = true,\n      AdvancedSyntaxFeatures = new List<AdvancedSyntaxFeatures>\n      {\n        Enum.Parse<AdvancedSyntaxFeatures>(\"ExactPhrase\"),\n      },\n    }\n  )\n);",
      "enable_advanced_syntax_exclude_words": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      AdvancedSyntax = true,\n      AdvancedSyntaxFeatures = new List<AdvancedSyntaxFeatures>\n      {\n        Enum.Parse<AdvancedSyntaxFeatures>(\"ExcludeWords\"),\n      },\n    }\n  )\n);",
      "override_distinct": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", Distinct = new Distinct(0) })\n);",
      "get_ranking_info": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", GetRankingInfo = true })\n);",
      "disable_click_analytics": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", ClickAnalytics = false })\n);",
      "enable_click_analytics": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", ClickAnalytics = true })\n);",
      "disable_analytics": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", Analytics = false })\n);",
      "add_analytics_tags": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      AnalyticsTags = new List<string> { \"front_end\", \"website2\" },\n    }\n  )\n);",
      "disable_synonyms": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", Synonyms = false })\n);",
      "override_replace_synonyms_in_highlights": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject { Query = \"query\", ReplaceSynonymsInHighlight = true }\n  )\n);",
      "override_min_proximity": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", MinProximity = 2 })\n);",
      "override_default_field": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(\n    new SearchParamsObject\n    {\n      Query = \"query\",\n      ResponseFields = new List<string> { \"hits\", \"facets\" },\n    }\n  )\n);",
      "override_percentile_computation": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", PercentileComputation = false })\n);",
      "set_ab_test": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", EnableABTest = false })\n);",
      "set_enable_re_ranking": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\", EnableReRanking = false })\n);",
      "with algolia user id": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"query\" }),\n  new RequestOptionBuilder().AddExtraHeader(\"X-Algolia-User-ID\", \"user1234\").Build()\n);",
      "mcm with algolia user id": "var response = await client.SearchSingleIndexAsync<Hit>(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParams(new SearchParamsObject { Query = \"peace\" }),\n  new RequestOptionBuilder().AddExtraHeader(\"X-Algolia-User-ID\", \"user42\").Build()\n);"
    },
    "searchSynonyms": {
      "searchSynonyms with minimal parameters": "var response = await client.SearchSynonymsAsync(\"<YOUR_INDEX_NAME>\");",
      "searchSynonyms with all parameters": "var response = await client.SearchSynonymsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchSynonymsParams\n  {\n    Query = \"myQuery\",\n    Type = Enum.Parse<SynonymType>(\"Altcorrection1\"),\n    Page = 10,\n    HitsPerPage = 10,\n  }\n);"
    },
    "searchUserIds": {
      "default": "var response = await client.SearchUserIdsAsync(\n  new SearchUserIdsParams\n  {\n    Query = \"test\",\n    ClusterName = \"theClusterName\",\n    Page = 5,\n    HitsPerPage = 10,\n  }\n);"
    },
    "setClientApiKey": {
      "default": "client.SetClientApiKey(\"updated-api-key\");"
    },
    "setDictionarySettings": {
      "get setDictionarySettings results with minimal parameters": "var response = await client.SetDictionarySettingsAsync(\n  new DictionarySettingsParams\n  {\n    DisableStandardEntries = new StandardEntries\n    {\n      Plurals = new Dictionary<string, Boolean>\n      {\n        { \"fr\", false },\n        { \"en\", false },\n        { \"ru\", true },\n      },\n    },\n  }\n);",
      "get setDictionarySettings results with all parameters": "var response = await client.SetDictionarySettingsAsync(\n  new DictionarySettingsParams\n  {\n    DisableStandardEntries = new StandardEntries\n    {\n      Plurals = new Dictionary<string, Boolean>\n      {\n        { \"fr\", false },\n        { \"en\", false },\n        { \"ru\", true },\n      },\n      Stopwords = new Dictionary<string, Boolean> { { \"fr\", false } },\n      Compounds = new Dictionary<string, Boolean> { { \"ru\", true } },\n    },\n  }\n);"
    },
    "setSettings": {
      "minimal parameters": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { PaginationLimitedTo = 10 },\n  true\n);",
      "boolean typoTolerance": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { TypoTolerance = new TypoTolerance(true) },\n  true\n);",
      "enum typoTolerance": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { TypoTolerance = new TypoTolerance(Enum.Parse<TypoToleranceEnum>(\"Min\")) },\n  true\n);",
      "ignorePlurals": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { IgnorePlurals = new IgnorePlurals(true) },\n  true\n);",
      "list of string ignorePlurals": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    IgnorePlurals = new IgnorePlurals(\n      new List<SupportedLanguage> { Enum.Parse<SupportedLanguage>(\"Fr\") }\n    ),\n  },\n  true\n);",
      "removeStopWords boolean": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { RemoveStopWords = new RemoveStopWords(true) },\n  true\n);",
      "removeStopWords list of string": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    RemoveStopWords = new RemoveStopWords(\n      new List<SupportedLanguage> { Enum.Parse<SupportedLanguage>(\"Fr\") }\n    ),\n  },\n  true\n);",
      "boolean distinct": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { Distinct = new Distinct(true) },\n  true\n);",
      "integer distinct": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { Distinct = new Distinct(1) },\n  true\n);",
      "distinct company": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { AttributeForDistinct = \"company\", Distinct = new Distinct(true) }\n);",
      "distinct design": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { AttributeForDistinct = \"design\", Distinct = new Distinct(true) }\n);",
      "distinct true": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { Distinct = new Distinct(true) }\n);",
      "distinct section": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { AttributeForDistinct = \"section\", Distinct = new Distinct(true) }\n);",
      "attributesForFaceting allergens": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { AttributesForFaceting = new List<string> { \"allergens\" } }\n);",
      "attributesForFaceting availableIn": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    AttributesForFaceting = new List<string> { \"color\", \"availableIn\" },\n  }\n);",
      "api_attributes_for_faceting": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    AttributesForFaceting = new List<string> { \"genre\", \"author\" },\n  }\n);",
      "api_attributes_for_faceting_searchable": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    AttributesForFaceting = new List<string> { \"genre\", \"searchable(author)\" },\n  }\n);",
      "api_attributes_for_filter_only": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    AttributesForFaceting = new List<string> { \"filterOnly(genre)\", \"author\" },\n  }\n);",
      "attributesForFaceting categoryPageId": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    AttributesForFaceting = new List<string> { \"searchable(categoryPageId)\" },\n  }\n);",
      "unretrievableAttributes": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { UnretrievableAttributes = new List<string> { \"visible_by\" } }\n);",
      "attributesForFaceting user restricted data": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { AttributesForFaceting = new List<string> { \"filterOnly(visible_by)\" } }\n);",
      "attributesForFaceting optional filters": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    AttributesForFaceting = new List<string> { \"can_deliver_quickly\", \"restaurant\" },\n  }\n);",
      "attributesForFaceting redirect index": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { AttributesForFaceting = new List<string> { \"query_terms\" } }\n);",
      "attributesForFaceting multiple consequences": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { AttributesForFaceting = new List<string> { \"director\" } }\n);",
      "attributesForFaceting in-depth optional filters": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { AttributesForFaceting = new List<string> { \"filterOnly(brand)\" } }\n);",
      "mode neuralSearch": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { Mode = Enum.Parse<Mode>(\"NeuralSearch\") }\n);",
      "mode keywordSearch": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { Mode = Enum.Parse<Mode>(\"KeywordSearch\") }\n);",
      "searchableAttributes same priority": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    SearchableAttributes = new List<string> { \"title,comments\", \"ingredients\" },\n  }\n);",
      "searchableAttributes higher priority": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    SearchableAttributes = new List<string> { \"title\", \"ingredients\" },\n  }\n);",
      "customRanking retweets": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    CustomRanking = new List<string> { \"desc(retweets)\", \"desc(likes)\" },\n  }\n);",
      "customRanking boosted": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { CustomRanking = new List<string> { \"desc(boosted)\" } }\n);",
      "customRanking pageviews": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    CustomRanking = new List<string> { \"desc(pageviews)\", \"desc(comments)\" },\n  }\n);",
      "customRanking applying search parameters for a specific query": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    CustomRanking = new List<string> { \"desc(nb_airline_liaisons)\" },\n    AttributesForFaceting = new List<string> { \"city, country\" },\n  }\n);",
      "customRanking rounded pageviews": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    CustomRanking = new List<string> { \"desc(rounded_pageviews)\", \"desc(comments)\" },\n  }\n);",
      "customRanking price": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { CustomRanking = new List<string> { \"desc(price)\" } }\n);",
      "ranking exhaustive (price)": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    Ranking = new List<string>\n    {\n      \"desc(price)\",\n      \"typo\",\n      \"geo\",\n      \"words\",\n      \"filters\",\n      \"proximity\",\n      \"attribute\",\n      \"exact\",\n      \"custom\",\n    },\n  }\n);",
      "ranking exhaustive (is_popular)": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    Ranking = new List<string>\n    {\n      \"desc(is_popular)\",\n      \"typo\",\n      \"geo\",\n      \"words\",\n      \"filters\",\n      \"proximity\",\n      \"attribute\",\n      \"exact\",\n      \"custom\",\n    },\n  }\n);",
      "ranking standard replica": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { Ranking = new List<string> { \"desc(post_date_timestamp)\" } }\n);",
      "ranking virtual replica": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { CustomRanking = new List<string> { \"desc(post_date_timestamp)\" } }\n);",
      "customRanking and ranking sort alphabetically": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    CustomRanking = new List<string> { \"asc(textual_attribute)\" },\n    Ranking = new List<string>\n    {\n      \"custom\",\n      \"typo\",\n      \"geo\",\n      \"words\",\n      \"filters\",\n      \"proximity\",\n      \"attribute\",\n      \"exact\",\n    },\n  }\n);",
      "relevancyStrictness": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    CustomRanking = new List<string> { \"asc(textual_attribute)\" },\n    RelevancyStrictness = 0,\n  }\n);",
      "create replica index": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { Replicas = new List<string> { \"products_price_desc\" } }\n);",
      "create replica index articles": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { Replicas = new List<string> { \"articles_date_desc\" } }\n);",
      "create virtual replica index": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { Replicas = new List<string> { \"virtual(products_price_desc)\" } }\n);",
      "unlink replica index": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { Replicas = new List<string> { \"\" } }\n);",
      "forwardToReplicas": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    SearchableAttributes = new List<string> { \"name\", \"description\" },\n  },\n  true\n);",
      "maxValuesPerFacet": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { MaxValuesPerFacet = 1000 }\n);",
      "maxFacetHits": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { MaxFacetHits = 100 }\n);",
      "attributesForFaceting complex": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    AttributesForFaceting = new List<string>\n    {\n      \"actor\",\n      \"filterOnly(category)\",\n      \"searchable(publisher)\",\n    },\n  }\n);",
      "ranking closest dates": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    Ranking = new List<string>\n    {\n      \"asc(date_timestamp)\",\n      \"typo\",\n      \"geo\",\n      \"words\",\n      \"filters\",\n      \"proximity\",\n      \"attribute\",\n      \"exact\",\n      \"custom\",\n    },\n  }\n);",
      "searchableAttributes item variation": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    SearchableAttributes = new List<string> { \"design\", \"type\", \"color\" },\n  }\n);",
      "searchableAttributes around location": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    SearchableAttributes = new List<string> { \"name\", \"country\", \"city\", \"iata_code\" },\n    CustomRanking = new List<string> { \"desc(links_count)\" },\n  }\n);",
      "attributesToHighlight": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    AttributesToHighlight = new List<string> { \"author\", \"title\", \"content\" },\n  }\n);",
      "attributesToHighlightStar": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { AttributesToHighlight = new List<string> { \"*\" } }\n);",
      "everything": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    AdvancedSyntax = true,\n    AdvancedSyntaxFeatures = new List<AdvancedSyntaxFeatures>\n    {\n      Enum.Parse<AdvancedSyntaxFeatures>(\"ExactPhrase\"),\n    },\n    AllowCompressionOfIntegerArray = true,\n    AllowTyposOnNumericTokens = true,\n    AlternativesAsExact = new List<AlternativesAsExact>\n    {\n      Enum.Parse<AlternativesAsExact>(\"SingleWordSynonym\"),\n    },\n    AttributeCriteriaComputedByMinProximity = true,\n    AttributeForDistinct = \"test\",\n    AttributesForFaceting = new List<string> { \"algolia\" },\n    AttributesToHighlight = new List<string> { \"algolia\" },\n    AttributesToRetrieve = new List<string> { \"algolia\" },\n    AttributesToSnippet = new List<string> { \"algolia\" },\n    AttributesToTransliterate = new List<string> { \"algolia\" },\n    CamelCaseAttributes = new List<string> { \"algolia\" },\n    CustomNormalization = new Dictionary<string, Dictionary<string, string>>\n    {\n      {\n        \"algolia\",\n        new Dictionary<string, string> { { \"aloglia\", \"aglolia\" } }\n      },\n    },\n    CustomRanking = new List<string> { \"algolia\" },\n    DecompoundQuery = false,\n    DecompoundedAttributes = new Dictionary<string, string> { { \"algolia\", \"aloglia\" } },\n    DisableExactOnAttributes = new List<string> { \"algolia\" },\n    DisablePrefixOnAttributes = new List<string> { \"algolia\" },\n    DisableTypoToleranceOnAttributes = new List<string> { \"algolia\" },\n    DisableTypoToleranceOnWords = new List<string> { \"algolia\" },\n    Distinct = new Distinct(3),\n    EnablePersonalization = true,\n    EnableReRanking = false,\n    EnableRules = true,\n    ExactOnSingleWordQuery = Enum.Parse<ExactOnSingleWordQuery>(\"Attribute\"),\n    HighlightPreTag = \"<span>\",\n    HighlightPostTag = \"</span>\",\n    HitsPerPage = 10,\n    IgnorePlurals = new IgnorePlurals(false),\n    IndexLanguages = new List<SupportedLanguage> { Enum.Parse<SupportedLanguage>(\"Fr\") },\n    KeepDiacriticsOnCharacters = \"abc\",\n    MaxFacetHits = 20,\n    MaxValuesPerFacet = 30,\n    MinProximity = 6,\n    MinWordSizefor1Typo = 5,\n    MinWordSizefor2Typos = 11,\n    Mode = Enum.Parse<Mode>(\"NeuralSearch\"),\n    NumericAttributesForFiltering = new List<string> { \"algolia\" },\n    OptionalWords = new OptionalWords(new List<string> { \"myspace\" }),\n    PaginationLimitedTo = 0,\n    QueryLanguages = new List<SupportedLanguage> { Enum.Parse<SupportedLanguage>(\"Fr\") },\n    QueryType = Enum.Parse<QueryType>(\"PrefixLast\"),\n    Ranking = new List<string> { \"geo\" },\n    ReRankingApplyFilter = new ReRankingApplyFilter(\"mySearch:filters\"),\n    RelevancyStrictness = 10,\n    RemoveStopWords = new RemoveStopWords(false),\n    RemoveWordsIfNoResults = Enum.Parse<RemoveWordsIfNoResults>(\"LastWords\"),\n    RenderingContent = new RenderingContent\n    {\n      FacetOrdering = new FacetOrdering\n      {\n        Facets = new Facets\n        {\n          Order = new List<string> { \"a\", \"b\" },\n        },\n        Values = new Dictionary<string, Value>\n        {\n          {\n            \"a\",\n            new Value\n            {\n              Order = new List<string> { \"b\" },\n              SortRemainingBy = Enum.Parse<SortRemainingBy>(\"Count\"),\n            }\n          },\n        },\n      },\n    },\n    ReplaceSynonymsInHighlight = true,\n    Replicas = new List<string> { \"\" },\n    ResponseFields = new List<string> { \"algolia\" },\n    RestrictHighlightAndSnippetArrays = true,\n    SearchableAttributes = new List<string> { \"foo\" },\n    SemanticSearch = new SemanticSearch { EventSources = new List<string> { \"foo\" } },\n    SeparatorsToIndex = \"bar\",\n    SnippetEllipsisText = \"---\",\n    SortFacetValuesBy = \"date\",\n    TypoTolerance = new TypoTolerance(false),\n    UnretrievableAttributes = new List<string> { \"foo\" },\n    UserData = new Dictionary<string, string> { { \"user\", \"data\" } },\n  }\n);",
      "searchableAttributesWithCustomRankingsAndAttributesForFaceting": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    SearchableAttributes = new List<string>\n    {\n      \"brand\",\n      \"name\",\n      \"categories\",\n      \"unordered(description)\",\n    },\n    CustomRanking = new List<string> { \"desc(popularity)\" },\n    AttributesForFaceting = new List<string>\n    {\n      \"searchable(brand)\",\n      \"type\",\n      \"categories\",\n      \"price\",\n    },\n  }\n);",
      "searchableAttributesOrdering": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    SearchableAttributes = new List<string> { \"unordered(title)\", \"cast\" },\n  }\n);",
      "searchableAttributesProductReferenceSuffixes": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    SearchableAttributes = new List<string>\n    {\n      \"name\",\n      \"product_reference\",\n      \"product_reference_suffixes\",\n    },\n  }\n);",
      "queryLanguageAndIgnorePlurals": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    QueryLanguages = new List<SupportedLanguage> { Enum.Parse<SupportedLanguage>(\"En\") },\n    IgnorePlurals = new IgnorePlurals(true),\n  }\n);",
      "searchableAttributesInMovies": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    SearchableAttributes = new List<string> { \"title_eng\", \"title_fr\", \"title_es\" },\n  }\n);",
      "disablePrefixOnAttributes": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { DisablePrefixOnAttributes = new List<string> { \"serial_number\" } }\n);",
      "disableTypoToleranceOnAttributes": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { DisableTypoToleranceOnAttributes = new List<string> { \"serial_number\" } }\n);",
      "searchableAttributesSimpleExample": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { SearchableAttributes = new List<string> { \"serial_number\" } }\n);",
      "searchableAttributesSimpleExampleAlt": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    SearchableAttributes = new List<string> { \"serial_number\", \"serial_number_suffixes\" },\n  }\n);",
      "set_searchable_attributes": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    AttributesForFaceting = new List<string>\n    {\n      \"author\",\n      \"filterOnly(isbn)\",\n      \"searchable(edition)\",\n      \"afterDistinct(category)\",\n      \"afterDistinct(searchable(publisher))\",\n    },\n  }\n);",
      "unretrievable_attributes": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { UnretrievableAttributes = new List<string> { \"total_number_of_sales\" } }\n);",
      "set_retrievable_attributes": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    AttributesToRetrieve = new List<string> { \"author\", \"title\", \"content\" },\n  }\n);",
      "set_all_attributes_as_retrievable": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { AttributesToRetrieve = new List<string> { \"*\" } }\n);",
      "specify_attributes_not_to_retrieve": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    AttributesToRetrieve = new List<string> { \"*\", \"-SKU\", \"-internal_desc\" },\n  }\n);",
      "neural_search": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { Mode = Enum.Parse<Mode>(\"NeuralSearch\") }\n);",
      "keyword_search": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { Mode = Enum.Parse<Mode>(\"KeywordSearch\") }\n);",
      "set_default_ranking": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    Ranking = new List<string>\n    {\n      \"typo\",\n      \"geo\",\n      \"words\",\n      \"filters\",\n      \"attribute\",\n      \"proximity\",\n      \"exact\",\n      \"custom\",\n    },\n  }\n);",
      "set_ranking_by_attribute_asc": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    Ranking = new List<string>\n    {\n      \"asc(price)\",\n      \"typo\",\n      \"geo\",\n      \"words\",\n      \"filters\",\n      \"proximity\",\n      \"attribute\",\n      \"exact\",\n      \"custom\",\n    },\n  }\n);",
      "set_ranking_by_attribute_desc": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    Ranking = new List<string>\n    {\n      \"desc(price)\",\n      \"typo\",\n      \"geo\",\n      \"words\",\n      \"filters\",\n      \"proximity\",\n      \"attribute\",\n      \"exact\",\n      \"custom\",\n    },\n  }\n);",
      "restrict_searchable_attributes": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    CustomRanking = new List<string> { \"desc(popularity)\", \"asc(price)\" },\n  }\n);",
      "set_default_relevancy": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { RelevancyStrictness = 90 }\n);",
      "set_replicas": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    Replicas = new List<string> { \"name_of_replica_index1\", \"name_of_replica_index2\" },\n  }\n);",
      "set_default_max_values_per_facet": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { MaxValuesPerFacet = 100 }\n);",
      "set_default_sort_facet_values_by": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { SortFacetValuesBy = \"alpha\" }\n);",
      "set_attributes_to_snippet": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    AttributesToSnippet = new List<string> { \"content:80\", \"description\" },\n  }\n);",
      "set_all_attributes_to_snippet": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { AttributesToSnippet = new List<string> { \"*:80\" } }\n);",
      "set_default_highlight_pre_tag": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { HighlightPreTag = \"<em>\" }\n);",
      "set_default_highlight_post_tag": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { HighlightPostTag = \"</em>\" }\n);",
      "set_default_snippet_ellipsis_text": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { SnippetEllipsisText = \"…\" }\n);",
      "enable_restrict_highlight_and_snippet_arrays_by_default": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { RestrictHighlightAndSnippetArrays = true }\n);",
      "set_default_hits_per_page": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { HitsPerPage = 20 }\n);",
      "set_pagination_limit": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { PaginationLimitedTo = 1000 }\n);",
      "set_default_min_word_size_for_one_typo": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { MinWordSizefor1Typo = 4 }\n);",
      "set_default_min_word_size_for_two_typos": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { MinWordSizefor2Typos = 4 }\n);",
      "set_default_typo_tolerance_mode": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { TypoTolerance = new TypoTolerance(true) }\n);",
      "disable_typos_on_numeric_tokens_by_default": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { AllowTyposOnNumericTokens = false }\n);",
      "disable_typo_tolerance_for_words": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    DisableTypoToleranceOnWords = new List<string> { \"wheel\", \"1X2BCD\" },\n  }\n);",
      "set_separators_to_index": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { SeparatorsToIndex = \"+#\" }\n);",
      "set_languages_using_querylanguages": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    QueryLanguages = new List<SupportedLanguage> { Enum.Parse<SupportedLanguage>(\"Es\") },\n    RemoveStopWords = new RemoveStopWords(true),\n    IgnorePlurals = new IgnorePlurals(true),\n  }\n);",
      "set_attributes_to_transliterate": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    IndexLanguages = new List<SupportedLanguage> { Enum.Parse<SupportedLanguage>(\"Ja\") },\n    AttributesToTransliterate = new List<string> { \"name\", \"description\" },\n  }\n);",
      "set_camel_case_attributes": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { CamelCaseAttributes = new List<string> { \"description\" } }\n);",
      "set_decompounded_attributes": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    DecompoundedAttributes = new Dictionary<string, List<string>>\n    {\n      {\n        \"de\",\n        new List<string> { \"name\" }\n      },\n    },\n  }\n);",
      "set_decompounded_multiple_attributes": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    DecompoundedAttributes = new Dictionary<string, List<string>>\n    {\n      {\n        \"de\",\n        new List<string> { \"name_de\", \"description_de\" }\n      },\n      {\n        \"fi\",\n        new List<string> { \"name_fi\", \"description_fi\" }\n      },\n    },\n  }\n);",
      "set_keep_diacritics_on_characters": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { KeepDiacriticsOnCharacters = \"øé\" }\n);",
      "set_custom_normalization": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    CustomNormalization = new Dictionary<string, Dictionary<string, string>>\n    {\n      {\n        \"default\",\n        new Dictionary<string, string> { { \"ä\", \"ae\" } }\n      },\n    },\n  }\n);",
      "set_indexlanguages": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    IndexLanguages = new List<SupportedLanguage> { Enum.Parse<SupportedLanguage>(\"Ja\") },\n  }\n);",
      "enable_decompound_query_by_default": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { DecompoundQuery = true }\n);",
      "enable_rules_syntax_by_default": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { EnableRules = true }\n);",
      "enable_personalization_settings": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { EnablePersonalization = true }\n);",
      "set_default_query_type": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { QueryType = Enum.Parse<QueryType>(\"PrefixLast\") }\n);",
      "set_default_remove_words_if_no_result": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { RemoveWordsIfNoResults = Enum.Parse<RemoveWordsIfNoResults>(\"None\") }\n);",
      "enable_advanced_syntax_by_default": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { AdvancedSyntax = true }\n);",
      "set_default_optional_words": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    OptionalWords = new OptionalWords(new List<string> { \"blue\", \"iphone case\" }),\n  }\n);",
      "disabling_prefix_search_for_some_attributes_by_default": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { DisablePrefixOnAttributes = new List<string> { \"sku\" } }\n);",
      "disabling_exact_for_some_attributes_by_default": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { DisableExactOnAttributes = new List<string> { \"description\" } }\n);",
      "set_default_exact_single_word_query": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { ExactOnSingleWordQuery = Enum.Parse<ExactOnSingleWordQuery>(\"Attribute\") }\n);",
      "set_default_aternative_as_exact": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    AlternativesAsExact = new List<AlternativesAsExact>\n    {\n      Enum.Parse<AlternativesAsExact>(\"IgnorePlurals\"),\n      Enum.Parse<AlternativesAsExact>(\"SingleWordSynonym\"),\n    },\n  }\n);",
      "set_numeric_attributes_for_filtering": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    NumericAttributesForFiltering = new List<string> { \"quantity\", \"popularity\" },\n  }\n);",
      "enable_compression_of_integer_array": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { AllowCompressionOfIntegerArray = true }\n);",
      "set_attributes_for_distinct": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { AttributeForDistinct = \"url\" }\n);",
      "set_distinct": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { Distinct = new Distinct(1), AttributeForDistinct = \"url\" }\n);",
      "set_replace_synonyms_in_highlights": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { ReplaceSynonymsInHighlight = false }\n);",
      "set_min_proximity": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { MinProximity = 1 }\n);",
      "set_default_field": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    ResponseFields = new List<string> { \"hits\", \"hitsPerPage\", \"nbPages\", \"page\" },\n  }\n);",
      "set_max_facet_hits": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { MaxFacetHits = 10 }\n);",
      "set_attribute_criteria_computed_by_min_proximity": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings { AttributeCriteriaComputedByMinProximity = true }\n);",
      "set_user_data": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    UserData = new Dictionary<string, string>\n    {\n      { \"extraData\", \"This is the custom data that you want to store in your index\" },\n    },\n  }\n);",
      "set_rendering_content": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    RenderingContent = new RenderingContent\n    {\n      FacetOrdering = new FacetOrdering\n      {\n        Facets = new Facets\n        {\n          Order = new List<string> { \"size\", \"brand\" },\n        },\n        Values = new Dictionary<string, Value>\n        {\n          {\n            \"brand\",\n            new Value\n            {\n              Order = new List<string> { \"uniqlo\" },\n              Hide = new List<string> { \"muji\" },\n              SortRemainingBy = Enum.Parse<SortRemainingBy>(\"Count\"),\n            }\n          },\n          {\n            \"size\",\n            new Value\n            {\n              Order = new List<string> { \"S\", \"M\", \"L\" },\n              SortRemainingBy = Enum.Parse<SortRemainingBy>(\"Hidden\"),\n            }\n          },\n        },\n      },\n    },\n  }\n);"
    },
    "updateApiKey": {
      "default": "var response = await client.UpdateApiKeyAsync(\n  \"ALGOLIA_API_KEY\",\n  new ApiKey\n  {\n    Acl = new List<Acl> { Enum.Parse<Acl>(\"Search\"), Enum.Parse<Acl>(\"AddObject\") },\n    Validity = 300,\n    MaxQueriesPerIPPerHour = 100,\n    MaxHitsPerQuery = 20,\n  }\n);"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "var response = await client.WaitForApiKeyAsync(\n  \"api-key-add-operation-test-csharp\",\n  Enum.Parse<ApiKeyOperation>(\"Add\")\n);",
      "wait for api key - update": "var response = await client.WaitForApiKeyAsync(\n  \"api-key-update-operation-test-csharp\",\n  Enum.Parse<ApiKeyOperation>(\"Update\"),\n  new ApiKey\n  {\n    Description = \"my updated api key\",\n    Acl = new List<Acl>\n    {\n      Enum.Parse<Acl>(\"Search\"),\n      Enum.Parse<Acl>(\"AddObject\"),\n      Enum.Parse<Acl>(\"DeleteObject\"),\n    },\n    Indexes = new List<string> { \"Movies\", \"Books\" },\n    Referers = new List<string> { \"*google.com\", \"*algolia.com\" },\n    Validity = 305,\n    MaxQueriesPerIPPerHour = 95,\n    MaxHitsPerQuery = 20,\n  }\n);",
      "wait for api key - delete": "var response = await client.WaitForApiKeyAsync(\n  \"api-key-delete-operation-test-csharp\",\n  Enum.Parse<ApiKeyOperation>(\"Delete\")\n);"
    },
    "waitForAppTask": {
      "default": "var response = await client.WaitForAppTaskAsync(123L);"
    },
    "waitForTask": {
      "default": "var response = await client.WaitForTaskAsync(\"<YOUR_INDEX_NAME>\", 123L);"
    },
    "init": {
      "default": "var client = new SearchClient(new SearchConfig(\"ALGOLIA_APPLICATION_ID\", \"ALGOLIA_API_KEY\"));"
    }
  },
  "dart": {
    "import": {
      "default": "import 'package:algolia_client_search/algolia_client_search.dart';"
    },
    "addApiKey": {
      "minimal": "final response = await client.addApiKey(\n  apiKey: ApiKey(\n    acl: [\n      Acl.fromJson(\"search\"),\n      Acl.fromJson(\"addObject\"),\n    ],\n    description: \"my new api key\",\n  ),\n);",
      "all": "final response = await client.addApiKey(\n  apiKey: ApiKey(\n    acl: [\n      Acl.fromJson(\"search\"),\n      Acl.fromJson(\"addObject\"),\n    ],\n    description: \"my new api key\",\n    validity: 300,\n    maxQueriesPerIPPerHour: 100,\n    maxHitsPerQuery: 20,\n  ),\n);"
    },
    "addOrUpdateObject": {
      "default": "final response = await client.addOrUpdateObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"uniqueID\",\n  body: {\n    'key': \"value\",\n  },\n);"
    },
    "appendSource": {
      "default": "final response = await client.appendSource(\n  source: Source(\n    source: \"theSource\",\n    description: \"theDescription\",\n  ),\n);"
    },
    "assignUserId": {
      "simple": "final response = await client.assignUserId(\n  xAlgoliaUserID: \"user42\",\n  assignUserIdParams: AssignUserIdParams(\n    cluster: \"d4242-eu\",\n  ),\n);",
      "it should not encode the userID": "final response = await client.assignUserId(\n  xAlgoliaUserID: \"user id with spaces\",\n  assignUserIdParams: AssignUserIdParams(\n    cluster: \"cluster with spaces\",\n  ),\n);"
    },
    "batch": {
      "addObject": "final response = await client.batch(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  batchWriteParams: BatchWriteParams(\n    requests: [\n      BatchRequest(\n        action: Action.fromJson(\"addObject\"),\n        body: {\n          'key': \"bar\",\n          'foo': \"1\",\n        },\n      ),\n      BatchRequest(\n        action: Action.fromJson(\"addObject\"),\n        body: {\n          'key': \"baz\",\n          'foo': \"2\",\n        },\n      ),\n    ],\n  ),\n);",
      "clear": "final response = await client.batch(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  batchWriteParams: BatchWriteParams(\n    requests: [\n      BatchRequest(\n        action: Action.fromJson(\"clear\"),\n        body: {\n          'key': \"value\",\n        },\n      ),\n    ],\n  ),\n);",
      "delete": "final response = await client.batch(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  batchWriteParams: BatchWriteParams(\n    requests: [\n      BatchRequest(\n        action: Action.fromJson(\"delete\"),\n        body: {\n          'key': \"value\",\n        },\n      ),\n    ],\n  ),\n);",
      "deleteObject": "final response = await client.batch(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  batchWriteParams: BatchWriteParams(\n    requests: [\n      BatchRequest(\n        action: Action.fromJson(\"deleteObject\"),\n        body: {\n          'key': \"value\",\n        },\n      ),\n    ],\n  ),\n);",
      "partialUpdateObject": "final response = await client.batch(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  batchWriteParams: BatchWriteParams(\n    requests: [\n      BatchRequest(\n        action: Action.fromJson(\"partialUpdateObject\"),\n        body: {\n          'key': \"value\",\n        },\n      ),\n    ],\n  ),\n);",
      "partialUpdateObjectNoCreate": "final response = await client.batch(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  batchWriteParams: BatchWriteParams(\n    requests: [\n      BatchRequest(\n        action: Action.fromJson(\"partialUpdateObjectNoCreate\"),\n        body: {\n          'key': \"value\",\n        },\n      ),\n    ],\n  ),\n);",
      "updateObject": "final response = await client.batch(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  batchWriteParams: BatchWriteParams(\n    requests: [\n      BatchRequest(\n        action: Action.fromJson(\"updateObject\"),\n        body: {\n          'key': \"value\",\n        },\n      ),\n    ],\n  ),\n);"
    },
    "batchAssignUserIds": {
      "default": "final response = await client.batchAssignUserIds(\n  xAlgoliaUserID: \"userID\",\n  batchAssignUserIdsParams: BatchAssignUserIdsParams(\n    cluster: \"theCluster\",\n    users: [\n      \"user1\",\n      \"user2\",\n    ],\n  ),\n);"
    },
    "batchDictionaryEntries": {
      "replace": "final response = await client.batchDictionaryEntries(\n  dictionaryName: DictionaryType.fromJson(\"plurals\"),\n  batchDictionaryEntriesParams: BatchDictionaryEntriesParams(\n    clearExistingDictionaryEntries: true,\n    requests: [\n      BatchDictionaryEntriesRequest(\n        action: DictionaryAction.fromJson(\"addEntry\"),\n        body: DictionaryEntry(\n          objectID: \"1\",\n          language: SupportedLanguage.fromJson(\"en\"),\n          word: \"fancy\",\n          words: [\n            \"believe\",\n            \"algolia\",\n          ],\n          decomposition: [\n            \"trust\",\n            \"algolia\",\n          ],\n          state: DictionaryEntryState.fromJson(\"enabled\"),\n        ),\n      ),\n    ],\n  ),\n);",
      "delete": "final response = await client.batchDictionaryEntries(\n  dictionaryName: DictionaryType.fromJson(\"plurals\"),\n  batchDictionaryEntriesParams: BatchDictionaryEntriesParams(\n    clearExistingDictionaryEntries: true,\n    requests: [\n      BatchDictionaryEntriesRequest(\n        action: DictionaryAction.fromJson(\"deleteEntry\"),\n        body: DictionaryEntry(\n          objectID: \"1\",\n        ),\n      ),\n    ],\n  ),\n);",
      "append": "final response = await client.batchDictionaryEntries(\n  dictionaryName: DictionaryType.fromJson(\"stopwords\"),\n  batchDictionaryEntriesParams: BatchDictionaryEntriesParams(\n    requests: [\n      BatchDictionaryEntriesRequest(\n        action: DictionaryAction.fromJson(\"addEntry\"),\n        body: DictionaryEntry(\n          objectID: \"1\",\n          language: SupportedLanguage.fromJson(\"en\"),\n          additionalProperties: {'additional': 'try me'},\n        ),\n      ),\n    ],\n  ),\n);"
    },
    "browse": {
      "browse with minimal parameters": "final response = await client.browse(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);",
      "browse with search parameters": "final response = await client.browse(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  browseParams: BrowseParamsObject(\n    query: \"myQuery\",\n    facetFilters: [\n      \"tags:algolia\",\n    ],\n  ),\n);",
      "browse allow a cursor in parameters": "final response = await client.browse(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  browseParams: BrowseParamsObject(\n    cursor: \"test\",\n  ),\n);"
    },
    "clearObjects": {
      "default": "final response = await client.clearObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);"
    },
    "clearRules": {
      "default": "final response = await client.clearRules(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);"
    },
    "clearSynonyms": {
      "default": "final response = await client.clearSynonyms(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);"
    },
    "customDelete": {
      "allow del method for a custom path with minimal parameters": "final response = await client.customDelete(\n  path: \"test/minimal\",\n);",
      "allow del method for a custom path with all parameters": "final response = await client.customDelete(\n  path: \"test/all\",\n  parameters: {\n    'query': \"parameters\",\n  },\n);"
    },
    "customGet": {
      "allow get method for a custom path with minimal parameters": "final response = await client.customGet(\n  path: \"test/minimal\",\n);",
      "allow get method for a custom path with all parameters": "final response = await client.customGet(\n  path: \"test/all\",\n  parameters: {\n    'query': \"parameters with space\",\n  },\n);",
      "requestOptions should be escaped too": "final response = await client.customGet(\n  path: \"test/all\",\n  parameters: {\n    'query': \"to be overriden\",\n  },\n  requestOptions: RequestOptions(\n    headers: {\n      'x-header-1': 'spaces are left alone',\n    },\n    urlParameters: {\n      'query': \"parameters with space\",\n      'and an array': [\n        \"array\",\n        \"with spaces\",\n      ],\n    },\n  ),\n);"
    },
    "customPost": {
      "allow post method for a custom path with minimal parameters": "final response = await client.customPost(\n  path: \"test/minimal\",\n);",
      "allow post method for a custom path with all parameters": "final response = await client.customPost(\n  path: \"test/all\",\n  parameters: {\n    'query': \"parameters\",\n  },\n  body: {\n    'body': \"parameters\",\n  },\n);",
      "requestOptions can override default query parameters": "final response = await client.customPost(\n  path: \"test/requestOptions\",\n  parameters: {\n    'query': \"parameters\",\n  },\n  body: {\n    'facet': \"filters\",\n  },\n  requestOptions: RequestOptions(\n    urlParameters: {\n      'query': \"myQueryParameter\",\n    },\n  ),\n);",
      "requestOptions merges query parameters with default ones": "final response = await client.customPost(\n  path: \"test/requestOptions\",\n  parameters: {\n    'query': \"parameters\",\n  },\n  body: {\n    'facet': \"filters\",\n  },\n  requestOptions: RequestOptions(\n    urlParameters: {\n      'query2': \"myQueryParameter\",\n    },\n  ),\n);",
      "requestOptions can override default headers": "final response = await client.customPost(\n  path: \"test/requestOptions\",\n  parameters: {\n    'query': \"parameters\",\n  },\n  body: {\n    'facet': \"filters\",\n  },\n  requestOptions: RequestOptions(\n    headers: {\n      'x-algolia-api-key': 'ALGOLIA_API_KEY',\n    },\n  ),\n);",
      "requestOptions merges headers with default ones": "final response = await client.customPost(\n  path: \"test/requestOptions\",\n  parameters: {\n    'query': \"parameters\",\n  },\n  body: {\n    'facet': \"filters\",\n  },\n  requestOptions: RequestOptions(\n    headers: {\n      'x-algolia-api-key': 'ALGOLIA_API_KEY',\n    },\n  ),\n);",
      "requestOptions queryParameters accepts booleans": "final response = await client.customPost(\n  path: \"test/requestOptions\",\n  parameters: {\n    'query': \"parameters\",\n  },\n  body: {\n    'facet': \"filters\",\n  },\n  requestOptions: RequestOptions(\n    urlParameters: {\n      'isItWorking': true,\n    },\n  ),\n);",
      "requestOptions queryParameters accepts integers": "final response = await client.customPost(\n  path: \"test/requestOptions\",\n  parameters: {\n    'query': \"parameters\",\n  },\n  body: {\n    'facet': \"filters\",\n  },\n  requestOptions: RequestOptions(\n    urlParameters: {\n      'myParam': 2,\n    },\n  ),\n);",
      "requestOptions queryParameters accepts list of string": "final response = await client.customPost(\n  path: \"test/requestOptions\",\n  parameters: {\n    'query': \"parameters\",\n  },\n  body: {\n    'facet': \"filters\",\n  },\n  requestOptions: RequestOptions(\n    urlParameters: {\n      'myParam': [\n        \"b and c\",\n        \"d\",\n      ],\n    },\n  ),\n);",
      "requestOptions queryParameters accepts list of booleans": "final response = await client.customPost(\n  path: \"test/requestOptions\",\n  parameters: {\n    'query': \"parameters\",\n  },\n  body: {\n    'facet': \"filters\",\n  },\n  requestOptions: RequestOptions(\n    urlParameters: {\n      'myParam': [\n        true,\n        true,\n        false,\n      ],\n    },\n  ),\n);",
      "requestOptions queryParameters accepts list of integers": "final response = await client.customPost(\n  path: \"test/requestOptions\",\n  parameters: {\n    'query': \"parameters\",\n  },\n  body: {\n    'facet': \"filters\",\n  },\n  requestOptions: RequestOptions(\n    urlParameters: {\n      'myParam': [\n        1,\n        2,\n      ],\n    },\n  ),\n);"
    },
    "customPut": {
      "allow put method for a custom path with minimal parameters": "final response = await client.customPut(\n  path: \"test/minimal\",\n);",
      "allow put method for a custom path with all parameters": "final response = await client.customPut(\n  path: \"test/all\",\n  parameters: {\n    'query': \"parameters\",\n  },\n  body: {\n    'body': \"parameters\",\n  },\n);"
    },
    "deleteApiKey": {
      "default": "final response = await client.deleteApiKey(\n  key: \"myTestApiKey\",\n);"
    },
    "deleteBy": {
      "default": "final response = await client.deleteBy(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  deleteByParams: DeleteByParams(\n    filters: \"brand:brandName\",\n  ),\n);"
    },
    "deleteIndex": {
      "default": "final response = await client.deleteIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);"
    },
    "deleteObject": {
      "default": "final response = await client.deleteObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"uniqueID\",\n);"
    },
    "deleteObjects": {
      "default": "final response = await client.deleteObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectIDs: [\n    \"1\",\n    \"2\",\n  ],\n);"
    },
    "deleteRule": {
      "delete rule simple case": "final response = await client.deleteRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"id1\",\n);",
      "delete rule with simple characters to encode in objectID": "final response = await client.deleteRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"test/with/slash\",\n);"
    },
    "deleteSource": {
      "default": "final response = await client.deleteSource(\n  source: \"theSource\",\n);"
    },
    "deleteSynonym": {
      "default": "final response = await client.deleteSynonym(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"id1\",\n);"
    },
    "generateSecuredApiKey": {
      "api key basic": "final response = client.generateSecuredApiKey(\n  parentApiKey: \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions: SecuredApiKeyRestrictions(\n    validUntil: 2524604400,\n    restrictIndices: [\n      \"Movies\",\n    ],\n  ),\n);",
      "with searchParams": "final response = client.generateSecuredApiKey(\n  parentApiKey: \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions: SecuredApiKeyRestrictions(\n    validUntil: 2524604400,\n    restrictIndices: [\n      \"Movies\",\n      \"cts_e2e_settings\",\n    ],\n    restrictSources: \"192.168.1.0/24\",\n    filters: \"category:Book OR category:Ebook AND _tags:published\",\n    userToken: \"user123\",\n    searchParams: SearchParamsObject(\n      query: \"batman\",\n      typoTolerance: TypoToleranceEnum.fromJson(\"strict\"),\n      aroundRadius: AroundRadiusAll.fromJson(\"all\"),\n      mode: Mode.fromJson(\"neuralSearch\"),\n      hitsPerPage: 10,\n      optionalWords: [\n        \"one\",\n        \"two\",\n      ],\n    ),\n  ),\n);",
      "with filters": "final response = client.generateSecuredApiKey(\n  parentApiKey: \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions: SecuredApiKeyRestrictions(\n    filters:\n        \"user:user42 AND user:public AND (visible_by:John OR visible_by:group/Finance)\",\n  ),\n);",
      "with visible_by filter": "final response = client.generateSecuredApiKey(\n  parentApiKey: \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions: SecuredApiKeyRestrictions(\n    filters: \"visible_by:group/Finance\",\n  ),\n);",
      "with userID": "final response = client.generateSecuredApiKey(\n  parentApiKey: \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions: SecuredApiKeyRestrictions(\n    userToken: \"user42\",\n  ),\n);",
      "mcm with filters": "final response = client.generateSecuredApiKey(\n  parentApiKey: \"YourSearchOnlyApiKey\",\n  restrictions: SecuredApiKeyRestrictions(\n    filters: \"user:user42 AND user:public\",\n  ),\n);",
      "mcm with user token": "final response = client.generateSecuredApiKey(\n  parentApiKey: \"YourSearchOnlyApiKey\",\n  restrictions: SecuredApiKeyRestrictions(\n    userToken: \"user42\",\n  ),\n);"
    },
    "getApiKey": {
      "default": "final response = await client.getApiKey(\n  key: \"myTestApiKey\",\n);"
    },
    "getAppTask": {
      "default": "final response = await client.getAppTask(\n  taskID: 123,\n);"
    },
    "getDictionaryLanguages": {
      "default": "final response = await client.getDictionaryLanguages();"
    },
    "getDictionarySettings": {
      "default": "final response = await client.getDictionarySettings();"
    },
    "getLogs": {
      "getLogs with minimal parameters": "final response = await client.getLogs();",
      "getLogs with parameters": "final response = await client.getLogs(\n  offset: 5,\n  length: 10,\n  indexName: \"<YOUR_INDEX_NAME>\",\n  type: LogType.fromJson(\"all\"),\n);"
    },
    "getObject": {
      "getObject": "final response = await client.getObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"uniqueID\",\n  attributesToRetrieve: [\n    \"attr1\",\n    \"attr2\",\n  ],\n);",
      "search with a real object": "final response = await client.getObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"Batman and Robin\",\n);"
    },
    "getObjects": {
      "by ID": "final response = await client.getObjects(\n  getObjectsParams: GetObjectsParams(\n    requests: [\n      GetObjectsRequest(\n        objectID: \"uniqueID\",\n        indexName: \"<YOUR_INDEX_NAME>\",\n      ),\n    ],\n  ),\n);",
      "multiple IDs": "final response = await client.getObjects(\n  getObjectsParams: GetObjectsParams(\n    requests: [\n      GetObjectsRequest(\n        objectID: \"uniqueID1\",\n        indexName: \"<YOUR_INDEX_NAME>\",\n      ),\n      GetObjectsRequest(\n        objectID: \"uniqueID2\",\n        indexName: \"<YOUR_INDEX_NAME>\",\n      ),\n    ],\n  ),\n);",
      "with attributesToRetrieve": "final response = await client.getObjects(\n  getObjectsParams: GetObjectsParams(\n    requests: [\n      GetObjectsRequest(\n        attributesToRetrieve: [\n          \"attr1\",\n          \"attr2\",\n        ],\n        objectID: \"uniqueID\",\n        indexName: \"<YOUR_INDEX_NAME>\",\n      ),\n    ],\n  ),\n);"
    },
    "getRule": {
      "default": "final response = await client.getRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"qr-1725004648916\",\n);"
    },
    "getSettings": {
      "default": "final response = await client.getSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);"
    },
    "getSources": {
      "default": "final response = await client.getSources();"
    },
    "getSynonym": {
      "default": "final response = await client.getSynonym(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"id1\",\n);"
    },
    "getTask": {
      "default": "final response = await client.getTask(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  taskID: 123,\n);"
    },
    "getTopUserIds": {
      "default": "final response = await client.getTopUserIds();"
    },
    "getUserId": {
      "default": "final response = await client.getUserId(\n  userID: \"uniqueID\",\n);"
    },
    "hasPendingMappings": {
      "hasPendingMappings with minimal parameters": "final response = await client.hasPendingMappings();",
      "hasPendingMappings with parameters": "final response = await client.hasPendingMappings(\n  getClusters: true,\n);"
    },
    "indexExists": {
      "indexExists": "final response = await client.indexExists(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);",
      "indexNotExists": "final response = await client.indexExists(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);",
      "indexExistsWithError": "final response = await client.indexExists(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);"
    },
    "listApiKeys": {
      "default": "final response = await client.listApiKeys();"
    },
    "listClusters": {
      "default": "final response = await client.listClusters();"
    },
    "listIndices": {
      "listIndices with minimal parameters": "final response = await client.listIndices();",
      "listIndices with parameters": "final response = await client.listIndices(\n  page: 8,\n  hitsPerPage: 3,\n);"
    },
    "listUserIds": {
      "listUserIds with minimal parameters": "final response = await client.listUserIds();",
      "listUserIds with parameters": "final response = await client.listUserIds(\n  page: 8,\n  hitsPerPage: 100,\n);"
    },
    "multipleBatch": {
      "default": "final response = await client.multipleBatch(\n  batchParams: BatchParams(\n    requests: [\n      MultipleBatchRequest(\n        action: Action.fromJson(\"addObject\"),\n        body: {\n          'key': \"value\",\n        },\n        indexName: \"<YOUR_INDEX_NAME>\",\n      ),\n    ],\n  ),\n);"
    },
    "operationIndex": {
      "scopes": "final response = await client.operationIndex(\n  indexName: \"<SOURCE_INDEX_NAME>\",\n  operationIndexParams: OperationIndexParams(\n    operation: OperationType.fromJson(\"move\"),\n    destination: \"<DESTINATION_INDEX_NAME>\",\n    scope: [\n      ScopeType.fromJson(\"rules\"),\n      ScopeType.fromJson(\"settings\"),\n    ],\n  ),\n);",
      "copy": "final response = await client.operationIndex(\n  indexName: \"<SOURCE_INDEX_NAME>\",\n  operationIndexParams: OperationIndexParams(\n    operation: OperationType.fromJson(\"copy\"),\n    destination: \"<DESTINATION_INDEX_NAME>\",\n  ),\n);",
      "move": "final response = await client.operationIndex(\n  indexName: \"<SOURCE_INDEX_NAME>\",\n  operationIndexParams: OperationIndexParams(\n    operation: OperationType.fromJson(\"move\"),\n    destination: \"<DESTINATION_INDEX_NAME>\",\n  ),\n);"
    },
    "partialUpdateObject": {
      "Partial update with a new value for a string attribute": "final response = await client.partialUpdateObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"uniqueID\",\n  attributesToUpdate: {\n    'attributeId': \"new value\",\n  },\n);",
      "Partial update with a new value for an integer attribute": "final response = await client.partialUpdateObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"uniqueID\",\n  attributesToUpdate: {\n    'attributeId': 1,\n  },\n);",
      "Partial update with a new value for a boolean attribute": "final response = await client.partialUpdateObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"uniqueID\",\n  attributesToUpdate: {\n    'attributeId': true,\n  },\n);",
      "Partial update with a new value for an array attribute": "final response = await client.partialUpdateObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"uniqueID\",\n  attributesToUpdate: {\n    'attributeId': [\n      \"one\",\n      \"two\",\n      \"three\",\n    ],\n  },\n);",
      "Partial update with a new value for an object attribute": "final response = await client.partialUpdateObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"uniqueID\",\n  attributesToUpdate: {\n    'attributeId': {\n      'nested': \"value\",\n    },\n  },\n);",
      "with visible_by filter": "final response = await client.partialUpdateObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"uniqueID\",\n  attributesToUpdate: {\n    'visible_by': [\n      \"Angela\",\n      \"group/Finance\",\n      \"group/Shareholders\",\n    ],\n  },\n);",
      "add men pant": "final response = await client.partialUpdateObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"productId\",\n  attributesToUpdate: {\n    'categoryPageId': {\n      '_operation': \"Add\",\n      'value': \"men-clothing-pants\",\n    },\n  },\n);",
      "remove men pant": "final response = await client.partialUpdateObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"productId\",\n  attributesToUpdate: {\n    'categoryPageId': {\n      '_operation': \"Remove\",\n      'value': \"men-clothing-pants\",\n    },\n  },\n);"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "final response = await client.partialUpdateObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objects: [\n    {\n      'objectID': \"1\",\n      'name': \"Adam\",\n    },\n    {\n      'objectID': \"2\",\n      'name': \"Benoit\",\n    },\n  ],\n  createIfNotExists: true,\n);",
      "call partialUpdateObjects with createIfNotExists=false": "final response = await client.partialUpdateObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objects: [\n    {\n      'objectID': \"3\",\n      'name': \"Cyril\",\n    },\n    {\n      'objectID': \"4\",\n      'name': \"David\",\n    },\n  ],\n  createIfNotExists: false,\n);"
    },
    "removeUserId": {
      "default": "final response = await client.removeUserId(\n  userID: \"uniqueID\",\n);"
    },
    "replaceAllObjects": {
      "call replaceAllObjects without error": "final response = await client.replaceAllObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objects: [\n    {\n      'objectID': \"1\",\n      'name': \"Adam\",\n    },\n    {\n      'objectID': \"2\",\n      'name': \"Benoit\",\n    },\n    {\n      'objectID': \"3\",\n      'name': \"Cyril\",\n    },\n    {\n      'objectID': \"4\",\n      'name': \"David\",\n    },\n    {\n      'objectID': \"5\",\n      'name': \"Eva\",\n    },\n    {\n      'objectID': \"6\",\n      'name': \"Fiona\",\n    },\n    {\n      'objectID': \"7\",\n      'name': \"Gael\",\n    },\n    {\n      'objectID': \"8\",\n      'name': \"Hugo\",\n    },\n    {\n      'objectID': \"9\",\n      'name': \"Igor\",\n    },\n    {\n      'objectID': \"10\",\n      'name': \"Julia\",\n    },\n  ],\n  batchSize: 3,\n);",
      "call replaceAllObjects with partial scopes": "final response = await client.replaceAllObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objects: [\n    {\n      'objectID': \"1\",\n      'name': \"Adam\",\n    },\n    {\n      'objectID': \"2\",\n      'name': \"Benoit\",\n    },\n  ],\n  batchSize: 77,\n  scopes: [\n    ScopeType.fromJson(\"settings\"),\n    ScopeType.fromJson(\"synonyms\"),\n  ],\n);",
      "replaceAllObjects should cleanup on failure": "final response = await client.replaceAllObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objects: [\n    {\n      'objectID': \"fine\",\n      'body': \"small obj\",\n    },\n    {\n      'objectID': \"toolarge\",\n      'body': \"something bigger than 10KB\",\n    },\n  ],\n);"
    },
    "replaceSources": {
      "default": "final response = await client.replaceSources(\n  source: [\n    Source(\n      source: \"theSource\",\n      description: \"theDescription\",\n    ),\n  ],\n);"
    },
    "restoreApiKey": {
      "default": "final response = await client.restoreApiKey(\n  key: \"ALGOLIA_API_KEY\",\n);"
    },
    "saveObject": {
      "default": "final response = await client.saveObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  body: {\n    'name': \"Black T-shirt\",\n    'color': \"#000000||black\",\n    'availableIn': \"https://source.unsplash.com/100x100/?paris||Paris\",\n    'objectID': \"myID\",\n  },\n);"
    },
    "saveObjects": {
      "call saveObjects without error": "final response = await client.saveObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objects: [\n    {\n      'objectID': \"1\",\n      'name': \"Adam\",\n    },\n    {\n      'objectID': \"2\",\n      'name': \"Benoit\",\n    },\n  ],\n);",
      "saveObjects should report errors": "final response = await client.saveObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objects: [\n    {\n      'objectID': \"1\",\n      'name': \"Adam\",\n    },\n    {\n      'objectID': \"2\",\n      'name': \"Benoit\",\n    },\n  ],\n);",
      "saveObjectsPlaylist": "final response = await client.saveObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objects: [\n    {\n      'objectID': \"1\",\n      'visibility': \"public\",\n      'name': \"Hot 100 Billboard Charts\",\n      'playlistId': \"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\",\n      'createdAt': \"1500240452\",\n    },\n  ],\n);",
      "saveObjectsPublicUser": "final response = await client.saveObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objects: [\n    {\n      'objectID': \"1\",\n      'visibility': \"public\",\n      'name': \"Hot 100 Billboard Charts\",\n      'playlistId': \"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\",\n      'createdAt': \"1500240452\",\n    },\n  ],\n  waitForTasks: false,\n  batchSize: 1000,\n  requestOptions: RequestOptions(\n    headers: {\n      'X-Algolia-User-ID': '*',\n    },\n  ),\n);"
    },
    "saveRule": {
      "saveRule with minimal parameters": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"id1\",\n  rule: Rule(\n    objectID: \"id1\",\n    conditions: [\n      Condition(\n        pattern: \"apple\",\n        anchoring: Anchoring.fromJson(\"contains\"),\n      ),\n    ],\n    consequence: Consequence(\n      params: ConsequenceParams(\n        filters: \"brand:xiaomi\",\n      ),\n    ),\n  ),\n);",
      "saveRule with all parameters": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"id1\",\n  rule: Rule(\n    objectID: \"id1\",\n    conditions: [\n      Condition(\n        pattern: \"apple\",\n        anchoring: Anchoring.fromJson(\"contains\"),\n        alternatives: false,\n        context: \"search\",\n      ),\n    ],\n    consequence: Consequence(\n      params: ConsequenceParams(\n        filters: \"brand:apple\",\n        query: ConsequenceQueryObject(\n          remove: [\n            \"algolia\",\n          ],\n          edits: [\n            Edit(\n              type: EditType.fromJson(\"remove\"),\n              delete: \"abc\",\n              insert: \"cde\",\n            ),\n            Edit(\n              type: EditType.fromJson(\"replace\"),\n              delete: \"abc\",\n              insert: \"cde\",\n            ),\n          ],\n        ),\n      ),\n      hide: [\n        ConsequenceHide(\n          objectID: \"321\",\n        ),\n      ],\n      filterPromotes: false,\n      userData: {\n        'algolia': \"aloglia\",\n      },\n      promote: [\n        PromoteObjectID(\n          objectID: \"abc\",\n          position: 3,\n        ),\n        PromoteObjectIDs(\n          objectIDs: [\n            \"abc\",\n            \"def\",\n          ],\n          position: 1,\n        ),\n      ],\n    ),\n    description: \"test\",\n    enabled: true,\n    validity: [\n      TimeRange(\n        from: 1656670273,\n        until: 1656670277,\n      ),\n    ],\n  ),\n  forwardToReplicas: true,\n);",
      "b2b catalog": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"article-rule\",\n  rule: Rule(\n    objectID: \"article-rule\",\n    conditions: [\n      Condition(\n        pattern: \"article\",\n        anchoring: Anchoring.fromJson(\"startsWith\"),\n      ),\n    ],\n    consequence: Consequence(\n      params: ConsequenceParams(\n        query: ConsequenceQueryObject(\n          edits: [\n            Edit(\n              type: EditType.fromJson(\"remove\"),\n              delete: \"article\",\n            ),\n          ],\n        ),\n        restrictSearchableAttributes: [\n          \"title\",\n          \"book_id\",\n        ],\n      ),\n    ),\n  ),\n);",
      "merchandising and promoting": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"director-rule\",\n  rule: Rule(\n    objectID: \"director-rule\",\n    conditions: [\n      Condition(\n        pattern: \"{facet:director} director\",\n        anchoring: Anchoring.fromJson(\"contains\"),\n      ),\n    ],\n    consequence: Consequence(\n      params: ConsequenceParams(\n        restrictSearchableAttributes: [\n          \"title\",\n          \"book_id\",\n        ],\n        automaticFacetFilters: [\n          AutomaticFacetFilter(\n            facet: \"director\",\n          ),\n        ],\n        query: ConsequenceQueryObject(\n          edits: [\n            Edit(\n              type: EditType.fromJson(\"remove\"),\n              delete: \"director\",\n            ),\n          ],\n        ),\n      ),\n    ),\n  ),\n);",
      "harry potter": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"harry-potter-rule\",\n  rule: Rule(\n    objectID: \"harry-potter-rule\",\n    conditions: [\n      Condition(\n        pattern: \"harry potter\",\n        anchoring: Anchoring.fromJson(\"contains\"),\n      ),\n    ],\n    consequence: Consequence(\n      userData: {\n        'promo_content': \"20% OFF on all Harry Potter books!\",\n      },\n    ),\n  ),\n);",
      "merchandising empty query": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"clearance-category-filter\",\n  rule: Rule(\n    objectID: \"clearance-category-filter\",\n    conditions: [\n      Condition(\n        pattern: \"\",\n        anchoring: Anchoring.fromJson(\"is\"),\n        context: \"landing\",\n      ),\n    ],\n    consequence: Consequence(\n      params: ConsequenceParams(\n        optionalFilters: \"clearance:true\",\n      ),\n    ),\n  ),\n);",
      "redirect": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"redirect-help-rule\",\n  rule: Rule(\n    objectID: \"redirect-help-rule\",\n    conditions: [\n      Condition(\n        pattern: \"help\",\n        anchoring: Anchoring.fromJson(\"contains\"),\n      ),\n    ],\n    consequence: Consequence(\n      userData: {\n        'redirect': \"https://www.algolia.com/support\",\n      },\n    ),\n  ),\n);",
      "promote some results over others": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"tomato-fruit\",\n  rule: Rule(\n    objectID: \"tomato-fruit\",\n    conditions: [\n      Condition(\n        pattern: \"tomato\",\n        anchoring: Anchoring.fromJson(\"contains\"),\n      ),\n    ],\n    consequence: Consequence(\n      params: ConsequenceParams(\n        optionalFilters: \"food_group:fruit\",\n      ),\n    ),\n  ),\n);",
      "promote several hits": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"Promote-Apple-Newest\",\n  rule: Rule(\n    objectID: \"Promote-Apple-Newest\",\n    conditions: [\n      Condition(\n        pattern: \"apple\",\n        anchoring: Anchoring.fromJson(\"is\"),\n      ),\n    ],\n    consequence: Consequence(\n      promote: [\n        PromoteObjectIDs(\n          objectIDs: [\n            \"iPhone-12345\",\n            \"watch-123\",\n          ],\n          position: 0,\n        ),\n      ],\n    ),\n  ),\n);",
      "promote newest release": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"Promote-iPhone-X\",\n  rule: Rule(\n    objectID: \"Promote-iPhone-X\",\n    conditions: [\n      Condition(\n        pattern: \"iPhone\",\n        anchoring: Anchoring.fromJson(\"contains\"),\n      ),\n    ],\n    consequence: Consequence(\n      promote: [\n        PromoteObjectID(\n          objectID: \"iPhone-12345\",\n          position: 0,\n        ),\n      ],\n    ),\n  ),\n);",
      "promote single item": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"promote-harry-potter-box-set\",\n  rule: Rule(\n    objectID: \"promote-harry-potter-box-set\",\n    conditions: [\n      Condition(\n        pattern: \"Harry Potter\",\n        anchoring: Anchoring.fromJson(\"contains\"),\n      ),\n    ],\n    consequence: Consequence(\n      promote: [\n        PromoteObjectID(\n          objectID: \"HP-12345\",\n          position: 0,\n        ),\n      ],\n    ),\n  ),\n);",
      "limit search results": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"article-rule\",\n  rule: Rule(\n    objectID: \"article-rule\",\n    conditions: [\n      Condition(\n        pattern: \"article\",\n        anchoring: Anchoring.fromJson(\"startsWith\"),\n      ),\n    ],\n    consequence: Consequence(\n      params: ConsequenceParams(\n        query: ConsequenceQueryObject(\n          edits: [\n            Edit(\n              type: EditType.fromJson(\"remove\"),\n              delete: \"article\",\n            ),\n          ],\n        ),\n        restrictSearchableAttributes: [\n          \"title\",\n          \"book_id\",\n        ],\n      ),\n    ),\n  ),\n);",
      "query match": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"tagged-brand-rule\",\n  rule: Rule(\n    conditions: [\n      Condition(\n        pattern: \"brand: {facet:brand}\",\n        anchoring: Anchoring.fromJson(\"contains\"),\n        alternatives: false,\n      ),\n    ],\n    consequence: Consequence(\n      params: ConsequenceParams(\n        automaticFacetFilters: [\n          AutomaticFacetFilter(\n            facet: \"brand\",\n          ),\n        ],\n        query: ConsequenceQueryObject(\n          remove: [\n            \"brand:\",\n            \"{facet:brand}\",\n          ],\n        ),\n      ),\n    ),\n    description: \"filter on brand: {brand}\",\n    objectID: \"tagged-brand-rule\",\n  ),\n);",
      "dynamic filtering": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"color-facets\",\n  rule: Rule(\n    objectID: \"color-facets\",\n    conditions: [\n      Condition(\n        pattern: \"{facet:color}\",\n      ),\n    ],\n    consequence: Consequence(\n      params: ConsequenceParams(\n        automaticFacetFilters: [\n          AutomaticFacetFilter(\n            facet: \"color\",\n          ),\n        ],\n      ),\n    ),\n  ),\n);",
      "hide hits": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"hide-12345\",\n  rule: Rule(\n    objectID: \"hide-12345\",\n    conditions: [\n      Condition(\n        pattern: \"cheap\",\n        anchoring: Anchoring.fromJson(\"contains\"),\n      ),\n    ],\n    consequence: Consequence(\n      hide: [\n        ConsequenceHide(\n          objectID: \"to-hide-12345\",\n        ),\n      ],\n    ),\n  ),\n);",
      "one rule per facet": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"red-color\",\n  rule: Rule(\n    objectID: \"red-color\",\n    conditions: [\n      Condition(\n        pattern: \"red\",\n        anchoring: Anchoring.fromJson(\"contains\"),\n      ),\n    ],\n    consequence: Consequence(\n      params: ConsequenceParams(\n        query: ConsequenceQueryObject(\n          remove: [\n            \"red\",\n          ],\n        ),\n        filters: \"color:red\",\n      ),\n    ),\n  ),\n);",
      "numerical filters": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"cheap\",\n  rule: Rule(\n    objectID: \"cheap\",\n    conditions: [\n      Condition(\n        pattern: \"cheap\",\n        anchoring: Anchoring.fromJson(\"contains\"),\n      ),\n    ],\n    consequence: Consequence(\n      params: ConsequenceParams(\n        query: ConsequenceQueryObject(\n          remove: [\n            \"cheap\",\n          ],\n        ),\n        filters: \"price < 10\",\n      ),\n    ),\n  ),\n);",
      "negative filters": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"gluten-free-rule\",\n  rule: Rule(\n    objectID: \"gluten-free-rule\",\n    conditions: [\n      Condition(\n        pattern: \"gluten-free\",\n        anchoring: Anchoring.fromJson(\"contains\"),\n      ),\n    ],\n    consequence: Consequence(\n      params: ConsequenceParams(\n        filters: \"NOT allergens:gluten\",\n        query: ConsequenceQueryObject(\n          edits: [\n            Edit(\n              type: EditType.fromJson(\"remove\"),\n              delete: \"gluten-free\",\n            ),\n          ],\n        ),\n      ),\n    ),\n  ),\n);",
      "positive filters": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"diet-rule\",\n  rule: Rule(\n    objectID: \"diet-rule\",\n    conditions: [\n      Condition(\n        pattern: \"diet\",\n        anchoring: Anchoring.fromJson(\"contains\"),\n      ),\n    ],\n    consequence: Consequence(\n      params: ConsequenceParams(\n        filters: \"'low-carb' OR 'low-fat'\",\n        query: ConsequenceQueryObject(\n          edits: [\n            Edit(\n              type: EditType.fromJson(\"remove\"),\n              delete: \"diet\",\n            ),\n          ],\n        ),\n      ),\n    ),\n  ),\n);",
      "conditionless": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"diet-rule\",\n  rule: Rule(\n    objectID: \"diet-rule\",\n    consequence: Consequence(\n      params: ConsequenceParams(\n        filters: \"'low-carb' OR 'low-fat'\",\n        query: ConsequenceQueryObject(\n          edits: [\n            Edit(\n              type: EditType.fromJson(\"remove\"),\n              delete: \"diet\",\n            ),\n          ],\n        ),\n      ),\n    ),\n  ),\n);",
      "contextual": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"a-rule-id\",\n  rule: Rule(\n    objectID: \"a-rule-id\",\n    conditions: [\n      Condition(\n        context: \"mobile\",\n      ),\n    ],\n    consequence: Consequence(\n      params: ConsequenceParams(\n        filters: \"release_date >= 1577836800\",\n      ),\n    ),\n  ),\n);",
      "saveRule always active rule": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"a-rule-id\",\n  rule: Rule(\n    objectID: \"a-rule-id\",\n    consequence: Consequence(\n      params: ConsequenceParams(\n        aroundRadius: 1000,\n      ),\n    ),\n    validity: [\n      TimeRange(\n        from: 1577836800,\n        until: 1577836800,\n      ),\n    ],\n  ),\n);"
    },
    "saveRules": {
      "saveRules with minimal parameters": "final response = await client.saveRules(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  rules: [\n    Rule(\n      objectID: \"a-rule-id\",\n      conditions: [\n        Condition(\n          pattern: \"smartphone\",\n          anchoring: Anchoring.fromJson(\"contains\"),\n        ),\n      ],\n      consequence: Consequence(\n        params: ConsequenceParams(\n          filters: \"brand:apple\",\n        ),\n      ),\n    ),\n    Rule(\n      objectID: \"a-second-rule-id\",\n      conditions: [\n        Condition(\n          pattern: \"apple\",\n          anchoring: Anchoring.fromJson(\"contains\"),\n        ),\n      ],\n      consequence: Consequence(\n        params: ConsequenceParams(\n          filters: \"brand:samsung\",\n        ),\n      ),\n    ),\n  ],\n  forwardToReplicas: false,\n  clearExistingRules: true,\n);",
      "saveRules with all parameters": "final response = await client.saveRules(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  rules: [\n    Rule(\n      objectID: \"id1\",\n      conditions: [\n        Condition(\n          pattern: \"apple\",\n          anchoring: Anchoring.fromJson(\"contains\"),\n          alternatives: false,\n          context: \"search\",\n        ),\n      ],\n      consequence: Consequence(\n        params: ConsequenceParams(\n          filters: \"brand:apple\",\n          query: ConsequenceQueryObject(\n            remove: [\n              \"algolia\",\n            ],\n            edits: [\n              Edit(\n                type: EditType.fromJson(\"remove\"),\n                delete: \"abc\",\n                insert: \"cde\",\n              ),\n              Edit(\n                type: EditType.fromJson(\"replace\"),\n                delete: \"abc\",\n                insert: \"cde\",\n              ),\n            ],\n          ),\n        ),\n        hide: [\n          ConsequenceHide(\n            objectID: \"321\",\n          ),\n        ],\n        filterPromotes: false,\n        userData: {\n          'algolia': \"aloglia\",\n        },\n        promote: [\n          PromoteObjectID(\n            objectID: \"abc\",\n            position: 3,\n          ),\n          PromoteObjectIDs(\n            objectIDs: [\n              \"abc\",\n              \"def\",\n            ],\n            position: 1,\n          ),\n        ],\n      ),\n      description: \"test\",\n      enabled: true,\n      validity: [\n        TimeRange(\n          from: 1656670273,\n          until: 1656670277,\n        ),\n      ],\n    ),\n  ],\n  forwardToReplicas: true,\n  clearExistingRules: true,\n);",
      "dynamic filtering": "final response = await client.saveRules(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  rules: [\n    Rule(\n      objectID: \"toaster\",\n      conditions: [\n        Condition(\n          pattern: \"toaster\",\n          anchoring: Anchoring.fromJson(\"contains\"),\n        ),\n      ],\n      consequence: Consequence(\n        params: ConsequenceParams(\n          query: ConsequenceQueryObject(\n            remove: [\n              \"toaster\",\n            ],\n          ),\n          filters: \"product_type:toaster\",\n        ),\n      ),\n    ),\n    Rule(\n      objectID: \"cheap\",\n      conditions: [\n        Condition(\n          pattern: \"cheap\",\n          anchoring: Anchoring.fromJson(\"contains\"),\n        ),\n      ],\n      consequence: Consequence(\n        params: ConsequenceParams(\n          query: ConsequenceQueryObject(\n            remove: [\n              \"cheap\",\n            ],\n          ),\n          filters: \"price < 15\",\n        ),\n      ),\n    ),\n  ],\n);",
      "enhance search results": "final response = await client.saveRules(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  rules: [\n    Rule(\n      objectID: \"country\",\n      conditions: [\n        Condition(\n          pattern: \"{facet:country}\",\n          anchoring: Anchoring.fromJson(\"contains\"),\n        ),\n      ],\n      consequence: Consequence(\n        params: ConsequenceParams(\n          aroundLatLngViaIP: false,\n        ),\n      ),\n    ),\n    Rule(\n      objectID: \"city\",\n      conditions: [\n        Condition(\n          pattern: \"{facet:city}\",\n          anchoring: Anchoring.fromJson(\"contains\"),\n        ),\n      ],\n      consequence: Consequence(\n        params: ConsequenceParams(\n          aroundLatLngViaIP: false,\n        ),\n      ),\n    ),\n  ],\n);"
    },
    "saveSynonym": {
      "default": "final response = await client.saveSynonym(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"id1\",\n  synonymHit: SynonymHit(\n    objectID: \"id1\",\n    type: SynonymType.fromJson(\"synonym\"),\n    synonyms: [\n      \"car\",\n      \"vehicule\",\n      \"auto\",\n    ],\n  ),\n  forwardToReplicas: true,\n);"
    },
    "saveSynonyms": {
      "default": "final response = await client.saveSynonyms(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  synonymHit: [\n    SynonymHit(\n      objectID: \"id1\",\n      type: SynonymType.fromJson(\"synonym\"),\n      synonyms: [\n        \"car\",\n        \"vehicule\",\n        \"auto\",\n      ],\n    ),\n    SynonymHit(\n      objectID: \"id2\",\n      type: SynonymType.fromJson(\"onewaysynonym\"),\n      input: \"iphone\",\n      synonyms: [\n        \"ephone\",\n        \"aphone\",\n        \"yphone\",\n      ],\n    ),\n  ],\n  forwardToReplicas: true,\n  replaceExistingSynonyms: true,\n);"
    },
    "search": {
      "withHitsPerPage": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        hitsPerPage: 50,\n      ),\n    ],\n  ),\n);",
      "filterOnly": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        filters: \"actor:Scarlett Johansson\",\n      ),\n    ],\n  ),\n);",
      "filterOr": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        filters: \"actor:Tom Cruise OR actor:Scarlett Johansson\",\n      ),\n    ],\n  ),\n);",
      "filterNot": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        filters: \"NOT actor:Nicolas Cage\",\n      ),\n    ],\n  ),\n);",
      "search for a single hits request with minimal parameters": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n      ),\n    ],\n  ),\n);",
      "search with highlight and snippet results": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        query: \"vim\",\n        attributesToSnippet: [\n          \"*:20\",\n        ],\n        attributesToHighlight: [\n          \"*\",\n        ],\n        attributesToRetrieve: [\n          \"*\",\n        ],\n      ),\n    ],\n  ),\n);",
      "retrieveFacets": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        facets: [\n          \"author\",\n          \"genre\",\n        ],\n      ),\n    ],\n  ),\n);",
      "retrieveFacetsWildcard": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        facets: [\n          \"*\",\n        ],\n      ),\n    ],\n  ),\n);",
      "search for a single facet request with minimal parameters": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForFacets(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        type: SearchTypeFacet.fromJson(\"facet\"),\n        facet: \"editor\",\n      ),\n    ],\n    strategy: SearchStrategy.fromJson(\"stopIfEnoughMatches\"),\n  ),\n);",
      "search for a single hits request with all parameters": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        query: \"myQuery\",\n        hitsPerPage: 50,\n        type: SearchTypeDefault.fromJson(\"default\"),\n      ),\n    ],\n  ),\n);",
      "search for a single facet request with all parameters": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForFacets(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        type: SearchTypeFacet.fromJson(\"facet\"),\n        facet: \"theFacet\",\n        facetQuery: \"theFacetQuery\",\n        query: \"theQuery\",\n        maxFacetHits: 50,\n      ),\n    ],\n    strategy: SearchStrategy.fromJson(\"stopIfEnoughMatches\"),\n  ),\n);",
      "search for multiple mixed requests in multiple indices with minimal parameters": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n      ),\n      SearchForFacets(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        type: SearchTypeFacet.fromJson(\"facet\"),\n        facet: \"theFacet\",\n      ),\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        type: SearchTypeDefault.fromJson(\"default\"),\n      ),\n    ],\n    strategy: SearchStrategy.fromJson(\"stopIfEnoughMatches\"),\n  ),\n);",
      "search for multiple mixed requests in multiple indices with all parameters": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForFacets(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        type: SearchTypeFacet.fromJson(\"facet\"),\n        facet: \"theFacet\",\n        facetQuery: \"theFacetQuery\",\n        query: \"theQuery\",\n        maxFacetHits: 50,\n      ),\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        query: \"myQuery\",\n        hitsPerPage: 50,\n        type: SearchTypeDefault.fromJson(\"default\"),\n      ),\n    ],\n    strategy: SearchStrategy.fromJson(\"stopIfEnoughMatches\"),\n  ),\n);",
      "search filters accept all of the possible shapes": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        facetFilters: \"mySearch:filters\",\n        reRankingApplyFilter: \"mySearch:filters\",\n        tagFilters: \"mySearch:filters\",\n        numericFilters: \"mySearch:filters\",\n        optionalFilters: \"mySearch:filters\",\n      ),\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        facetFilters: [\n          \"mySearch:filters\",\n          [\n            \"mySearch:filters\",\n            [\n              \"mySearch:filters\",\n            ],\n          ],\n        ],\n        reRankingApplyFilter: [\n          \"mySearch:filters\",\n          [\n            \"mySearch:filters\",\n          ],\n        ],\n        tagFilters: [\n          \"mySearch:filters\",\n          [\n            \"mySearch:filters\",\n          ],\n        ],\n        numericFilters: [\n          \"mySearch:filters\",\n          [\n            \"mySearch:filters\",\n          ],\n        ],\n        optionalFilters: [\n          \"mySearch:filters\",\n          [\n            \"mySearch:filters\",\n          ],\n        ],\n      ),\n    ],\n  ),\n);",
      "search filters end to end": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        filters: \"editor:'visual studio' OR editor:neovim\",\n      ),\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        facetFilters: [\n          \"editor:'visual studio'\",\n          \"editor:neovim\",\n        ],\n      ),\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        facetFilters: [\n          \"editor:'visual studio'\",\n          [\n            \"editor:neovim\",\n          ],\n        ],\n      ),\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        facetFilters: [\n          \"editor:'visual studio'\",\n          [\n            \"editor:neovim\",\n            [\n              \"editor:goland\",\n            ],\n          ],\n        ],\n      ),\n    ],\n  ),\n);",
      "search with all search parameters": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        advancedSyntax: true,\n        advancedSyntaxFeatures: [\n          AdvancedSyntaxFeatures.fromJson(\"exactPhrase\"),\n        ],\n        allowTyposOnNumericTokens: true,\n        alternativesAsExact: [\n          AlternativesAsExact.fromJson(\"multiWordsSynonym\"),\n        ],\n        analytics: true,\n        analyticsTags: [\n          \"\",\n        ],\n        aroundLatLng: \"\",\n        aroundLatLngViaIP: true,\n        aroundPrecision: 0,\n        aroundRadius: AroundRadiusAll.fromJson(\"all\"),\n        attributeCriteriaComputedByMinProximity: true,\n        attributesToHighlight: [\n          \"\",\n        ],\n        attributesToRetrieve: [\n          \"\",\n        ],\n        attributesToSnippet: [\n          \"\",\n        ],\n        clickAnalytics: true,\n        decompoundQuery: true,\n        disableExactOnAttributes: [\n          \"\",\n        ],\n        disableTypoToleranceOnAttributes: [\n          \"\",\n        ],\n        distinct: 0,\n        enableABTest: true,\n        enablePersonalization: true,\n        enableReRanking: true,\n        enableRules: true,\n        exactOnSingleWordQuery: ExactOnSingleWordQuery.fromJson(\"attribute\"),\n        facetFilters: [\n          \"\",\n        ],\n        facetingAfterDistinct: true,\n        facets: [\n          \"\",\n        ],\n        filters: \"\",\n        getRankingInfo: true,\n        highlightPostTag: \"\",\n        highlightPreTag: \"\",\n        hitsPerPage: 1,\n        ignorePlurals: false,\n        indexName: \"<YOUR_INDEX_NAME>\",\n        insideBoundingBox: [\n          [\n            47.3165,\n            4.9665,\n            47.3424,\n            5.0201,\n          ],\n          [\n            40.9234,\n            2.1185,\n            38.643,\n            1.9916,\n          ],\n        ],\n        insidePolygon: [\n          [\n            47.3165,\n            4.9665,\n            47.3424,\n            5.0201,\n            47.32,\n            4.9,\n          ],\n          [\n            40.9234,\n            2.1185,\n            38.643,\n            1.9916,\n            39.2587,\n            2.0104,\n          ],\n        ],\n        length: 1,\n        maxValuesPerFacet: 0,\n        minProximity: 1,\n        minWordSizefor1Typo: 0,\n        minWordSizefor2Typos: 0,\n        minimumAroundRadius: 1,\n        naturalLanguages: [\n          SupportedLanguage.fromJson(\"fr\"),\n        ],\n        numericFilters: [\n          \"\",\n        ],\n        offset: 0,\n        optionalFilters: [\n          \"\",\n        ],\n        optionalWords: [\n          \"\",\n        ],\n        page: 0,\n        percentileComputation: true,\n        personalizationImpact: 0,\n        query: \"\",\n        queryLanguages: [\n          SupportedLanguage.fromJson(\"fr\"),\n        ],\n        queryType: QueryType.fromJson(\"prefixAll\"),\n        ranking: [\n          \"\",\n        ],\n        reRankingApplyFilter: [\n          \"\",\n        ],\n        relevancyStrictness: 0,\n        removeStopWords: true,\n        removeWordsIfNoResults:\n            RemoveWordsIfNoResults.fromJson(\"allOptional\"),\n        renderingContent: RenderingContent(\n          facetOrdering: FacetOrdering(\n            facets: Facets(\n              order: [\n                \"a\",\n                \"b\",\n              ],\n            ),\n            values: {\n              'a': Value(\n                order: [\n                  \"b\",\n                ],\n                sortRemainingBy: SortRemainingBy.fromJson(\"count\"),\n              ),\n            },\n          ),\n        ),\n        replaceSynonymsInHighlight: true,\n        responseFields: [\n          \"\",\n        ],\n        restrictHighlightAndSnippetArrays: true,\n        restrictSearchableAttributes: [\n          \"\",\n        ],\n        ruleContexts: [\n          \"\",\n        ],\n        similarQuery: \"\",\n        snippetEllipsisText: \"\",\n        sortFacetValuesBy: \"\",\n        sumOrFiltersScores: true,\n        synonyms: true,\n        tagFilters: [\n          \"\",\n        ],\n        type: SearchTypeDefault.fromJson(\"default\"),\n        typoTolerance: TypoToleranceEnum.fromJson(\"min\"),\n        userToken: \"\",\n      ),\n    ],\n  ),\n);"
    },
    "searchDictionaryEntries": {
      "get searchDictionaryEntries results with minimal parameters": "final response = await client.searchDictionaryEntries(\n  dictionaryName: DictionaryType.fromJson(\"stopwords\"),\n  searchDictionaryEntriesParams: SearchDictionaryEntriesParams(\n    query: \"about\",\n  ),\n);",
      "get searchDictionaryEntries results with all parameters": "final response = await client.searchDictionaryEntries(\n  dictionaryName: DictionaryType.fromJson(\"compounds\"),\n  searchDictionaryEntriesParams: SearchDictionaryEntriesParams(\n    query: \"foo\",\n    page: 4,\n    hitsPerPage: 2,\n    language: SupportedLanguage.fromJson(\"fr\"),\n  ),\n);"
    },
    "searchForFacetValues": {
      "get searchForFacetValues results with minimal parameters": "final response = await client.searchForFacetValues(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  facetName: \"facetName\",\n);",
      "get searchForFacetValues results with all parameters": "final response = await client.searchForFacetValues(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  facetName: \"facetName\",\n  searchForFacetValuesRequest: SearchForFacetValuesRequest(\n    params: \"query=foo&facetFilters=['bar']\",\n    facetQuery: \"foo\",\n    maxFacetHits: 42,\n  ),\n);",
      "facetName and facetQuery": "final response = await client.searchForFacetValues(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  facetName: \"author\",\n  searchForFacetValuesRequest: SearchForFacetValuesRequest(\n    facetQuery: \"stephen\",\n  ),\n);"
    },
    "searchRules": {
      "default": "final response = await client.searchRules(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchRulesParams: SearchRulesParams(\n    query: \"zorro\",\n  ),\n);"
    },
    "searchSingleIndex": {
      "search with minimal parameters": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);",
      "search with special characters in indexName": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);",
      "search with searchParams": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"myQuery\",\n    facetFilters: [\n      \"tags:algolia\",\n    ],\n  ),\n);",
      "single search retrieve snippets": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"batman mask of the phantasm\",\n    attributesToRetrieve: [\n      \"*\",\n    ],\n    attributesToSnippet: [\n      \"*:20\",\n    ],\n  ),\n);",
      "query": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"phone\",\n  ),\n);",
      "filters": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    filters: \"country:US AND price.gross < 2.0\",\n  ),\n);",
      "filters for stores": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"ben\",\n    filters: \"categories:politics AND store:Gibert Joseph Saint-Michel\",\n  ),\n);",
      "filters boolean": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    filters: \"is_available:true\",\n  ),\n);",
      "distinct": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    distinct: true,\n  ),\n);",
      "filtersNumeric": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    filters: \"price < 10\",\n  ),\n);",
      "filtersTimestamp": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    filters: \"NOT date_timestamp:1514764800 TO 1546300799\",\n  ),\n);",
      "filtersSumOrFiltersScoresFalse": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    filters:\n        \"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\",\n    sumOrFiltersScores: false,\n  ),\n);",
      "filtersSumOrFiltersScoresTrue": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    filters:\n        \"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\",\n    sumOrFiltersScores: true,\n  ),\n);",
      "filtersStephenKing": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    filters: \"author:\\\"Stephen King\\\"\",\n  ),\n);",
      "filtersNotTags": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"harry\",\n    filters: \"_tags:non-fiction\",\n  ),\n);",
      "facetFiltersList": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    facetFilters: [\n      \"publisher:Penguin\",\n      [\n        \"author:Stephen King\",\n        \"genre:Horror\",\n      ],\n    ],\n  ),\n);",
      "facetFiltersBook": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    facetFilters: [\n      \"category:Book\",\n    ],\n  ),\n);",
      "facetFiltersAND": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    facetFilters: [\n      \"category:Book\",\n      \"author:John Doe\",\n    ],\n  ),\n);",
      "facetFiltersOR": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    facetFilters: [\n      [\n        \"category:Book\",\n        \"author:John Doe\",\n      ],\n    ],\n  ),\n);",
      "facetFiltersCombined": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    facetFilters: [\n      \"author:John Doe\",\n      [\n        \"category:Book\",\n        \"category:Movie\",\n      ],\n    ],\n  ),\n);",
      "facetFiltersNeg": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    facetFilters: \"category:-Ebook\",\n  ),\n);",
      "filtersAndFacetFilters": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    filters: \"(author:\\\"Stephen King\\\" OR genre:\\\"Horror\\\")\",\n    facetFilters: [\n      \"publisher:Penguin\",\n    ],\n  ),\n);",
      "facet author genre": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    facets: [\n      \"author\",\n      \"genre\",\n    ],\n  ),\n);",
      "facet wildcard": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    facets: [\n      \"*\",\n    ],\n  ),\n);",
      "maxValuesPerFacet": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    maxValuesPerFacet: 1000,\n  ),\n);",
      "aroundLatLng": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    aroundLatLng: \"40.71, -74.01\",\n  ),\n);",
      "aroundLatLngViaIP": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    aroundLatLngViaIP: true,\n  ),\n);",
      "aroundRadius": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    aroundLatLng: \"40.71, -74.01\",\n    aroundRadius: 1000000,\n  ),\n);",
      "insideBoundingBox": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    insideBoundingBox: [\n      [\n        49.067996905313834,\n        65.73828125,\n        25.905859247243498,\n        128.8046875,\n      ],\n    ],\n  ),\n);",
      "insidePolygon": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    insidePolygon: [\n      [\n        42.01,\n        -124.31,\n        48.835509470063045,\n        -124.40453125000005,\n        45.01082951668149,\n        -65.95726562500005,\n        31.247243545293433,\n        -81.06578125000004,\n        25.924152577235226,\n        -97.68234374999997,\n        32.300311895879545,\n        -117.54828125,\n      ],\n    ],\n  ),\n);",
      "optionalFilters": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    optionalFilters: [\n      \"can_deliver_quickly:true\",\n    ],\n  ),\n);",
      "optionalFiltersMany": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    optionalFilters: [\n      \"brand:Apple<score=3>\",\n      \"brand:Samsung<score=2>\",\n      \"brand:-Huawei\",\n    ],\n  ),\n);",
      "optionalFiltersSimple": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    optionalFilters: [\n      \"brand:Apple<score=2>\",\n      \"type:tablet\",\n    ],\n  ),\n);",
      "restrictSearchableAttributes": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    restrictSearchableAttributes: [\n      \"title_fr\",\n    ],\n  ),\n);",
      "getRankingInfo": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    getRankingInfo: true,\n  ),\n);",
      "clickAnalytics": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    clickAnalytics: true,\n  ),\n);",
      "clickAnalyticsUserToken": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    clickAnalytics: true,\n    userToken: \"user-1\",\n  ),\n);",
      "enablePersonalization": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    enablePersonalization: true,\n    userToken: \"user-1\",\n  ),\n);",
      "userToken": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    userToken: \"user-1\",\n  ),\n);",
      "userToken1234": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    userToken: \"user-1234\",\n  ),\n);",
      "analyticsTag": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    analyticsTags: [\n      \"YOUR_ANALYTICS_TAG\",\n    ],\n  ),\n);",
      "facetFiltersUsers": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    facetFilters: [\n      \"user:user42\",\n      \"user:public\",\n    ],\n  ),\n);",
      "buildTheQuery": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    filters: \"categoryPageId: Men's Clothing\",\n    hitsPerPage: 50,\n    analyticsTags: [\n      \"mens-clothing\",\n    ],\n  ),\n);",
      "attributesToHighlightOverride": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    attributesToHighlight: [\n      \"title\",\n      \"content\",\n    ],\n  ),\n);",
      "disableTypoToleranceOnAttributes": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    disableTypoToleranceOnAttributes: [\n      \"serial_number\",\n    ],\n  ),\n);",
      "search_a_query": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"\",\n    similarQuery:\n        \"Comedy Drama Crime McDormand Macy Buscemi Stormare Presnell Coen\",\n    filters: \"year:1991 TO 2001\",\n  ),\n);",
      "search_everything": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"\",\n  ),\n);",
      "api_filtering_range_example": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"books\",\n    filters: \"price:10 TO 20\",\n  ),\n);",
      "override_retrievable_attributes": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    attributesToRetrieve: [\n      \"title\",\n      \"content\",\n    ],\n  ),\n);",
      "restrict_searchable_attributes": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    restrictSearchableAttributes: [\n      \"title\",\n      \"author\",\n    ],\n  ),\n);",
      "override_default_relevancy": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    relevancyStrictness: 70,\n  ),\n);",
      "apply_filters": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    sumOrFiltersScores: true,\n  ),\n);",
      "apply_all_filters": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    filters:\n        \"available = 1 AND (category:Book OR NOT category:Ebook) AND _tags:published AND publication_date:1441745506 TO 1441755506 AND inStock > 0 AND author:\\\"John Doe\\\"\",\n  ),\n);",
      "escape_spaces": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    filters: \"category:\\\"Books and Comics\\\"\",\n  ),\n);",
      "escape_keywords": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    filters: \"keyword:\\\"OR\\\"\",\n  ),\n);",
      "escape_single_quotes": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    filters: \"content:\\\"It's a wonderful day\\\"\",\n  ),\n);",
      "escape_double_quotes": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    filters: \"content:\\\"She said \\\"Hello World\\\"\",\n  ),\n);",
      "apply_negative_filters": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    optionalFilters: [\n      \"category:Book\",\n      \"author:-John Doe\",\n    ],\n  ),\n);",
      "apply_negative_filters_restaurants": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    optionalFilters: [\n      \"restaurant:-Bert's Inn\",\n    ],\n  ),\n);",
      "apply_numeric_filters": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    numericFilters: [\n      \"price < 1000\",\n      [\n        \"inStock = 1\",\n        \"deliveryDate < 1441755506\",\n      ],\n    ],\n  ),\n);",
      "apply_tag_filters": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    tagFilters: [\n      \"SciFi\",\n      [\n        \"Book\",\n        \"Movie\",\n      ],\n    ],\n  ),\n);",
      "facets_all": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    facets: [\n      \"*\",\n    ],\n  ),\n);",
      "retrieve_only_some_facets": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    facets: [\n      \"category\",\n      \"author\",\n    ],\n  ),\n);",
      "override_default_max_values_per_facet": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    maxValuesPerFacet: 20,\n  ),\n);",
      "enable_faceting_after_distinct": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    facetingAfterDistinct: true,\n  ),\n);",
      "sort_facet_values_alphabetically": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    sortFacetValuesBy: \"count\",\n  ),\n);",
      "override_attributes_to_snippet": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    attributesToSnippet: [\n      \"title\",\n      \"content:80\",\n    ],\n  ),\n);",
      "override_default_highlight_pre_tag": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    highlightPreTag: \"<strong>\",\n  ),\n);",
      "override_default_highlight_post_tag": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    highlightPostTag: \"</strong>\",\n  ),\n);",
      "override_default_snippet_ellipsis_text": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    snippetEllipsisText: \"\",\n  ),\n);",
      "enable_restrict_highlight_and_snippet_arrays": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    restrictHighlightAndSnippetArrays: false,\n  ),\n);",
      "access_page": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    page: 0,\n  ),\n);",
      "override_default_hits_per_page": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    hitsPerPage: 10,\n  ),\n);",
      "get_nth_hit": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    offset: 4,\n  ),\n);",
      "get_n_results": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    length: 4,\n  ),\n);",
      "override_default_min_word_size_for_one_typo": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    minWordSizefor1Typo: 2,\n  ),\n);",
      "override_default_min_word_size_for_two_typos": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    minWordSizefor2Typos: 2,\n  ),\n);",
      "override_default_typo_tolerance_mode": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    typoTolerance: false,\n  ),\n);",
      "disable_typos_on_numeric_tokens_at_search_time": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    allowTyposOnNumericTokens: false,\n  ),\n);",
      "search_around_a_position": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    aroundLatLng: \"40.71, -74.01\",\n  ),\n);",
      "search_around_server_ip": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    aroundLatLngViaIP: true,\n  ),\n  requestOptions: RequestOptions(\n    headers: {\n      'x-forwarded-for':\n          '94.228.178.246 // should be replaced with the actual IP you would like to search around',\n    },\n  ),\n);",
      "set_around_radius": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    aroundRadius: 1000,\n  ),\n);",
      "disable_automatic_radius": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    aroundRadius: AroundRadiusAll.fromJson(\"all\"),\n  ),\n);",
      "set_geo_search_precision": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    aroundPrecision: 100,\n  ),\n);",
      "set_geo_search_precision_non_linear": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    aroundPrecision: [\n      Range(\n        from: 0,\n        value: 25,\n      ),\n      Range(\n        from: 2000,\n        value: 1000,\n      ),\n    ],\n  ),\n);",
      "set_minimum_geo_search_radius": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    minimumAroundRadius: 1000,\n  ),\n);",
      "search_inside_rectangular_area": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    insideBoundingBox: [\n      [\n        46.650828100116044,\n        7.123046875,\n        45.17210966999772,\n        1.009765625,\n      ],\n    ],\n  ),\n);",
      "search_inside_multiple_rectangular_areas": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    insideBoundingBox: [\n      [\n        46.650828100116044,\n        7.123046875,\n        45.17210966999772,\n        1.009765625,\n      ],\n      [\n        49.62625916704081,\n        4.6181640625,\n        47.715070300900194,\n        0.482421875,\n      ],\n    ],\n  ),\n);",
      "search_inside_polygon_area": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    insidePolygon: [\n      [\n        46.650828100116044,\n        7.123046875,\n        45.17210966999772,\n        1.009765625,\n        49.62625916704081,\n        4.6181640625,\n      ],\n    ],\n  ),\n);",
      "search_inside_multiple_polygon_areas": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    insidePolygon: [\n      [\n        46.650828100116044,\n        7.123046875,\n        45.17210966999772,\n        1.009765625,\n        49.62625916704081,\n        4.6181640625,\n      ],\n      [\n        49.62625916704081,\n        4.6181640625,\n        47.715070300900194,\n        0.482421875,\n        45.17210966999772,\n        1.009765625,\n        50.62626704081,\n        4.6181640625,\n      ],\n    ],\n  ),\n);",
      "set_querylanguages_override": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    removeStopWords: [\n      SupportedLanguage.fromJson(\"ca\"),\n      SupportedLanguage.fromJson(\"es\"),\n    ],\n  ),\n);",
      "set_querylanguages_with_japanese_query": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    queryLanguages: [\n      SupportedLanguage.fromJson(\"ja\"),\n      SupportedLanguage.fromJson(\"en\"),\n    ],\n  ),\n);",
      "set_natural_languages": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"\",\n    naturalLanguages: [\n      SupportedLanguage.fromJson(\"fr\"),\n    ],\n  ),\n);",
      "override_natural_languages_with_query": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"\",\n    naturalLanguages: [\n      SupportedLanguage.fromJson(\"fr\"),\n    ],\n    removeWordsIfNoResults: RemoveWordsIfNoResults.fromJson(\"firstWords\"),\n  ),\n);",
      "enable_decompound_query_search_time": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    decompoundQuery: true,\n  ),\n);",
      "enable_rules_search_time": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    enableRules: true,\n  ),\n);",
      "set_rule_contexts": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    ruleContexts: [\n      \"front_end\",\n      \"website2\",\n    ],\n  ),\n);",
      "enable_personalization": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    enablePersonalization: true,\n  ),\n);",
      "enable_personalization_with_user_token": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    enablePersonalization: true,\n    userToken: \"123456\",\n  ),\n);",
      "personalization_impact": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    personalizationImpact: 20,\n  ),\n);",
      "set_user_token": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    userToken: \"123456\",\n  ),\n);",
      "set_user_token_with_personalization": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    enablePersonalization: true,\n    userToken: \"123456\",\n  ),\n);",
      "override_default_query_type": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    queryType: QueryType.fromJson(\"prefixAll\"),\n  ),\n);",
      "override_default_remove_words_if_no_results": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    removeWordsIfNoResults: RemoveWordsIfNoResults.fromJson(\"lastWords\"),\n  ),\n);",
      "enable_advanced_syntax_search_time": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    advancedSyntax: true,\n  ),\n);",
      "overide_default_optional_words": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    optionalWords: [\n      \"toyota\",\n      \"2020 2021\",\n    ],\n  ),\n);",
      "disabling_exact_for_some_attributes_search_time": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    disableExactOnAttributes: [\n      \"description\",\n    ],\n  ),\n);",
      "override_default_exact_single_word_query": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    exactOnSingleWordQuery: ExactOnSingleWordQuery.fromJson(\"none\"),\n  ),\n);",
      "override_default_aternative_as_exact": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    alternativesAsExact: [\n      AlternativesAsExact.fromJson(\"multiWordsSynonym\"),\n    ],\n  ),\n);",
      "enable_advanced_syntax_exact_phrase": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    advancedSyntax: true,\n    advancedSyntaxFeatures: [\n      AdvancedSyntaxFeatures.fromJson(\"exactPhrase\"),\n    ],\n  ),\n);",
      "enable_advanced_syntax_exclude_words": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    advancedSyntax: true,\n    advancedSyntaxFeatures: [\n      AdvancedSyntaxFeatures.fromJson(\"excludeWords\"),\n    ],\n  ),\n);",
      "override_distinct": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    distinct: 0,\n  ),\n);",
      "get_ranking_info": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    getRankingInfo: true,\n  ),\n);",
      "disable_click_analytics": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    clickAnalytics: false,\n  ),\n);",
      "enable_click_analytics": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    clickAnalytics: true,\n  ),\n);",
      "disable_analytics": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    analytics: false,\n  ),\n);",
      "add_analytics_tags": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    analyticsTags: [\n      \"front_end\",\n      \"website2\",\n    ],\n  ),\n);",
      "disable_synonyms": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    synonyms: false,\n  ),\n);",
      "override_replace_synonyms_in_highlights": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    replaceSynonymsInHighlight: true,\n  ),\n);",
      "override_min_proximity": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    minProximity: 2,\n  ),\n);",
      "override_default_field": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    responseFields: [\n      \"hits\",\n      \"facets\",\n    ],\n  ),\n);",
      "override_percentile_computation": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    percentileComputation: false,\n  ),\n);",
      "set_ab_test": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    enableABTest: false,\n  ),\n);",
      "set_enable_re_ranking": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n    enableReRanking: false,\n  ),\n);",
      "with algolia user id": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"query\",\n  ),\n  requestOptions: RequestOptions(\n    headers: {\n      'X-Algolia-User-ID': 'user1234',\n    },\n  ),\n);",
      "mcm with algolia user id": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchParams: SearchParamsObject(\n    query: \"peace\",\n  ),\n  requestOptions: RequestOptions(\n    headers: {\n      'X-Algolia-User-ID': 'user42',\n    },\n  ),\n);"
    },
    "searchSynonyms": {
      "searchSynonyms with minimal parameters": "final response = await client.searchSynonyms(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);",
      "searchSynonyms with all parameters": "final response = await client.searchSynonyms(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchSynonymsParams: SearchSynonymsParams(\n    query: \"myQuery\",\n    type: SynonymType.fromJson(\"altcorrection1\"),\n    page: 10,\n    hitsPerPage: 10,\n  ),\n);"
    },
    "searchUserIds": {
      "default": "final response = await client.searchUserIds(\n  searchUserIdsParams: SearchUserIdsParams(\n    query: \"test\",\n    clusterName: \"theClusterName\",\n    page: 5,\n    hitsPerPage: 10,\n  ),\n);"
    },
    "setClientApiKey": {
      "default": "client.setClientApiKey(\n  apiKey: \"updated-api-key\",\n);"
    },
    "setDictionarySettings": {
      "get setDictionarySettings results with minimal parameters": "final response = await client.setDictionarySettings(\n  dictionarySettingsParams: DictionarySettingsParams(\n    disableStandardEntries: StandardEntries(\n      plurals: {\n        'fr': false,\n        'en': false,\n        'ru': true,\n      },\n    ),\n  ),\n);",
      "get setDictionarySettings results with all parameters": "final response = await client.setDictionarySettings(\n  dictionarySettingsParams: DictionarySettingsParams(\n    disableStandardEntries: StandardEntries(\n      plurals: {\n        'fr': false,\n        'en': false,\n        'ru': true,\n      },\n      stopwords: {\n        'fr': false,\n      },\n      compounds: {\n        'ru': true,\n      },\n    ),\n  ),\n);"
    },
    "setSettings": {
      "minimal parameters": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    paginationLimitedTo: 10,\n  ),\n  forwardToReplicas: true,\n);",
      "boolean typoTolerance": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    typoTolerance: true,\n  ),\n  forwardToReplicas: true,\n);",
      "enum typoTolerance": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    typoTolerance: TypoToleranceEnum.fromJson(\"min\"),\n  ),\n  forwardToReplicas: true,\n);",
      "ignorePlurals": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    ignorePlurals: true,\n  ),\n  forwardToReplicas: true,\n);",
      "list of string ignorePlurals": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    ignorePlurals: [\n      SupportedLanguage.fromJson(\"fr\"),\n    ],\n  ),\n  forwardToReplicas: true,\n);",
      "removeStopWords boolean": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    removeStopWords: true,\n  ),\n  forwardToReplicas: true,\n);",
      "removeStopWords list of string": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    removeStopWords: [\n      SupportedLanguage.fromJson(\"fr\"),\n    ],\n  ),\n  forwardToReplicas: true,\n);",
      "boolean distinct": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    distinct: true,\n  ),\n  forwardToReplicas: true,\n);",
      "integer distinct": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    distinct: 1,\n  ),\n  forwardToReplicas: true,\n);",
      "distinct company": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributeForDistinct: \"company\",\n    distinct: true,\n  ),\n);",
      "distinct design": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributeForDistinct: \"design\",\n    distinct: true,\n  ),\n);",
      "distinct true": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    distinct: true,\n  ),\n);",
      "distinct section": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributeForDistinct: \"section\",\n    distinct: true,\n  ),\n);",
      "attributesForFaceting allergens": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesForFaceting: [\n      \"allergens\",\n    ],\n  ),\n);",
      "attributesForFaceting availableIn": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesForFaceting: [\n      \"color\",\n      \"availableIn\",\n    ],\n  ),\n);",
      "api_attributes_for_faceting": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesForFaceting: [\n      \"genre\",\n      \"author\",\n    ],\n  ),\n);",
      "api_attributes_for_faceting_searchable": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesForFaceting: [\n      \"genre\",\n      \"searchable(author)\",\n    ],\n  ),\n);",
      "api_attributes_for_filter_only": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesForFaceting: [\n      \"filterOnly(genre)\",\n      \"author\",\n    ],\n  ),\n);",
      "attributesForFaceting categoryPageId": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesForFaceting: [\n      \"searchable(categoryPageId)\",\n    ],\n  ),\n);",
      "unretrievableAttributes": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    unretrievableAttributes: [\n      \"visible_by\",\n    ],\n  ),\n);",
      "attributesForFaceting user restricted data": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesForFaceting: [\n      \"filterOnly(visible_by)\",\n    ],\n  ),\n);",
      "attributesForFaceting optional filters": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesForFaceting: [\n      \"can_deliver_quickly\",\n      \"restaurant\",\n    ],\n  ),\n);",
      "attributesForFaceting redirect index": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesForFaceting: [\n      \"query_terms\",\n    ],\n  ),\n);",
      "attributesForFaceting multiple consequences": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesForFaceting: [\n      \"director\",\n    ],\n  ),\n);",
      "attributesForFaceting in-depth optional filters": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesForFaceting: [\n      \"filterOnly(brand)\",\n    ],\n  ),\n);",
      "mode neuralSearch": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    mode: Mode.fromJson(\"neuralSearch\"),\n  ),\n);",
      "mode keywordSearch": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    mode: Mode.fromJson(\"keywordSearch\"),\n  ),\n);",
      "searchableAttributes same priority": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    searchableAttributes: [\n      \"title,comments\",\n      \"ingredients\",\n    ],\n  ),\n);",
      "searchableAttributes higher priority": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    searchableAttributes: [\n      \"title\",\n      \"ingredients\",\n    ],\n  ),\n);",
      "customRanking retweets": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    customRanking: [\n      \"desc(retweets)\",\n      \"desc(likes)\",\n    ],\n  ),\n);",
      "customRanking boosted": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    customRanking: [\n      \"desc(boosted)\",\n    ],\n  ),\n);",
      "customRanking pageviews": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    customRanking: [\n      \"desc(pageviews)\",\n      \"desc(comments)\",\n    ],\n  ),\n);",
      "customRanking applying search parameters for a specific query": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    customRanking: [\n      \"desc(nb_airline_liaisons)\",\n    ],\n    attributesForFaceting: [\n      \"city, country\",\n    ],\n  ),\n);",
      "customRanking rounded pageviews": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    customRanking: [\n      \"desc(rounded_pageviews)\",\n      \"desc(comments)\",\n    ],\n  ),\n);",
      "customRanking price": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    customRanking: [\n      \"desc(price)\",\n    ],\n  ),\n);",
      "ranking exhaustive (price)": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    ranking: [\n      \"desc(price)\",\n      \"typo\",\n      \"geo\",\n      \"words\",\n      \"filters\",\n      \"proximity\",\n      \"attribute\",\n      \"exact\",\n      \"custom\",\n    ],\n  ),\n);",
      "ranking exhaustive (is_popular)": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    ranking: [\n      \"desc(is_popular)\",\n      \"typo\",\n      \"geo\",\n      \"words\",\n      \"filters\",\n      \"proximity\",\n      \"attribute\",\n      \"exact\",\n      \"custom\",\n    ],\n  ),\n);",
      "ranking standard replica": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    ranking: [\n      \"desc(post_date_timestamp)\",\n    ],\n  ),\n);",
      "ranking virtual replica": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    customRanking: [\n      \"desc(post_date_timestamp)\",\n    ],\n  ),\n);",
      "customRanking and ranking sort alphabetically": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    customRanking: [\n      \"asc(textual_attribute)\",\n    ],\n    ranking: [\n      \"custom\",\n      \"typo\",\n      \"geo\",\n      \"words\",\n      \"filters\",\n      \"proximity\",\n      \"attribute\",\n      \"exact\",\n    ],\n  ),\n);",
      "relevancyStrictness": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    customRanking: [\n      \"asc(textual_attribute)\",\n    ],\n    relevancyStrictness: 0,\n  ),\n);",
      "create replica index": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    replicas: [\n      \"products_price_desc\",\n    ],\n  ),\n);",
      "create replica index articles": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    replicas: [\n      \"articles_date_desc\",\n    ],\n  ),\n);",
      "create virtual replica index": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    replicas: [\n      \"virtual(products_price_desc)\",\n    ],\n  ),\n);",
      "unlink replica index": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    replicas: [\n      \"\",\n    ],\n  ),\n);",
      "forwardToReplicas": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    searchableAttributes: [\n      \"name\",\n      \"description\",\n    ],\n  ),\n  forwardToReplicas: true,\n);",
      "maxValuesPerFacet": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    maxValuesPerFacet: 1000,\n  ),\n);",
      "maxFacetHits": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    maxFacetHits: 100,\n  ),\n);",
      "attributesForFaceting complex": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesForFaceting: [\n      \"actor\",\n      \"filterOnly(category)\",\n      \"searchable(publisher)\",\n    ],\n  ),\n);",
      "ranking closest dates": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    ranking: [\n      \"asc(date_timestamp)\",\n      \"typo\",\n      \"geo\",\n      \"words\",\n      \"filters\",\n      \"proximity\",\n      \"attribute\",\n      \"exact\",\n      \"custom\",\n    ],\n  ),\n);",
      "searchableAttributes item variation": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    searchableAttributes: [\n      \"design\",\n      \"type\",\n      \"color\",\n    ],\n  ),\n);",
      "searchableAttributes around location": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    searchableAttributes: [\n      \"name\",\n      \"country\",\n      \"city\",\n      \"iata_code\",\n    ],\n    customRanking: [\n      \"desc(links_count)\",\n    ],\n  ),\n);",
      "attributesToHighlight": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesToHighlight: [\n      \"author\",\n      \"title\",\n      \"content\",\n    ],\n  ),\n);",
      "attributesToHighlightStar": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesToHighlight: [\n      \"*\",\n    ],\n  ),\n);",
      "everything": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    advancedSyntax: true,\n    advancedSyntaxFeatures: [\n      AdvancedSyntaxFeatures.fromJson(\"exactPhrase\"),\n    ],\n    allowCompressionOfIntegerArray: true,\n    allowTyposOnNumericTokens: true,\n    alternativesAsExact: [\n      AlternativesAsExact.fromJson(\"singleWordSynonym\"),\n    ],\n    attributeCriteriaComputedByMinProximity: true,\n    attributeForDistinct: \"test\",\n    attributesForFaceting: [\n      \"algolia\",\n    ],\n    attributesToHighlight: [\n      \"algolia\",\n    ],\n    attributesToRetrieve: [\n      \"algolia\",\n    ],\n    attributesToSnippet: [\n      \"algolia\",\n    ],\n    attributesToTransliterate: [\n      \"algolia\",\n    ],\n    camelCaseAttributes: [\n      \"algolia\",\n    ],\n    customNormalization: {\n      'algolia': {\n        'aloglia': \"aglolia\",\n      },\n    },\n    customRanking: [\n      \"algolia\",\n    ],\n    decompoundQuery: false,\n    decompoundedAttributes: {\n      'algolia': \"aloglia\",\n    },\n    disableExactOnAttributes: [\n      \"algolia\",\n    ],\n    disablePrefixOnAttributes: [\n      \"algolia\",\n    ],\n    disableTypoToleranceOnAttributes: [\n      \"algolia\",\n    ],\n    disableTypoToleranceOnWords: [\n      \"algolia\",\n    ],\n    distinct: 3,\n    enablePersonalization: true,\n    enableReRanking: false,\n    enableRules: true,\n    exactOnSingleWordQuery: ExactOnSingleWordQuery.fromJson(\"attribute\"),\n    highlightPreTag: \"<span>\",\n    highlightPostTag: \"</span>\",\n    hitsPerPage: 10,\n    ignorePlurals: false,\n    indexLanguages: [\n      SupportedLanguage.fromJson(\"fr\"),\n    ],\n    keepDiacriticsOnCharacters: \"abc\",\n    maxFacetHits: 20,\n    maxValuesPerFacet: 30,\n    minProximity: 6,\n    minWordSizefor1Typo: 5,\n    minWordSizefor2Typos: 11,\n    mode: Mode.fromJson(\"neuralSearch\"),\n    numericAttributesForFiltering: [\n      \"algolia\",\n    ],\n    optionalWords: [\n      \"myspace\",\n    ],\n    paginationLimitedTo: 0,\n    queryLanguages: [\n      SupportedLanguage.fromJson(\"fr\"),\n    ],\n    queryType: QueryType.fromJson(\"prefixLast\"),\n    ranking: [\n      \"geo\",\n    ],\n    reRankingApplyFilter: \"mySearch:filters\",\n    relevancyStrictness: 10,\n    removeStopWords: false,\n    removeWordsIfNoResults: RemoveWordsIfNoResults.fromJson(\"lastWords\"),\n    renderingContent: RenderingContent(\n      facetOrdering: FacetOrdering(\n        facets: Facets(\n          order: [\n            \"a\",\n            \"b\",\n          ],\n        ),\n        values: {\n          'a': Value(\n            order: [\n              \"b\",\n            ],\n            sortRemainingBy: SortRemainingBy.fromJson(\"count\"),\n          ),\n        },\n      ),\n    ),\n    replaceSynonymsInHighlight: true,\n    replicas: [\n      \"\",\n    ],\n    responseFields: [\n      \"algolia\",\n    ],\n    restrictHighlightAndSnippetArrays: true,\n    searchableAttributes: [\n      \"foo\",\n    ],\n    semanticSearch: SemanticSearch(\n      eventSources: [\n        \"foo\",\n      ],\n    ),\n    separatorsToIndex: \"bar\",\n    snippetEllipsisText: \"---\",\n    sortFacetValuesBy: \"date\",\n    typoTolerance: false,\n    unretrievableAttributes: [\n      \"foo\",\n    ],\n    userData: {\n      'user': \"data\",\n    },\n  ),\n);",
      "searchableAttributesWithCustomRankingsAndAttributesForFaceting": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    searchableAttributes: [\n      \"brand\",\n      \"name\",\n      \"categories\",\n      \"unordered(description)\",\n    ],\n    customRanking: [\n      \"desc(popularity)\",\n    ],\n    attributesForFaceting: [\n      \"searchable(brand)\",\n      \"type\",\n      \"categories\",\n      \"price\",\n    ],\n  ),\n);",
      "searchableAttributesOrdering": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    searchableAttributes: [\n      \"unordered(title)\",\n      \"cast\",\n    ],\n  ),\n);",
      "searchableAttributesProductReferenceSuffixes": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    searchableAttributes: [\n      \"name\",\n      \"product_reference\",\n      \"product_reference_suffixes\",\n    ],\n  ),\n);",
      "queryLanguageAndIgnorePlurals": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    queryLanguages: [\n      SupportedLanguage.fromJson(\"en\"),\n    ],\n    ignorePlurals: true,\n  ),\n);",
      "searchableAttributesInMovies": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    searchableAttributes: [\n      \"title_eng\",\n      \"title_fr\",\n      \"title_es\",\n    ],\n  ),\n);",
      "disablePrefixOnAttributes": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    disablePrefixOnAttributes: [\n      \"serial_number\",\n    ],\n  ),\n);",
      "disableTypoToleranceOnAttributes": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    disableTypoToleranceOnAttributes: [\n      \"serial_number\",\n    ],\n  ),\n);",
      "searchableAttributesSimpleExample": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    searchableAttributes: [\n      \"serial_number\",\n    ],\n  ),\n);",
      "searchableAttributesSimpleExampleAlt": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    searchableAttributes: [\n      \"serial_number\",\n      \"serial_number_suffixes\",\n    ],\n  ),\n);",
      "set_searchable_attributes": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesForFaceting: [\n      \"author\",\n      \"filterOnly(isbn)\",\n      \"searchable(edition)\",\n      \"afterDistinct(category)\",\n      \"afterDistinct(searchable(publisher))\",\n    ],\n  ),\n);",
      "unretrievable_attributes": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    unretrievableAttributes: [\n      \"total_number_of_sales\",\n    ],\n  ),\n);",
      "set_retrievable_attributes": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesToRetrieve: [\n      \"author\",\n      \"title\",\n      \"content\",\n    ],\n  ),\n);",
      "set_all_attributes_as_retrievable": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesToRetrieve: [\n      \"*\",\n    ],\n  ),\n);",
      "specify_attributes_not_to_retrieve": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesToRetrieve: [\n      \"*\",\n      \"-SKU\",\n      \"-internal_desc\",\n    ],\n  ),\n);",
      "neural_search": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    mode: Mode.fromJson(\"neuralSearch\"),\n  ),\n);",
      "keyword_search": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    mode: Mode.fromJson(\"keywordSearch\"),\n  ),\n);",
      "set_default_ranking": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    ranking: [\n      \"typo\",\n      \"geo\",\n      \"words\",\n      \"filters\",\n      \"attribute\",\n      \"proximity\",\n      \"exact\",\n      \"custom\",\n    ],\n  ),\n);",
      "set_ranking_by_attribute_asc": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    ranking: [\n      \"asc(price)\",\n      \"typo\",\n      \"geo\",\n      \"words\",\n      \"filters\",\n      \"proximity\",\n      \"attribute\",\n      \"exact\",\n      \"custom\",\n    ],\n  ),\n);",
      "set_ranking_by_attribute_desc": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    ranking: [\n      \"desc(price)\",\n      \"typo\",\n      \"geo\",\n      \"words\",\n      \"filters\",\n      \"proximity\",\n      \"attribute\",\n      \"exact\",\n      \"custom\",\n    ],\n  ),\n);",
      "restrict_searchable_attributes": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    customRanking: [\n      \"desc(popularity)\",\n      \"asc(price)\",\n    ],\n  ),\n);",
      "set_default_relevancy": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    relevancyStrictness: 90,\n  ),\n);",
      "set_replicas": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    replicas: [\n      \"name_of_replica_index1\",\n      \"name_of_replica_index2\",\n    ],\n  ),\n);",
      "set_default_max_values_per_facet": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    maxValuesPerFacet: 100,\n  ),\n);",
      "set_default_sort_facet_values_by": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    sortFacetValuesBy: \"alpha\",\n  ),\n);",
      "set_attributes_to_snippet": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesToSnippet: [\n      \"content:80\",\n      \"description\",\n    ],\n  ),\n);",
      "set_all_attributes_to_snippet": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesToSnippet: [\n      \"*:80\",\n    ],\n  ),\n);",
      "set_default_highlight_pre_tag": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    highlightPreTag: \"<em>\",\n  ),\n);",
      "set_default_highlight_post_tag": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    highlightPostTag: \"</em>\",\n  ),\n);",
      "set_default_snippet_ellipsis_text": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    snippetEllipsisText: \"…\",\n  ),\n);",
      "enable_restrict_highlight_and_snippet_arrays_by_default": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    restrictHighlightAndSnippetArrays: true,\n  ),\n);",
      "set_default_hits_per_page": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    hitsPerPage: 20,\n  ),\n);",
      "set_pagination_limit": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    paginationLimitedTo: 1000,\n  ),\n);",
      "set_default_min_word_size_for_one_typo": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    minWordSizefor1Typo: 4,\n  ),\n);",
      "set_default_min_word_size_for_two_typos": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    minWordSizefor2Typos: 4,\n  ),\n);",
      "set_default_typo_tolerance_mode": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    typoTolerance: true,\n  ),\n);",
      "disable_typos_on_numeric_tokens_by_default": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    allowTyposOnNumericTokens: false,\n  ),\n);",
      "disable_typo_tolerance_for_words": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    disableTypoToleranceOnWords: [\n      \"wheel\",\n      \"1X2BCD\",\n    ],\n  ),\n);",
      "set_separators_to_index": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    separatorsToIndex: \"+#\",\n  ),\n);",
      "set_languages_using_querylanguages": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    queryLanguages: [\n      SupportedLanguage.fromJson(\"es\"),\n    ],\n    removeStopWords: true,\n    ignorePlurals: true,\n  ),\n);",
      "set_attributes_to_transliterate": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    indexLanguages: [\n      SupportedLanguage.fromJson(\"ja\"),\n    ],\n    attributesToTransliterate: [\n      \"name\",\n      \"description\",\n    ],\n  ),\n);",
      "set_camel_case_attributes": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    camelCaseAttributes: [\n      \"description\",\n    ],\n  ),\n);",
      "set_decompounded_attributes": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    decompoundedAttributes: {\n      'de': [\n        \"name\",\n      ],\n    },\n  ),\n);",
      "set_decompounded_multiple_attributes": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    decompoundedAttributes: {\n      'de': [\n        \"name_de\",\n        \"description_de\",\n      ],\n      'fi': [\n        \"name_fi\",\n        \"description_fi\",\n      ],\n    },\n  ),\n);",
      "set_keep_diacritics_on_characters": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    keepDiacriticsOnCharacters: \"øé\",\n  ),\n);",
      "set_custom_normalization": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    customNormalization: {\n      'default': {\n        'ä': \"ae\",\n      },\n    },\n  ),\n);",
      "set_indexlanguages": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    indexLanguages: [\n      SupportedLanguage.fromJson(\"ja\"),\n    ],\n  ),\n);",
      "enable_decompound_query_by_default": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    decompoundQuery: true,\n  ),\n);",
      "enable_rules_syntax_by_default": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    enableRules: true,\n  ),\n);",
      "enable_personalization_settings": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    enablePersonalization: true,\n  ),\n);",
      "set_default_query_type": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    queryType: QueryType.fromJson(\"prefixLast\"),\n  ),\n);",
      "set_default_remove_words_if_no_result": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    removeWordsIfNoResults: RemoveWordsIfNoResults.fromJson(\"none\"),\n  ),\n);",
      "enable_advanced_syntax_by_default": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    advancedSyntax: true,\n  ),\n);",
      "set_default_optional_words": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    optionalWords: [\n      \"blue\",\n      \"iphone case\",\n    ],\n  ),\n);",
      "disabling_prefix_search_for_some_attributes_by_default": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    disablePrefixOnAttributes: [\n      \"sku\",\n    ],\n  ),\n);",
      "disabling_exact_for_some_attributes_by_default": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    disableExactOnAttributes: [\n      \"description\",\n    ],\n  ),\n);",
      "set_default_exact_single_word_query": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    exactOnSingleWordQuery: ExactOnSingleWordQuery.fromJson(\"attribute\"),\n  ),\n);",
      "set_default_aternative_as_exact": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    alternativesAsExact: [\n      AlternativesAsExact.fromJson(\"ignorePlurals\"),\n      AlternativesAsExact.fromJson(\"singleWordSynonym\"),\n    ],\n  ),\n);",
      "set_numeric_attributes_for_filtering": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    numericAttributesForFiltering: [\n      \"quantity\",\n      \"popularity\",\n    ],\n  ),\n);",
      "enable_compression_of_integer_array": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    allowCompressionOfIntegerArray: true,\n  ),\n);",
      "set_attributes_for_distinct": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributeForDistinct: \"url\",\n  ),\n);",
      "set_distinct": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    distinct: 1,\n    attributeForDistinct: \"url\",\n  ),\n);",
      "set_replace_synonyms_in_highlights": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    replaceSynonymsInHighlight: false,\n  ),\n);",
      "set_min_proximity": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    minProximity: 1,\n  ),\n);",
      "set_default_field": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    responseFields: [\n      \"hits\",\n      \"hitsPerPage\",\n      \"nbPages\",\n      \"page\",\n    ],\n  ),\n);",
      "set_max_facet_hits": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    maxFacetHits: 10,\n  ),\n);",
      "set_attribute_criteria_computed_by_min_proximity": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributeCriteriaComputedByMinProximity: true,\n  ),\n);",
      "set_user_data": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    userData: {\n      'extraData':\n          \"This is the custom data that you want to store in your index\",\n    },\n  ),\n);",
      "set_rendering_content": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    renderingContent: RenderingContent(\n      facetOrdering: FacetOrdering(\n        facets: Facets(\n          order: [\n            \"size\",\n            \"brand\",\n          ],\n        ),\n        values: {\n          'brand': Value(\n            order: [\n              \"uniqlo\",\n            ],\n            hide: [\n              \"muji\",\n            ],\n            sortRemainingBy: SortRemainingBy.fromJson(\"count\"),\n          ),\n          'size': Value(\n            order: [\n              \"S\",\n              \"M\",\n              \"L\",\n            ],\n            sortRemainingBy: SortRemainingBy.fromJson(\"hidden\"),\n          ),\n        },\n      ),\n    ),\n  ),\n);"
    },
    "updateApiKey": {
      "default": "final response = await client.updateApiKey(\n  key: \"ALGOLIA_API_KEY\",\n  apiKey: ApiKey(\n    acl: [\n      Acl.fromJson(\"search\"),\n      Acl.fromJson(\"addObject\"),\n    ],\n    validity: 300,\n    maxQueriesPerIPPerHour: 100,\n    maxHitsPerQuery: 20,\n  ),\n);"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "final response = await client.waitForApiKey(\n  key: \"api-key-add-operation-test-dart\",\n  operation: ApiKeyOperation.fromJson(\"add\"),\n);",
      "wait for api key - update": "final response = await client.waitForApiKey(\n  key: \"api-key-update-operation-test-dart\",\n  operation: ApiKeyOperation.fromJson(\"update\"),\n  apiKey: ApiKey(\n    description: \"my updated api key\",\n    acl: [\n      Acl.fromJson(\"search\"),\n      Acl.fromJson(\"addObject\"),\n      Acl.fromJson(\"deleteObject\"),\n    ],\n    indexes: [\n      \"Movies\",\n      \"Books\",\n    ],\n    referers: [\n      \"*google.com\",\n      \"*algolia.com\",\n    ],\n    validity: 305,\n    maxQueriesPerIPPerHour: 95,\n    maxHitsPerQuery: 20,\n  ),\n);",
      "wait for api key - delete": "final response = await client.waitForApiKey(\n  key: \"api-key-delete-operation-test-dart\",\n  operation: ApiKeyOperation.fromJson(\"delete\"),\n);"
    },
    "waitForAppTask": {
      "default": "final response = await client.waitForAppTask(\n  taskID: 123,\n);"
    },
    "waitForTask": {
      "default": "final response = await client.waitForTask(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  taskID: 123,\n);"
    },
    "init": {
      "default": "final client =\n    SearchClient(appId: 'ALGOLIA_APPLICATION_ID', apiKey: 'ALGOLIA_API_KEY');"
    }
  },
  "go": {
    "import": {
      "default": "import \"github.com/algolia/algoliasearch-client-go/v4/algolia/search\""
    },
    "addApiKey": {
      "minimal": "response, err := client.AddApiKey(client.NewApiAddApiKeyRequest(\n\n  search.NewEmptyApiKey().SetAcl(\n    []search.Acl{search.Acl(\"search\"), search.Acl(\"addObject\")}).SetDescription(\"my new api key\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "all": "response, err := client.AddApiKey(client.NewApiAddApiKeyRequest(\n\n  search.NewEmptyApiKey().SetAcl(\n    []search.Acl{search.Acl(\"search\"), search.Acl(\"addObject\")}).SetDescription(\"my new api key\").SetValidity(300).SetMaxQueriesPerIPPerHour(100).SetMaxHitsPerQuery(20)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "addOrUpdateObject": {
      "default": "response, err := client.AddOrUpdateObject(client.NewApiAddOrUpdateObjectRequest(\n  \"<YOUR_INDEX_NAME>\", \"uniqueID\", map[string]any{\"key\": \"value\"}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "appendSource": {
      "default": "response, err := client.AppendSource(client.NewApiAppendSourceRequest(\n\n  search.NewEmptySource().SetSource(\"theSource\").SetDescription(\"theDescription\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "assignUserId": {
      "simple": "response, err := client.AssignUserId(client.NewApiAssignUserIdRequest(\n  \"user42\",\n  search.NewEmptyAssignUserIdParams().SetCluster(\"d4242-eu\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "it should not encode the userID": "response, err := client.AssignUserId(client.NewApiAssignUserIdRequest(\n  \"user id with spaces\",\n  search.NewEmptyAssignUserIdParams().SetCluster(\"cluster with spaces\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "batch": {
      "addObject": "response, err := client.Batch(client.NewApiBatchRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyBatchWriteParams().SetRequests(\n    []search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action(\"addObject\")).SetBody(map[string]any{\"key\": \"bar\", \"foo\": \"1\"}), *search.NewEmptyBatchRequest().SetAction(search.Action(\"addObject\")).SetBody(map[string]any{\"key\": \"baz\", \"foo\": \"2\"})})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "clear": "response, err := client.Batch(client.NewApiBatchRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyBatchWriteParams().SetRequests(\n    []search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action(\"clear\")).SetBody(map[string]any{\"key\": \"value\"})})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "delete": "response, err := client.Batch(client.NewApiBatchRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyBatchWriteParams().SetRequests(\n    []search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action(\"delete\")).SetBody(map[string]any{\"key\": \"value\"})})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "deleteObject": "response, err := client.Batch(client.NewApiBatchRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyBatchWriteParams().SetRequests(\n    []search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action(\"deleteObject\")).SetBody(map[string]any{\"key\": \"value\"})})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "partialUpdateObject": "response, err := client.Batch(client.NewApiBatchRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyBatchWriteParams().SetRequests(\n    []search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action(\"partialUpdateObject\")).SetBody(map[string]any{\"key\": \"value\"})})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "partialUpdateObjectNoCreate": "response, err := client.Batch(client.NewApiBatchRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyBatchWriteParams().SetRequests(\n    []search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action(\"partialUpdateObjectNoCreate\")).SetBody(map[string]any{\"key\": \"value\"})})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "updateObject": "response, err := client.Batch(client.NewApiBatchRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyBatchWriteParams().SetRequests(\n    []search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action(\"updateObject\")).SetBody(map[string]any{\"key\": \"value\"})})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "batchAssignUserIds": {
      "default": "response, err := client.BatchAssignUserIds(client.NewApiBatchAssignUserIdsRequest(\n  \"userID\",\n  search.NewEmptyBatchAssignUserIdsParams().SetCluster(\"theCluster\").SetUsers(\n    []string{\"user1\", \"user2\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "batchDictionaryEntries": {
      "replace": "response, err := client.BatchDictionaryEntries(client.NewApiBatchDictionaryEntriesRequest(\n  search.DictionaryType(\"plurals\"),\n  search.NewEmptyBatchDictionaryEntriesParams().SetClearExistingDictionaryEntries(true).SetRequests(\n    []search.BatchDictionaryEntriesRequest{*search.NewEmptyBatchDictionaryEntriesRequest().SetAction(search.DictionaryAction(\"addEntry\")).SetBody(\n      search.NewEmptyDictionaryEntry().SetObjectID(\"1\").SetLanguage(search.SupportedLanguage(\"en\")).SetWord(\"fancy\").SetWords(\n        []string{\"believe\", \"algolia\"}).SetDecomposition(\n        []string{\"trust\", \"algolia\"}).SetState(search.DictionaryEntryState(\"enabled\")))})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "delete": "response, err := client.BatchDictionaryEntries(client.NewApiBatchDictionaryEntriesRequest(\n  search.DictionaryType(\"plurals\"),\n  search.NewEmptyBatchDictionaryEntriesParams().SetClearExistingDictionaryEntries(true).SetRequests(\n    []search.BatchDictionaryEntriesRequest{*search.NewEmptyBatchDictionaryEntriesRequest().SetAction(search.DictionaryAction(\"deleteEntry\")).SetBody(\n      search.NewEmptyDictionaryEntry().SetObjectID(\"1\"))})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "append": "response, err := client.BatchDictionaryEntries(client.NewApiBatchDictionaryEntriesRequest(\n  search.DictionaryType(\"stopwords\"),\n  search.NewEmptyBatchDictionaryEntriesParams().SetRequests(\n    []search.BatchDictionaryEntriesRequest{*search.NewEmptyBatchDictionaryEntriesRequest().SetAction(search.DictionaryAction(\"addEntry\")).SetBody(\n      search.NewEmptyDictionaryEntry().SetObjectID(\"1\").SetLanguage(search.SupportedLanguage(\"en\")).SetAdditionalProperty(\"additional\", \"try me\"))})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "browse": {
      "browse with minimal parameters": "response, err := client.Browse(client.NewApiBrowseRequest(\n  \"<YOUR_INDEX_NAME>\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "browse with search parameters": "response, err := client.Browse(client.NewApiBrowseRequest(\n  \"<YOUR_INDEX_NAME>\").WithBrowseParams(search.BrowseParamsObjectAsBrowseParams(\n  search.NewEmptyBrowseParamsObject().SetQuery(\"myQuery\").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(\n    []search.FacetFilters{*search.StringAsFacetFilters(\"tags:algolia\")})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "browse allow a cursor in parameters": "response, err := client.Browse(client.NewApiBrowseRequest(\n  \"<YOUR_INDEX_NAME>\").WithBrowseParams(search.BrowseParamsObjectAsBrowseParams(\n  search.NewEmptyBrowseParamsObject().SetCursor(\"test\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "clearObjects": {
      "default": "response, err := client.ClearObjects(client.NewApiClearObjectsRequest(\n  \"<YOUR_INDEX_NAME>\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "clearRules": {
      "default": "response, err := client.ClearRules(client.NewApiClearRulesRequest(\n  \"<YOUR_INDEX_NAME>\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "clearSynonyms": {
      "default": "response, err := client.ClearSynonyms(client.NewApiClearSynonymsRequest(\n  \"<YOUR_INDEX_NAME>\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "customDelete": {
      "allow del method for a custom path with minimal parameters": "response, err := client.CustomDelete(client.NewApiCustomDeleteRequest(\n  \"test/minimal\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "allow del method for a custom path with all parameters": "response, err := client.CustomDelete(client.NewApiCustomDeleteRequest(\n  \"test/all\").WithParameters(map[string]any{\"query\": \"parameters\"}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "customGet": {
      "allow get method for a custom path with minimal parameters": "response, err := client.CustomGet(client.NewApiCustomGetRequest(\n  \"test/minimal\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "allow get method for a custom path with all parameters": "response, err := client.CustomGet(client.NewApiCustomGetRequest(\n  \"test/all\").WithParameters(map[string]any{\"query\": \"parameters with space\"}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "requestOptions should be escaped too": "response, err := client.CustomGet(client.NewApiCustomGetRequest(\n  \"test/all\").WithParameters(map[string]any{\"query\": \"to be overriden\"}), search.WithQueryParam(\"query\", \"parameters with space\"), search.WithQueryParam(\"and an array\",\n  []string{\"array\", \"with spaces\"}), search.WithHeaderParam(\"x-header-1\", \"spaces are left alone\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "customPost": {
      "allow post method for a custom path with minimal parameters": "response, err := client.CustomPost(client.NewApiCustomPostRequest(\n  \"test/minimal\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "allow post method for a custom path with all parameters": "response, err := client.CustomPost(client.NewApiCustomPostRequest(\n  \"test/all\").WithParameters(map[string]any{\"query\": \"parameters\"}).WithBody(map[string]any{\"body\": \"parameters\"}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "requestOptions can override default query parameters": "response, err := client.CustomPost(client.NewApiCustomPostRequest(\n  \"test/requestOptions\").WithParameters(map[string]any{\"query\": \"parameters\"}).WithBody(map[string]any{\"facet\": \"filters\"}), search.WithQueryParam(\"query\", \"myQueryParameter\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "requestOptions merges query parameters with default ones": "response, err := client.CustomPost(client.NewApiCustomPostRequest(\n  \"test/requestOptions\").WithParameters(map[string]any{\"query\": \"parameters\"}).WithBody(map[string]any{\"facet\": \"filters\"}), search.WithQueryParam(\"query2\", \"myQueryParameter\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "requestOptions can override default headers": "response, err := client.CustomPost(client.NewApiCustomPostRequest(\n  \"test/requestOptions\").WithParameters(map[string]any{\"query\": \"parameters\"}).WithBody(map[string]any{\"facet\": \"filters\"}), search.WithHeaderParam(\"x-algolia-api-key\", \"ALGOLIA_API_KEY\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "requestOptions merges headers with default ones": "response, err := client.CustomPost(client.NewApiCustomPostRequest(\n  \"test/requestOptions\").WithParameters(map[string]any{\"query\": \"parameters\"}).WithBody(map[string]any{\"facet\": \"filters\"}), search.WithHeaderParam(\"x-algolia-api-key\", \"ALGOLIA_API_KEY\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "requestOptions queryParameters accepts booleans": "response, err := client.CustomPost(client.NewApiCustomPostRequest(\n  \"test/requestOptions\").WithParameters(map[string]any{\"query\": \"parameters\"}).WithBody(map[string]any{\"facet\": \"filters\"}), search.WithQueryParam(\"isItWorking\", true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "requestOptions queryParameters accepts integers": "response, err := client.CustomPost(client.NewApiCustomPostRequest(\n  \"test/requestOptions\").WithParameters(map[string]any{\"query\": \"parameters\"}).WithBody(map[string]any{\"facet\": \"filters\"}), search.WithQueryParam(\"myParam\", 2))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "requestOptions queryParameters accepts list of string": "response, err := client.CustomPost(client.NewApiCustomPostRequest(\n  \"test/requestOptions\").WithParameters(map[string]any{\"query\": \"parameters\"}).WithBody(map[string]any{\"facet\": \"filters\"}), search.WithQueryParam(\"myParam\",\n  []string{\"b and c\", \"d\"}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "requestOptions queryParameters accepts list of booleans": "response, err := client.CustomPost(client.NewApiCustomPostRequest(\n  \"test/requestOptions\").WithParameters(map[string]any{\"query\": \"parameters\"}).WithBody(map[string]any{\"facet\": \"filters\"}), search.WithQueryParam(\"myParam\",\n  []bool{true, true, false}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "requestOptions queryParameters accepts list of integers": "response, err := client.CustomPost(client.NewApiCustomPostRequest(\n  \"test/requestOptions\").WithParameters(map[string]any{\"query\": \"parameters\"}).WithBody(map[string]any{\"facet\": \"filters\"}), search.WithQueryParam(\"myParam\",\n  []int32{1, 2}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "customPut": {
      "allow put method for a custom path with minimal parameters": "response, err := client.CustomPut(client.NewApiCustomPutRequest(\n  \"test/minimal\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "allow put method for a custom path with all parameters": "response, err := client.CustomPut(client.NewApiCustomPutRequest(\n  \"test/all\").WithParameters(map[string]any{\"query\": \"parameters\"}).WithBody(map[string]any{\"body\": \"parameters\"}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "deleteApiKey": {
      "default": "response, err := client.DeleteApiKey(client.NewApiDeleteApiKeyRequest(\n  \"myTestApiKey\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "deleteBy": {
      "default": "response, err := client.DeleteBy(client.NewApiDeleteByRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyDeleteByParams().SetFilters(\"brand:brandName\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "deleteIndex": {
      "default": "response, err := client.DeleteIndex(client.NewApiDeleteIndexRequest(\n  \"<YOUR_INDEX_NAME>\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "deleteObject": {
      "default": "response, err := client.DeleteObject(client.NewApiDeleteObjectRequest(\n  \"<YOUR_INDEX_NAME>\", \"uniqueID\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "deleteObjects": {
      "default": "response, err := client.DeleteObjects(\n  \"<YOUR_INDEX_NAME>\",\n  []string{\"1\", \"2\"})\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "deleteRule": {
      "delete rule simple case": "response, err := client.DeleteRule(client.NewApiDeleteRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"id1\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "delete rule with simple characters to encode in objectID": "response, err := client.DeleteRule(client.NewApiDeleteRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"test/with/slash\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "deleteSource": {
      "default": "response, err := client.DeleteSource(client.NewApiDeleteSourceRequest(\n  \"theSource\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "deleteSynonym": {
      "default": "response, err := client.DeleteSynonym(client.NewApiDeleteSynonymRequest(\n  \"<YOUR_INDEX_NAME>\", \"id1\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "generateSecuredApiKey": {
      "api key basic": "response, err := client.GenerateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  search.NewEmptySecuredApiKeyRestrictions().SetValidUntil(2524604400).SetRestrictIndices(\n    []string{\"Movies\"}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "with searchParams": "response, err := client.GenerateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  search.NewEmptySecuredApiKeyRestrictions().SetValidUntil(2524604400).SetRestrictIndices(\n    []string{\"Movies\", \"cts_e2e_settings\"}).SetRestrictSources(\"192.168.1.0/24\").SetFilters(\"category:Book OR category:Ebook AND _tags:published\").SetUserToken(\"user123\").SetSearchParams(\n    search.NewEmptySearchParamsObject().SetQuery(\"batman\").SetTypoTolerance(search.TypoToleranceEnumAsTypoTolerance(search.TypoToleranceEnum(\"strict\"))).SetAroundRadius(search.AroundRadiusAllAsAroundRadius(search.AroundRadiusAll(\"all\"))).SetMode(search.Mode(\"neuralSearch\")).SetHitsPerPage(10).SetOptionalWords(search.ArrayOfStringAsOptionalWords(\n      []string{\"one\", \"two\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "with filters": "response, err := client.GenerateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  search.NewEmptySecuredApiKeyRestrictions().SetFilters(\"user:user42 AND user:public AND (visible_by:John OR visible_by:group/Finance)\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "with visible_by filter": "response, err := client.GenerateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  search.NewEmptySecuredApiKeyRestrictions().SetFilters(\"visible_by:group/Finance\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "with userID": "response, err := client.GenerateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  search.NewEmptySecuredApiKeyRestrictions().SetUserToken(\"user42\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "mcm with filters": "response, err := client.GenerateSecuredApiKey(\n  \"YourSearchOnlyApiKey\",\n  search.NewEmptySecuredApiKeyRestrictions().SetFilters(\"user:user42 AND user:public\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "mcm with user token": "response, err := client.GenerateSecuredApiKey(\n  \"YourSearchOnlyApiKey\",\n  search.NewEmptySecuredApiKeyRestrictions().SetUserToken(\"user42\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getApiKey": {
      "default": "response, err := client.GetApiKey(client.NewApiGetApiKeyRequest(\n  \"myTestApiKey\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getAppTask": {
      "default": "response, err := client.GetAppTask(client.NewApiGetAppTaskRequest(\n  123))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getDictionaryLanguages": {
      "default": "response, err := client.GetDictionaryLanguages()\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getDictionarySettings": {
      "default": "response, err := client.GetDictionarySettings()\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getLogs": {
      "getLogs with minimal parameters": "response, err := client.GetLogs(client.NewApiGetLogsRequest())\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "getLogs with parameters": "response, err := client.GetLogs(client.NewApiGetLogsRequest().WithOffset(5).WithLength(10).WithIndexName(\"<YOUR_INDEX_NAME>\").WithType(search.LogType(\"all\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getObject": {
      "getObject": "response, err := client.GetObject(client.NewApiGetObjectRequest(\n  \"<YOUR_INDEX_NAME>\", \"uniqueID\").WithAttributesToRetrieve(\n  []string{\"attr1\", \"attr2\"}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search with a real object": "response, err := client.GetObject(client.NewApiGetObjectRequest(\n  \"<YOUR_INDEX_NAME>\", \"Batman and Robin\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getObjects": {
      "by ID": "response, err := client.GetObjects(client.NewApiGetObjectsRequest(\n\n  search.NewEmptyGetObjectsParams().SetRequests(\n    []search.GetObjectsRequest{*search.NewEmptyGetObjectsRequest().SetObjectID(\"uniqueID\").SetIndexName(\"<YOUR_INDEX_NAME>\")})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "multiple IDs": "response, err := client.GetObjects(client.NewApiGetObjectsRequest(\n\n  search.NewEmptyGetObjectsParams().SetRequests(\n    []search.GetObjectsRequest{*search.NewEmptyGetObjectsRequest().SetObjectID(\"uniqueID1\").SetIndexName(\"<YOUR_INDEX_NAME>\"), *search.NewEmptyGetObjectsRequest().SetObjectID(\"uniqueID2\").SetIndexName(\"<YOUR_INDEX_NAME>\")})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "with attributesToRetrieve": "response, err := client.GetObjects(client.NewApiGetObjectsRequest(\n\n  search.NewEmptyGetObjectsParams().SetRequests(\n    []search.GetObjectsRequest{*search.NewEmptyGetObjectsRequest().SetAttributesToRetrieve(\n      []string{\"attr1\", \"attr2\"}).SetObjectID(\"uniqueID\").SetIndexName(\"<YOUR_INDEX_NAME>\")})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getRule": {
      "default": "response, err := client.GetRule(client.NewApiGetRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"qr-1725004648916\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getSettings": {
      "default": "response, err := client.GetSettings(client.NewApiGetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getSources": {
      "default": "response, err := client.GetSources()\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getSynonym": {
      "default": "response, err := client.GetSynonym(client.NewApiGetSynonymRequest(\n  \"<YOUR_INDEX_NAME>\", \"id1\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getTask": {
      "default": "response, err := client.GetTask(client.NewApiGetTaskRequest(\n  \"<YOUR_INDEX_NAME>\", 123))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getTopUserIds": {
      "default": "response, err := client.GetTopUserIds()\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getUserId": {
      "default": "response, err := client.GetUserId(client.NewApiGetUserIdRequest(\n  \"uniqueID\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "hasPendingMappings": {
      "hasPendingMappings with minimal parameters": "response, err := client.HasPendingMappings(client.NewApiHasPendingMappingsRequest())\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "hasPendingMappings with parameters": "response, err := client.HasPendingMappings(client.NewApiHasPendingMappingsRequest().WithGetClusters(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "indexExists": {
      "indexExists": "response, err := client.IndexExists(\n  \"<YOUR_INDEX_NAME>\")\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "indexNotExists": "response, err := client.IndexExists(\n  \"<YOUR_INDEX_NAME>\")\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "indexExistsWithError": "response, err := client.IndexExists(\n  \"<YOUR_INDEX_NAME>\")\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "listApiKeys": {
      "default": "response, err := client.ListApiKeys()\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "listClusters": {
      "default": "response, err := client.ListClusters()\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "listIndices": {
      "listIndices with minimal parameters": "response, err := client.ListIndices(client.NewApiListIndicesRequest())\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "listIndices with parameters": "response, err := client.ListIndices(client.NewApiListIndicesRequest().WithPage(8).WithHitsPerPage(3))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "listUserIds": {
      "listUserIds with minimal parameters": "response, err := client.ListUserIds(client.NewApiListUserIdsRequest())\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "listUserIds with parameters": "response, err := client.ListUserIds(client.NewApiListUserIdsRequest().WithPage(8).WithHitsPerPage(100))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "multipleBatch": {
      "default": "response, err := client.MultipleBatch(client.NewApiMultipleBatchRequest(\n\n  search.NewEmptyBatchParams().SetRequests(\n    []search.MultipleBatchRequest{*search.NewEmptyMultipleBatchRequest().SetAction(search.Action(\"addObject\")).SetBody(map[string]any{\"key\": \"value\"}).SetIndexName(\"<YOUR_INDEX_NAME>\")})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "operationIndex": {
      "scopes": "response, err := client.OperationIndex(client.NewApiOperationIndexRequest(\n  \"<SOURCE_INDEX_NAME>\",\n  search.NewEmptyOperationIndexParams().SetOperation(search.OperationType(\"move\")).SetDestination(\"<DESTINATION_INDEX_NAME>\").SetScope(\n    []search.ScopeType{search.ScopeType(\"rules\"), search.ScopeType(\"settings\")})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "copy": "response, err := client.OperationIndex(client.NewApiOperationIndexRequest(\n  \"<SOURCE_INDEX_NAME>\",\n  search.NewEmptyOperationIndexParams().SetOperation(search.OperationType(\"copy\")).SetDestination(\"<DESTINATION_INDEX_NAME>\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "move": "response, err := client.OperationIndex(client.NewApiOperationIndexRequest(\n  \"<SOURCE_INDEX_NAME>\",\n  search.NewEmptyOperationIndexParams().SetOperation(search.OperationType(\"move\")).SetDestination(\"<DESTINATION_INDEX_NAME>\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "partialUpdateObject": {
      "Partial update with a new value for a string attribute": "response, err := client.PartialUpdateObject(client.NewApiPartialUpdateObjectRequest(\n  \"<YOUR_INDEX_NAME>\", \"uniqueID\", map[string]any{\"attributeId\": \"new value\"}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "Partial update with a new value for an integer attribute": "response, err := client.PartialUpdateObject(client.NewApiPartialUpdateObjectRequest(\n  \"<YOUR_INDEX_NAME>\", \"uniqueID\", map[string]any{\"attributeId\": 1}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "Partial update with a new value for a boolean attribute": "response, err := client.PartialUpdateObject(client.NewApiPartialUpdateObjectRequest(\n  \"<YOUR_INDEX_NAME>\", \"uniqueID\", map[string]any{\"attributeId\": true}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "Partial update with a new value for an array attribute": "response, err := client.PartialUpdateObject(client.NewApiPartialUpdateObjectRequest(\n  \"<YOUR_INDEX_NAME>\", \"uniqueID\", map[string]any{\"attributeId\": []string{\"one\", \"two\", \"three\"}}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "Partial update with a new value for an object attribute": "response, err := client.PartialUpdateObject(client.NewApiPartialUpdateObjectRequest(\n  \"<YOUR_INDEX_NAME>\", \"uniqueID\", map[string]any{\"attributeId\": map[string]any{\"nested\": \"value\"}}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "with visible_by filter": "response, err := client.PartialUpdateObject(client.NewApiPartialUpdateObjectRequest(\n  \"<YOUR_INDEX_NAME>\", \"uniqueID\", map[string]any{\"visible_by\": []string{\"Angela\", \"group/Finance\", \"group/Shareholders\"}}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "add men pant": "response, err := client.PartialUpdateObject(client.NewApiPartialUpdateObjectRequest(\n  \"<YOUR_INDEX_NAME>\", \"productId\", map[string]any{\"categoryPageId\": map[string]any{\"_operation\": \"Add\", \"value\": \"men-clothing-pants\"}}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "remove men pant": "response, err := client.PartialUpdateObject(client.NewApiPartialUpdateObjectRequest(\n  \"<YOUR_INDEX_NAME>\", \"productId\", map[string]any{\"categoryPageId\": map[string]any{\"_operation\": \"Remove\", \"value\": \"men-clothing-pants\"}}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "response, err := client.PartialUpdateObjects(\n  \"<YOUR_INDEX_NAME>\",\n  []map[string]any{map[string]any{\"objectID\": \"1\", \"name\": \"Adam\"}, map[string]any{\"objectID\": \"2\", \"name\": \"Benoit\"}}, search.WithCreateIfNotExists(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "call partialUpdateObjects with createIfNotExists=false": "response, err := client.PartialUpdateObjects(\n  \"<YOUR_INDEX_NAME>\",\n  []map[string]any{map[string]any{\"objectID\": \"3\", \"name\": \"Cyril\"}, map[string]any{\"objectID\": \"4\", \"name\": \"David\"}}, search.WithCreateIfNotExists(false))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "removeUserId": {
      "default": "response, err := client.RemoveUserId(client.NewApiRemoveUserIdRequest(\n  \"uniqueID\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "replaceAllObjects": {
      "call replaceAllObjects without error": "response, err := client.ReplaceAllObjects(\n  \"<YOUR_INDEX_NAME>\",\n  []map[string]any{map[string]any{\"objectID\": \"1\", \"name\": \"Adam\"}, map[string]any{\"objectID\": \"2\", \"name\": \"Benoit\"}, map[string]any{\"objectID\": \"3\", \"name\": \"Cyril\"}, map[string]any{\"objectID\": \"4\", \"name\": \"David\"}, map[string]any{\"objectID\": \"5\", \"name\": \"Eva\"}, map[string]any{\"objectID\": \"6\", \"name\": \"Fiona\"}, map[string]any{\"objectID\": \"7\", \"name\": \"Gael\"}, map[string]any{\"objectID\": \"8\", \"name\": \"Hugo\"}, map[string]any{\"objectID\": \"9\", \"name\": \"Igor\"}, map[string]any{\"objectID\": \"10\", \"name\": \"Julia\"}}, search.WithBatchSize(3))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "call replaceAllObjects with partial scopes": "response, err := client.ReplaceAllObjects(\n  \"<YOUR_INDEX_NAME>\",\n  []map[string]any{map[string]any{\"objectID\": \"1\", \"name\": \"Adam\"}, map[string]any{\"objectID\": \"2\", \"name\": \"Benoit\"}}, search.WithBatchSize(77), search.WithScopes(\n    []search.ScopeType{search.ScopeType(\"settings\"), search.ScopeType(\"synonyms\")}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "replaceAllObjects should cleanup on failure": "response, err := client.ReplaceAllObjects(\n  \"<YOUR_INDEX_NAME>\",\n  []map[string]any{map[string]any{\"objectID\": \"fine\", \"body\": \"small obj\"}, map[string]any{\"objectID\": \"toolarge\", \"body\": \"something bigger than 10KB\"}})\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "replaceSources": {
      "default": "response, err := client.ReplaceSources(client.NewApiReplaceSourcesRequest(\n\n  []search.Source{*search.NewEmptySource().SetSource(\"theSource\").SetDescription(\"theDescription\")}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "restoreApiKey": {
      "default": "response, err := client.RestoreApiKey(client.NewApiRestoreApiKeyRequest(\n  \"ALGOLIA_API_KEY\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "saveObject": {
      "default": "response, err := client.SaveObject(client.NewApiSaveObjectRequest(\n  \"<YOUR_INDEX_NAME>\", map[string]any{\"name\": \"Black T-shirt\", \"color\": \"#000000||black\", \"availableIn\": \"https://source.unsplash.com/100x100/?paris||Paris\", \"objectID\": \"myID\"}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "saveObjects": {
      "call saveObjects without error": "response, err := client.SaveObjects(\n  \"<YOUR_INDEX_NAME>\",\n  []map[string]any{map[string]any{\"objectID\": \"1\", \"name\": \"Adam\"}, map[string]any{\"objectID\": \"2\", \"name\": \"Benoit\"}})\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "saveObjects should report errors": "response, err := client.SaveObjects(\n  \"<YOUR_INDEX_NAME>\",\n  []map[string]any{map[string]any{\"objectID\": \"1\", \"name\": \"Adam\"}, map[string]any{\"objectID\": \"2\", \"name\": \"Benoit\"}})\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "saveObjectsPlaylist": "response, err := client.SaveObjects(\n  \"<YOUR_INDEX_NAME>\",\n  []map[string]any{map[string]any{\"objectID\": \"1\", \"visibility\": \"public\", \"name\": \"Hot 100 Billboard Charts\", \"playlistId\": \"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\", \"createdAt\": \"1500240452\"}})\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "saveObjectsPublicUser": "response, err := client.SaveObjects(\n  \"<YOUR_INDEX_NAME>\",\n  []map[string]any{map[string]any{\"objectID\": \"1\", \"visibility\": \"public\", \"name\": \"Hot 100 Billboard Charts\", \"playlistId\": \"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\", \"createdAt\": \"1500240452\"}}, search.WithWaitForTasks(false), search.WithBatchSize(1000), search.WithHeaderParam(\"X-Algolia-User-ID\", \"*\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "saveRule": {
      "saveRule with minimal parameters": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"id1\",\n  search.NewEmptyRule().SetObjectID(\"id1\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"apple\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetFilters(\"brand:xiaomi\")))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "saveRule with all parameters": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"id1\",\n  search.NewEmptyRule().SetObjectID(\"id1\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"apple\").SetAnchoring(search.Anchoring(\"contains\")).SetAlternatives(false).SetContext(\"search\")}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetFilters(\"brand:apple\").SetQuery(search.ConsequenceQueryObjectAsConsequenceQuery(\n        search.NewEmptyConsequenceQueryObject().SetRemove(\n          []string{\"algolia\"}).SetEdits(\n          []search.Edit{*search.NewEmptyEdit().SetType(search.EditType(\"remove\")).SetDelete(\"abc\").SetInsert(\"cde\"), *search.NewEmptyEdit().SetType(search.EditType(\"replace\")).SetDelete(\"abc\").SetInsert(\"cde\")})))).SetHide(\n      []search.ConsequenceHide{*search.NewEmptyConsequenceHide().SetObjectID(\"321\")}).SetFilterPromotes(false).SetUserData(map[string]any{\"algolia\": \"aloglia\"}).SetPromote(\n      []search.Promote{*search.PromoteObjectIDAsPromote(\n        search.NewEmptyPromoteObjectID().SetObjectID(\"abc\").SetPosition(3)), *search.PromoteObjectIDsAsPromote(\n        search.NewEmptyPromoteObjectIDs().SetObjectIDs(\n          []string{\"abc\", \"def\"}).SetPosition(1))})).SetDescription(\"test\").SetEnabled(true).SetValidity(\n    []search.TimeRange{*search.NewEmptyTimeRange().SetFrom(1656670273).SetUntil(1656670277)})).WithForwardToReplicas(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "b2b catalog": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"article-rule\",\n  search.NewEmptyRule().SetObjectID(\"article-rule\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"article\").SetAnchoring(search.Anchoring(\"startsWith\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetQuery(search.ConsequenceQueryObjectAsConsequenceQuery(\n        search.NewEmptyConsequenceQueryObject().SetEdits(\n          []search.Edit{*search.NewEmptyEdit().SetType(search.EditType(\"remove\")).SetDelete(\"article\")}))).SetRestrictSearchableAttributes(\n        []string{\"title\", \"book_id\"})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "merchandising and promoting": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"director-rule\",\n  search.NewEmptyRule().SetObjectID(\"director-rule\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"{facet:director} director\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetRestrictSearchableAttributes(\n        []string{\"title\", \"book_id\"}).SetAutomaticFacetFilters(search.ArrayOfAutomaticFacetFilterAsAutomaticFacetFilters(\n        []search.AutomaticFacetFilter{*search.NewEmptyAutomaticFacetFilter().SetFacet(\"director\")})).SetQuery(search.ConsequenceQueryObjectAsConsequenceQuery(\n        search.NewEmptyConsequenceQueryObject().SetEdits(\n          []search.Edit{*search.NewEmptyEdit().SetType(search.EditType(\"remove\")).SetDelete(\"director\")})))))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "harry potter": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"harry-potter-rule\",\n  search.NewEmptyRule().SetObjectID(\"harry-potter-rule\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"harry potter\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetUserData(map[string]any{\"promo_content\": \"20% OFF on all Harry Potter books!\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "merchandising empty query": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"clearance-category-filter\",\n  search.NewEmptyRule().SetObjectID(\"clearance-category-filter\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"\").SetAnchoring(search.Anchoring(\"is\")).SetContext(\"landing\")}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetOptionalFilters(search.StringAsOptionalFilters(\"clearance:true\"))))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "redirect": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"redirect-help-rule\",\n  search.NewEmptyRule().SetObjectID(\"redirect-help-rule\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"help\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetUserData(map[string]any{\"redirect\": \"https://www.algolia.com/support\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "promote some results over others": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"tomato-fruit\",\n  search.NewEmptyRule().SetObjectID(\"tomato-fruit\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"tomato\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetOptionalFilters(search.StringAsOptionalFilters(\"food_group:fruit\"))))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "promote several hits": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"Promote-Apple-Newest\",\n  search.NewEmptyRule().SetObjectID(\"Promote-Apple-Newest\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"apple\").SetAnchoring(search.Anchoring(\"is\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetPromote(\n      []search.Promote{*search.PromoteObjectIDsAsPromote(\n        search.NewEmptyPromoteObjectIDs().SetObjectIDs(\n          []string{\"iPhone-12345\", \"watch-123\"}).SetPosition(0))}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "promote newest release": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"Promote-iPhone-X\",\n  search.NewEmptyRule().SetObjectID(\"Promote-iPhone-X\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"iPhone\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetPromote(\n      []search.Promote{*search.PromoteObjectIDAsPromote(\n        search.NewEmptyPromoteObjectID().SetObjectID(\"iPhone-12345\").SetPosition(0))}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "promote single item": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"promote-harry-potter-box-set\",\n  search.NewEmptyRule().SetObjectID(\"promote-harry-potter-box-set\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"Harry Potter\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetPromote(\n      []search.Promote{*search.PromoteObjectIDAsPromote(\n        search.NewEmptyPromoteObjectID().SetObjectID(\"HP-12345\").SetPosition(0))}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "limit search results": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"article-rule\",\n  search.NewEmptyRule().SetObjectID(\"article-rule\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"article\").SetAnchoring(search.Anchoring(\"startsWith\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetQuery(search.ConsequenceQueryObjectAsConsequenceQuery(\n        search.NewEmptyConsequenceQueryObject().SetEdits(\n          []search.Edit{*search.NewEmptyEdit().SetType(search.EditType(\"remove\")).SetDelete(\"article\")}))).SetRestrictSearchableAttributes(\n        []string{\"title\", \"book_id\"})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "query match": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"tagged-brand-rule\",\n  search.NewEmptyRule().SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"brand: {facet:brand}\").SetAnchoring(search.Anchoring(\"contains\")).SetAlternatives(false)}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetAutomaticFacetFilters(search.ArrayOfAutomaticFacetFilterAsAutomaticFacetFilters(\n        []search.AutomaticFacetFilter{*search.NewEmptyAutomaticFacetFilter().SetFacet(\"brand\")})).SetQuery(search.ConsequenceQueryObjectAsConsequenceQuery(\n        search.NewEmptyConsequenceQueryObject().SetRemove(\n          []string{\"brand:\", \"{facet:brand}\"}))))).SetDescription(\"filter on brand: {brand}\").SetObjectID(\"tagged-brand-rule\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "dynamic filtering": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"color-facets\",\n  search.NewEmptyRule().SetObjectID(\"color-facets\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"{facet:color}\")}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetAutomaticFacetFilters(search.ArrayOfAutomaticFacetFilterAsAutomaticFacetFilters(\n        []search.AutomaticFacetFilter{*search.NewEmptyAutomaticFacetFilter().SetFacet(\"color\")}))))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "hide hits": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"hide-12345\",\n  search.NewEmptyRule().SetObjectID(\"hide-12345\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"cheap\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetHide(\n      []search.ConsequenceHide{*search.NewEmptyConsequenceHide().SetObjectID(\"to-hide-12345\")}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "one rule per facet": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"red-color\",\n  search.NewEmptyRule().SetObjectID(\"red-color\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"red\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetQuery(search.ConsequenceQueryObjectAsConsequenceQuery(\n        search.NewEmptyConsequenceQueryObject().SetRemove(\n          []string{\"red\"}))).SetFilters(\"color:red\")))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "numerical filters": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"cheap\",\n  search.NewEmptyRule().SetObjectID(\"cheap\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"cheap\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetQuery(search.ConsequenceQueryObjectAsConsequenceQuery(\n        search.NewEmptyConsequenceQueryObject().SetRemove(\n          []string{\"cheap\"}))).SetFilters(\"price < 10\")))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "negative filters": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"gluten-free-rule\",\n  search.NewEmptyRule().SetObjectID(\"gluten-free-rule\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"gluten-free\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetFilters(\"NOT allergens:gluten\").SetQuery(search.ConsequenceQueryObjectAsConsequenceQuery(\n        search.NewEmptyConsequenceQueryObject().SetEdits(\n          []search.Edit{*search.NewEmptyEdit().SetType(search.EditType(\"remove\")).SetDelete(\"gluten-free\")})))))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "positive filters": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"diet-rule\",\n  search.NewEmptyRule().SetObjectID(\"diet-rule\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"diet\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetFilters(\"'low-carb' OR 'low-fat'\").SetQuery(search.ConsequenceQueryObjectAsConsequenceQuery(\n        search.NewEmptyConsequenceQueryObject().SetEdits(\n          []search.Edit{*search.NewEmptyEdit().SetType(search.EditType(\"remove\")).SetDelete(\"diet\")})))))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "conditionless": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"diet-rule\",\n  search.NewEmptyRule().SetObjectID(\"diet-rule\").SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetFilters(\"'low-carb' OR 'low-fat'\").SetQuery(search.ConsequenceQueryObjectAsConsequenceQuery(\n        search.NewEmptyConsequenceQueryObject().SetEdits(\n          []search.Edit{*search.NewEmptyEdit().SetType(search.EditType(\"remove\")).SetDelete(\"diet\")})))))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "contextual": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"a-rule-id\",\n  search.NewEmptyRule().SetObjectID(\"a-rule-id\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetContext(\"mobile\")}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetFilters(\"release_date >= 1577836800\")))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "saveRule always active rule": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"a-rule-id\",\n  search.NewEmptyRule().SetObjectID(\"a-rule-id\").SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetAroundRadius(search.Int32AsAroundRadius(1000)))).SetValidity(\n    []search.TimeRange{*search.NewEmptyTimeRange().SetFrom(1577836800).SetUntil(1577836800)})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "saveRules": {
      "saveRules with minimal parameters": "response, err := client.SaveRules(client.NewApiSaveRulesRequest(\n  \"<YOUR_INDEX_NAME>\",\n  []search.Rule{*search.NewEmptyRule().SetObjectID(\"a-rule-id\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"smartphone\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetFilters(\"brand:apple\"))), *search.NewEmptyRule().SetObjectID(\"a-second-rule-id\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"apple\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetFilters(\"brand:samsung\")))}).WithForwardToReplicas(false).WithClearExistingRules(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "saveRules with all parameters": "response, err := client.SaveRules(client.NewApiSaveRulesRequest(\n  \"<YOUR_INDEX_NAME>\",\n  []search.Rule{*search.NewEmptyRule().SetObjectID(\"id1\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"apple\").SetAnchoring(search.Anchoring(\"contains\")).SetAlternatives(false).SetContext(\"search\")}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetFilters(\"brand:apple\").SetQuery(search.ConsequenceQueryObjectAsConsequenceQuery(\n        search.NewEmptyConsequenceQueryObject().SetRemove(\n          []string{\"algolia\"}).SetEdits(\n          []search.Edit{*search.NewEmptyEdit().SetType(search.EditType(\"remove\")).SetDelete(\"abc\").SetInsert(\"cde\"), *search.NewEmptyEdit().SetType(search.EditType(\"replace\")).SetDelete(\"abc\").SetInsert(\"cde\")})))).SetHide(\n      []search.ConsequenceHide{*search.NewEmptyConsequenceHide().SetObjectID(\"321\")}).SetFilterPromotes(false).SetUserData(map[string]any{\"algolia\": \"aloglia\"}).SetPromote(\n      []search.Promote{*search.PromoteObjectIDAsPromote(\n        search.NewEmptyPromoteObjectID().SetObjectID(\"abc\").SetPosition(3)), *search.PromoteObjectIDsAsPromote(\n        search.NewEmptyPromoteObjectIDs().SetObjectIDs(\n          []string{\"abc\", \"def\"}).SetPosition(1))})).SetDescription(\"test\").SetEnabled(true).SetValidity(\n    []search.TimeRange{*search.NewEmptyTimeRange().SetFrom(1656670273).SetUntil(1656670277)})}).WithForwardToReplicas(true).WithClearExistingRules(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "dynamic filtering": "response, err := client.SaveRules(client.NewApiSaveRulesRequest(\n  \"<YOUR_INDEX_NAME>\",\n  []search.Rule{*search.NewEmptyRule().SetObjectID(\"toaster\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"toaster\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetQuery(search.ConsequenceQueryObjectAsConsequenceQuery(\n        search.NewEmptyConsequenceQueryObject().SetRemove(\n          []string{\"toaster\"}))).SetFilters(\"product_type:toaster\"))), *search.NewEmptyRule().SetObjectID(\"cheap\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"cheap\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetQuery(search.ConsequenceQueryObjectAsConsequenceQuery(\n        search.NewEmptyConsequenceQueryObject().SetRemove(\n          []string{\"cheap\"}))).SetFilters(\"price < 15\")))}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enhance search results": "response, err := client.SaveRules(client.NewApiSaveRulesRequest(\n  \"<YOUR_INDEX_NAME>\",\n  []search.Rule{*search.NewEmptyRule().SetObjectID(\"country\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"{facet:country}\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetAroundLatLngViaIP(false))), *search.NewEmptyRule().SetObjectID(\"city\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"{facet:city}\").SetAnchoring(search.Anchoring(\"contains\"))}).SetConsequence(\n    search.NewEmptyConsequence().SetParams(\n      search.NewEmptyConsequenceParams().SetAroundLatLngViaIP(false)))}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "saveSynonym": {
      "default": "response, err := client.SaveSynonym(client.NewApiSaveSynonymRequest(\n  \"<YOUR_INDEX_NAME>\", \"id1\",\n  search.NewEmptySynonymHit().SetObjectID(\"id1\").SetType(search.SynonymType(\"synonym\")).SetSynonyms(\n    []string{\"car\", \"vehicule\", \"auto\"})).WithForwardToReplicas(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "saveSynonyms": {
      "default": "response, err := client.SaveSynonyms(client.NewApiSaveSynonymsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  []search.SynonymHit{*search.NewEmptySynonymHit().SetObjectID(\"id1\").SetType(search.SynonymType(\"synonym\")).SetSynonyms(\n    []string{\"car\", \"vehicule\", \"auto\"}), *search.NewEmptySynonymHit().SetObjectID(\"id2\").SetType(search.SynonymType(\"onewaysynonym\")).SetInput(\"iphone\").SetSynonyms(\n    []string{\"ephone\", \"aphone\", \"yphone\"})}).WithForwardToReplicas(true).WithReplaceExistingSynonyms(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "search": {
      "withHitsPerPage": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetQuery(\"<YOUR_QUERY>\").SetHitsPerPage(50))})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "filterOnly": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetQuery(\"<YOUR_QUERY>\").SetFilters(\"actor:Scarlett Johansson\"))})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "filterOr": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetQuery(\"<YOUR_QUERY>\").SetFilters(\"actor:Tom Cruise OR actor:Scarlett Johansson\"))})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "filterNot": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetQuery(\"<YOUR_QUERY>\").SetFilters(\"NOT actor:Nicolas Cage\"))})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search for a single hits request with minimal parameters": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\"))})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search with highlight and snippet results": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetQuery(\"vim\").SetAttributesToSnippet(\n        []string{\"*:20\"}).SetAttributesToHighlight(\n        []string{\"*\"}).SetAttributesToRetrieve(\n        []string{\"*\"}))})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "retrieveFacets": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetQuery(\"<YOUR_QUERY>\").SetFacets(\n        []string{\"author\", \"genre\"}))})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "retrieveFacetsWildcard": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetQuery(\"<YOUR_QUERY>\").SetFacets(\n        []string{\"*\"}))})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search for a single facet request with minimal parameters": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForFacetsAsSearchQuery(\n      search.NewEmptySearchForFacets().SetIndexName(\"<YOUR_INDEX_NAME>\").SetType(search.SearchTypeFacet(\"facet\")).SetFacet(\"editor\"))}).SetStrategy(search.SearchStrategy(\"stopIfEnoughMatches\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search for a single hits request with all parameters": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetQuery(\"myQuery\").SetHitsPerPage(50).SetType(search.SearchTypeDefault(\"default\")))})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search for a single facet request with all parameters": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForFacetsAsSearchQuery(\n      search.NewEmptySearchForFacets().SetIndexName(\"<YOUR_INDEX_NAME>\").SetType(search.SearchTypeFacet(\"facet\")).SetFacet(\"theFacet\").SetFacetQuery(\"theFacetQuery\").SetQuery(\"theQuery\").SetMaxFacetHits(50))}).SetStrategy(search.SearchStrategy(\"stopIfEnoughMatches\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search for multiple mixed requests in multiple indices with minimal parameters": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\")), *search.SearchForFacetsAsSearchQuery(\n      search.NewEmptySearchForFacets().SetIndexName(\"<YOUR_INDEX_NAME>\").SetType(search.SearchTypeFacet(\"facet\")).SetFacet(\"theFacet\")), *search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetType(search.SearchTypeDefault(\"default\")))}).SetStrategy(search.SearchStrategy(\"stopIfEnoughMatches\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search for multiple mixed requests in multiple indices with all parameters": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForFacetsAsSearchQuery(\n      search.NewEmptySearchForFacets().SetIndexName(\"<YOUR_INDEX_NAME>\").SetType(search.SearchTypeFacet(\"facet\")).SetFacet(\"theFacet\").SetFacetQuery(\"theFacetQuery\").SetQuery(\"theQuery\").SetMaxFacetHits(50)), *search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetQuery(\"myQuery\").SetHitsPerPage(50).SetType(search.SearchTypeDefault(\"default\")))}).SetStrategy(search.SearchStrategy(\"stopIfEnoughMatches\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search filters accept all of the possible shapes": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetFacetFilters(search.StringAsFacetFilters(\"mySearch:filters\")).SetReRankingApplyFilter(search.StringAsReRankingApplyFilter(\"mySearch:filters\")).SetTagFilters(search.StringAsTagFilters(\"mySearch:filters\")).SetNumericFilters(search.StringAsNumericFilters(\"mySearch:filters\")).SetOptionalFilters(search.StringAsOptionalFilters(\"mySearch:filters\"))), *search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(\n        []search.FacetFilters{*search.StringAsFacetFilters(\"mySearch:filters\"), *search.ArrayOfFacetFiltersAsFacetFilters(\n          []search.FacetFilters{*search.StringAsFacetFilters(\"mySearch:filters\"), *search.ArrayOfFacetFiltersAsFacetFilters(\n            []search.FacetFilters{*search.StringAsFacetFilters(\"mySearch:filters\")})})})).SetReRankingApplyFilter(search.ArrayOfReRankingApplyFilterAsReRankingApplyFilter(\n        []search.ReRankingApplyFilter{*search.StringAsReRankingApplyFilter(\"mySearch:filters\"), *search.ArrayOfReRankingApplyFilterAsReRankingApplyFilter(\n          []search.ReRankingApplyFilter{*search.StringAsReRankingApplyFilter(\"mySearch:filters\")})})).SetTagFilters(search.ArrayOfTagFiltersAsTagFilters(\n        []search.TagFilters{*search.StringAsTagFilters(\"mySearch:filters\"), *search.ArrayOfTagFiltersAsTagFilters(\n          []search.TagFilters{*search.StringAsTagFilters(\"mySearch:filters\")})})).SetNumericFilters(search.ArrayOfNumericFiltersAsNumericFilters(\n        []search.NumericFilters{*search.StringAsNumericFilters(\"mySearch:filters\"), *search.ArrayOfNumericFiltersAsNumericFilters(\n          []search.NumericFilters{*search.StringAsNumericFilters(\"mySearch:filters\")})})).SetOptionalFilters(search.ArrayOfOptionalFiltersAsOptionalFilters(\n        []search.OptionalFilters{*search.StringAsOptionalFilters(\"mySearch:filters\"), *search.ArrayOfOptionalFiltersAsOptionalFilters(\n          []search.OptionalFilters{*search.StringAsOptionalFilters(\"mySearch:filters\")})})))})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search filters end to end": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetFilters(\"editor:'visual studio' OR editor:neovim\")), *search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(\n        []search.FacetFilters{*search.StringAsFacetFilters(\"editor:'visual studio'\"), *search.StringAsFacetFilters(\"editor:neovim\")}))), *search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(\n        []search.FacetFilters{*search.StringAsFacetFilters(\"editor:'visual studio'\"), *search.ArrayOfFacetFiltersAsFacetFilters(\n          []search.FacetFilters{*search.StringAsFacetFilters(\"editor:neovim\")})}))), *search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(\n        []search.FacetFilters{*search.StringAsFacetFilters(\"editor:'visual studio'\"), *search.ArrayOfFacetFiltersAsFacetFilters(\n          []search.FacetFilters{*search.StringAsFacetFilters(\"editor:neovim\"), *search.ArrayOfFacetFiltersAsFacetFilters(\n            []search.FacetFilters{*search.StringAsFacetFilters(\"editor:goland\")})})})))})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search with all search parameters": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetAdvancedSyntax(true).SetAdvancedSyntaxFeatures(\n        []search.AdvancedSyntaxFeatures{search.AdvancedSyntaxFeatures(\"exactPhrase\")}).SetAllowTyposOnNumericTokens(true).SetAlternativesAsExact(\n        []search.AlternativesAsExact{search.AlternativesAsExact(\"multiWordsSynonym\")}).SetAnalytics(true).SetAnalyticsTags(\n        []string{\"\"}).SetAroundLatLng(\"\").SetAroundLatLngViaIP(true).SetAroundPrecision(search.Int32AsAroundPrecision(0)).SetAroundRadius(search.AroundRadiusAllAsAroundRadius(search.AroundRadiusAll(\"all\"))).SetAttributeCriteriaComputedByMinProximity(true).SetAttributesToHighlight(\n        []string{\"\"}).SetAttributesToRetrieve(\n        []string{\"\"}).SetAttributesToSnippet(\n        []string{\"\"}).SetClickAnalytics(true).SetDecompoundQuery(true).SetDisableExactOnAttributes(\n        []string{\"\"}).SetDisableTypoToleranceOnAttributes(\n        []string{\"\"}).SetDistinct(search.Int32AsDistinct(0)).SetEnableABTest(true).SetEnablePersonalization(true).SetEnableReRanking(true).SetEnableRules(true).SetExactOnSingleWordQuery(search.ExactOnSingleWordQuery(\"attribute\")).SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(\n        []search.FacetFilters{*search.StringAsFacetFilters(\"\")})).SetFacetingAfterDistinct(true).SetFacets(\n        []string{\"\"}).SetFilters(\"\").SetGetRankingInfo(true).SetHighlightPostTag(\"\").SetHighlightPreTag(\"\").SetHitsPerPage(1).SetIgnorePlurals(search.BoolAsIgnorePlurals(false)).SetIndexName(\"<YOUR_INDEX_NAME>\").SetInsideBoundingBox(search.ArrayOfArrayOfFloat64AsInsideBoundingBox(\n        [][]float64{\n          []float64{47.3165, 4.9665, 47.3424, 5.0201},\n          []float64{40.9234, 2.1185, 38.643, 1.9916}})).SetInsidePolygon(\n        [][]float64{\n          []float64{47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9},\n          []float64{40.9234, 2.1185, 38.643, 1.9916, 39.2587, 2.0104}}).SetLength(1).SetMaxValuesPerFacet(0).SetMinProximity(1).SetMinWordSizefor1Typo(0).SetMinWordSizefor2Typos(0).SetMinimumAroundRadius(1).SetNaturalLanguages(\n        []search.SupportedLanguage{search.SupportedLanguage(\"fr\")}).SetNumericFilters(search.ArrayOfNumericFiltersAsNumericFilters(\n        []search.NumericFilters{*search.StringAsNumericFilters(\"\")})).SetOffset(0).SetOptionalFilters(search.ArrayOfOptionalFiltersAsOptionalFilters(\n        []search.OptionalFilters{*search.StringAsOptionalFilters(\"\")})).SetOptionalWords(search.ArrayOfStringAsOptionalWords(\n        []string{\"\"})).SetPage(0).SetPercentileComputation(true).SetPersonalizationImpact(0).SetQuery(\"\").SetQueryLanguages(\n        []search.SupportedLanguage{search.SupportedLanguage(\"fr\")}).SetQueryType(search.QueryType(\"prefixAll\")).SetRanking(\n        []string{\"\"}).SetReRankingApplyFilter(search.ArrayOfReRankingApplyFilterAsReRankingApplyFilter(\n        []search.ReRankingApplyFilter{*search.StringAsReRankingApplyFilter(\"\")})).SetRelevancyStrictness(0).SetRemoveStopWords(search.BoolAsRemoveStopWords(true)).SetRemoveWordsIfNoResults(search.RemoveWordsIfNoResults(\"allOptional\")).SetRenderingContent(\n        search.NewEmptyRenderingContent().SetFacetOrdering(\n          search.NewEmptyFacetOrdering().SetFacets(\n            search.NewEmptyFacets().SetOrder(\n              []string{\"a\", \"b\"})).SetValues(map[string]search.Value{\"a\": *search.NewEmptyValue().SetOrder(\n            []string{\"b\"}).SetSortRemainingBy(search.SortRemainingBy(\"count\"))}))).SetReplaceSynonymsInHighlight(true).SetResponseFields(\n        []string{\"\"}).SetRestrictHighlightAndSnippetArrays(true).SetRestrictSearchableAttributes(\n        []string{\"\"}).SetRuleContexts(\n        []string{\"\"}).SetSimilarQuery(\"\").SetSnippetEllipsisText(\"\").SetSortFacetValuesBy(\"\").SetSumOrFiltersScores(true).SetSynonyms(true).SetTagFilters(search.ArrayOfTagFiltersAsTagFilters(\n        []search.TagFilters{*search.StringAsTagFilters(\"\")})).SetType(search.SearchTypeDefault(\"default\")).SetTypoTolerance(search.TypoToleranceEnumAsTypoTolerance(search.TypoToleranceEnum(\"min\"))).SetUserToken(\"\"))})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "searchDictionaryEntries": {
      "get searchDictionaryEntries results with minimal parameters": "response, err := client.SearchDictionaryEntries(client.NewApiSearchDictionaryEntriesRequest(\n  search.DictionaryType(\"stopwords\"),\n  search.NewEmptySearchDictionaryEntriesParams().SetQuery(\"about\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "get searchDictionaryEntries results with all parameters": "response, err := client.SearchDictionaryEntries(client.NewApiSearchDictionaryEntriesRequest(\n  search.DictionaryType(\"compounds\"),\n  search.NewEmptySearchDictionaryEntriesParams().SetQuery(\"foo\").SetPage(4).SetHitsPerPage(2).SetLanguage(search.SupportedLanguage(\"fr\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "searchForFacetValues": {
      "get searchForFacetValues results with minimal parameters": "response, err := client.SearchForFacetValues(client.NewApiSearchForFacetValuesRequest(\n  \"<YOUR_INDEX_NAME>\", \"facetName\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "get searchForFacetValues results with all parameters": "response, err := client.SearchForFacetValues(client.NewApiSearchForFacetValuesRequest(\n  \"<YOUR_INDEX_NAME>\", \"facetName\").WithSearchForFacetValuesRequest(\n  search.NewEmptySearchForFacetValuesRequest().SetParams(\"query=foo&facetFilters=['bar']\").SetFacetQuery(\"foo\").SetMaxFacetHits(42)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "facetName and facetQuery": "response, err := client.SearchForFacetValues(client.NewApiSearchForFacetValuesRequest(\n  \"<YOUR_INDEX_NAME>\", \"author\").WithSearchForFacetValuesRequest(\n  search.NewEmptySearchForFacetValuesRequest().SetFacetQuery(\"stephen\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "searchRules": {
      "default": "response, err := client.SearchRules(client.NewApiSearchRulesRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchRulesParams(\n  search.NewEmptySearchRulesParams().SetQuery(\"zorro\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "searchSingleIndex": {
      "search with minimal parameters": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search with special characters in indexName": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search with searchParams": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"myQuery\").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(\n    []search.FacetFilters{*search.StringAsFacetFilters(\"tags:algolia\")})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "single search retrieve snippets": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"batman mask of the phantasm\").SetAttributesToRetrieve(\n    []string{\"*\"}).SetAttributesToSnippet(\n    []string{\"*:20\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "query": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"phone\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "filters": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetFilters(\"country:US AND price.gross < 2.0\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "filters for stores": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"ben\").SetFilters(\"categories:politics AND store:Gibert Joseph Saint-Michel\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "filters boolean": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetFilters(\"is_available:true\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "distinct": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetDistinct(search.BoolAsDistinct(true)))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "filtersNumeric": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetFilters(\"price < 10\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "filtersTimestamp": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetFilters(\"NOT date_timestamp:1514764800 TO 1546300799\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "filtersSumOrFiltersScoresFalse": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetFilters(\"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\").SetSumOrFiltersScores(false))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "filtersSumOrFiltersScoresTrue": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetFilters(\"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\").SetSumOrFiltersScores(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "filtersStephenKing": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetFilters(\"author:\\\"Stephen King\\\"\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "filtersNotTags": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"harry\").SetFilters(\"_tags:non-fiction\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "facetFiltersList": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(\n    []search.FacetFilters{*search.StringAsFacetFilters(\"publisher:Penguin\"), *search.ArrayOfFacetFiltersAsFacetFilters(\n      []search.FacetFilters{*search.StringAsFacetFilters(\"author:Stephen King\"), *search.StringAsFacetFilters(\"genre:Horror\")})})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "facetFiltersBook": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(\n    []search.FacetFilters{*search.StringAsFacetFilters(\"category:Book\")})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "facetFiltersAND": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(\n    []search.FacetFilters{*search.StringAsFacetFilters(\"category:Book\"), *search.StringAsFacetFilters(\"author:John Doe\")})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "facetFiltersOR": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(\n    []search.FacetFilters{*search.ArrayOfFacetFiltersAsFacetFilters(\n      []search.FacetFilters{*search.StringAsFacetFilters(\"category:Book\"), *search.StringAsFacetFilters(\"author:John Doe\")})})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "facetFiltersCombined": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(\n    []search.FacetFilters{*search.StringAsFacetFilters(\"author:John Doe\"), *search.ArrayOfFacetFiltersAsFacetFilters(\n      []search.FacetFilters{*search.StringAsFacetFilters(\"category:Book\"), *search.StringAsFacetFilters(\"category:Movie\")})})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "facetFiltersNeg": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetFacetFilters(search.StringAsFacetFilters(\"category:-Ebook\")))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "filtersAndFacetFilters": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetFilters(\"(author:\\\"Stephen King\\\" OR genre:\\\"Horror\\\")\").SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(\n    []search.FacetFilters{*search.StringAsFacetFilters(\"publisher:Penguin\")})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "facet author genre": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetFacets(\n    []string{\"author\", \"genre\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "facet wildcard": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetFacets(\n    []string{\"*\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "maxValuesPerFacet": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetMaxValuesPerFacet(1000))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "aroundLatLng": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetAroundLatLng(\"40.71, -74.01\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "aroundLatLngViaIP": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetAroundLatLngViaIP(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "aroundRadius": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetAroundLatLng(\"40.71, -74.01\").SetAroundRadius(search.Int32AsAroundRadius(1000000)))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "insideBoundingBox": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetInsideBoundingBox(search.ArrayOfArrayOfFloat64AsInsideBoundingBox(\n    [][]float64{\n      []float64{49.067996905313834, 65.73828125, 25.905859247243498, 128.8046875}})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "insidePolygon": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetInsidePolygon(\n    [][]float64{\n      []float64{42.01, -124.31, 48.835509470063045, -124.40453125000005, 45.01082951668149, -65.95726562500005, 31.247243545293433, -81.06578125000004, 25.924152577235226, -97.68234374999997, 32.300311895879545, -117.54828125}}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "optionalFilters": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetOptionalFilters(search.ArrayOfOptionalFiltersAsOptionalFilters(\n    []search.OptionalFilters{*search.StringAsOptionalFilters(\"can_deliver_quickly:true\")})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "optionalFiltersMany": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetOptionalFilters(search.ArrayOfOptionalFiltersAsOptionalFilters(\n    []search.OptionalFilters{*search.StringAsOptionalFilters(\"brand:Apple<score=3>\"), *search.StringAsOptionalFilters(\"brand:Samsung<score=2>\"), *search.StringAsOptionalFilters(\"brand:-Huawei\")})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "optionalFiltersSimple": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetOptionalFilters(search.ArrayOfOptionalFiltersAsOptionalFilters(\n    []search.OptionalFilters{*search.StringAsOptionalFilters(\"brand:Apple<score=2>\"), *search.StringAsOptionalFilters(\"type:tablet\")})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "restrictSearchableAttributes": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetRestrictSearchableAttributes(\n    []string{\"title_fr\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "getRankingInfo": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetGetRankingInfo(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "clickAnalytics": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetClickAnalytics(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "clickAnalyticsUserToken": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetClickAnalytics(true).SetUserToken(\"user-1\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enablePersonalization": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetEnablePersonalization(true).SetUserToken(\"user-1\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "userToken": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetUserToken(\"user-1\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "userToken1234": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetUserToken(\"user-1234\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "analyticsTag": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetAnalyticsTags(\n    []string{\"YOUR_ANALYTICS_TAG\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "facetFiltersUsers": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetFacetFilters(search.ArrayOfFacetFiltersAsFacetFilters(\n    []search.FacetFilters{*search.StringAsFacetFilters(\"user:user42\"), *search.StringAsFacetFilters(\"user:public\")})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "buildTheQuery": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetFilters(\"categoryPageId: Men's Clothing\").SetHitsPerPage(50).SetAnalyticsTags(\n    []string{\"mens-clothing\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "attributesToHighlightOverride": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetAttributesToHighlight(\n    []string{\"title\", \"content\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "disableTypoToleranceOnAttributes": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetDisableTypoToleranceOnAttributes(\n    []string{\"serial_number\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search_a_query": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"\").SetSimilarQuery(\"Comedy Drama Crime McDormand Macy Buscemi Stormare Presnell Coen\").SetFilters(\"year:1991 TO 2001\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search_everything": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "api_filtering_range_example": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"books\").SetFilters(\"price:10 TO 20\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_retrievable_attributes": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetAttributesToRetrieve(\n    []string{\"title\", \"content\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "restrict_searchable_attributes": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetRestrictSearchableAttributes(\n    []string{\"title\", \"author\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_default_relevancy": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetRelevancyStrictness(70))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "apply_filters": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetSumOrFiltersScores(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "apply_all_filters": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetFilters(\"available = 1 AND (category:Book OR NOT category:Ebook) AND _tags:published AND publication_date:1441745506 TO 1441755506 AND inStock > 0 AND author:\\\"John Doe\\\"\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "escape_spaces": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetFilters(\"category:\\\"Books and Comics\\\"\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "escape_keywords": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetFilters(\"keyword:\\\"OR\\\"\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "escape_single_quotes": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetFilters(\"content:\\\"It's a wonderful day\\\"\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "escape_double_quotes": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetFilters(\"content:\\\"She said \\\"Hello World\\\"\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "apply_negative_filters": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetOptionalFilters(search.ArrayOfOptionalFiltersAsOptionalFilters(\n    []search.OptionalFilters{*search.StringAsOptionalFilters(\"category:Book\"), *search.StringAsOptionalFilters(\"author:-John Doe\")})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "apply_negative_filters_restaurants": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetOptionalFilters(search.ArrayOfOptionalFiltersAsOptionalFilters(\n    []search.OptionalFilters{*search.StringAsOptionalFilters(\"restaurant:-Bert's Inn\")})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "apply_numeric_filters": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetNumericFilters(search.ArrayOfNumericFiltersAsNumericFilters(\n    []search.NumericFilters{*search.StringAsNumericFilters(\"price < 1000\"), *search.ArrayOfNumericFiltersAsNumericFilters(\n      []search.NumericFilters{*search.StringAsNumericFilters(\"inStock = 1\"), *search.StringAsNumericFilters(\"deliveryDate < 1441755506\")})})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "apply_tag_filters": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetTagFilters(search.ArrayOfTagFiltersAsTagFilters(\n    []search.TagFilters{*search.StringAsTagFilters(\"SciFi\"), *search.ArrayOfTagFiltersAsTagFilters(\n      []search.TagFilters{*search.StringAsTagFilters(\"Book\"), *search.StringAsTagFilters(\"Movie\")})})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "facets_all": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetFacets(\n    []string{\"*\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "retrieve_only_some_facets": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetFacets(\n    []string{\"category\", \"author\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_default_max_values_per_facet": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetMaxValuesPerFacet(20))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enable_faceting_after_distinct": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetFacetingAfterDistinct(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "sort_facet_values_alphabetically": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetSortFacetValuesBy(\"count\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_attributes_to_snippet": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetAttributesToSnippet(\n    []string{\"title\", \"content:80\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_default_highlight_pre_tag": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetHighlightPreTag(\"<strong>\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_default_highlight_post_tag": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetHighlightPostTag(\"</strong>\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_default_snippet_ellipsis_text": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetSnippetEllipsisText(\"\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enable_restrict_highlight_and_snippet_arrays": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetRestrictHighlightAndSnippetArrays(false))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "access_page": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetPage(0))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_default_hits_per_page": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetHitsPerPage(10))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "get_nth_hit": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetOffset(4))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "get_n_results": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetLength(4))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_default_min_word_size_for_one_typo": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetMinWordSizefor1Typo(2))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_default_min_word_size_for_two_typos": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetMinWordSizefor2Typos(2))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_default_typo_tolerance_mode": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetTypoTolerance(search.BoolAsTypoTolerance(false)))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "disable_typos_on_numeric_tokens_at_search_time": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetAllowTyposOnNumericTokens(false))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search_around_a_position": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetAroundLatLng(\"40.71, -74.01\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search_around_server_ip": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetAroundLatLngViaIP(true))), search.WithHeaderParam(\"x-forwarded-for\", \"94.228.178.246 // should be replaced with the actual IP you would like to search around\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_around_radius": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetAroundRadius(search.Int32AsAroundRadius(1000)))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "disable_automatic_radius": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetAroundRadius(search.AroundRadiusAllAsAroundRadius(search.AroundRadiusAll(\"all\"))))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_geo_search_precision": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetAroundPrecision(search.Int32AsAroundPrecision(100)))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_geo_search_precision_non_linear": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetAroundPrecision(search.ArrayOfModelRangeAsAroundPrecision(\n    []search.ModelRange{*search.NewEmptyModelRange().SetFrom(0).SetValue(25), *search.NewEmptyModelRange().SetFrom(2000).SetValue(1000)})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_minimum_geo_search_radius": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetMinimumAroundRadius(1000))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search_inside_rectangular_area": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetInsideBoundingBox(search.ArrayOfArrayOfFloat64AsInsideBoundingBox(\n    [][]float64{\n      []float64{46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625}})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search_inside_multiple_rectangular_areas": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetInsideBoundingBox(search.ArrayOfArrayOfFloat64AsInsideBoundingBox(\n    [][]float64{\n      []float64{46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625},\n      []float64{49.62625916704081, 4.6181640625, 47.715070300900194, 0.482421875}})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search_inside_polygon_area": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetInsidePolygon(\n    [][]float64{\n      []float64{46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625}}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "search_inside_multiple_polygon_areas": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetInsidePolygon(\n    [][]float64{\n      []float64{46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625},\n      []float64{49.62625916704081, 4.6181640625, 47.715070300900194, 0.482421875, 45.17210966999772, 1.009765625, 50.62626704081, 4.6181640625}}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_querylanguages_override": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetRemoveStopWords(search.ArrayOfSupportedLanguageAsRemoveStopWords(\n    []search.SupportedLanguage{search.SupportedLanguage(\"ca\"), search.SupportedLanguage(\"es\")})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_querylanguages_with_japanese_query": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetQueryLanguages(\n    []search.SupportedLanguage{search.SupportedLanguage(\"ja\"), search.SupportedLanguage(\"en\")}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_natural_languages": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"\").SetNaturalLanguages(\n    []search.SupportedLanguage{search.SupportedLanguage(\"fr\")}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_natural_languages_with_query": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"\").SetNaturalLanguages(\n    []search.SupportedLanguage{search.SupportedLanguage(\"fr\")}).SetRemoveWordsIfNoResults(search.RemoveWordsIfNoResults(\"firstWords\")))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enable_decompound_query_search_time": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetDecompoundQuery(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enable_rules_search_time": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetEnableRules(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_rule_contexts": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetRuleContexts(\n    []string{\"front_end\", \"website2\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enable_personalization": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetEnablePersonalization(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enable_personalization_with_user_token": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetEnablePersonalization(true).SetUserToken(\"123456\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "personalization_impact": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetPersonalizationImpact(20))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_user_token": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetUserToken(\"123456\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_user_token_with_personalization": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetEnablePersonalization(true).SetUserToken(\"123456\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_default_query_type": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetQueryType(search.QueryType(\"prefixAll\")))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_default_remove_words_if_no_results": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetRemoveWordsIfNoResults(search.RemoveWordsIfNoResults(\"lastWords\")))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enable_advanced_syntax_search_time": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetAdvancedSyntax(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "overide_default_optional_words": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetOptionalWords(search.ArrayOfStringAsOptionalWords(\n    []string{\"toyota\", \"2020 2021\"})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "disabling_exact_for_some_attributes_search_time": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetDisableExactOnAttributes(\n    []string{\"description\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_default_exact_single_word_query": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetExactOnSingleWordQuery(search.ExactOnSingleWordQuery(\"none\")))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_default_aternative_as_exact": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetAlternativesAsExact(\n    []search.AlternativesAsExact{search.AlternativesAsExact(\"multiWordsSynonym\")}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enable_advanced_syntax_exact_phrase": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetAdvancedSyntax(true).SetAdvancedSyntaxFeatures(\n    []search.AdvancedSyntaxFeatures{search.AdvancedSyntaxFeatures(\"exactPhrase\")}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enable_advanced_syntax_exclude_words": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetAdvancedSyntax(true).SetAdvancedSyntaxFeatures(\n    []search.AdvancedSyntaxFeatures{search.AdvancedSyntaxFeatures(\"excludeWords\")}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_distinct": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetDistinct(search.Int32AsDistinct(0)))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "get_ranking_info": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetGetRankingInfo(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "disable_click_analytics": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetClickAnalytics(false))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enable_click_analytics": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetClickAnalytics(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "disable_analytics": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetAnalytics(false))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "add_analytics_tags": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetAnalyticsTags(\n    []string{\"front_end\", \"website2\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "disable_synonyms": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetSynonyms(false))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_replace_synonyms_in_highlights": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetReplaceSynonymsInHighlight(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_min_proximity": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetMinProximity(2))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_default_field": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetResponseFields(\n    []string{\"hits\", \"facets\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "override_percentile_computation": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetPercentileComputation(false))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_ab_test": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetEnableABTest(false))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_enable_re_ranking": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\").SetEnableReRanking(false))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "with algolia user id": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"query\"))), search.WithHeaderParam(\"X-Algolia-User-ID\", \"user1234\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "mcm with algolia user id": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchParams(search.SearchParamsObjectAsSearchParams(\n  search.NewEmptySearchParamsObject().SetQuery(\"peace\"))), search.WithHeaderParam(\"X-Algolia-User-ID\", \"user42\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "searchSynonyms": {
      "searchSynonyms with minimal parameters": "response, err := client.SearchSynonyms(client.NewApiSearchSynonymsRequest(\n  \"<YOUR_INDEX_NAME>\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "searchSynonyms with all parameters": "response, err := client.SearchSynonyms(client.NewApiSearchSynonymsRequest(\n  \"<YOUR_INDEX_NAME>\").WithSearchSynonymsParams(\n  search.NewEmptySearchSynonymsParams().SetQuery(\"myQuery\").SetType(search.SynonymType(\"altcorrection1\")).SetPage(10).SetHitsPerPage(10)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "searchUserIds": {
      "default": "response, err := client.SearchUserIds(client.NewApiSearchUserIdsRequest(\n\n  search.NewEmptySearchUserIdsParams().SetQuery(\"test\").SetClusterName(\"theClusterName\").SetPage(5).SetHitsPerPage(10)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "setClientApiKey": {
      "default": "err = client.SetClientApiKey(\n  \"updated-api-key\")\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "setDictionarySettings": {
      "get setDictionarySettings results with minimal parameters": "response, err := client.SetDictionarySettings(client.NewApiSetDictionarySettingsRequest(\n\n  search.NewEmptyDictionarySettingsParams().SetDisableStandardEntries(\n    search.NewEmptyStandardEntries().SetPlurals(map[string]bool{\"fr\": false, \"en\": false, \"ru\": true}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "get setDictionarySettings results with all parameters": "response, err := client.SetDictionarySettings(client.NewApiSetDictionarySettingsRequest(\n\n  search.NewEmptyDictionarySettingsParams().SetDisableStandardEntries(\n    search.NewEmptyStandardEntries().SetPlurals(map[string]bool{\"fr\": false, \"en\": false, \"ru\": true}).SetStopwords(map[string]bool{\"fr\": false}).SetCompounds(map[string]bool{\"ru\": true}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "setSettings": {
      "minimal parameters": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetPaginationLimitedTo(10)).WithForwardToReplicas(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "boolean typoTolerance": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetTypoTolerance(search.BoolAsTypoTolerance(true))).WithForwardToReplicas(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enum typoTolerance": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetTypoTolerance(search.TypoToleranceEnumAsTypoTolerance(search.TypoToleranceEnum(\"min\")))).WithForwardToReplicas(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "ignorePlurals": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetIgnorePlurals(search.BoolAsIgnorePlurals(true))).WithForwardToReplicas(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "list of string ignorePlurals": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetIgnorePlurals(search.ArrayOfSupportedLanguageAsIgnorePlurals(\n    []search.SupportedLanguage{search.SupportedLanguage(\"fr\")}))).WithForwardToReplicas(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "removeStopWords boolean": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetRemoveStopWords(search.BoolAsRemoveStopWords(true))).WithForwardToReplicas(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "removeStopWords list of string": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetRemoveStopWords(search.ArrayOfSupportedLanguageAsRemoveStopWords(\n    []search.SupportedLanguage{search.SupportedLanguage(\"fr\")}))).WithForwardToReplicas(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "boolean distinct": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetDistinct(search.BoolAsDistinct(true))).WithForwardToReplicas(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "integer distinct": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetDistinct(search.Int32AsDistinct(1))).WithForwardToReplicas(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "distinct company": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributeForDistinct(\"company\").SetDistinct(search.BoolAsDistinct(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "distinct design": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributeForDistinct(\"design\").SetDistinct(search.BoolAsDistinct(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "distinct true": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetDistinct(search.BoolAsDistinct(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "distinct section": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributeForDistinct(\"section\").SetDistinct(search.BoolAsDistinct(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "attributesForFaceting allergens": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesForFaceting(\n    []string{\"allergens\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "attributesForFaceting availableIn": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesForFaceting(\n    []string{\"color\", \"availableIn\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "api_attributes_for_faceting": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesForFaceting(\n    []string{\"genre\", \"author\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "api_attributes_for_faceting_searchable": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesForFaceting(\n    []string{\"genre\", \"searchable(author)\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "api_attributes_for_filter_only": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesForFaceting(\n    []string{\"filterOnly(genre)\", \"author\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "attributesForFaceting categoryPageId": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesForFaceting(\n    []string{\"searchable(categoryPageId)\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "unretrievableAttributes": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetUnretrievableAttributes(\n    []string{\"visible_by\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "attributesForFaceting user restricted data": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesForFaceting(\n    []string{\"filterOnly(visible_by)\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "attributesForFaceting optional filters": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesForFaceting(\n    []string{\"can_deliver_quickly\", \"restaurant\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "attributesForFaceting redirect index": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesForFaceting(\n    []string{\"query_terms\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "attributesForFaceting multiple consequences": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesForFaceting(\n    []string{\"director\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "attributesForFaceting in-depth optional filters": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesForFaceting(\n    []string{\"filterOnly(brand)\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "mode neuralSearch": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetMode(search.Mode(\"neuralSearch\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "mode keywordSearch": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetMode(search.Mode(\"keywordSearch\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "searchableAttributes same priority": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetSearchableAttributes(\n    []string{\"title,comments\", \"ingredients\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "searchableAttributes higher priority": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetSearchableAttributes(\n    []string{\"title\", \"ingredients\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "customRanking retweets": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetCustomRanking(\n    []string{\"desc(retweets)\", \"desc(likes)\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "customRanking boosted": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetCustomRanking(\n    []string{\"desc(boosted)\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "customRanking pageviews": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetCustomRanking(\n    []string{\"desc(pageviews)\", \"desc(comments)\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "customRanking applying search parameters for a specific query": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetCustomRanking(\n    []string{\"desc(nb_airline_liaisons)\"}).SetAttributesForFaceting(\n    []string{\"city, country\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "customRanking rounded pageviews": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetCustomRanking(\n    []string{\"desc(rounded_pageviews)\", \"desc(comments)\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "customRanking price": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetCustomRanking(\n    []string{\"desc(price)\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "ranking exhaustive (price)": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetRanking(\n    []string{\"desc(price)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "ranking exhaustive (is_popular)": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetRanking(\n    []string{\"desc(is_popular)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "ranking standard replica": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetRanking(\n    []string{\"desc(post_date_timestamp)\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "ranking virtual replica": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetCustomRanking(\n    []string{\"desc(post_date_timestamp)\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "customRanking and ranking sort alphabetically": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetCustomRanking(\n    []string{\"asc(textual_attribute)\"}).SetRanking(\n    []string{\"custom\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "relevancyStrictness": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetCustomRanking(\n    []string{\"asc(textual_attribute)\"}).SetRelevancyStrictness(0)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "create replica index": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetReplicas(\n    []string{\"products_price_desc\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "create replica index articles": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetReplicas(\n    []string{\"articles_date_desc\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "create virtual replica index": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetReplicas(\n    []string{\"virtual(products_price_desc)\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "unlink replica index": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetReplicas(\n    []string{\"\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "forwardToReplicas": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetSearchableAttributes(\n    []string{\"name\", \"description\"})).WithForwardToReplicas(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "maxValuesPerFacet": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetMaxValuesPerFacet(1000)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "maxFacetHits": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetMaxFacetHits(100)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "attributesForFaceting complex": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesForFaceting(\n    []string{\"actor\", \"filterOnly(category)\", \"searchable(publisher)\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "ranking closest dates": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetRanking(\n    []string{\"asc(date_timestamp)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "searchableAttributes item variation": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetSearchableAttributes(\n    []string{\"design\", \"type\", \"color\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "searchableAttributes around location": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetSearchableAttributes(\n    []string{\"name\", \"country\", \"city\", \"iata_code\"}).SetCustomRanking(\n    []string{\"desc(links_count)\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "attributesToHighlight": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesToHighlight(\n    []string{\"author\", \"title\", \"content\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "attributesToHighlightStar": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesToHighlight(\n    []string{\"*\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "everything": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAdvancedSyntax(true).SetAdvancedSyntaxFeatures(\n    []search.AdvancedSyntaxFeatures{search.AdvancedSyntaxFeatures(\"exactPhrase\")}).SetAllowCompressionOfIntegerArray(true).SetAllowTyposOnNumericTokens(true).SetAlternativesAsExact(\n    []search.AlternativesAsExact{search.AlternativesAsExact(\"singleWordSynonym\")}).SetAttributeCriteriaComputedByMinProximity(true).SetAttributeForDistinct(\"test\").SetAttributesForFaceting(\n    []string{\"algolia\"}).SetAttributesToHighlight(\n    []string{\"algolia\"}).SetAttributesToRetrieve(\n    []string{\"algolia\"}).SetAttributesToSnippet(\n    []string{\"algolia\"}).SetAttributesToTransliterate(\n    []string{\"algolia\"}).SetCamelCaseAttributes(\n    []string{\"algolia\"}).SetCustomNormalization(map[string]map[string]string{\"algolia\": map[string]string{\"aloglia\": \"aglolia\"}}).SetCustomRanking(\n    []string{\"algolia\"}).SetDecompoundQuery(false).SetDecompoundedAttributes(map[string]any{\"algolia\": \"aloglia\"}).SetDisableExactOnAttributes(\n    []string{\"algolia\"}).SetDisablePrefixOnAttributes(\n    []string{\"algolia\"}).SetDisableTypoToleranceOnAttributes(\n    []string{\"algolia\"}).SetDisableTypoToleranceOnWords(\n    []string{\"algolia\"}).SetDistinct(search.Int32AsDistinct(3)).SetEnablePersonalization(true).SetEnableReRanking(false).SetEnableRules(true).SetExactOnSingleWordQuery(search.ExactOnSingleWordQuery(\"attribute\")).SetHighlightPreTag(\"<span>\").SetHighlightPostTag(\"</span>\").SetHitsPerPage(10).SetIgnorePlurals(search.BoolAsIgnorePlurals(false)).SetIndexLanguages(\n    []search.SupportedLanguage{search.SupportedLanguage(\"fr\")}).SetKeepDiacriticsOnCharacters(\"abc\").SetMaxFacetHits(20).SetMaxValuesPerFacet(30).SetMinProximity(6).SetMinWordSizefor1Typo(5).SetMinWordSizefor2Typos(11).SetMode(search.Mode(\"neuralSearch\")).SetNumericAttributesForFiltering(\n    []string{\"algolia\"}).SetOptionalWords(search.ArrayOfStringAsOptionalWords(\n    []string{\"myspace\"})).SetPaginationLimitedTo(0).SetQueryLanguages(\n    []search.SupportedLanguage{search.SupportedLanguage(\"fr\")}).SetQueryType(search.QueryType(\"prefixLast\")).SetRanking(\n    []string{\"geo\"}).SetReRankingApplyFilter(search.StringAsReRankingApplyFilter(\"mySearch:filters\")).SetRelevancyStrictness(10).SetRemoveStopWords(search.BoolAsRemoveStopWords(false)).SetRemoveWordsIfNoResults(search.RemoveWordsIfNoResults(\"lastWords\")).SetRenderingContent(\n    search.NewEmptyRenderingContent().SetFacetOrdering(\n      search.NewEmptyFacetOrdering().SetFacets(\n        search.NewEmptyFacets().SetOrder(\n          []string{\"a\", \"b\"})).SetValues(map[string]search.Value{\"a\": *search.NewEmptyValue().SetOrder(\n        []string{\"b\"}).SetSortRemainingBy(search.SortRemainingBy(\"count\"))}))).SetReplaceSynonymsInHighlight(true).SetReplicas(\n    []string{\"\"}).SetResponseFields(\n    []string{\"algolia\"}).SetRestrictHighlightAndSnippetArrays(true).SetSearchableAttributes(\n    []string{\"foo\"}).SetSemanticSearch(\n    search.NewEmptySemanticSearch().SetEventSources(\n      []string{\"foo\"})).SetSeparatorsToIndex(\"bar\").SetSnippetEllipsisText(\"---\").SetSortFacetValuesBy(\"date\").SetTypoTolerance(search.BoolAsTypoTolerance(false)).SetUnretrievableAttributes(\n    []string{\"foo\"}).SetUserData(map[string]any{\"user\": \"data\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "searchableAttributesWithCustomRankingsAndAttributesForFaceting": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetSearchableAttributes(\n    []string{\"brand\", \"name\", \"categories\", \"unordered(description)\"}).SetCustomRanking(\n    []string{\"desc(popularity)\"}).SetAttributesForFaceting(\n    []string{\"searchable(brand)\", \"type\", \"categories\", \"price\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "searchableAttributesOrdering": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetSearchableAttributes(\n    []string{\"unordered(title)\", \"cast\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "searchableAttributesProductReferenceSuffixes": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetSearchableAttributes(\n    []string{\"name\", \"product_reference\", \"product_reference_suffixes\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "queryLanguageAndIgnorePlurals": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetQueryLanguages(\n    []search.SupportedLanguage{search.SupportedLanguage(\"en\")}).SetIgnorePlurals(search.BoolAsIgnorePlurals(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "searchableAttributesInMovies": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetSearchableAttributes(\n    []string{\"title_eng\", \"title_fr\", \"title_es\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "disablePrefixOnAttributes": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetDisablePrefixOnAttributes(\n    []string{\"serial_number\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "disableTypoToleranceOnAttributes": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetDisableTypoToleranceOnAttributes(\n    []string{\"serial_number\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "searchableAttributesSimpleExample": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetSearchableAttributes(\n    []string{\"serial_number\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "searchableAttributesSimpleExampleAlt": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetSearchableAttributes(\n    []string{\"serial_number\", \"serial_number_suffixes\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_searchable_attributes": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesForFaceting(\n    []string{\"author\", \"filterOnly(isbn)\", \"searchable(edition)\", \"afterDistinct(category)\", \"afterDistinct(searchable(publisher))\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "unretrievable_attributes": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetUnretrievableAttributes(\n    []string{\"total_number_of_sales\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_retrievable_attributes": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesToRetrieve(\n    []string{\"author\", \"title\", \"content\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_all_attributes_as_retrievable": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesToRetrieve(\n    []string{\"*\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "specify_attributes_not_to_retrieve": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesToRetrieve(\n    []string{\"*\", \"-SKU\", \"-internal_desc\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "neural_search": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetMode(search.Mode(\"neuralSearch\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "keyword_search": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetMode(search.Mode(\"keywordSearch\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_ranking": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetRanking(\n    []string{\"typo\", \"geo\", \"words\", \"filters\", \"attribute\", \"proximity\", \"exact\", \"custom\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_ranking_by_attribute_asc": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetRanking(\n    []string{\"asc(price)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_ranking_by_attribute_desc": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetRanking(\n    []string{\"desc(price)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "restrict_searchable_attributes": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetCustomRanking(\n    []string{\"desc(popularity)\", \"asc(price)\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_relevancy": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetRelevancyStrictness(90)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_replicas": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetReplicas(\n    []string{\"name_of_replica_index1\", \"name_of_replica_index2\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_max_values_per_facet": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetMaxValuesPerFacet(100)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_sort_facet_values_by": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetSortFacetValuesBy(\"alpha\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_attributes_to_snippet": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesToSnippet(\n    []string{\"content:80\", \"description\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_all_attributes_to_snippet": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesToSnippet(\n    []string{\"*:80\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_highlight_pre_tag": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetHighlightPreTag(\"<em>\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_highlight_post_tag": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetHighlightPostTag(\"</em>\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_snippet_ellipsis_text": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetSnippetEllipsisText(\"…\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enable_restrict_highlight_and_snippet_arrays_by_default": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetRestrictHighlightAndSnippetArrays(true)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_hits_per_page": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetHitsPerPage(20)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_pagination_limit": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetPaginationLimitedTo(1000)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_min_word_size_for_one_typo": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetMinWordSizefor1Typo(4)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_min_word_size_for_two_typos": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetMinWordSizefor2Typos(4)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_typo_tolerance_mode": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetTypoTolerance(search.BoolAsTypoTolerance(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "disable_typos_on_numeric_tokens_by_default": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAllowTyposOnNumericTokens(false)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "disable_typo_tolerance_for_words": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetDisableTypoToleranceOnWords(\n    []string{\"wheel\", \"1X2BCD\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_separators_to_index": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetSeparatorsToIndex(\"+#\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_languages_using_querylanguages": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetQueryLanguages(\n    []search.SupportedLanguage{search.SupportedLanguage(\"es\")}).SetRemoveStopWords(search.BoolAsRemoveStopWords(true)).SetIgnorePlurals(search.BoolAsIgnorePlurals(true))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_attributes_to_transliterate": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetIndexLanguages(\n    []search.SupportedLanguage{search.SupportedLanguage(\"ja\")}).SetAttributesToTransliterate(\n    []string{\"name\", \"description\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_camel_case_attributes": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetCamelCaseAttributes(\n    []string{\"description\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_decompounded_attributes": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetDecompoundedAttributes(map[string]any{\"de\": []string{\"name\"}})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_decompounded_multiple_attributes": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetDecompoundedAttributes(map[string]any{\"de\": []string{\"name_de\", \"description_de\"}, \"fi\": []string{\"name_fi\", \"description_fi\"}})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_keep_diacritics_on_characters": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetKeepDiacriticsOnCharacters(\"øé\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_custom_normalization": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetCustomNormalization(map[string]map[string]string{\"default\": map[string]string{\"ä\": \"ae\"}})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_indexlanguages": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetIndexLanguages(\n    []search.SupportedLanguage{search.SupportedLanguage(\"ja\")})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enable_decompound_query_by_default": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetDecompoundQuery(true)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enable_rules_syntax_by_default": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetEnableRules(true)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enable_personalization_settings": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetEnablePersonalization(true)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_query_type": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetQueryType(search.QueryType(\"prefixLast\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_remove_words_if_no_result": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetRemoveWordsIfNoResults(search.RemoveWordsIfNoResults(\"none\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enable_advanced_syntax_by_default": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAdvancedSyntax(true)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_optional_words": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetOptionalWords(search.ArrayOfStringAsOptionalWords(\n    []string{\"blue\", \"iphone case\"}))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "disabling_prefix_search_for_some_attributes_by_default": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetDisablePrefixOnAttributes(\n    []string{\"sku\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "disabling_exact_for_some_attributes_by_default": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetDisableExactOnAttributes(\n    []string{\"description\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_exact_single_word_query": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetExactOnSingleWordQuery(search.ExactOnSingleWordQuery(\"attribute\"))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_aternative_as_exact": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAlternativesAsExact(\n    []search.AlternativesAsExact{search.AlternativesAsExact(\"ignorePlurals\"), search.AlternativesAsExact(\"singleWordSynonym\")})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_numeric_attributes_for_filtering": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetNumericAttributesForFiltering(\n    []string{\"quantity\", \"popularity\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "enable_compression_of_integer_array": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAllowCompressionOfIntegerArray(true)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_attributes_for_distinct": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributeForDistinct(\"url\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_distinct": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetDistinct(search.Int32AsDistinct(1)).SetAttributeForDistinct(\"url\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_replace_synonyms_in_highlights": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetReplaceSynonymsInHighlight(false)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_min_proximity": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetMinProximity(1)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_default_field": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetResponseFields(\n    []string{\"hits\", \"hitsPerPage\", \"nbPages\", \"page\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_max_facet_hits": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetMaxFacetHits(10)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_attribute_criteria_computed_by_min_proximity": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributeCriteriaComputedByMinProximity(true)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_user_data": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetUserData(map[string]any{\"extraData\": \"This is the custom data that you want to store in your index\"})))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "set_rendering_content": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetRenderingContent(\n    search.NewEmptyRenderingContent().SetFacetOrdering(\n      search.NewEmptyFacetOrdering().SetFacets(\n        search.NewEmptyFacets().SetOrder(\n          []string{\"size\", \"brand\"})).SetValues(map[string]search.Value{\"brand\": *search.NewEmptyValue().SetOrder(\n        []string{\"uniqlo\"}).SetHide(\n        []string{\"muji\"}).SetSortRemainingBy(search.SortRemainingBy(\"count\")), \"size\": *search.NewEmptyValue().SetOrder(\n        []string{\"S\", \"M\", \"L\"}).SetSortRemainingBy(search.SortRemainingBy(\"hidden\"))})))))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "updateApiKey": {
      "default": "response, err := client.UpdateApiKey(client.NewApiUpdateApiKeyRequest(\n  \"ALGOLIA_API_KEY\",\n  search.NewEmptyApiKey().SetAcl(\n    []search.Acl{search.Acl(\"search\"), search.Acl(\"addObject\")}).SetValidity(300).SetMaxQueriesPerIPPerHour(100).SetMaxHitsPerQuery(20)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "response, err := client.WaitForApiKey(\n  \"api-key-add-operation-test-go\", search.ApiKeyOperation(\"add\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "wait for api key - update": "response, err := client.WaitForApiKey(\n  \"api-key-update-operation-test-go\", search.ApiKeyOperation(\"update\"), search.WithApiKey(\n    search.NewEmptyApiKey().SetDescription(\"my updated api key\").SetAcl(\n      []search.Acl{search.Acl(\"search\"), search.Acl(\"addObject\"), search.Acl(\"deleteObject\")}).SetIndexes(\n      []string{\"Movies\", \"Books\"}).SetReferers(\n      []string{\"*google.com\", \"*algolia.com\"}).SetValidity(305).SetMaxQueriesPerIPPerHour(95).SetMaxHitsPerQuery(20)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "wait for api key - delete": "response, err := client.WaitForApiKey(\n  \"api-key-delete-operation-test-go\", search.ApiKeyOperation(\"delete\"))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "waitForAppTask": {
      "default": "response, err := client.WaitForAppTask(\n  123)\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "waitForTask": {
      "default": "response, err := client.WaitForTask(\n  \"<YOUR_INDEX_NAME>\", 123)\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "init": {
      "default": "client, err := search.NewClient(\"ALGOLIA_APPLICATION_ID\", \"ALGOLIA_API_KEY\")\nif err != nil {\n  // The client can fail to initialize if you pass an invalid parameter.\n  panic(err)\n}"
    }
  },
  "java": {
    "import": {
      "default": "import com.algolia.api.SearchClient;\nimport com.algolia.config.*;"
    },
    "addApiKey": {
      "minimal": "client.addApiKey(new ApiKey().setAcl(Arrays.asList(Acl.SEARCH, Acl.ADD_OBJECT)).setDescription(\"my new api key\"));",
      "all": "client.addApiKey(\n  new ApiKey()\n    .setAcl(Arrays.asList(Acl.SEARCH, Acl.ADD_OBJECT))\n    .setDescription(\"my new api key\")\n    .setValidity(300)\n    .setMaxQueriesPerIPPerHour(100)\n    .setMaxHitsPerQuery(20)\n);"
    },
    "addOrUpdateObject": {
      "default": "client.addOrUpdateObject(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new HashMap() {\n    {\n      put(\"key\", \"value\");\n    }\n  }\n);"
    },
    "appendSource": {
      "default": "client.appendSource(new Source().setSource(\"theSource\").setDescription(\"theDescription\"));"
    },
    "assignUserId": {
      "simple": "client.assignUserId(\"user42\", new AssignUserIdParams().setCluster(\"d4242-eu\"));",
      "it should not encode the userID": "client.assignUserId(\"user id with spaces\", new AssignUserIdParams().setCluster(\"cluster with spaces\"));"
    },
    "batch": {
      "addObject": "client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams()\n    .setRequests(\n      Arrays.asList(\n        new BatchRequest()\n          .setAction(Action.ADD_OBJECT)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"bar\");\n                put(\"foo\", \"1\");\n              }\n            }\n          ),\n        new BatchRequest()\n          .setAction(Action.ADD_OBJECT)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"baz\");\n                put(\"foo\", \"2\");\n              }\n            }\n          )\n      )\n    )\n);",
      "clear": "client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams()\n    .setRequests(\n      Arrays.asList(\n        new BatchRequest()\n          .setAction(Action.CLEAR)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"value\");\n              }\n            }\n          )\n      )\n    )\n);",
      "delete": "client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams()\n    .setRequests(\n      Arrays.asList(\n        new BatchRequest()\n          .setAction(Action.DELETE)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"value\");\n              }\n            }\n          )\n      )\n    )\n);",
      "deleteObject": "client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams()\n    .setRequests(\n      Arrays.asList(\n        new BatchRequest()\n          .setAction(Action.DELETE_OBJECT)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"value\");\n              }\n            }\n          )\n      )\n    )\n);",
      "partialUpdateObject": "client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams()\n    .setRequests(\n      Arrays.asList(\n        new BatchRequest()\n          .setAction(Action.PARTIAL_UPDATE_OBJECT)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"value\");\n              }\n            }\n          )\n      )\n    )\n);",
      "partialUpdateObjectNoCreate": "client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams()\n    .setRequests(\n      Arrays.asList(\n        new BatchRequest()\n          .setAction(Action.PARTIAL_UPDATE_OBJECT_NO_CREATE)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"value\");\n              }\n            }\n          )\n      )\n    )\n);",
      "updateObject": "client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams()\n    .setRequests(\n      Arrays.asList(\n        new BatchRequest()\n          .setAction(Action.UPDATE_OBJECT)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"value\");\n              }\n            }\n          )\n      )\n    )\n);"
    },
    "batchAssignUserIds": {
      "default": "client.batchAssignUserIds(\"userID\", new BatchAssignUserIdsParams().setCluster(\"theCluster\").setUsers(Arrays.asList(\"user1\", \"user2\")));"
    },
    "batchDictionaryEntries": {
      "replace": "client.batchDictionaryEntries(\n  DictionaryType.PLURALS,\n  new BatchDictionaryEntriesParams()\n    .setClearExistingDictionaryEntries(true)\n    .setRequests(\n      Arrays.asList(\n        new BatchDictionaryEntriesRequest()\n          .setAction(DictionaryAction.ADD_ENTRY)\n          .setBody(\n            new DictionaryEntry()\n              .setObjectID(\"1\")\n              .setLanguage(SupportedLanguage.EN)\n              .setWord(\"fancy\")\n              .setWords(Arrays.asList(\"believe\", \"algolia\"))\n              .setDecomposition(Arrays.asList(\"trust\", \"algolia\"))\n              .setState(DictionaryEntryState.ENABLED)\n          )\n      )\n    )\n);",
      "delete": "client.batchDictionaryEntries(\n  DictionaryType.PLURALS,\n  new BatchDictionaryEntriesParams()\n    .setClearExistingDictionaryEntries(true)\n    .setRequests(\n      Arrays.asList(\n        new BatchDictionaryEntriesRequest().setAction(DictionaryAction.DELETE_ENTRY).setBody(new DictionaryEntry().setObjectID(\"1\"))\n      )\n    )\n);",
      "append": "client.batchDictionaryEntries(\n  DictionaryType.STOPWORDS,\n  new BatchDictionaryEntriesParams()\n    .setRequests(\n      Arrays.asList(\n        new BatchDictionaryEntriesRequest()\n          .setAction(DictionaryAction.ADD_ENTRY)\n          .setBody(\n            new DictionaryEntry().setObjectID(\"1\").setLanguage(SupportedLanguage.EN).setAdditionalProperty(\"additional\", \"try me\")\n          )\n      )\n    )\n);"
    },
    "browse": {
      "browse with minimal parameters": "client.browse(\"<YOUR_INDEX_NAME>\", Hit.class);",
      "browse with search parameters": "client.browse(\n  \"<YOUR_INDEX_NAME>\",\n  new BrowseParamsObject().setQuery(\"myQuery\").setFacetFilters(FacetFilters.of(Arrays.asList(FacetFilters.of(\"tags:algolia\")))),\n  Hit.class\n);",
      "browse allow a cursor in parameters": "client.browse(\"<YOUR_INDEX_NAME>\", new BrowseParamsObject().setCursor(\"test\"), Hit.class);"
    },
    "clearObjects": {
      "default": "client.clearObjects(\"<YOUR_INDEX_NAME>\");"
    },
    "clearRules": {
      "default": "client.clearRules(\"<YOUR_INDEX_NAME>\");"
    },
    "clearSynonyms": {
      "default": "client.clearSynonyms(\"<YOUR_INDEX_NAME>\");"
    },
    "customDelete": {
      "allow del method for a custom path with minimal parameters": "client.customDelete(\"test/minimal\");",
      "allow del method for a custom path with all parameters": "client.customDelete(\n  \"test/all\",\n  new HashMap() {\n    {\n      put(\"query\", \"parameters\");\n    }\n  }\n);"
    },
    "customGet": {
      "allow get method for a custom path with minimal parameters": "client.customGet(\"test/minimal\");",
      "allow get method for a custom path with all parameters": "client.customGet(\n  \"test/all\",\n  new HashMap() {\n    {\n      put(\"query\", \"parameters with space\");\n    }\n  }\n);",
      "requestOptions should be escaped too": "client.customGet(\n  \"test/all\",\n  new HashMap() {\n    {\n      put(\"query\", \"to be overriden\");\n    }\n  },\n  new RequestOptions()\n    .addExtraQueryParameters(\"query\", \"parameters with space\")\n    .addExtraQueryParameters(\"and an array\", Arrays.asList(\"array\", \"with spaces\"))\n    .addExtraHeader(\"x-header-1\", \"spaces are left alone\")\n);"
    },
    "customPost": {
      "allow post method for a custom path with minimal parameters": "client.customPost(\"test/minimal\");",
      "allow post method for a custom path with all parameters": "client.customPost(\n  \"test/all\",\n  new HashMap() {\n    {\n      put(\"query\", \"parameters\");\n    }\n  },\n  new HashMap() {\n    {\n      put(\"body\", \"parameters\");\n    }\n  }\n);",
      "requestOptions can override default query parameters": "client.customPost(\n  \"test/requestOptions\",\n  new HashMap() {\n    {\n      put(\"query\", \"parameters\");\n    }\n  },\n  new HashMap() {\n    {\n      put(\"facet\", \"filters\");\n    }\n  },\n  new RequestOptions().addExtraQueryParameters(\"query\", \"myQueryParameter\")\n);",
      "requestOptions merges query parameters with default ones": "client.customPost(\n  \"test/requestOptions\",\n  new HashMap() {\n    {\n      put(\"query\", \"parameters\");\n    }\n  },\n  new HashMap() {\n    {\n      put(\"facet\", \"filters\");\n    }\n  },\n  new RequestOptions().addExtraQueryParameters(\"query2\", \"myQueryParameter\")\n);",
      "requestOptions can override default headers": "client.customPost(\n  \"test/requestOptions\",\n  new HashMap() {\n    {\n      put(\"query\", \"parameters\");\n    }\n  },\n  new HashMap() {\n    {\n      put(\"facet\", \"filters\");\n    }\n  },\n  new RequestOptions().addExtraHeader(\"x-algolia-api-key\", \"ALGOLIA_API_KEY\")\n);",
      "requestOptions merges headers with default ones": "client.customPost(\n  \"test/requestOptions\",\n  new HashMap() {\n    {\n      put(\"query\", \"parameters\");\n    }\n  },\n  new HashMap() {\n    {\n      put(\"facet\", \"filters\");\n    }\n  },\n  new RequestOptions().addExtraHeader(\"x-algolia-api-key\", \"ALGOLIA_API_KEY\")\n);",
      "requestOptions queryParameters accepts booleans": "client.customPost(\n  \"test/requestOptions\",\n  new HashMap() {\n    {\n      put(\"query\", \"parameters\");\n    }\n  },\n  new HashMap() {\n    {\n      put(\"facet\", \"filters\");\n    }\n  },\n  new RequestOptions().addExtraQueryParameters(\"isItWorking\", true)\n);",
      "requestOptions queryParameters accepts integers": "client.customPost(\n  \"test/requestOptions\",\n  new HashMap() {\n    {\n      put(\"query\", \"parameters\");\n    }\n  },\n  new HashMap() {\n    {\n      put(\"facet\", \"filters\");\n    }\n  },\n  new RequestOptions().addExtraQueryParameters(\"myParam\", 2)\n);",
      "requestOptions queryParameters accepts list of string": "client.customPost(\n  \"test/requestOptions\",\n  new HashMap() {\n    {\n      put(\"query\", \"parameters\");\n    }\n  },\n  new HashMap() {\n    {\n      put(\"facet\", \"filters\");\n    }\n  },\n  new RequestOptions().addExtraQueryParameters(\"myParam\", Arrays.asList(\"b and c\", \"d\"))\n);",
      "requestOptions queryParameters accepts list of booleans": "client.customPost(\n  \"test/requestOptions\",\n  new HashMap() {\n    {\n      put(\"query\", \"parameters\");\n    }\n  },\n  new HashMap() {\n    {\n      put(\"facet\", \"filters\");\n    }\n  },\n  new RequestOptions().addExtraQueryParameters(\"myParam\", Arrays.asList(true, true, false))\n);",
      "requestOptions queryParameters accepts list of integers": "client.customPost(\n  \"test/requestOptions\",\n  new HashMap() {\n    {\n      put(\"query\", \"parameters\");\n    }\n  },\n  new HashMap() {\n    {\n      put(\"facet\", \"filters\");\n    }\n  },\n  new RequestOptions().addExtraQueryParameters(\"myParam\", Arrays.asList(1, 2))\n);"
    },
    "customPut": {
      "allow put method for a custom path with minimal parameters": "client.customPut(\"test/minimal\");",
      "allow put method for a custom path with all parameters": "client.customPut(\n  \"test/all\",\n  new HashMap() {\n    {\n      put(\"query\", \"parameters\");\n    }\n  },\n  new HashMap() {\n    {\n      put(\"body\", \"parameters\");\n    }\n  }\n);"
    },
    "deleteApiKey": {
      "default": "client.deleteApiKey(\"myTestApiKey\");"
    },
    "deleteBy": {
      "default": "client.deleteBy(\"<YOUR_INDEX_NAME>\", new DeleteByParams().setFilters(\"brand:brandName\"));"
    },
    "deleteIndex": {
      "default": "client.deleteIndex(\"<YOUR_INDEX_NAME>\");"
    },
    "deleteObject": {
      "default": "client.deleteObject(\"<YOUR_INDEX_NAME>\", \"uniqueID\");"
    },
    "deleteObjects": {
      "default": "client.deleteObjects(\"<YOUR_INDEX_NAME>\", Arrays.asList(\"1\", \"2\"));"
    },
    "deleteRule": {
      "delete rule simple case": "client.deleteRule(\"<YOUR_INDEX_NAME>\", \"id1\");",
      "delete rule with simple characters to encode in objectID": "client.deleteRule(\"<YOUR_INDEX_NAME>\", \"test/with/slash\");"
    },
    "deleteSource": {
      "default": "client.deleteSource(\"theSource\");"
    },
    "deleteSynonym": {
      "default": "client.deleteSynonym(\"<YOUR_INDEX_NAME>\", \"id1\");"
    },
    "generateSecuredApiKey": {
      "api key basic": "client.generateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  new SecuredApiKeyRestrictions().setValidUntil(2524604400L).setRestrictIndices(Arrays.asList(\"Movies\"))\n);",
      "with searchParams": "client.generateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  new SecuredApiKeyRestrictions()\n    .setValidUntil(2524604400L)\n    .setRestrictIndices(Arrays.asList(\"Movies\", \"cts_e2e_settings\"))\n    .setRestrictSources(\"192.168.1.0/24\")\n    .setFilters(\"category:Book OR category:Ebook AND _tags:published\")\n    .setUserToken(\"user123\")\n    .setSearchParams(\n      new SearchParamsObject()\n        .setQuery(\"batman\")\n        .setTypoTolerance(TypoToleranceEnum.STRICT)\n        .setAroundRadius(AroundRadiusAll.ALL)\n        .setMode(Mode.NEURAL_SEARCH)\n        .setHitsPerPage(10)\n        .setOptionalWords(OptionalWords.of(Arrays.asList(\"one\", \"two\")))\n    )\n);",
      "with filters": "client.generateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  new SecuredApiKeyRestrictions().setFilters(\"user:user42 AND user:public AND (visible_by:John OR visible_by:group/Finance)\")\n);",
      "with visible_by filter": "client.generateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  new SecuredApiKeyRestrictions().setFilters(\"visible_by:group/Finance\")\n);",
      "with userID": "client.generateSecuredApiKey(\"2640659426d5107b6e47d75db9cbaef8\", new SecuredApiKeyRestrictions().setUserToken(\"user42\"));",
      "mcm with filters": "client.generateSecuredApiKey(\"YourSearchOnlyApiKey\", new SecuredApiKeyRestrictions().setFilters(\"user:user42 AND user:public\"));",
      "mcm with user token": "client.generateSecuredApiKey(\"YourSearchOnlyApiKey\", new SecuredApiKeyRestrictions().setUserToken(\"user42\"));"
    },
    "getApiKey": {
      "default": "client.getApiKey(\"myTestApiKey\");"
    },
    "getAppTask": {
      "default": "client.getAppTask(123L);"
    },
    "getDictionaryLanguages": {
      "default": "client.getDictionaryLanguages();"
    },
    "getDictionarySettings": {
      "default": "client.getDictionarySettings();"
    },
    "getLogs": {
      "getLogs with minimal parameters": "client.getLogs();",
      "getLogs with parameters": "client.getLogs(5, 10, \"<YOUR_INDEX_NAME>\", LogType.ALL);"
    },
    "getObject": {
      "getObject": "client.getObject(\"<YOUR_INDEX_NAME>\", \"uniqueID\", Arrays.asList(\"attr1\", \"attr2\"));",
      "search with a real object": "client.getObject(\"<YOUR_INDEX_NAME>\", \"Batman and Robin\");"
    },
    "getObjects": {
      "by ID": "client.getObjects(\n  new GetObjectsParams().setRequests(Arrays.asList(new GetObjectsRequest().setObjectID(\"uniqueID\").setIndexName(\"<YOUR_INDEX_NAME>\"))),\n  Hit.class\n);",
      "multiple IDs": "client.getObjects(\n  new GetObjectsParams()\n    .setRequests(\n      Arrays.asList(\n        new GetObjectsRequest().setObjectID(\"uniqueID1\").setIndexName(\"<YOUR_INDEX_NAME>\"),\n        new GetObjectsRequest().setObjectID(\"uniqueID2\").setIndexName(\"<YOUR_INDEX_NAME>\")\n      )\n    ),\n  Hit.class\n);",
      "with attributesToRetrieve": "client.getObjects(\n  new GetObjectsParams()\n    .setRequests(\n      Arrays.asList(\n        new GetObjectsRequest()\n          .setAttributesToRetrieve(Arrays.asList(\"attr1\", \"attr2\"))\n          .setObjectID(\"uniqueID\")\n          .setIndexName(\"<YOUR_INDEX_NAME>\")\n      )\n    ),\n  Hit.class\n);"
    },
    "getRule": {
      "default": "client.getRule(\"<YOUR_INDEX_NAME>\", \"qr-1725004648916\");"
    },
    "getSettings": {
      "default": "client.getSettings(\"<YOUR_INDEX_NAME>\");"
    },
    "getSources": {
      "default": "client.getSources();"
    },
    "getSynonym": {
      "default": "client.getSynonym(\"<YOUR_INDEX_NAME>\", \"id1\");"
    },
    "getTask": {
      "default": "client.getTask(\"<YOUR_INDEX_NAME>\", 123L);"
    },
    "getTopUserIds": {
      "default": "client.getTopUserIds();"
    },
    "getUserId": {
      "default": "client.getUserId(\"uniqueID\");"
    },
    "hasPendingMappings": {
      "hasPendingMappings with minimal parameters": "client.hasPendingMappings();",
      "hasPendingMappings with parameters": "client.hasPendingMappings(true);"
    },
    "indexExists": {
      "indexExists": "client.indexExists(\"<YOUR_INDEX_NAME>\");",
      "indexNotExists": "client.indexExists(\"<YOUR_INDEX_NAME>\");",
      "indexExistsWithError": "client.indexExists(\"<YOUR_INDEX_NAME>\");"
    },
    "listApiKeys": {
      "default": "client.listApiKeys();"
    },
    "listClusters": {
      "default": "client.listClusters();"
    },
    "listIndices": {
      "listIndices with minimal parameters": "client.listIndices();",
      "listIndices with parameters": "client.listIndices(8, 3);"
    },
    "listUserIds": {
      "listUserIds with minimal parameters": "client.listUserIds();",
      "listUserIds with parameters": "client.listUserIds(8, 100);"
    },
    "multipleBatch": {
      "default": "client.multipleBatch(\n  new BatchParams()\n    .setRequests(\n      Arrays.asList(\n        new MultipleBatchRequest()\n          .setAction(Action.ADD_OBJECT)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"value\");\n              }\n            }\n          )\n          .setIndexName(\"<YOUR_INDEX_NAME>\")\n      )\n    )\n);"
    },
    "operationIndex": {
      "scopes": "client.operationIndex(\n  \"<SOURCE_INDEX_NAME>\",\n  new OperationIndexParams()\n    .setOperation(OperationType.MOVE)\n    .setDestination(\"<DESTINATION_INDEX_NAME>\")\n    .setScope(Arrays.asList(ScopeType.RULES, ScopeType.SETTINGS))\n);",
      "copy": "client.operationIndex(\n  \"<SOURCE_INDEX_NAME>\",\n  new OperationIndexParams().setOperation(OperationType.COPY).setDestination(\"<DESTINATION_INDEX_NAME>\")\n);",
      "move": "client.operationIndex(\n  \"<SOURCE_INDEX_NAME>\",\n  new OperationIndexParams().setOperation(OperationType.MOVE).setDestination(\"<DESTINATION_INDEX_NAME>\")\n);"
    },
    "partialUpdateObject": {
      "Partial update with a new value for a string attribute": "client.partialUpdateObject(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new HashMap() {\n    {\n      put(\"attributeId\", \"new value\");\n    }\n  }\n);",
      "Partial update with a new value for an integer attribute": "client.partialUpdateObject(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new HashMap() {\n    {\n      put(\"attributeId\", 1);\n    }\n  }\n);",
      "Partial update with a new value for a boolean attribute": "client.partialUpdateObject(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new HashMap() {\n    {\n      put(\"attributeId\", true);\n    }\n  }\n);",
      "Partial update with a new value for an array attribute": "client.partialUpdateObject(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new HashMap() {\n    {\n      put(\"attributeId\", Arrays.asList(\"one\", \"two\", \"three\"));\n    }\n  }\n);",
      "Partial update with a new value for an object attribute": "client.partialUpdateObject(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new HashMap() {\n    {\n      put(\n        \"attributeId\",\n        new HashMap() {\n          {\n            put(\"nested\", \"value\");\n          }\n        }\n      );\n    }\n  }\n);",
      "with visible_by filter": "client.partialUpdateObject(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new HashMap() {\n    {\n      put(\"visible_by\", Arrays.asList(\"Angela\", \"group/Finance\", \"group/Shareholders\"));\n    }\n  }\n);",
      "add men pant": "client.partialUpdateObject(\n  \"<YOUR_INDEX_NAME>\",\n  \"productId\",\n  new HashMap() {\n    {\n      put(\n        \"categoryPageId\",\n        new HashMap() {\n          {\n            put(\"_operation\", \"Add\");\n            put(\"value\", \"men-clothing-pants\");\n          }\n        }\n      );\n    }\n  }\n);",
      "remove men pant": "client.partialUpdateObject(\n  \"<YOUR_INDEX_NAME>\",\n  \"productId\",\n  new HashMap() {\n    {\n      put(\n        \"categoryPageId\",\n        new HashMap() {\n          {\n            put(\"_operation\", \"Remove\");\n            put(\"value\", \"men-clothing-pants\");\n          }\n        }\n      );\n    }\n  }\n);"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "client.partialUpdateObjects(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new HashMap() {\n      {\n        put(\"objectID\", \"1\");\n        put(\"name\", \"Adam\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"2\");\n        put(\"name\", \"Benoit\");\n      }\n    }\n  ),\n  true\n);",
      "call partialUpdateObjects with createIfNotExists=false": "client.partialUpdateObjects(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new HashMap() {\n      {\n        put(\"objectID\", \"3\");\n        put(\"name\", \"Cyril\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"4\");\n        put(\"name\", \"David\");\n      }\n    }\n  ),\n  false\n);"
    },
    "removeUserId": {
      "default": "client.removeUserId(\"uniqueID\");"
    },
    "replaceAllObjects": {
      "call replaceAllObjects without error": "client.replaceAllObjects(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new HashMap() {\n      {\n        put(\"objectID\", \"1\");\n        put(\"name\", \"Adam\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"2\");\n        put(\"name\", \"Benoit\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"3\");\n        put(\"name\", \"Cyril\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"4\");\n        put(\"name\", \"David\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"5\");\n        put(\"name\", \"Eva\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"6\");\n        put(\"name\", \"Fiona\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"7\");\n        put(\"name\", \"Gael\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"8\");\n        put(\"name\", \"Hugo\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"9\");\n        put(\"name\", \"Igor\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"10\");\n        put(\"name\", \"Julia\");\n      }\n    }\n  ),\n  3\n);",
      "call replaceAllObjects with partial scopes": "client.replaceAllObjects(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new HashMap() {\n      {\n        put(\"objectID\", \"1\");\n        put(\"name\", \"Adam\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"2\");\n        put(\"name\", \"Benoit\");\n      }\n    }\n  ),\n  77,\n  Arrays.asList(ScopeType.SETTINGS, ScopeType.SYNONYMS)\n);",
      "replaceAllObjects should cleanup on failure": "client.replaceAllObjects(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new HashMap() {\n      {\n        put(\"objectID\", \"fine\");\n        put(\"body\", \"small obj\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"toolarge\");\n        put(\"body\", \"something bigger than 10KB\");\n      }\n    }\n  )\n);"
    },
    "replaceSources": {
      "default": "client.replaceSources(Arrays.asList(new Source().setSource(\"theSource\").setDescription(\"theDescription\")));"
    },
    "restoreApiKey": {
      "default": "client.restoreApiKey(\"ALGOLIA_API_KEY\");"
    },
    "saveObject": {
      "default": "client.saveObject(\n  \"<YOUR_INDEX_NAME>\",\n  new HashMap() {\n    {\n      put(\"name\", \"Black T-shirt\");\n      put(\"color\", \"#000000||black\");\n      put(\"availableIn\", \"https://source.unsplash.com/100x100/?paris||Paris\");\n      put(\"objectID\", \"myID\");\n    }\n  }\n);"
    },
    "saveObjects": {
      "call saveObjects without error": "client.saveObjects(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new HashMap() {\n      {\n        put(\"objectID\", \"1\");\n        put(\"name\", \"Adam\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"2\");\n        put(\"name\", \"Benoit\");\n      }\n    }\n  )\n);",
      "saveObjects should report errors": "client.saveObjects(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new HashMap() {\n      {\n        put(\"objectID\", \"1\");\n        put(\"name\", \"Adam\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"2\");\n        put(\"name\", \"Benoit\");\n      }\n    }\n  )\n);",
      "saveObjectsPlaylist": "client.saveObjects(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new HashMap() {\n      {\n        put(\"objectID\", \"1\");\n        put(\"visibility\", \"public\");\n        put(\"name\", \"Hot 100 Billboard Charts\");\n        put(\"playlistId\", \"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\");\n        put(\"createdAt\", \"1500240452\");\n      }\n    }\n  )\n);",
      "saveObjectsPublicUser": "client.saveObjects(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new HashMap() {\n      {\n        put(\"objectID\", \"1\");\n        put(\"visibility\", \"public\");\n        put(\"name\", \"Hot 100 Billboard Charts\");\n        put(\"playlistId\", \"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\");\n        put(\"createdAt\", \"1500240452\");\n      }\n    }\n  ),\n  false,\n  1000,\n  new RequestOptions().addExtraHeader(\"X-Algolia-User-ID\", \"*\")\n);"
    },
    "saveRule": {
      "saveRule with minimal parameters": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"id1\",\n  new Rule()\n    .setObjectID(\"id1\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"apple\").setAnchoring(Anchoring.CONTAINS)))\n    .setConsequence(new Consequence().setParams(new ConsequenceParams().setFilters(\"brand:xiaomi\")))\n);",
      "saveRule with all parameters": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"id1\",\n  new Rule()\n    .setObjectID(\"id1\")\n    .setConditions(\n      Arrays.asList(new Condition().setPattern(\"apple\").setAnchoring(Anchoring.CONTAINS).setAlternatives(false).setContext(\"search\"))\n    )\n    .setConsequence(\n      new Consequence()\n        .setParams(\n          new ConsequenceParams()\n            .setFilters(\"brand:apple\")\n            .setQuery(\n              new ConsequenceQueryObject()\n                .setRemove(Arrays.asList(\"algolia\"))\n                .setEdits(\n                  Arrays.asList(\n                    new Edit().setType(EditType.REMOVE).setDelete(\"abc\").setInsert(\"cde\"),\n                    new Edit().setType(EditType.REPLACE).setDelete(\"abc\").setInsert(\"cde\")\n                  )\n                )\n            )\n        )\n        .setHide(Arrays.asList(new ConsequenceHide().setObjectID(\"321\")))\n        .setFilterPromotes(false)\n        .setUserData(\n          new HashMap() {\n            {\n              put(\"algolia\", \"aloglia\");\n            }\n          }\n        )\n        .setPromote(\n          Arrays.asList(\n            new PromoteObjectID().setObjectID(\"abc\").setPosition(3),\n            new PromoteObjectIDs().setObjectIDs(Arrays.asList(\"abc\", \"def\")).setPosition(1)\n          )\n        )\n    )\n    .setDescription(\"test\")\n    .setEnabled(true)\n    .setValidity(Arrays.asList(new TimeRange().setFrom(1656670273L).setUntil(1656670277L))),\n  true\n);",
      "b2b catalog": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"article-rule\",\n  new Rule()\n    .setObjectID(\"article-rule\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"article\").setAnchoring(Anchoring.STARTS_WITH)))\n    .setConsequence(\n      new Consequence()\n        .setParams(\n          new ConsequenceParams()\n            .setQuery(new ConsequenceQueryObject().setEdits(Arrays.asList(new Edit().setType(EditType.REMOVE).setDelete(\"article\"))))\n            .setRestrictSearchableAttributes(Arrays.asList(\"title\", \"book_id\"))\n        )\n    )\n);",
      "merchandising and promoting": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"director-rule\",\n  new Rule()\n    .setObjectID(\"director-rule\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"{facet:director} director\").setAnchoring(Anchoring.CONTAINS)))\n    .setConsequence(\n      new Consequence()\n        .setParams(\n          new ConsequenceParams()\n            .setRestrictSearchableAttributes(Arrays.asList(\"title\", \"book_id\"))\n            .setAutomaticFacetFilters(\n              AutomaticFacetFilters.ofListOfAutomaticFacetFilter(Arrays.asList(new AutomaticFacetFilter().setFacet(\"director\")))\n            )\n            .setQuery(new ConsequenceQueryObject().setEdits(Arrays.asList(new Edit().setType(EditType.REMOVE).setDelete(\"director\"))))\n        )\n    )\n);",
      "harry potter": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"harry-potter-rule\",\n  new Rule()\n    .setObjectID(\"harry-potter-rule\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"harry potter\").setAnchoring(Anchoring.CONTAINS)))\n    .setConsequence(\n      new Consequence()\n        .setUserData(\n          new HashMap() {\n            {\n              put(\"promo_content\", \"20% OFF on all Harry Potter books!\");\n            }\n          }\n        )\n    )\n);",
      "merchandising empty query": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"clearance-category-filter\",\n  new Rule()\n    .setObjectID(\"clearance-category-filter\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"\").setAnchoring(Anchoring.IS).setContext(\"landing\")))\n    .setConsequence(new Consequence().setParams(new ConsequenceParams().setOptionalFilters(OptionalFilters.of(\"clearance:true\"))))\n);",
      "redirect": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"redirect-help-rule\",\n  new Rule()\n    .setObjectID(\"redirect-help-rule\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"help\").setAnchoring(Anchoring.CONTAINS)))\n    .setConsequence(\n      new Consequence()\n        .setUserData(\n          new HashMap() {\n            {\n              put(\"redirect\", \"https://www.algolia.com/support\");\n            }\n          }\n        )\n    )\n);",
      "promote some results over others": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"tomato-fruit\",\n  new Rule()\n    .setObjectID(\"tomato-fruit\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"tomato\").setAnchoring(Anchoring.CONTAINS)))\n    .setConsequence(new Consequence().setParams(new ConsequenceParams().setOptionalFilters(OptionalFilters.of(\"food_group:fruit\"))))\n);",
      "promote several hits": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"Promote-Apple-Newest\",\n  new Rule()\n    .setObjectID(\"Promote-Apple-Newest\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"apple\").setAnchoring(Anchoring.IS)))\n    .setConsequence(\n      new Consequence()\n        .setPromote(Arrays.asList(new PromoteObjectIDs().setObjectIDs(Arrays.asList(\"iPhone-12345\", \"watch-123\")).setPosition(0)))\n    )\n);",
      "promote newest release": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"Promote-iPhone-X\",\n  new Rule()\n    .setObjectID(\"Promote-iPhone-X\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"iPhone\").setAnchoring(Anchoring.CONTAINS)))\n    .setConsequence(new Consequence().setPromote(Arrays.asList(new PromoteObjectID().setObjectID(\"iPhone-12345\").setPosition(0))))\n);",
      "promote single item": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"promote-harry-potter-box-set\",\n  new Rule()\n    .setObjectID(\"promote-harry-potter-box-set\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"Harry Potter\").setAnchoring(Anchoring.CONTAINS)))\n    .setConsequence(new Consequence().setPromote(Arrays.asList(new PromoteObjectID().setObjectID(\"HP-12345\").setPosition(0))))\n);",
      "limit search results": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"article-rule\",\n  new Rule()\n    .setObjectID(\"article-rule\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"article\").setAnchoring(Anchoring.STARTS_WITH)))\n    .setConsequence(\n      new Consequence()\n        .setParams(\n          new ConsequenceParams()\n            .setQuery(new ConsequenceQueryObject().setEdits(Arrays.asList(new Edit().setType(EditType.REMOVE).setDelete(\"article\"))))\n            .setRestrictSearchableAttributes(Arrays.asList(\"title\", \"book_id\"))\n        )\n    )\n);",
      "query match": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"tagged-brand-rule\",\n  new Rule()\n    .setConditions(\n      Arrays.asList(new Condition().setPattern(\"brand: {facet:brand}\").setAnchoring(Anchoring.CONTAINS).setAlternatives(false))\n    )\n    .setConsequence(\n      new Consequence()\n        .setParams(\n          new ConsequenceParams()\n            .setAutomaticFacetFilters(\n              AutomaticFacetFilters.ofListOfAutomaticFacetFilter(Arrays.asList(new AutomaticFacetFilter().setFacet(\"brand\")))\n            )\n            .setQuery(new ConsequenceQueryObject().setRemove(Arrays.asList(\"brand:\", \"{facet:brand}\")))\n        )\n    )\n    .setDescription(\"filter on brand: {brand}\")\n    .setObjectID(\"tagged-brand-rule\")\n);",
      "dynamic filtering": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"color-facets\",\n  new Rule()\n    .setObjectID(\"color-facets\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"{facet:color}\")))\n    .setConsequence(\n      new Consequence()\n        .setParams(\n          new ConsequenceParams()\n            .setAutomaticFacetFilters(\n              AutomaticFacetFilters.ofListOfAutomaticFacetFilter(Arrays.asList(new AutomaticFacetFilter().setFacet(\"color\")))\n            )\n        )\n    )\n);",
      "hide hits": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"hide-12345\",\n  new Rule()\n    .setObjectID(\"hide-12345\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"cheap\").setAnchoring(Anchoring.CONTAINS)))\n    .setConsequence(new Consequence().setHide(Arrays.asList(new ConsequenceHide().setObjectID(\"to-hide-12345\"))))\n);",
      "one rule per facet": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"red-color\",\n  new Rule()\n    .setObjectID(\"red-color\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"red\").setAnchoring(Anchoring.CONTAINS)))\n    .setConsequence(\n      new Consequence()\n        .setParams(\n          new ConsequenceParams().setQuery(new ConsequenceQueryObject().setRemove(Arrays.asList(\"red\"))).setFilters(\"color:red\")\n        )\n    )\n);",
      "numerical filters": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"cheap\",\n  new Rule()\n    .setObjectID(\"cheap\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"cheap\").setAnchoring(Anchoring.CONTAINS)))\n    .setConsequence(\n      new Consequence()\n        .setParams(\n          new ConsequenceParams().setQuery(new ConsequenceQueryObject().setRemove(Arrays.asList(\"cheap\"))).setFilters(\"price < 10\")\n        )\n    )\n);",
      "negative filters": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"gluten-free-rule\",\n  new Rule()\n    .setObjectID(\"gluten-free-rule\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"gluten-free\").setAnchoring(Anchoring.CONTAINS)))\n    .setConsequence(\n      new Consequence()\n        .setParams(\n          new ConsequenceParams()\n            .setFilters(\"NOT allergens:gluten\")\n            .setQuery(\n              new ConsequenceQueryObject().setEdits(Arrays.asList(new Edit().setType(EditType.REMOVE).setDelete(\"gluten-free\")))\n            )\n        )\n    )\n);",
      "positive filters": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"diet-rule\",\n  new Rule()\n    .setObjectID(\"diet-rule\")\n    .setConditions(Arrays.asList(new Condition().setPattern(\"diet\").setAnchoring(Anchoring.CONTAINS)))\n    .setConsequence(\n      new Consequence()\n        .setParams(\n          new ConsequenceParams()\n            .setFilters(\"'low-carb' OR 'low-fat'\")\n            .setQuery(new ConsequenceQueryObject().setEdits(Arrays.asList(new Edit().setType(EditType.REMOVE).setDelete(\"diet\"))))\n        )\n    )\n);",
      "conditionless": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"diet-rule\",\n  new Rule()\n    .setObjectID(\"diet-rule\")\n    .setConsequence(\n      new Consequence()\n        .setParams(\n          new ConsequenceParams()\n            .setFilters(\"'low-carb' OR 'low-fat'\")\n            .setQuery(new ConsequenceQueryObject().setEdits(Arrays.asList(new Edit().setType(EditType.REMOVE).setDelete(\"diet\"))))\n        )\n    )\n);",
      "contextual": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"a-rule-id\",\n  new Rule()\n    .setObjectID(\"a-rule-id\")\n    .setConditions(Arrays.asList(new Condition().setContext(\"mobile\")))\n    .setConsequence(new Consequence().setParams(new ConsequenceParams().setFilters(\"release_date >= 1577836800\")))\n);",
      "saveRule always active rule": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"a-rule-id\",\n  new Rule()\n    .setObjectID(\"a-rule-id\")\n    .setConsequence(new Consequence().setParams(new ConsequenceParams().setAroundRadius(AroundRadius.of(1000))))\n    .setValidity(Arrays.asList(new TimeRange().setFrom(1577836800L).setUntil(1577836800L)))\n);"
    },
    "saveRules": {
      "saveRules with minimal parameters": "client.saveRules(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new Rule()\n      .setObjectID(\"a-rule-id\")\n      .setConditions(Arrays.asList(new Condition().setPattern(\"smartphone\").setAnchoring(Anchoring.CONTAINS)))\n      .setConsequence(new Consequence().setParams(new ConsequenceParams().setFilters(\"brand:apple\"))),\n    new Rule()\n      .setObjectID(\"a-second-rule-id\")\n      .setConditions(Arrays.asList(new Condition().setPattern(\"apple\").setAnchoring(Anchoring.CONTAINS)))\n      .setConsequence(new Consequence().setParams(new ConsequenceParams().setFilters(\"brand:samsung\")))\n  ),\n  false,\n  true\n);",
      "saveRules with all parameters": "client.saveRules(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new Rule()\n      .setObjectID(\"id1\")\n      .setConditions(\n        Arrays.asList(new Condition().setPattern(\"apple\").setAnchoring(Anchoring.CONTAINS).setAlternatives(false).setContext(\"search\"))\n      )\n      .setConsequence(\n        new Consequence()\n          .setParams(\n            new ConsequenceParams()\n              .setFilters(\"brand:apple\")\n              .setQuery(\n                new ConsequenceQueryObject()\n                  .setRemove(Arrays.asList(\"algolia\"))\n                  .setEdits(\n                    Arrays.asList(\n                      new Edit().setType(EditType.REMOVE).setDelete(\"abc\").setInsert(\"cde\"),\n                      new Edit().setType(EditType.REPLACE).setDelete(\"abc\").setInsert(\"cde\")\n                    )\n                  )\n              )\n          )\n          .setHide(Arrays.asList(new ConsequenceHide().setObjectID(\"321\")))\n          .setFilterPromotes(false)\n          .setUserData(\n            new HashMap() {\n              {\n                put(\"algolia\", \"aloglia\");\n              }\n            }\n          )\n          .setPromote(\n            Arrays.asList(\n              new PromoteObjectID().setObjectID(\"abc\").setPosition(3),\n              new PromoteObjectIDs().setObjectIDs(Arrays.asList(\"abc\", \"def\")).setPosition(1)\n            )\n          )\n      )\n      .setDescription(\"test\")\n      .setEnabled(true)\n      .setValidity(Arrays.asList(new TimeRange().setFrom(1656670273L).setUntil(1656670277L)))\n  ),\n  true,\n  true\n);",
      "dynamic filtering": "client.saveRules(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new Rule()\n      .setObjectID(\"toaster\")\n      .setConditions(Arrays.asList(new Condition().setPattern(\"toaster\").setAnchoring(Anchoring.CONTAINS)))\n      .setConsequence(\n        new Consequence()\n          .setParams(\n            new ConsequenceParams()\n              .setQuery(new ConsequenceQueryObject().setRemove(Arrays.asList(\"toaster\")))\n              .setFilters(\"product_type:toaster\")\n          )\n      ),\n    new Rule()\n      .setObjectID(\"cheap\")\n      .setConditions(Arrays.asList(new Condition().setPattern(\"cheap\").setAnchoring(Anchoring.CONTAINS)))\n      .setConsequence(\n        new Consequence()\n          .setParams(\n            new ConsequenceParams().setQuery(new ConsequenceQueryObject().setRemove(Arrays.asList(\"cheap\"))).setFilters(\"price < 15\")\n          )\n      )\n  )\n);",
      "enhance search results": "client.saveRules(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new Rule()\n      .setObjectID(\"country\")\n      .setConditions(Arrays.asList(new Condition().setPattern(\"{facet:country}\").setAnchoring(Anchoring.CONTAINS)))\n      .setConsequence(new Consequence().setParams(new ConsequenceParams().setAroundLatLngViaIP(false))),\n    new Rule()\n      .setObjectID(\"city\")\n      .setConditions(Arrays.asList(new Condition().setPattern(\"{facet:city}\").setAnchoring(Anchoring.CONTAINS)))\n      .setConsequence(new Consequence().setParams(new ConsequenceParams().setAroundLatLngViaIP(false)))\n  )\n);"
    },
    "saveSynonym": {
      "default": "client.saveSynonym(\n  \"<YOUR_INDEX_NAME>\",\n  \"id1\",\n  new SynonymHit().setObjectID(\"id1\").setType(SynonymType.SYNONYM).setSynonyms(Arrays.asList(\"car\", \"vehicule\", \"auto\")),\n  true\n);"
    },
    "saveSynonyms": {
      "default": "client.saveSynonyms(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new SynonymHit().setObjectID(\"id1\").setType(SynonymType.SYNONYM).setSynonyms(Arrays.asList(\"car\", \"vehicule\", \"auto\")),\n    new SynonymHit()\n      .setObjectID(\"id2\")\n      .setType(SynonymType.ONEWAYSYNONYM)\n      .setInput(\"iphone\")\n      .setSynonyms(Arrays.asList(\"ephone\", \"aphone\", \"yphone\"))\n  ),\n  true,\n  true\n);"
    },
    "search": {
      "withHitsPerPage": "client.search(\n  new SearchMethodParams()\n    .setRequests(Arrays.asList(new SearchForHits().setIndexName(\"<YOUR_INDEX_NAME>\").setQuery(\"<YOUR_QUERY>\").setHitsPerPage(50))),\n  Hit.class\n);",
      "filterOnly": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(\n        new SearchForHits().setIndexName(\"<YOUR_INDEX_NAME>\").setQuery(\"<YOUR_QUERY>\").setFilters(\"actor:Scarlett Johansson\")\n      )\n    ),\n  Hit.class\n);",
      "filterOr": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(\n        new SearchForHits()\n          .setIndexName(\"<YOUR_INDEX_NAME>\")\n          .setQuery(\"<YOUR_QUERY>\")\n          .setFilters(\"actor:Tom Cruise OR actor:Scarlett Johansson\")\n      )\n    ),\n  Hit.class\n);",
      "filterNot": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(new SearchForHits().setIndexName(\"<YOUR_INDEX_NAME>\").setQuery(\"<YOUR_QUERY>\").setFilters(\"NOT actor:Nicolas Cage\"))\n    ),\n  Hit.class\n);",
      "search for a single hits request with minimal parameters": "client.search(new SearchMethodParams().setRequests(Arrays.asList(new SearchForHits().setIndexName(\"<YOUR_INDEX_NAME>\"))), Hit.class);",
      "search with highlight and snippet results": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(\n        new SearchForHits()\n          .setIndexName(\"<YOUR_INDEX_NAME>\")\n          .setQuery(\"vim\")\n          .setAttributesToSnippet(Arrays.asList(\"*:20\"))\n          .setAttributesToHighlight(Arrays.asList(\"*\"))\n          .setAttributesToRetrieve(Arrays.asList(\"*\"))\n      )\n    ),\n  Hit.class\n);",
      "retrieveFacets": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(\n        new SearchForHits().setIndexName(\"<YOUR_INDEX_NAME>\").setQuery(\"<YOUR_QUERY>\").setFacets(Arrays.asList(\"author\", \"genre\"))\n      )\n    ),\n  Hit.class\n);",
      "retrieveFacetsWildcard": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(new SearchForHits().setIndexName(\"<YOUR_INDEX_NAME>\").setQuery(\"<YOUR_QUERY>\").setFacets(Arrays.asList(\"*\")))\n    ),\n  Hit.class\n);",
      "search for a single facet request with minimal parameters": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(new SearchForFacets().setIndexName(\"<YOUR_INDEX_NAME>\").setType(SearchTypeFacet.FACET).setFacet(\"editor\"))\n    )\n    .setStrategy(SearchStrategy.STOP_IF_ENOUGH_MATCHES),\n  Hit.class\n);",
      "search for a single hits request with all parameters": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(\n        new SearchForHits().setIndexName(\"<YOUR_INDEX_NAME>\").setQuery(\"myQuery\").setHitsPerPage(50).setType(SearchTypeDefault.DEFAULT)\n      )\n    ),\n  Hit.class\n);",
      "search for a single facet request with all parameters": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(\n        new SearchForFacets()\n          .setIndexName(\"<YOUR_INDEX_NAME>\")\n          .setType(SearchTypeFacet.FACET)\n          .setFacet(\"theFacet\")\n          .setFacetQuery(\"theFacetQuery\")\n          .setQuery(\"theQuery\")\n          .setMaxFacetHits(50)\n      )\n    )\n    .setStrategy(SearchStrategy.STOP_IF_ENOUGH_MATCHES),\n  Hit.class\n);",
      "search for multiple mixed requests in multiple indices with minimal": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(\n        new SearchForHits().setIndexName(\"<YOUR_INDEX_NAME>\"),\n        new SearchForFacets().setIndexName(\"<YOUR_INDEX_NAME>\").setType(SearchTypeFacet.FACET).setFacet(\"theFacet\"),\n        new SearchForHits().setIndexName(\"<YOUR_INDEX_NAME>\").setType(SearchTypeDefault.DEFAULT)\n      )\n    )\n    .setStrategy(SearchStrategy.STOP_IF_ENOUGH_MATCHES),\n  Hit.class\n);",
      "search for multiple mixed requests in multiple indices with all parameters": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(\n        new SearchForFacets()\n          .setIndexName(\"<YOUR_INDEX_NAME>\")\n          .setType(SearchTypeFacet.FACET)\n          .setFacet(\"theFacet\")\n          .setFacetQuery(\"theFacetQuery\")\n          .setQuery(\"theQuery\")\n          .setMaxFacetHits(50),\n        new SearchForHits().setIndexName(\"<YOUR_INDEX_NAME>\").setQuery(\"myQuery\").setHitsPerPage(50).setType(SearchTypeDefault.DEFAULT)\n      )\n    )\n    .setStrategy(SearchStrategy.STOP_IF_ENOUGH_MATCHES),\n  Hit.class\n);",
      "search filters accept all of the possible shapes": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(\n        new SearchForHits()\n          .setIndexName(\"<YOUR_INDEX_NAME>\")\n          .setFacetFilters(FacetFilters.of(\"mySearch:filters\"))\n          .setReRankingApplyFilter(ReRankingApplyFilter.of(\"mySearch:filters\"))\n          .setTagFilters(TagFilters.of(\"mySearch:filters\"))\n          .setNumericFilters(NumericFilters.of(\"mySearch:filters\"))\n          .setOptionalFilters(OptionalFilters.of(\"mySearch:filters\")),\n        new SearchForHits()\n          .setIndexName(\"<YOUR_INDEX_NAME>\")\n          .setFacetFilters(\n            FacetFilters.of(\n              Arrays.asList(\n                FacetFilters.of(\"mySearch:filters\"),\n                FacetFilters.of(\n                  Arrays.asList(\n                    FacetFilters.of(\"mySearch:filters\"),\n                    FacetFilters.of(Arrays.asList(FacetFilters.of(\"mySearch:filters\")))\n                  )\n                )\n              )\n            )\n          )\n          .setReRankingApplyFilter(\n            ReRankingApplyFilter.of(\n              Arrays.asList(\n                ReRankingApplyFilter.of(\"mySearch:filters\"),\n                ReRankingApplyFilter.of(Arrays.asList(ReRankingApplyFilter.of(\"mySearch:filters\")))\n              )\n            )\n          )\n          .setTagFilters(\n            TagFilters.of(\n              Arrays.asList(TagFilters.of(\"mySearch:filters\"), TagFilters.of(Arrays.asList(TagFilters.of(\"mySearch:filters\"))))\n            )\n          )\n          .setNumericFilters(\n            NumericFilters.of(\n              Arrays.asList(\n                NumericFilters.of(\"mySearch:filters\"),\n                NumericFilters.of(Arrays.asList(NumericFilters.of(\"mySearch:filters\")))\n              )\n            )\n          )\n          .setOptionalFilters(\n            OptionalFilters.of(\n              Arrays.asList(\n                OptionalFilters.of(\"mySearch:filters\"),\n                OptionalFilters.of(Arrays.asList(OptionalFilters.of(\"mySearch:filters\")))\n              )\n            )\n          )\n      )\n    ),\n  Hit.class\n);",
      "search filters end to end": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(\n        new SearchForHits().setIndexName(\"<YOUR_INDEX_NAME>\").setFilters(\"editor:'visual studio' OR editor:neovim\"),\n        new SearchForHits()\n          .setIndexName(\"<YOUR_INDEX_NAME>\")\n          .setFacetFilters(FacetFilters.of(Arrays.asList(FacetFilters.of(\"editor:'visual studio'\"), FacetFilters.of(\"editor:neovim\")))),\n        new SearchForHits()\n          .setIndexName(\"<YOUR_INDEX_NAME>\")\n          .setFacetFilters(\n            FacetFilters.of(\n              Arrays.asList(FacetFilters.of(\"editor:'visual studio'\"), FacetFilters.of(Arrays.asList(FacetFilters.of(\"editor:neovim\"))))\n            )\n          ),\n        new SearchForHits()\n          .setIndexName(\"<YOUR_INDEX_NAME>\")\n          .setFacetFilters(\n            FacetFilters.of(\n              Arrays.asList(\n                FacetFilters.of(\"editor:'visual studio'\"),\n                FacetFilters.of(\n                  Arrays.asList(FacetFilters.of(\"editor:neovim\"), FacetFilters.of(Arrays.asList(FacetFilters.of(\"editor:goland\"))))\n                )\n              )\n            )\n          )\n      )\n    ),\n  Hit.class\n);",
      "search with all search parameters": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(\n        new SearchForHits()\n          .setAdvancedSyntax(true)\n          .setAdvancedSyntaxFeatures(Arrays.asList(AdvancedSyntaxFeatures.EXACT_PHRASE))\n          .setAllowTyposOnNumericTokens(true)\n          .setAlternativesAsExact(Arrays.asList(AlternativesAsExact.MULTI_WORDS_SYNONYM))\n          .setAnalytics(true)\n          .setAnalyticsTags(Arrays.asList(\"\"))\n          .setAroundLatLng(\"\")\n          .setAroundLatLngViaIP(true)\n          .setAroundPrecision(AroundPrecision.of(0))\n          .setAroundRadius(AroundRadiusAll.ALL)\n          .setAttributeCriteriaComputedByMinProximity(true)\n          .setAttributesToHighlight(Arrays.asList(\"\"))\n          .setAttributesToRetrieve(Arrays.asList(\"\"))\n          .setAttributesToSnippet(Arrays.asList(\"\"))\n          .setClickAnalytics(true)\n          .setDecompoundQuery(true)\n          .setDisableExactOnAttributes(Arrays.asList(\"\"))\n          .setDisableTypoToleranceOnAttributes(Arrays.asList(\"\"))\n          .setDistinct(Distinct.of(0))\n          .setEnableABTest(true)\n          .setEnablePersonalization(true)\n          .setEnableReRanking(true)\n          .setEnableRules(true)\n          .setExactOnSingleWordQuery(ExactOnSingleWordQuery.ATTRIBUTE)\n          .setFacetFilters(FacetFilters.of(Arrays.asList(FacetFilters.of(\"\"))))\n          .setFacetingAfterDistinct(true)\n          .setFacets(Arrays.asList(\"\"))\n          .setFilters(\"\")\n          .setGetRankingInfo(true)\n          .setHighlightPostTag(\"\")\n          .setHighlightPreTag(\"\")\n          .setHitsPerPage(1)\n          .setIgnorePlurals(IgnorePlurals.of(false))\n          .setIndexName(\"<YOUR_INDEX_NAME>\")\n          .setInsideBoundingBox(\n            InsideBoundingBox.of(\n              Arrays.asList(Arrays.asList(47.3165, 4.9665, 47.3424, 5.0201), Arrays.asList(40.9234, 2.1185, 38.643, 1.9916))\n            )\n          )\n          .setInsidePolygon(\n            Arrays.asList(\n              Arrays.asList(47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9),\n              Arrays.asList(40.9234, 2.1185, 38.643, 1.9916, 39.2587, 2.0104)\n            )\n          )\n          .setLength(1)\n          .setMaxValuesPerFacet(0)\n          .setMinProximity(1)\n          .setMinWordSizefor1Typo(0)\n          .setMinWordSizefor2Typos(0)\n          .setMinimumAroundRadius(1)\n          .setNaturalLanguages(Arrays.asList(SupportedLanguage.FR))\n          .setNumericFilters(NumericFilters.of(Arrays.asList(NumericFilters.of(\"\"))))\n          .setOffset(0)\n          .setOptionalFilters(OptionalFilters.of(Arrays.asList(OptionalFilters.of(\"\"))))\n          .setOptionalWords(OptionalWords.of(Arrays.asList(\"\")))\n          .setPage(0)\n          .setPercentileComputation(true)\n          .setPersonalizationImpact(0)\n          .setQuery(\"\")\n          .setQueryLanguages(Arrays.asList(SupportedLanguage.FR))\n          .setQueryType(QueryType.PREFIX_ALL)\n          .setRanking(Arrays.asList(\"\"))\n          .setReRankingApplyFilter(ReRankingApplyFilter.of(Arrays.asList(ReRankingApplyFilter.of(\"\"))))\n          .setRelevancyStrictness(0)\n          .setRemoveStopWords(RemoveStopWords.of(true))\n          .setRemoveWordsIfNoResults(RemoveWordsIfNoResults.ALL_OPTIONAL)\n          .setRenderingContent(\n            new RenderingContent()\n              .setFacetOrdering(\n                new FacetOrdering()\n                  .setFacets(new Facets().setOrder(Arrays.asList(\"a\", \"b\")))\n                  .setValues(\n                    new HashMap() {\n                      {\n                        put(\"a\", new Value().setOrder(Arrays.asList(\"b\")).setSortRemainingBy(SortRemainingBy.COUNT));\n                      }\n                    }\n                  )\n              )\n          )\n          .setReplaceSynonymsInHighlight(true)\n          .setResponseFields(Arrays.asList(\"\"))\n          .setRestrictHighlightAndSnippetArrays(true)\n          .setRestrictSearchableAttributes(Arrays.asList(\"\"))\n          .setRuleContexts(Arrays.asList(\"\"))\n          .setSimilarQuery(\"\")\n          .setSnippetEllipsisText(\"\")\n          .setSortFacetValuesBy(\"\")\n          .setSumOrFiltersScores(true)\n          .setSynonyms(true)\n          .setTagFilters(TagFilters.of(Arrays.asList(TagFilters.of(\"\"))))\n          .setType(SearchTypeDefault.DEFAULT)\n          .setTypoTolerance(TypoToleranceEnum.MIN)\n          .setUserToken(\"\")\n      )\n    ),\n  Hit.class\n);"
    },
    "searchDictionaryEntries": {
      "get searchDictionaryEntries results with minimal": "client.searchDictionaryEntries(DictionaryType.STOPWORDS, new SearchDictionaryEntriesParams().setQuery(\"about\"));",
      "get searchDictionaryEntries results with all parameters": "client.searchDictionaryEntries(\n  DictionaryType.COMPOUNDS,\n  new SearchDictionaryEntriesParams().setQuery(\"foo\").setPage(4).setHitsPerPage(2).setLanguage(SupportedLanguage.FR)\n);"
    },
    "searchForFacetValues": {
      "get searchForFacetValues results with minimal parameters": "client.searchForFacetValues(\"<YOUR_INDEX_NAME>\", \"facetName\");",
      "get searchForFacetValues results with all parameters": "client.searchForFacetValues(\n  \"<YOUR_INDEX_NAME>\",\n  \"facetName\",\n  new SearchForFacetValuesRequest().setParams(\"query=foo&facetFilters=['bar']\").setFacetQuery(\"foo\").setMaxFacetHits(42)\n);",
      "facetName and facetQuery": "client.searchForFacetValues(\"<YOUR_INDEX_NAME>\", \"author\", new SearchForFacetValuesRequest().setFacetQuery(\"stephen\"));"
    },
    "searchRules": {
      "default": "client.searchRules(\"<YOUR_INDEX_NAME>\", new SearchRulesParams().setQuery(\"zorro\"));"
    },
    "searchSingleIndex": {
      "search with minimal parameters": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", Hit.class);",
      "search with special characters in indexName": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", Hit.class);",
      "search with searchParams": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"myQuery\").setFacetFilters(FacetFilters.of(Arrays.asList(FacetFilters.of(\"tags:algolia\")))),\n  Hit.class\n);",
      "single search retrieve snippets": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"batman mask of the phantasm\")\n    .setAttributesToRetrieve(Arrays.asList(\"*\"))\n    .setAttributesToSnippet(Arrays.asList(\"*:20\")),\n  Hit.class\n);",
      "query": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"phone\"), Hit.class);",
      "filters": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setFilters(\"country:US AND price.gross < 2.0\"), Hit.class);",
      "filters for stores": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"ben\").setFilters(\"categories:politics AND store:Gibert Joseph Saint-Michel\"),\n  Hit.class\n);",
      "filters boolean": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setFilters(\"is_available:true\"), Hit.class);",
      "distinct": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setDistinct(Distinct.of(true)), Hit.class);",
      "filtersNumeric": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setFilters(\"price < 10\"), Hit.class);",
      "filtersTimestamp": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setFilters(\"NOT date_timestamp:1514764800 TO 1546300799\"),\n  Hit.class\n);",
      "filtersSumOrFiltersScoresFalse": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setFilters(\"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\")\n    .setSumOrFiltersScores(false),\n  Hit.class\n);",
      "filtersSumOrFiltersScoresTrue": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setFilters(\"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\")\n    .setSumOrFiltersScores(true),\n  Hit.class\n);",
      "filtersStephenKing": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setFilters(\"author:\\\"Stephen King\\\"\"), Hit.class);",
      "filtersNotTags": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"harry\").setFilters(\"_tags:non-fiction\"), Hit.class);",
      "facetFiltersList": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setFacetFilters(\n      FacetFilters.of(\n        Arrays.asList(\n          FacetFilters.of(\"publisher:Penguin\"),\n          FacetFilters.of(Arrays.asList(FacetFilters.of(\"author:Stephen King\"), FacetFilters.of(\"genre:Horror\")))\n        )\n      )\n    ),\n  Hit.class\n);",
      "facetFiltersBook": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setFacetFilters(FacetFilters.of(Arrays.asList(FacetFilters.of(\"category:Book\")))),\n  Hit.class\n);",
      "facetFiltersAND": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"query\")\n    .setFacetFilters(FacetFilters.of(Arrays.asList(FacetFilters.of(\"category:Book\"), FacetFilters.of(\"author:John Doe\")))),\n  Hit.class\n);",
      "facetFiltersOR": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"query\")\n    .setFacetFilters(\n      FacetFilters.of(\n        Arrays.asList(FacetFilters.of(Arrays.asList(FacetFilters.of(\"category:Book\"), FacetFilters.of(\"author:John Doe\"))))\n      )\n    ),\n  Hit.class\n);",
      "facetFiltersCombined": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"query\")\n    .setFacetFilters(\n      FacetFilters.of(\n        Arrays.asList(\n          FacetFilters.of(\"author:John Doe\"),\n          FacetFilters.of(Arrays.asList(FacetFilters.of(\"category:Book\"), FacetFilters.of(\"category:Movie\")))\n        )\n      )\n    ),\n  Hit.class\n);",
      "facetFiltersNeg": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setFacetFilters(FacetFilters.of(\"category:-Ebook\")), Hit.class);",
      "filtersAndFacetFilters": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setFilters(\"(author:\\\"Stephen King\\\" OR genre:\\\"Horror\\\")\")\n    .setFacetFilters(FacetFilters.of(Arrays.asList(FacetFilters.of(\"publisher:Penguin\")))),\n  Hit.class\n);",
      "facet author genre": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setFacets(Arrays.asList(\"author\", \"genre\")), Hit.class);",
      "facet wildcard": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setFacets(Arrays.asList(\"*\")), Hit.class);",
      "maxValuesPerFacet": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setMaxValuesPerFacet(1000), Hit.class);",
      "aroundLatLng": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setAroundLatLng(\"40.71, -74.01\"), Hit.class);",
      "aroundLatLngViaIP": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setAroundLatLngViaIP(true), Hit.class);",
      "aroundRadius": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setAroundLatLng(\"40.71, -74.01\").setAroundRadius(AroundRadius.of(1000000)),\n  Hit.class\n);",
      "insideBoundingBox": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setInsideBoundingBox(\n      InsideBoundingBox.of(Arrays.asList(Arrays.asList(49.067996905313834, 65.73828125, 25.905859247243498, 128.8046875)))\n    ),\n  Hit.class\n);",
      "insidePolygon": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setInsidePolygon(\n      Arrays.asList(\n        Arrays.asList(\n          42.01,\n          -124.31,\n          48.835509470063045,\n          -124.40453125000005,\n          45.01082951668149,\n          -65.95726562500005,\n          31.247243545293433,\n          -81.06578125000004,\n          25.924152577235226,\n          -97.68234374999997,\n          32.300311895879545,\n          -117.54828125\n        )\n      )\n    ),\n  Hit.class\n);",
      "optionalFilters": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setOptionalFilters(OptionalFilters.of(Arrays.asList(OptionalFilters.of(\"can_deliver_quickly:true\")))),\n  Hit.class\n);",
      "optionalFiltersMany": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setOptionalFilters(\n      OptionalFilters.of(\n        Arrays.asList(\n          OptionalFilters.of(\"brand:Apple<score=3>\"),\n          OptionalFilters.of(\"brand:Samsung<score=2>\"),\n          OptionalFilters.of(\"brand:-Huawei\")\n        )\n      )\n    ),\n  Hit.class\n);",
      "optionalFiltersSimple": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setOptionalFilters(\n      OptionalFilters.of(Arrays.asList(OptionalFilters.of(\"brand:Apple<score=2>\"), OptionalFilters.of(\"type:tablet\")))\n    ),\n  Hit.class\n);",
      "restrictSearchableAttributes": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setRestrictSearchableAttributes(Arrays.asList(\"title_fr\")),\n  Hit.class\n);",
      "getRankingInfo": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setGetRankingInfo(true), Hit.class);",
      "clickAnalytics": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setClickAnalytics(true), Hit.class);",
      "clickAnalyticsUserToken": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setClickAnalytics(true).setUserToken(\"user-1\"), Hit.class);",
      "enablePersonalization": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setEnablePersonalization(true).setUserToken(\"user-1\"),\n  Hit.class\n);",
      "userToken": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setUserToken(\"user-1\"), Hit.class);",
      "userToken1234": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setUserToken(\"user-1234\"), Hit.class);",
      "analyticsTag": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setAnalyticsTags(Arrays.asList(\"YOUR_ANALYTICS_TAG\")),\n  Hit.class\n);",
      "facetFiltersUsers": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setFacetFilters(FacetFilters.of(Arrays.asList(FacetFilters.of(\"user:user42\"), FacetFilters.of(\"user:public\")))),\n  Hit.class\n);",
      "buildTheQuery": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setFilters(\"categoryPageId: Men's Clothing\")\n    .setHitsPerPage(50)\n    .setAnalyticsTags(Arrays.asList(\"mens-clothing\")),\n  Hit.class\n);",
      "attributesToHighlightOverride": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setAttributesToHighlight(Arrays.asList(\"title\", \"content\")),\n  Hit.class\n);",
      "disableTypoToleranceOnAttributes": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setDisableTypoToleranceOnAttributes(Arrays.asList(\"serial_number\")),\n  Hit.class\n);",
      "search_a_query": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"\")\n    .setSimilarQuery(\"Comedy Drama Crime McDormand Macy Buscemi Stormare Presnell Coen\")\n    .setFilters(\"year:1991 TO 2001\"),\n  Hit.class\n);",
      "search_everything": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"\"), Hit.class);",
      "api_filtering_range_example": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"books\").setFilters(\"price:10 TO 20\"), Hit.class);",
      "override_retrievable_attributes": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setAttributesToRetrieve(Arrays.asList(\"title\", \"content\")),\n  Hit.class\n);",
      "restrict_searchable_attributes": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setRestrictSearchableAttributes(Arrays.asList(\"title\", \"author\")),\n  Hit.class\n);",
      "override_default_relevancy": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setRelevancyStrictness(70), Hit.class);",
      "apply_filters": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setSumOrFiltersScores(true), Hit.class);",
      "apply_all_filters": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"query\")\n    .setFilters(\n      \"available = 1 AND (category:Book OR NOT category:Ebook) AND _tags:published AND\" +\n      \" publication_date:1441745506 TO 1441755506 AND inStock > 0 AND author:\\\"John\" +\n      \" Doe\\\"\"\n    ),\n  Hit.class\n);",
      "escape_spaces": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setFilters(\"category:\\\"Books and Comics\\\"\"),\n  Hit.class\n);",
      "escape_keywords": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setFilters(\"keyword:\\\"OR\\\"\"), Hit.class);",
      "escape_single_quotes": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setFilters(\"content:\\\"It's a wonderful day\\\"\"),\n  Hit.class\n);",
      "escape_double_quotes": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setFilters(\"content:\\\"She said \\\"Hello World\\\"\"),\n  Hit.class\n);",
      "apply_negative_filters": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"query\")\n    .setOptionalFilters(OptionalFilters.of(Arrays.asList(OptionalFilters.of(\"category:Book\"), OptionalFilters.of(\"author:-John Doe\")))),\n  Hit.class\n);",
      "apply_negative_filters_restaurants": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"query\")\n    .setOptionalFilters(OptionalFilters.of(Arrays.asList(OptionalFilters.of(\"restaurant:-Bert's Inn\")))),\n  Hit.class\n);",
      "apply_numeric_filters": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"query\")\n    .setNumericFilters(\n      NumericFilters.of(\n        Arrays.asList(\n          NumericFilters.of(\"price < 1000\"),\n          NumericFilters.of(Arrays.asList(NumericFilters.of(\"inStock = 1\"), NumericFilters.of(\"deliveryDate < 1441755506\")))\n        )\n      )\n    ),\n  Hit.class\n);",
      "apply_tag_filters": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"query\")\n    .setTagFilters(\n      TagFilters.of(Arrays.asList(TagFilters.of(\"SciFi\"), TagFilters.of(Arrays.asList(TagFilters.of(\"Book\"), TagFilters.of(\"Movie\")))))\n    ),\n  Hit.class\n);",
      "facets_all": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setFacets(Arrays.asList(\"*\")), Hit.class);",
      "retrieve_only_some_facets": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setFacets(Arrays.asList(\"category\", \"author\")),\n  Hit.class\n);",
      "override_default_max_values_per_facet": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setMaxValuesPerFacet(20), Hit.class);",
      "enable_faceting_after_distinct": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setFacetingAfterDistinct(true), Hit.class);",
      "sort_facet_values_alphabetically": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setSortFacetValuesBy(\"count\"), Hit.class);",
      "override_attributes_to_snippet": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setAttributesToSnippet(Arrays.asList(\"title\", \"content:80\")),\n  Hit.class\n);",
      "override_default_highlight_pre_tag": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setHighlightPreTag(\"<strong>\"), Hit.class);",
      "override_default_highlight_post_tag": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setHighlightPostTag(\"</strong>\"), Hit.class);",
      "override_default_snippet_ellipsis_text": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setSnippetEllipsisText(\"\"), Hit.class);",
      "enable_restrict_highlight_and_snippet_arrays": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setRestrictHighlightAndSnippetArrays(false),\n  Hit.class\n);",
      "access_page": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setPage(0), Hit.class);",
      "override_default_hits_per_page": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setHitsPerPage(10), Hit.class);",
      "get_nth_hit": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setOffset(4), Hit.class);",
      "get_n_results": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setLength(4), Hit.class);",
      "override_default_min_word_size_for_one_typo": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setMinWordSizefor1Typo(2), Hit.class);",
      "override_default_min_word_size_for_two_typos": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setMinWordSizefor2Typos(2), Hit.class);",
      "override_default_typo_tolerance_mode": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setTypoTolerance(TypoTolerance.of(false)),\n  Hit.class\n);",
      "disable_typos_on_numeric_tokens_at_search_time": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setAllowTyposOnNumericTokens(false),\n  Hit.class\n);",
      "search_around_a_position": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setAroundLatLng(\"40.71, -74.01\"), Hit.class);",
      "search_around_server_ip": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setAroundLatLngViaIP(true),\n  Hit.class,\n  new RequestOptions()\n    .addExtraHeader(\"x-forwarded-for\", \"94.228.178.246 // should be replaced with the actual IP you would like to search\" + \" around\")\n);",
      "set_around_radius": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setAroundRadius(AroundRadius.of(1000)),\n  Hit.class\n);",
      "disable_automatic_radius": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setAroundRadius(AroundRadiusAll.ALL),\n  Hit.class\n);",
      "set_geo_search_precision": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setAroundPrecision(AroundPrecision.of(100)),\n  Hit.class\n);",
      "set_geo_search_precision_non_linear": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"query\")\n    .setAroundPrecision(\n      AroundPrecision.of(Arrays.asList(new Range().setFrom(0).setValue(25), new Range().setFrom(2000).setValue(1000)))\n    ),\n  Hit.class\n);",
      "set_minimum_geo_search_radius": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setMinimumAroundRadius(1000), Hit.class);",
      "search_inside_rectangular_area": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"query\")\n    .setInsideBoundingBox(\n      InsideBoundingBox.of(Arrays.asList(Arrays.asList(46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625)))\n    ),\n  Hit.class\n);",
      "search_inside_multiple_rectangular_areas": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"query\")\n    .setInsideBoundingBox(\n      InsideBoundingBox.of(\n        Arrays.asList(\n          Arrays.asList(46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625),\n          Arrays.asList(49.62625916704081, 4.6181640625, 47.715070300900194, 0.482421875)\n        )\n      )\n    ),\n  Hit.class\n);",
      "search_inside_polygon_area": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"query\")\n    .setInsidePolygon(\n      Arrays.asList(Arrays.asList(46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625))\n    ),\n  Hit.class\n);",
      "search_inside_multiple_polygon_areas": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"query\")\n    .setInsidePolygon(\n      Arrays.asList(\n        Arrays.asList(46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625),\n        Arrays.asList(\n          49.62625916704081,\n          4.6181640625,\n          47.715070300900194,\n          0.482421875,\n          45.17210966999772,\n          1.009765625,\n          50.62626704081,\n          4.6181640625\n        )\n      )\n    ),\n  Hit.class\n);",
      "set_querylanguages_override": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"query\")\n    .setRemoveStopWords(RemoveStopWords.of(Arrays.asList(SupportedLanguage.CA, SupportedLanguage.ES))),\n  Hit.class\n);",
      "set_querylanguages_with_japanese_query": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setQueryLanguages(Arrays.asList(SupportedLanguage.JA, SupportedLanguage.EN)),\n  Hit.class\n);",
      "set_natural_languages": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"\").setNaturalLanguages(Arrays.asList(SupportedLanguage.FR)),\n  Hit.class\n);",
      "override_natural_languages_with_query": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"\")\n    .setNaturalLanguages(Arrays.asList(SupportedLanguage.FR))\n    .setRemoveWordsIfNoResults(RemoveWordsIfNoResults.FIRST_WORDS),\n  Hit.class\n);",
      "enable_decompound_query_search_time": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setDecompoundQuery(true), Hit.class);",
      "enable_rules_search_time": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setEnableRules(true), Hit.class);",
      "set_rule_contexts": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setRuleContexts(Arrays.asList(\"front_end\", \"website2\")),\n  Hit.class\n);",
      "enable_personalization": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setEnablePersonalization(true), Hit.class);",
      "enable_personalization_with_user_token": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setEnablePersonalization(true).setUserToken(\"123456\"),\n  Hit.class\n);",
      "personalization_impact": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setPersonalizationImpact(20), Hit.class);",
      "set_user_token": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setUserToken(\"123456\"), Hit.class);",
      "set_user_token_with_personalization": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setEnablePersonalization(true).setUserToken(\"123456\"),\n  Hit.class\n);",
      "override_default_query_type": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setQueryType(QueryType.PREFIX_ALL), Hit.class);",
      "override_default_remove_words_if_no_results": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setRemoveWordsIfNoResults(RemoveWordsIfNoResults.LAST_WORDS),\n  Hit.class\n);",
      "enable_advanced_syntax_search_time": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setAdvancedSyntax(true), Hit.class);",
      "overide_default_optional_words": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setOptionalWords(OptionalWords.of(Arrays.asList(\"toyota\", \"2020 2021\"))),\n  Hit.class\n);",
      "disabling_exact_for_some_attributes_search_time": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setDisableExactOnAttributes(Arrays.asList(\"description\")),\n  Hit.class\n);",
      "override_default_exact_single_word_query": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setExactOnSingleWordQuery(ExactOnSingleWordQuery.NONE),\n  Hit.class\n);",
      "override_default_aternative_as_exact": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setAlternativesAsExact(Arrays.asList(AlternativesAsExact.MULTI_WORDS_SYNONYM)),\n  Hit.class\n);",
      "enable_advanced_syntax_exact_phrase": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"query\")\n    .setAdvancedSyntax(true)\n    .setAdvancedSyntaxFeatures(Arrays.asList(AdvancedSyntaxFeatures.EXACT_PHRASE)),\n  Hit.class\n);",
      "enable_advanced_syntax_exclude_words": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject()\n    .setQuery(\"query\")\n    .setAdvancedSyntax(true)\n    .setAdvancedSyntaxFeatures(Arrays.asList(AdvancedSyntaxFeatures.EXCLUDE_WORDS)),\n  Hit.class\n);",
      "override_distinct": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setDistinct(Distinct.of(0)), Hit.class);",
      "get_ranking_info": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setGetRankingInfo(true), Hit.class);",
      "disable_click_analytics": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setClickAnalytics(false), Hit.class);",
      "enable_click_analytics": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setClickAnalytics(true), Hit.class);",
      "disable_analytics": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setAnalytics(false), Hit.class);",
      "add_analytics_tags": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setAnalyticsTags(Arrays.asList(\"front_end\", \"website2\")),\n  Hit.class\n);",
      "disable_synonyms": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setSynonyms(false), Hit.class);",
      "override_replace_synonyms_in_highlights": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setReplaceSynonymsInHighlight(true),\n  Hit.class\n);",
      "override_min_proximity": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setMinProximity(2), Hit.class);",
      "override_default_field": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\").setResponseFields(Arrays.asList(\"hits\", \"facets\")),\n  Hit.class\n);",
      "override_percentile_computation": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setPercentileComputation(false), Hit.class);",
      "set_ab_test": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setEnableABTest(false), Hit.class);",
      "set_enable_re_ranking": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", new SearchParamsObject().setQuery(\"query\").setEnableReRanking(false), Hit.class);",
      "with algolia user id": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"query\"),\n  Hit.class,\n  new RequestOptions().addExtraHeader(\"X-Algolia-User-ID\", \"user1234\")\n);",
      "mcm with algolia user id": "client.searchSingleIndex(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchParamsObject().setQuery(\"peace\"),\n  Hit.class,\n  new RequestOptions().addExtraHeader(\"X-Algolia-User-ID\", \"user42\")\n);"
    },
    "searchSynonyms": {
      "searchSynonyms with minimal parameters": "client.searchSynonyms(\"<YOUR_INDEX_NAME>\");",
      "searchSynonyms with all parameters": "client.searchSynonyms(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchSynonymsParams().setQuery(\"myQuery\").setType(SynonymType.ALTCORRECTION_1).setPage(10).setHitsPerPage(10)\n);"
    },
    "searchUserIds": {
      "default": "client.searchUserIds(new SearchUserIdsParams().setQuery(\"test\").setClusterName(\"theClusterName\").setPage(5).setHitsPerPage(10));"
    },
    "setClientApiKey": {
      "default": "client.setClientApiKey(\"updated-api-key\");"
    },
    "setDictionarySettings": {
      "get setDictionarySettings results with minimal parameters": "client.setDictionarySettings(\n  new DictionarySettingsParams()\n    .setDisableStandardEntries(\n      new StandardEntries()\n        .setPlurals(\n          new HashMap() {\n            {\n              put(\"fr\", false);\n              put(\"en\", false);\n              put(\"ru\", true);\n            }\n          }\n        )\n    )\n);",
      "get setDictionarySettings results with all parameters": "client.setDictionarySettings(\n  new DictionarySettingsParams()\n    .setDisableStandardEntries(\n      new StandardEntries()\n        .setPlurals(\n          new HashMap() {\n            {\n              put(\"fr\", false);\n              put(\"en\", false);\n              put(\"ru\", true);\n            }\n          }\n        )\n        .setStopwords(\n          new HashMap() {\n            {\n              put(\"fr\", false);\n            }\n          }\n        )\n        .setCompounds(\n          new HashMap() {\n            {\n              put(\"ru\", true);\n            }\n          }\n        )\n    )\n);"
    },
    "setSettings": {
      "minimal parameters": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setPaginationLimitedTo(10), true);",
      "boolean typoTolerance": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setTypoTolerance(TypoTolerance.of(true)), true);",
      "enum typoTolerance": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setTypoTolerance(TypoToleranceEnum.MIN), true);",
      "ignorePlurals": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setIgnorePlurals(IgnorePlurals.of(true)), true);",
      "list of string ignorePlurals": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings().setIgnorePlurals(IgnorePlurals.of(Arrays.asList(SupportedLanguage.FR))),\n  true\n);",
      "removeStopWords boolean": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setRemoveStopWords(RemoveStopWords.of(true)), true);",
      "removeStopWords list of string": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings().setRemoveStopWords(RemoveStopWords.of(Arrays.asList(SupportedLanguage.FR))),\n  true\n);",
      "boolean distinct": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setDistinct(Distinct.of(true)), true);",
      "integer distinct": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setDistinct(Distinct.of(1)), true);",
      "distinct company": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributeForDistinct(\"company\").setDistinct(Distinct.of(true)));",
      "distinct design": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributeForDistinct(\"design\").setDistinct(Distinct.of(true)));",
      "distinct true": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setDistinct(Distinct.of(true)));",
      "distinct section": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributeForDistinct(\"section\").setDistinct(Distinct.of(true)));",
      "attributesForFaceting allergens": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesForFaceting(Arrays.asList(\"allergens\")));",
      "attributesForFaceting availableIn": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesForFaceting(Arrays.asList(\"color\", \"availableIn\")));",
      "api_attributes_for_faceting": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesForFaceting(Arrays.asList(\"genre\", \"author\")));",
      "api_attributes_for_faceting_searchable": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesForFaceting(Arrays.asList(\"genre\", \"searchable(author)\")));",
      "api_attributes_for_filter_only": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesForFaceting(Arrays.asList(\"filterOnly(genre)\", \"author\")));",
      "attributesForFaceting categoryPageId": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesForFaceting(Arrays.asList(\"searchable(categoryPageId)\")));",
      "unretrievableAttributes": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setUnretrievableAttributes(Arrays.asList(\"visible_by\")));",
      "attributesForFaceting user restricted data": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesForFaceting(Arrays.asList(\"filterOnly(visible_by)\")));",
      "attributesForFaceting optional filters": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings().setAttributesForFaceting(Arrays.asList(\"can_deliver_quickly\", \"restaurant\"))\n);",
      "attributesForFaceting redirect index": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesForFaceting(Arrays.asList(\"query_terms\")));",
      "attributesForFaceting multiple consequences": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesForFaceting(Arrays.asList(\"director\")));",
      "attributesForFaceting in-depth optional filters": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesForFaceting(Arrays.asList(\"filterOnly(brand)\")));",
      "mode neuralSearch": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setMode(Mode.NEURAL_SEARCH));",
      "mode keywordSearch": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setMode(Mode.KEYWORD_SEARCH));",
      "searchableAttributes same priority": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setSearchableAttributes(Arrays.asList(\"title,comments\", \"ingredients\")));",
      "searchableAttributes higher priority": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setSearchableAttributes(Arrays.asList(\"title\", \"ingredients\")));",
      "customRanking retweets": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setCustomRanking(Arrays.asList(\"desc(retweets)\", \"desc(likes)\")));",
      "customRanking boosted": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setCustomRanking(Arrays.asList(\"desc(boosted)\")));",
      "customRanking pageviews": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setCustomRanking(Arrays.asList(\"desc(pageviews)\", \"desc(comments)\")));",
      "customRanking applying search parameters for a specific query": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setCustomRanking(Arrays.asList(\"desc(nb_airline_liaisons)\"))\n    .setAttributesForFaceting(Arrays.asList(\"city, country\"))\n);",
      "customRanking rounded pageviews": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings().setCustomRanking(Arrays.asList(\"desc(rounded_pageviews)\", \"desc(comments)\"))\n);",
      "customRanking price": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setCustomRanking(Arrays.asList(\"desc(price)\")));",
      "ranking exhaustive (price)": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setRanking(Arrays.asList(\"desc(price)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"))\n);",
      "ranking exhaustive (is_popular)": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setRanking(Arrays.asList(\"desc(is_popular)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"))\n);",
      "ranking standard replica": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setRanking(Arrays.asList(\"desc(post_date_timestamp)\")));",
      "ranking virtual replica": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setCustomRanking(Arrays.asList(\"desc(post_date_timestamp)\")));",
      "customRanking and ranking sort alphabetically": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setCustomRanking(Arrays.asList(\"asc(textual_attribute)\"))\n    .setRanking(Arrays.asList(\"custom\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\"))\n);",
      "relevancyStrictness": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings().setCustomRanking(Arrays.asList(\"asc(textual_attribute)\")).setRelevancyStrictness(0)\n);",
      "create replica index": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setReplicas(Arrays.asList(\"products_price_desc\")));",
      "create replica index articles": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setReplicas(Arrays.asList(\"articles_date_desc\")));",
      "create virtual replica index": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setReplicas(Arrays.asList(\"virtual(products_price_desc)\")));",
      "unlink replica index": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setReplicas(Arrays.asList(\"\")));",
      "forwardToReplicas": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setSearchableAttributes(Arrays.asList(\"name\", \"description\")), true);",
      "maxValuesPerFacet": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setMaxValuesPerFacet(1000));",
      "maxFacetHits": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setMaxFacetHits(100));",
      "attributesForFaceting complex": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings().setAttributesForFaceting(Arrays.asList(\"actor\", \"filterOnly(category)\", \"searchable(publisher)\"))\n);",
      "ranking closest dates": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setRanking(Arrays.asList(\"asc(date_timestamp)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"))\n);",
      "searchableAttributes item variation": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setSearchableAttributes(Arrays.asList(\"design\", \"type\", \"color\")));",
      "searchableAttributes around location": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setSearchableAttributes(Arrays.asList(\"name\", \"country\", \"city\", \"iata_code\"))\n    .setCustomRanking(Arrays.asList(\"desc(links_count)\"))\n);",
      "attributesToHighlight": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesToHighlight(Arrays.asList(\"author\", \"title\", \"content\")));",
      "attributesToHighlightStar": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesToHighlight(Arrays.asList(\"*\")));",
      "everything": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setAdvancedSyntax(true)\n    .setAdvancedSyntaxFeatures(Arrays.asList(AdvancedSyntaxFeatures.EXACT_PHRASE))\n    .setAllowCompressionOfIntegerArray(true)\n    .setAllowTyposOnNumericTokens(true)\n    .setAlternativesAsExact(Arrays.asList(AlternativesAsExact.SINGLE_WORD_SYNONYM))\n    .setAttributeCriteriaComputedByMinProximity(true)\n    .setAttributeForDistinct(\"test\")\n    .setAttributesForFaceting(Arrays.asList(\"algolia\"))\n    .setAttributesToHighlight(Arrays.asList(\"algolia\"))\n    .setAttributesToRetrieve(Arrays.asList(\"algolia\"))\n    .setAttributesToSnippet(Arrays.asList(\"algolia\"))\n    .setAttributesToTransliterate(Arrays.asList(\"algolia\"))\n    .setCamelCaseAttributes(Arrays.asList(\"algolia\"))\n    .setCustomNormalization(\n      new HashMap() {\n        {\n          put(\n            \"algolia\",\n            new HashMap() {\n              {\n                put(\"aloglia\", \"aglolia\");\n              }\n            }\n          );\n        }\n      }\n    )\n    .setCustomRanking(Arrays.asList(\"algolia\"))\n    .setDecompoundQuery(false)\n    .setDecompoundedAttributes(\n      new HashMap() {\n        {\n          put(\"algolia\", \"aloglia\");\n        }\n      }\n    )\n    .setDisableExactOnAttributes(Arrays.asList(\"algolia\"))\n    .setDisablePrefixOnAttributes(Arrays.asList(\"algolia\"))\n    .setDisableTypoToleranceOnAttributes(Arrays.asList(\"algolia\"))\n    .setDisableTypoToleranceOnWords(Arrays.asList(\"algolia\"))\n    .setDistinct(Distinct.of(3))\n    .setEnablePersonalization(true)\n    .setEnableReRanking(false)\n    .setEnableRules(true)\n    .setExactOnSingleWordQuery(ExactOnSingleWordQuery.ATTRIBUTE)\n    .setHighlightPreTag(\"<span>\")\n    .setHighlightPostTag(\"</span>\")\n    .setHitsPerPage(10)\n    .setIgnorePlurals(IgnorePlurals.of(false))\n    .setIndexLanguages(Arrays.asList(SupportedLanguage.FR))\n    .setKeepDiacriticsOnCharacters(\"abc\")\n    .setMaxFacetHits(20)\n    .setMaxValuesPerFacet(30)\n    .setMinProximity(6)\n    .setMinWordSizefor1Typo(5)\n    .setMinWordSizefor2Typos(11)\n    .setMode(Mode.NEURAL_SEARCH)\n    .setNumericAttributesForFiltering(Arrays.asList(\"algolia\"))\n    .setOptionalWords(OptionalWords.of(Arrays.asList(\"myspace\")))\n    .setPaginationLimitedTo(0)\n    .setQueryLanguages(Arrays.asList(SupportedLanguage.FR))\n    .setQueryType(QueryType.PREFIX_LAST)\n    .setRanking(Arrays.asList(\"geo\"))\n    .setReRankingApplyFilter(ReRankingApplyFilter.of(\"mySearch:filters\"))\n    .setRelevancyStrictness(10)\n    .setRemoveStopWords(RemoveStopWords.of(false))\n    .setRemoveWordsIfNoResults(RemoveWordsIfNoResults.LAST_WORDS)\n    .setRenderingContent(\n      new RenderingContent()\n        .setFacetOrdering(\n          new FacetOrdering()\n            .setFacets(new Facets().setOrder(Arrays.asList(\"a\", \"b\")))\n            .setValues(\n              new HashMap() {\n                {\n                  put(\"a\", new Value().setOrder(Arrays.asList(\"b\")).setSortRemainingBy(SortRemainingBy.COUNT));\n                }\n              }\n            )\n        )\n    )\n    .setReplaceSynonymsInHighlight(true)\n    .setReplicas(Arrays.asList(\"\"))\n    .setResponseFields(Arrays.asList(\"algolia\"))\n    .setRestrictHighlightAndSnippetArrays(true)\n    .setSearchableAttributes(Arrays.asList(\"foo\"))\n    .setSemanticSearch(new SemanticSearch().setEventSources(Arrays.asList(\"foo\")))\n    .setSeparatorsToIndex(\"bar\")\n    .setSnippetEllipsisText(\"---\")\n    .setSortFacetValuesBy(\"date\")\n    .setTypoTolerance(TypoTolerance.of(false))\n    .setUnretrievableAttributes(Arrays.asList(\"foo\"))\n    .setUserData(\n      new HashMap() {\n        {\n          put(\"user\", \"data\");\n        }\n      }\n    )\n);",
      "searchableAttributesWithCustomRankingsAndAttributesForFaceting": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setSearchableAttributes(Arrays.asList(\"brand\", \"name\", \"categories\", \"unordered(description)\"))\n    .setCustomRanking(Arrays.asList(\"desc(popularity)\"))\n    .setAttributesForFaceting(Arrays.asList(\"searchable(brand)\", \"type\", \"categories\", \"price\"))\n);",
      "searchableAttributesOrdering": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setSearchableAttributes(Arrays.asList(\"unordered(title)\", \"cast\")));",
      "searchableAttributesProductReferenceSuffixes": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings().setSearchableAttributes(Arrays.asList(\"name\", \"product_reference\", \"product_reference_suffixes\"))\n);",
      "queryLanguageAndIgnorePlurals": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings().setQueryLanguages(Arrays.asList(SupportedLanguage.EN)).setIgnorePlurals(IgnorePlurals.of(true))\n);",
      "searchableAttributesInMovies": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings().setSearchableAttributes(Arrays.asList(\"title_eng\", \"title_fr\", \"title_es\"))\n);",
      "disablePrefixOnAttributes": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setDisablePrefixOnAttributes(Arrays.asList(\"serial_number\")));",
      "disableTypoToleranceOnAttributes": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setDisableTypoToleranceOnAttributes(Arrays.asList(\"serial_number\")));",
      "searchableAttributesSimpleExample": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setSearchableAttributes(Arrays.asList(\"serial_number\")));",
      "searchableAttributesSimpleExampleAlt": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings().setSearchableAttributes(Arrays.asList(\"serial_number\", \"serial_number_suffixes\"))\n);",
      "set_searchable_attributes": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setAttributesForFaceting(\n      Arrays.asList(\n        \"author\",\n        \"filterOnly(isbn)\",\n        \"searchable(edition)\",\n        \"afterDistinct(category)\",\n        \"afterDistinct(searchable(publisher))\"\n      )\n    )\n);",
      "unretrievable_attributes": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setUnretrievableAttributes(Arrays.asList(\"total_number_of_sales\")));",
      "set_retrievable_attributes": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesToRetrieve(Arrays.asList(\"author\", \"title\", \"content\")));",
      "set_all_attributes_as_retrievable": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesToRetrieve(Arrays.asList(\"*\")));",
      "specify_attributes_not_to_retrieve": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesToRetrieve(Arrays.asList(\"*\", \"-SKU\", \"-internal_desc\")));",
      "neural_search": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setMode(Mode.NEURAL_SEARCH));",
      "keyword_search": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setMode(Mode.KEYWORD_SEARCH));",
      "set_default_ranking": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings().setRanking(Arrays.asList(\"typo\", \"geo\", \"words\", \"filters\", \"attribute\", \"proximity\", \"exact\", \"custom\"))\n);",
      "set_ranking_by_attribute_asc": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setRanking(Arrays.asList(\"asc(price)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"))\n);",
      "set_ranking_by_attribute_desc": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setRanking(Arrays.asList(\"desc(price)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"))\n);",
      "restrict_searchable_attributes": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setCustomRanking(Arrays.asList(\"desc(popularity)\", \"asc(price)\")));",
      "set_default_relevancy": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setRelevancyStrictness(90));",
      "set_replicas": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings().setReplicas(Arrays.asList(\"name_of_replica_index1\", \"name_of_replica_index2\"))\n);",
      "set_default_max_values_per_facet": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setMaxValuesPerFacet(100));",
      "set_default_sort_facet_values_by": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setSortFacetValuesBy(\"alpha\"));",
      "set_attributes_to_snippet": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesToSnippet(Arrays.asList(\"content:80\", \"description\")));",
      "set_all_attributes_to_snippet": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributesToSnippet(Arrays.asList(\"*:80\")));",
      "set_default_highlight_pre_tag": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setHighlightPreTag(\"<em>\"));",
      "set_default_highlight_post_tag": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setHighlightPostTag(\"</em>\"));",
      "set_default_snippet_ellipsis_text": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setSnippetEllipsisText(\"…\"));",
      "enable_restrict_highlight_and_snippet_arrays_by_default": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setRestrictHighlightAndSnippetArrays(true));",
      "set_default_hits_per_page": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setHitsPerPage(20));",
      "set_pagination_limit": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setPaginationLimitedTo(1000));",
      "set_default_min_word_size_for_one_typo": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setMinWordSizefor1Typo(4));",
      "set_default_min_word_size_for_two_typos": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setMinWordSizefor2Typos(4));",
      "set_default_typo_tolerance_mode": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setTypoTolerance(TypoTolerance.of(true)));",
      "disable_typos_on_numeric_tokens_by_default": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAllowTyposOnNumericTokens(false));",
      "disable_typo_tolerance_for_words": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setDisableTypoToleranceOnWords(Arrays.asList(\"wheel\", \"1X2BCD\")));",
      "set_separators_to_index": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setSeparatorsToIndex(\"+#\"));",
      "set_languages_using_querylanguages": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setQueryLanguages(Arrays.asList(SupportedLanguage.ES))\n    .setRemoveStopWords(RemoveStopWords.of(true))\n    .setIgnorePlurals(IgnorePlurals.of(true))\n);",
      "set_attributes_to_transliterate": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setIndexLanguages(Arrays.asList(SupportedLanguage.JA))\n    .setAttributesToTransliterate(Arrays.asList(\"name\", \"description\"))\n);",
      "set_camel_case_attributes": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setCamelCaseAttributes(Arrays.asList(\"description\")));",
      "set_decompounded_attributes": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setDecompoundedAttributes(\n      new HashMap() {\n        {\n          put(\"de\", Arrays.asList(\"name\"));\n        }\n      }\n    )\n);",
      "set_decompounded_multiple_attributes": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setDecompoundedAttributes(\n      new HashMap() {\n        {\n          put(\"de\", Arrays.asList(\"name_de\", \"description_de\"));\n          put(\"fi\", Arrays.asList(\"name_fi\", \"description_fi\"));\n        }\n      }\n    )\n);",
      "set_keep_diacritics_on_characters": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setKeepDiacriticsOnCharacters(\"øé\"));",
      "set_custom_normalization": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setCustomNormalization(\n      new HashMap() {\n        {\n          put(\n            \"default\",\n            new HashMap() {\n              {\n                put(\"ä\", \"ae\");\n              }\n            }\n          );\n        }\n      }\n    )\n);",
      "set_indexlanguages": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setIndexLanguages(Arrays.asList(SupportedLanguage.JA)));",
      "enable_decompound_query_by_default": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setDecompoundQuery(true));",
      "enable_rules_syntax_by_default": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setEnableRules(true));",
      "enable_personalization_settings": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setEnablePersonalization(true));",
      "set_default_query_type": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setQueryType(QueryType.PREFIX_LAST));",
      "set_default_remove_words_if_no_result": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setRemoveWordsIfNoResults(RemoveWordsIfNoResults.NONE));",
      "enable_advanced_syntax_by_default": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAdvancedSyntax(true));",
      "set_default_optional_words": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setOptionalWords(OptionalWords.of(Arrays.asList(\"blue\", \"iphone case\"))));",
      "disabling_prefix_search_for_some_attributes_by_default": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setDisablePrefixOnAttributes(Arrays.asList(\"sku\")));",
      "disabling_exact_for_some_attributes_by_default": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setDisableExactOnAttributes(Arrays.asList(\"description\")));",
      "set_default_exact_single_word_query": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setExactOnSingleWordQuery(ExactOnSingleWordQuery.ATTRIBUTE));",
      "set_default_aternative_as_exact": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings().setAlternativesAsExact(Arrays.asList(AlternativesAsExact.IGNORE_PLURALS, AlternativesAsExact.SINGLE_WORD_SYNONYM))\n);",
      "set_numeric_attributes_for_filtering": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setNumericAttributesForFiltering(Arrays.asList(\"quantity\", \"popularity\")));",
      "enable_compression_of_integer_array": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAllowCompressionOfIntegerArray(true));",
      "set_attributes_for_distinct": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributeForDistinct(\"url\"));",
      "set_distinct": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setDistinct(Distinct.of(1)).setAttributeForDistinct(\"url\"));",
      "set_replace_synonyms_in_highlights": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setReplaceSynonymsInHighlight(false));",
      "set_min_proximity": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setMinProximity(1));",
      "set_default_field": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setResponseFields(Arrays.asList(\"hits\", \"hitsPerPage\", \"nbPages\", \"page\")));",
      "set_max_facet_hits": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setMaxFacetHits(10));",
      "set_attribute_criteria_computed_by_min_proximity": "client.setSettings(\"<YOUR_INDEX_NAME>\", new IndexSettings().setAttributeCriteriaComputedByMinProximity(true));",
      "set_user_data": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setUserData(\n      new HashMap() {\n        {\n          put(\"extraData\", \"This is the custom data that you want to store in your index\");\n        }\n      }\n    )\n);",
      "set_rendering_content": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings()\n    .setRenderingContent(\n      new RenderingContent()\n        .setFacetOrdering(\n          new FacetOrdering()\n            .setFacets(new Facets().setOrder(Arrays.asList(\"size\", \"brand\")))\n            .setValues(\n              new HashMap() {\n                {\n                  put(\n                    \"brand\",\n                    new Value()\n                      .setOrder(Arrays.asList(\"uniqlo\"))\n                      .setHide(Arrays.asList(\"muji\"))\n                      .setSortRemainingBy(SortRemainingBy.COUNT)\n                  );\n                  put(\"size\", new Value().setOrder(Arrays.asList(\"S\", \"M\", \"L\")).setSortRemainingBy(SortRemainingBy.HIDDEN));\n                }\n              }\n            )\n        )\n    )\n);"
    },
    "updateApiKey": {
      "default": "client.updateApiKey(\n  \"ALGOLIA_API_KEY\",\n  new ApiKey().setAcl(Arrays.asList(Acl.SEARCH, Acl.ADD_OBJECT)).setValidity(300).setMaxQueriesPerIPPerHour(100).setMaxHitsPerQuery(20)\n);"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "client.waitForApiKey(\"api-key-add-operation-test-java\", ApiKeyOperation.ADD);",
      "wait for api key - update": "client.waitForApiKey(\n  \"api-key-update-operation-test-java\",\n  ApiKeyOperation.UPDATE,\n  new ApiKey()\n    .setDescription(\"my updated api key\")\n    .setAcl(Arrays.asList(Acl.SEARCH, Acl.ADD_OBJECT, Acl.DELETE_OBJECT))\n    .setIndexes(Arrays.asList(\"Movies\", \"Books\"))\n    .setReferers(Arrays.asList(\"*google.com\", \"*algolia.com\"))\n    .setValidity(305)\n    .setMaxQueriesPerIPPerHour(95)\n    .setMaxHitsPerQuery(20)\n);",
      "wait for api key - delete": "client.waitForApiKey(\"api-key-delete-operation-test-java\", ApiKeyOperation.DELETE);"
    },
    "waitForAppTask": {
      "default": "client.waitForAppTask(123L);"
    },
    "waitForTask": {
      "default": "client.waitForTask(\"<YOUR_INDEX_NAME>\", 123L);"
    },
    "init": {
      "default": "SearchClient client = new SearchClient(\"ALGOLIA_APPLICATION_ID\", \"ALGOLIA_API_KEY\");"
    }
  },
  "javascript": {
    "import": {
      "default": "import { algoliasearch } from 'algoliasearch';"
    },
    "addApiKey": {
      "minimal": "const response = await client.addApiKey({ acl: ['search', 'addObject'], description: 'my new api key' });",
      "all": "const response = await client.addApiKey({\n  acl: ['search', 'addObject'],\n  description: 'my new api key',\n  validity: 300,\n  maxQueriesPerIPPerHour: 100,\n  maxHitsPerQuery: 20,\n});"
    },
    "addOrUpdateObject": {
      "default": "const response = await client.addOrUpdateObject({\n  indexName: 'indexName',\n  objectID: 'uniqueID',\n  body: { key: 'value' },\n});"
    },
    "appendSource": {
      "default": "const response = await client.appendSource({ source: 'theSource', description: 'theDescription' });"
    },
    "assignUserId": {
      "simple": "const response = await client.assignUserId({ xAlgoliaUserID: 'user42', assignUserIdParams: { cluster: 'd4242-eu' } });",
      "it should not encode the userID": "const response = await client.assignUserId({\n  xAlgoliaUserID: 'user id with spaces',\n  assignUserIdParams: { cluster: 'cluster with spaces' },\n});"
    },
    "batch": {
      "addObject": "const response = await client.batch({\n  indexName: '<YOUR_INDEX_NAME>',\n  batchWriteParams: {\n    requests: [\n      { action: 'addObject', body: { key: 'bar', foo: '1' } },\n      { action: 'addObject', body: { key: 'baz', foo: '2' } },\n    ],\n  },\n});",
      "clear": "const response = await client.batch({\n  indexName: '<YOUR_INDEX_NAME>',\n  batchWriteParams: { requests: [{ action: 'clear', body: { key: 'value' } }] },\n});",
      "delete": "const response = await client.batch({\n  indexName: '<YOUR_INDEX_NAME>',\n  batchWriteParams: { requests: [{ action: 'delete', body: { key: 'value' } }] },\n});",
      "deleteObject": "const response = await client.batch({\n  indexName: '<YOUR_INDEX_NAME>',\n  batchWriteParams: { requests: [{ action: 'deleteObject', body: { key: 'value' } }] },\n});",
      "partialUpdateObject": "const response = await client.batch({\n  indexName: '<YOUR_INDEX_NAME>',\n  batchWriteParams: { requests: [{ action: 'partialUpdateObject', body: { key: 'value' } }] },\n});",
      "partialUpdateObjectNoCreate": "const response = await client.batch({\n  indexName: '<YOUR_INDEX_NAME>',\n  batchWriteParams: { requests: [{ action: 'partialUpdateObjectNoCreate', body: { key: 'value' } }] },\n});",
      "updateObject": "const response = await client.batch({\n  indexName: '<YOUR_INDEX_NAME>',\n  batchWriteParams: { requests: [{ action: 'updateObject', body: { key: 'value' } }] },\n});"
    },
    "batchAssignUserIds": {
      "default": "const response = await client.batchAssignUserIds({\n  xAlgoliaUserID: 'userID',\n  batchAssignUserIdsParams: { cluster: 'theCluster', users: ['user1', 'user2'] },\n});"
    },
    "batchDictionaryEntries": {
      "replace": "const response = await client.batchDictionaryEntries({\n  dictionaryName: 'plurals',\n  batchDictionaryEntriesParams: {\n    clearExistingDictionaryEntries: true,\n    requests: [\n      {\n        action: 'addEntry',\n        body: {\n          objectID: '1',\n          language: 'en',\n          word: 'fancy',\n          words: ['believe', 'algolia'],\n          decomposition: ['trust', 'algolia'],\n          state: 'enabled',\n        },\n      },\n    ],\n  },\n});",
      "delete": "const response = await client.batchDictionaryEntries({\n  dictionaryName: 'plurals',\n  batchDictionaryEntriesParams: {\n    clearExistingDictionaryEntries: true,\n    requests: [{ action: 'deleteEntry', body: { objectID: '1' } }],\n  },\n});",
      "append": "const response = await client.batchDictionaryEntries({\n  dictionaryName: 'stopwords',\n  batchDictionaryEntriesParams: {\n    requests: [{ action: 'addEntry', body: { objectID: '1', language: 'en', additional: 'try me' } }],\n  },\n});"
    },
    "browse": {
      "browse with minimal parameters": "const response = await client.browse({ indexName: 'cts_e2e_browse' });",
      "browse with search parameters": "const response = await client.browse({\n  indexName: 'indexName',\n  browseParams: { query: 'myQuery', facetFilters: ['tags:algolia'] },\n});",
      "browse allow a cursor in parameters": "const response = await client.browse({ indexName: 'indexName', browseParams: { cursor: 'test' } });"
    },
    "clearObjects": {
      "default": "const response = await client.clearObjects({ indexName: 'theIndexName' });"
    },
    "clearRules": {
      "default": "const response = await client.clearRules({ indexName: 'indexName' });"
    },
    "clearSynonyms": {
      "default": "const response = await client.clearSynonyms({ indexName: 'indexName' });"
    },
    "customDelete": {
      "allow del method for a custom path with minimal parameters": "const response = await client.customDelete({ path: 'test/minimal' });",
      "allow del method for a custom path with all parameters": "const response = await client.customDelete({ path: 'test/all', parameters: { query: 'parameters' } });"
    },
    "customGet": {
      "allow get method for a custom path with minimal parameters": "const response = await client.customGet({ path: 'test/minimal' });",
      "allow get method for a custom path with all parameters": "const response = await client.customGet({ path: 'test/all', parameters: { query: 'parameters with space' } });",
      "requestOptions should be escaped too": "const response = await client.customGet(\n  { path: 'test/all', parameters: { query: 'to be overriden' } },\n  {\n    queryParameters: { query: 'parameters with space', 'and an array': ['array', 'with spaces'] },\n    headers: { 'x-header-1': 'spaces are left alone' },\n  },\n);"
    },
    "customPost": {
      "allow post method for a custom path with minimal parameters": "const response = await client.customPost({ path: 'test/minimal' });",
      "allow post method for a custom path with all parameters": "const response = await client.customPost({\n  path: 'test/all',\n  parameters: { query: 'parameters' },\n  body: { body: 'parameters' },\n});",
      "requestOptions can override default query parameters": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    queryParameters: { query: 'myQueryParameter' },\n  },\n);",
      "requestOptions merges query parameters with default ones": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    queryParameters: { query2: 'myQueryParameter' },\n  },\n);",
      "requestOptions can override default headers": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    headers: { 'x-algolia-api-key': 'ALGOLIA_API_KEY' },\n  },\n);",
      "requestOptions merges headers with default ones": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    headers: { 'x-algolia-api-key': 'ALGOLIA_API_KEY' },\n  },\n);",
      "requestOptions queryParameters accepts booleans": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    queryParameters: { isItWorking: true },\n  },\n);",
      "requestOptions queryParameters accepts integers": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    queryParameters: { myParam: 2 },\n  },\n);",
      "requestOptions queryParameters accepts list of string": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    queryParameters: { myParam: ['b and c', 'd'] },\n  },\n);",
      "requestOptions queryParameters accepts list of booleans": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    queryParameters: { myParam: [true, true, false] },\n  },\n);",
      "requestOptions queryParameters accepts list of integers": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    queryParameters: { myParam: [1, 2] },\n  },\n);"
    },
    "customPut": {
      "allow put method for a custom path with minimal parameters": "const response = await client.customPut({ path: 'test/minimal' });",
      "allow put method for a custom path with all parameters": "const response = await client.customPut({\n  path: 'test/all',\n  parameters: { query: 'parameters' },\n  body: { body: 'parameters' },\n});"
    },
    "deleteApiKey": {
      "default": "const response = await client.deleteApiKey({ key: 'myTestApiKey' });"
    },
    "deleteBy": {
      "default": "const response = await client.deleteBy({ indexName: 'theIndexName', deleteByParams: { filters: 'brand:brandName' } });"
    },
    "deleteIndex": {
      "default": "const response = await client.deleteIndex({ indexName: 'theIndexName' });"
    },
    "deleteObject": {
      "default": "const response = await client.deleteObject({ indexName: '<YOUR_INDEX_NAME>', objectID: 'uniqueID' });"
    },
    "deleteObjects": {
      "default": "const response = await client.deleteObjects({ indexName: 'cts_e2e_deleteObjects_javascript', objectIDs: ['1', '2'] });"
    },
    "deleteRule": {
      "delete rule simple case": "const response = await client.deleteRule({ indexName: 'indexName', objectID: 'id1' });",
      "delete rule with simple characters to encode in objectID": "const response = await client.deleteRule({ indexName: 'indexName', objectID: 'test/with/slash' });"
    },
    "deleteSource": {
      "default": "const response = await client.deleteSource({ source: 'theSource' });"
    },
    "deleteSynonym": {
      "default": "const response = await client.deleteSynonym({ indexName: 'indexName', objectID: 'id1' });"
    },
    "generateSecuredApiKey": {
      "api key basic": "const response = client.generateSecuredApiKey({\n  parentApiKey: '2640659426d5107b6e47d75db9cbaef8',\n  restrictions: { validUntil: 2524604400, restrictIndices: ['Movies'] },\n});",
      "with searchParams": "const response = client.generateSecuredApiKey({\n  parentApiKey: '2640659426d5107b6e47d75db9cbaef8',\n  restrictions: {\n    validUntil: 2524604400,\n    restrictIndices: ['Movies', 'cts_e2e_settings'],\n    restrictSources: '192.168.1.0/24',\n    filters: 'category:Book OR category:Ebook AND _tags:published',\n    userToken: 'user123',\n    searchParams: {\n      query: 'batman',\n      typoTolerance: 'strict',\n      aroundRadius: 'all',\n      mode: 'neuralSearch',\n      hitsPerPage: 10,\n      optionalWords: ['one', 'two'],\n    },\n  },\n});",
      "with filters": "const response = client.generateSecuredApiKey({\n  parentApiKey: '2640659426d5107b6e47d75db9cbaef8',\n  restrictions: { filters: 'user:user42 AND user:public AND (visible_by:John OR visible_by:group/Finance)' },\n});",
      "with visible_by filter": "const response = client.generateSecuredApiKey({\n  parentApiKey: '2640659426d5107b6e47d75db9cbaef8',\n  restrictions: { filters: 'visible_by:group/Finance' },\n});",
      "with userID": "const response = client.generateSecuredApiKey({\n  parentApiKey: '2640659426d5107b6e47d75db9cbaef8',\n  restrictions: { userToken: 'user42' },\n});",
      "mcm with filters": "const response = client.generateSecuredApiKey({\n  parentApiKey: 'YourSearchOnlyApiKey',\n  restrictions: { filters: 'user:user42 AND user:public' },\n});",
      "mcm with user token": "const response = client.generateSecuredApiKey({\n  parentApiKey: 'YourSearchOnlyApiKey',\n  restrictions: { userToken: 'user42' },\n});"
    },
    "getApiKey": {
      "default": "const response = await client.getApiKey({ key: 'myTestApiKey' });"
    },
    "getAppTask": {
      "default": "const response = await client.getAppTask({ taskID: 123 });"
    },
    "getDictionaryLanguages": {
      "default": "const response = await client.getDictionaryLanguages();"
    },
    "getDictionarySettings": {
      "default": "const response = await client.getDictionarySettings();"
    },
    "getLogs": {
      "getLogs with minimal parameters": "const response = await client.getLogs();",
      "getLogs with parameters": "const response = await client.getLogs({ offset: 5, length: 10, indexName: 'theIndexName', type: 'all' });"
    },
    "getObject": {
      "getObject": "const response = await client.getObject({\n  indexName: 'theIndexName',\n  objectID: 'uniqueID',\n  attributesToRetrieve: ['attr1', 'attr2'],\n});",
      "search with a real object": "const response = await client.getObject({ indexName: 'cts_e2e_browse', objectID: 'Batman and Robin' });"
    },
    "getObjects": {
      "by ID": "const response = await client.getObjects({ requests: [{ objectID: 'uniqueID', indexName: 'theIndexName' }] });",
      "multiple IDs": "const response = await client.getObjects({\n  requests: [\n    { objectID: 'uniqueID1', indexName: 'theIndexName1' },\n    { objectID: 'uniqueID2', indexName: 'theIndexName2' },\n  ],\n});",
      "with attributesToRetrieve": "const response = await client.getObjects({\n  requests: [{ attributesToRetrieve: ['attr1', 'attr2'], objectID: 'uniqueID', indexName: 'theIndexName' }],\n});"
    },
    "getRule": {
      "default": "const response = await client.getRule({ indexName: 'cts_e2e_browse', objectID: 'qr-1725004648916' });"
    },
    "getSettings": {
      "default": "const response = await client.getSettings({ indexName: 'cts_e2e_settings' });"
    },
    "getSources": {
      "default": "const response = await client.getSources();"
    },
    "getSynonym": {
      "default": "const response = await client.getSynonym({ indexName: 'indexName', objectID: 'id1' });"
    },
    "getTask": {
      "default": "const response = await client.getTask({ indexName: 'theIndexName', taskID: 123 });"
    },
    "getTopUserIds": {
      "default": "const response = await client.getTopUserIds();"
    },
    "getUserId": {
      "default": "const response = await client.getUserId({ userID: 'uniqueID' });"
    },
    "hasPendingMappings": {
      "hasPendingMappings with minimal parameters": "const response = await client.hasPendingMappings();",
      "hasPendingMappings with parameters": "const response = await client.hasPendingMappings({ getClusters: true });"
    },
    "indexExists": {
      "indexExists": "const response = await client.indexExists({ indexName: 'indexExistsYES' });",
      "indexNotExists": "const response = await client.indexExists({ indexName: 'indexExistsNO' });",
      "indexExistsWithError": "const response = await client.indexExists({ indexName: 'indexExistsERROR' });"
    },
    "listApiKeys": {
      "default": "const response = await client.listApiKeys();"
    },
    "listClusters": {
      "default": "const response = await client.listClusters();"
    },
    "listIndices": {
      "listIndices with minimal parameters": "const response = await client.listIndices();",
      "listIndices with parameters": "const response = await client.listIndices({ page: 8, hitsPerPage: 3 });"
    },
    "listUserIds": {
      "listUserIds with minimal parameters": "const response = await client.listUserIds();",
      "listUserIds with parameters": "const response = await client.listUserIds({ page: 8, hitsPerPage: 100 });"
    },
    "multipleBatch": {
      "default": "const response = await client.multipleBatch({\n  requests: [{ action: 'addObject', body: { key: 'value' }, indexName: 'theIndexName' }],\n});"
    },
    "operationIndex": {
      "scopes": "const response = await client.operationIndex({\n  indexName: '<SOURCE_INDEX_NAME>',\n  operationIndexParams: { operation: 'move', destination: '<DESTINATION_INDEX_NAME>', scope: ['rules', 'settings'] },\n});",
      "copy": "const response = await client.operationIndex({\n  indexName: '<SOURCE_INDEX_NAME>',\n  operationIndexParams: { operation: 'copy', destination: '<DESTINATION_INDEX_NAME>' },\n});",
      "move": "const response = await client.operationIndex({\n  indexName: '<SOURCE_INDEX_NAME>',\n  operationIndexParams: { operation: 'move', destination: '<DESTINATION_INDEX_NAME>' },\n});"
    },
    "partialUpdateObject": {
      "Partial update with a new value for a string attribute": "const response = await client.partialUpdateObject({\n  indexName: 'theIndexName',\n  objectID: 'uniqueID',\n  attributesToUpdate: { attributeId: 'new value' },\n});",
      "Partial update with a new value for an integer attribute": "const response = await client.partialUpdateObject({\n  indexName: 'theIndexName',\n  objectID: 'uniqueID',\n  attributesToUpdate: { attributeId: 1 },\n});",
      "Partial update with a new value for a boolean attribute": "const response = await client.partialUpdateObject({\n  indexName: 'theIndexName',\n  objectID: 'uniqueID',\n  attributesToUpdate: { attributeId: true },\n});",
      "Partial update with a new value for an array attribute": "const response = await client.partialUpdateObject({\n  indexName: 'theIndexName',\n  objectID: 'uniqueID',\n  attributesToUpdate: { attributeId: ['one', 'two', 'three'] },\n});",
      "Partial update with a new value for an object attribute": "const response = await client.partialUpdateObject({\n  indexName: 'theIndexName',\n  objectID: 'uniqueID',\n  attributesToUpdate: { attributeId: { nested: 'value' } },\n});",
      "with visible_by filter": "const response = await client.partialUpdateObject({\n  indexName: 'theIndexName',\n  objectID: 'uniqueID',\n  attributesToUpdate: { visible_by: ['Angela', 'group/Finance', 'group/Shareholders'] },\n});",
      "add men pant": "const response = await client.partialUpdateObject({\n  indexName: 'theIndexName',\n  objectID: 'productId',\n  attributesToUpdate: { categoryPageId: { _operation: 'Add', value: 'men-clothing-pants' } },\n});",
      "remove men pant": "const response = await client.partialUpdateObject({\n  indexName: 'theIndexName',\n  objectID: 'productId',\n  attributesToUpdate: { categoryPageId: { _operation: 'Remove', value: 'men-clothing-pants' } },\n});"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "const response = await client.partialUpdateObjects({\n  indexName: 'cts_e2e_partialUpdateObjects_javascript',\n  objects: [\n    { objectID: '1', name: 'Adam' },\n    { objectID: '2', name: 'Benoit' },\n  ],\n  createIfNotExists: true,\n});",
      "call partialUpdateObjects with createIfNotExists=false": "const response = await client.partialUpdateObjects({\n  indexName: 'cts_e2e_partialUpdateObjects_javascript',\n  objects: [\n    { objectID: '3', name: 'Cyril' },\n    { objectID: '4', name: 'David' },\n  ],\n  createIfNotExists: false,\n});"
    },
    "removeUserId": {
      "default": "const response = await client.removeUserId({ userID: 'uniqueID' });"
    },
    "replaceAllObjects": {
      "call replaceAllObjects without error": "const response = await client.replaceAllObjects({\n  indexName: 'cts_e2e_replace_all_objects_javascript',\n  objects: [\n    { objectID: '1', name: 'Adam' },\n    { objectID: '2', name: 'Benoit' },\n    { objectID: '3', name: 'Cyril' },\n    { objectID: '4', name: 'David' },\n    { objectID: '5', name: 'Eva' },\n    { objectID: '6', name: 'Fiona' },\n    { objectID: '7', name: 'Gael' },\n    { objectID: '8', name: 'Hugo' },\n    { objectID: '9', name: 'Igor' },\n    { objectID: '10', name: 'Julia' },\n  ],\n  batchSize: 3,\n});",
      "call replaceAllObjects with partial scopes": "const response = await client.replaceAllObjects({\n  indexName: 'cts_e2e_replace_all_objects_scopes_javascript',\n  objects: [\n    { objectID: '1', name: 'Adam' },\n    { objectID: '2', name: 'Benoit' },\n  ],\n  batchSize: 77,\n  scopes: ['settings', 'synonyms'],\n});",
      "replaceAllObjects should cleanup on failure": "const response = await client.replaceAllObjects({\n  indexName: 'cts_e2e_replace_all_objects_too_big_javascript',\n  objects: [\n    { objectID: 'fine', body: 'small obj' },\n    { objectID: 'toolarge', body: 'something bigger than 10KB' },\n  ],\n});"
    },
    "replaceSources": {
      "default": "const response = await client.replaceSources({ source: [{ source: 'theSource', description: 'theDescription' }] });"
    },
    "restoreApiKey": {
      "default": "const response = await client.restoreApiKey({ key: 'ALGOLIA_API_KEY' });"
    },
    "saveObject": {
      "default": "const response = await client.saveObject({\n  indexName: '<YOUR_INDEX_NAME>',\n  body: {\n    name: 'Black T-shirt',\n    color: '#000000||black',\n    availableIn: 'https://source.unsplash.com/100x100/?paris||Paris',\n    objectID: 'myID',\n  },\n});"
    },
    "saveObjects": {
      "call saveObjects without error": "const response = await client.saveObjects({\n  indexName: 'cts_e2e_saveObjects_javascript',\n  objects: [\n    { objectID: '1', name: 'Adam' },\n    { objectID: '2', name: 'Benoit' },\n  ],\n});",
      "saveObjects should report errors": "const response = await client.saveObjects({\n  indexName: 'cts_e2e_saveObjects_javascript',\n  objects: [\n    { objectID: '1', name: 'Adam' },\n    { objectID: '2', name: 'Benoit' },\n  ],\n});",
      "saveObjectsPlaylist": "const response = await client.saveObjects({\n  indexName: 'playlists',\n  objects: [\n    {\n      objectID: '1',\n      visibility: 'public',\n      name: 'Hot 100 Billboard Charts',\n      playlistId: 'd3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f',\n      createdAt: '1500240452',\n    },\n  ],\n});",
      "saveObjectsPublicUser": "const response = await client.saveObjects(\n  {\n    indexName: 'playlists',\n    objects: [\n      {\n        objectID: '1',\n        visibility: 'public',\n        name: 'Hot 100 Billboard Charts',\n        playlistId: 'd3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f',\n        createdAt: '1500240452',\n      },\n    ],\n    waitForTasks: false,\n    batchSize: 1000,\n  },\n  {\n    headers: { 'X-Algolia-User-ID': '*' },\n  },\n);"
    },
    "saveRule": {
      "saveRule with minimal parameters": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'id1',\n  rule: {\n    objectID: 'id1',\n    conditions: [{ pattern: 'apple', anchoring: 'contains' }],\n    consequence: { params: { filters: 'brand:xiaomi' } },\n  },\n});",
      "saveRule with all parameters": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'id1',\n  rule: {\n    objectID: 'id1',\n    conditions: [{ pattern: 'apple', anchoring: 'contains', alternatives: false, context: 'search' }],\n    consequence: {\n      params: {\n        filters: 'brand:apple',\n        query: {\n          remove: ['algolia'],\n          edits: [\n            { type: 'remove', delete: 'abc', insert: 'cde' },\n            { type: 'replace', delete: 'abc', insert: 'cde' },\n          ],\n        },\n      },\n      hide: [{ objectID: '321' }],\n      filterPromotes: false,\n      userData: { algolia: 'aloglia' },\n      promote: [\n        { objectID: 'abc', position: 3 },\n        { objectIDs: ['abc', 'def'], position: 1 },\n      ],\n    },\n    description: 'test',\n    enabled: true,\n    validity: [{ from: 1656670273, until: 1656670277 }],\n  },\n  forwardToReplicas: true,\n});",
      "b2b catalog": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'article-rule',\n  rule: {\n    objectID: 'article-rule',\n    conditions: [{ pattern: 'article', anchoring: 'startsWith' }],\n    consequence: {\n      params: {\n        query: { edits: [{ type: 'remove', delete: 'article' }] },\n        restrictSearchableAttributes: ['title', 'book_id'],\n      },\n    },\n  },\n});",
      "merchandising and promoting": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'director-rule',\n  rule: {\n    objectID: 'director-rule',\n    conditions: [{ pattern: '{facet:director} director', anchoring: 'contains' }],\n    consequence: {\n      params: {\n        restrictSearchableAttributes: ['title', 'book_id'],\n        automaticFacetFilters: [{ facet: 'director' }],\n        query: { edits: [{ type: 'remove', delete: 'director' }] },\n      },\n    },\n  },\n});",
      "harry potter": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'harry-potter-rule',\n  rule: {\n    objectID: 'harry-potter-rule',\n    conditions: [{ pattern: 'harry potter', anchoring: 'contains' }],\n    consequence: { userData: { promo_content: '20% OFF on all Harry Potter books!' } },\n  },\n});",
      "merchandising empty query": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'clearance-category-filter',\n  rule: {\n    objectID: 'clearance-category-filter',\n    conditions: [{ pattern: '', anchoring: 'is', context: 'landing' }],\n    consequence: { params: { optionalFilters: 'clearance:true' } },\n  },\n});",
      "redirect": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'redirect-help-rule',\n  rule: {\n    objectID: 'redirect-help-rule',\n    conditions: [{ pattern: 'help', anchoring: 'contains' }],\n    consequence: { userData: { redirect: 'https://www.algolia.com/support' } },\n  },\n});",
      "promote some results over others": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'tomato-fruit',\n  rule: {\n    objectID: 'tomato-fruit',\n    conditions: [{ pattern: 'tomato', anchoring: 'contains' }],\n    consequence: { params: { optionalFilters: 'food_group:fruit' } },\n  },\n});",
      "promote several hits": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'Promote-Apple-Newest',\n  rule: {\n    objectID: 'Promote-Apple-Newest',\n    conditions: [{ pattern: 'apple', anchoring: 'is' }],\n    consequence: { promote: [{ objectIDs: ['iPhone-12345', 'watch-123'], position: 0 }] },\n  },\n});",
      "promote newest release": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'Promote-iPhone-X',\n  rule: {\n    objectID: 'Promote-iPhone-X',\n    conditions: [{ pattern: 'iPhone', anchoring: 'contains' }],\n    consequence: { promote: [{ objectID: 'iPhone-12345', position: 0 }] },\n  },\n});",
      "promote single item": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'promote-harry-potter-box-set',\n  rule: {\n    objectID: 'promote-harry-potter-box-set',\n    conditions: [{ pattern: 'Harry Potter', anchoring: 'contains' }],\n    consequence: { promote: [{ objectID: 'HP-12345', position: 0 }] },\n  },\n});",
      "limit search results": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'article-rule',\n  rule: {\n    objectID: 'article-rule',\n    conditions: [{ pattern: 'article', anchoring: 'startsWith' }],\n    consequence: {\n      params: {\n        query: { edits: [{ type: 'remove', delete: 'article' }] },\n        restrictSearchableAttributes: ['title', 'book_id'],\n      },\n    },\n  },\n});",
      "query match": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'tagged-brand-rule',\n  rule: {\n    conditions: [{ pattern: 'brand: {facet:brand}', anchoring: 'contains', alternatives: false }],\n    consequence: {\n      params: { automaticFacetFilters: [{ facet: 'brand' }], query: { remove: ['brand:', '{facet:brand}'] } },\n    },\n    description: 'filter on brand: {brand}',\n    objectID: 'tagged-brand-rule',\n  },\n});",
      "dynamic filtering": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'color-facets',\n  rule: {\n    objectID: 'color-facets',\n    conditions: [{ pattern: '{facet:color}' }],\n    consequence: { params: { automaticFacetFilters: [{ facet: 'color' }] } },\n  },\n});",
      "hide hits": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'hide-12345',\n  rule: {\n    objectID: 'hide-12345',\n    conditions: [{ pattern: 'cheap', anchoring: 'contains' }],\n    consequence: { hide: [{ objectID: 'to-hide-12345' }] },\n  },\n});",
      "one rule per facet": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'red-color',\n  rule: {\n    objectID: 'red-color',\n    conditions: [{ pattern: 'red', anchoring: 'contains' }],\n    consequence: { params: { query: { remove: ['red'] }, filters: 'color:red' } },\n  },\n});",
      "numerical filters": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'cheap',\n  rule: {\n    objectID: 'cheap',\n    conditions: [{ pattern: 'cheap', anchoring: 'contains' }],\n    consequence: { params: { query: { remove: ['cheap'] }, filters: 'price < 10' } },\n  },\n});",
      "negative filters": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'gluten-free-rule',\n  rule: {\n    objectID: 'gluten-free-rule',\n    conditions: [{ pattern: 'gluten-free', anchoring: 'contains' }],\n    consequence: {\n      params: { filters: 'NOT allergens:gluten', query: { edits: [{ type: 'remove', delete: 'gluten-free' }] } },\n    },\n  },\n});",
      "positive filters": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'diet-rule',\n  rule: {\n    objectID: 'diet-rule',\n    conditions: [{ pattern: 'diet', anchoring: 'contains' }],\n    consequence: {\n      params: { filters: \"'low-carb' OR 'low-fat'\", query: { edits: [{ type: 'remove', delete: 'diet' }] } },\n    },\n  },\n});",
      "conditionless": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'diet-rule',\n  rule: {\n    objectID: 'diet-rule',\n    consequence: {\n      params: { filters: \"'low-carb' OR 'low-fat'\", query: { edits: [{ type: 'remove', delete: 'diet' }] } },\n    },\n  },\n});",
      "contextual": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'a-rule-id',\n  rule: {\n    objectID: 'a-rule-id',\n    conditions: [{ context: 'mobile' }],\n    consequence: { params: { filters: 'release_date >= 1577836800' } },\n  },\n});",
      "saveRule always active rule": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'a-rule-id',\n  rule: {\n    objectID: 'a-rule-id',\n    consequence: { params: { aroundRadius: 1000 } },\n    validity: [{ from: 1577836800, until: 1577836800 }],\n  },\n});"
    },
    "saveRules": {
      "saveRules with minimal parameters": "const response = await client.saveRules({\n  indexName: '<YOUR_INDEX_NAME>',\n  rules: [\n    {\n      objectID: 'a-rule-id',\n      conditions: [{ pattern: 'smartphone', anchoring: 'contains' }],\n      consequence: { params: { filters: 'brand:apple' } },\n    },\n    {\n      objectID: 'a-second-rule-id',\n      conditions: [{ pattern: 'apple', anchoring: 'contains' }],\n      consequence: { params: { filters: 'brand:samsung' } },\n    },\n  ],\n  forwardToReplicas: false,\n  clearExistingRules: true,\n});",
      "saveRules with all parameters": "const response = await client.saveRules({\n  indexName: '<YOUR_INDEX_NAME>',\n  rules: [\n    {\n      objectID: 'id1',\n      conditions: [{ pattern: 'apple', anchoring: 'contains', alternatives: false, context: 'search' }],\n      consequence: {\n        params: {\n          filters: 'brand:apple',\n          query: {\n            remove: ['algolia'],\n            edits: [\n              { type: 'remove', delete: 'abc', insert: 'cde' },\n              { type: 'replace', delete: 'abc', insert: 'cde' },\n            ],\n          },\n        },\n        hide: [{ objectID: '321' }],\n        filterPromotes: false,\n        userData: { algolia: 'aloglia' },\n        promote: [\n          { objectID: 'abc', position: 3 },\n          { objectIDs: ['abc', 'def'], position: 1 },\n        ],\n      },\n      description: 'test',\n      enabled: true,\n      validity: [{ from: 1656670273, until: 1656670277 }],\n    },\n  ],\n  forwardToReplicas: true,\n  clearExistingRules: true,\n});",
      "dynamic filtering": "const response = await client.saveRules({\n  indexName: '<YOUR_INDEX_NAME>',\n  rules: [\n    {\n      objectID: 'toaster',\n      conditions: [{ pattern: 'toaster', anchoring: 'contains' }],\n      consequence: { params: { query: { remove: ['toaster'] }, filters: 'product_type:toaster' } },\n    },\n    {\n      objectID: 'cheap',\n      conditions: [{ pattern: 'cheap', anchoring: 'contains' }],\n      consequence: { params: { query: { remove: ['cheap'] }, filters: 'price < 15' } },\n    },\n  ],\n});",
      "enhance search results": "const response = await client.saveRules({\n  indexName: '<YOUR_INDEX_NAME>',\n  rules: [\n    {\n      objectID: 'country',\n      conditions: [{ pattern: '{facet:country}', anchoring: 'contains' }],\n      consequence: { params: { aroundLatLngViaIP: false } },\n    },\n    {\n      objectID: 'city',\n      conditions: [{ pattern: '{facet:city}', anchoring: 'contains' }],\n      consequence: { params: { aroundLatLngViaIP: false } },\n    },\n  ],\n});"
    },
    "saveSynonym": {
      "default": "const response = await client.saveSynonym({\n  indexName: 'indexName',\n  objectID: 'id1',\n  synonymHit: { objectID: 'id1', type: 'synonym', synonyms: ['car', 'vehicule', 'auto'] },\n  forwardToReplicas: true,\n});"
    },
    "saveSynonyms": {
      "default": "const response = await client.saveSynonyms({\n  indexName: '<YOUR_INDEX_NAME>',\n  synonymHit: [\n    { objectID: 'id1', type: 'synonym', synonyms: ['car', 'vehicule', 'auto'] },\n    { objectID: 'id2', type: 'onewaysynonym', input: 'iphone', synonyms: ['ephone', 'aphone', 'yphone'] },\n  ],\n  forwardToReplicas: true,\n  replaceExistingSynonyms: true,\n});"
    },
    "search": {
      "withHitsPerPage": "const response = await client.search({\n  requests: [{ indexName: '<YOUR_INDEX_NAME>', query: '<YOUR_QUERY>', hitsPerPage: 50 }],\n});",
      "filterOnly": "const response = await client.search({\n  requests: [{ indexName: '<YOUR_INDEX_NAME>', query: '<YOUR_QUERY>', filters: 'actor:Scarlett Johansson' }],\n});",
      "filterOr": "const response = await client.search({\n  requests: [\n    {\n      indexName: '<YOUR_INDEX_NAME>',\n      query: '<YOUR_QUERY>',\n      filters: 'actor:Tom Cruise OR actor:Scarlett Johansson',\n    },\n  ],\n});",
      "filterNot": "const response = await client.search({\n  requests: [{ indexName: '<YOUR_INDEX_NAME>', query: '<YOUR_QUERY>', filters: 'NOT actor:Nicolas Cage' }],\n});",
      "search for a single hits request with minimal parameters": "const response = await client.search({ requests: [{ indexName: 'cts_e2e_search_empty_index' }] });",
      "search with highlight and snippet results": "const response = await client.search({\n  requests: [\n    {\n      indexName: 'cts_e2e_highlight_snippet_results',\n      query: 'vim',\n      attributesToSnippet: ['*:20'],\n      attributesToHighlight: ['*'],\n      attributesToRetrieve: ['*'],\n    },\n  ],\n});",
      "retrieveFacets": "const response = await client.search({\n  requests: [{ indexName: '<YOUR_INDEX_NAME>', query: '<YOUR_QUERY>', facets: ['author', 'genre'] }],\n});",
      "retrieveFacetsWildcard": "const response = await client.search({\n  requests: [{ indexName: '<YOUR_INDEX_NAME>', query: '<YOUR_QUERY>', facets: ['*'] }],\n});",
      "search for a single facet request with minimal parameters": "const response = await client.search({\n  requests: [{ indexName: 'cts_e2e_search_facet', type: 'facet', facet: 'editor' }],\n  strategy: 'stopIfEnoughMatches',\n});",
      "search for a single hits request with all parameters": "const response = await client.search({\n  requests: [{ indexName: 'theIndexName', query: 'myQuery', hitsPerPage: 50, type: 'default' }],\n});",
      "search for a single facet request with all parameters": "const response = await client.search({\n  requests: [\n    {\n      indexName: 'theIndexName',\n      type: 'facet',\n      facet: 'theFacet',\n      facetQuery: 'theFacetQuery',\n      query: 'theQuery',\n      maxFacetHits: 50,\n    },\n  ],\n  strategy: 'stopIfEnoughMatches',\n});",
      "search for multiple mixed requests in multiple indices with minimal parameters": "const response = await client.search({\n  requests: [\n    { indexName: 'theIndexName' },\n    { indexName: 'theIndexName2', type: 'facet', facet: 'theFacet' },\n    { indexName: 'theIndexName', type: 'default' },\n  ],\n  strategy: 'stopIfEnoughMatches',\n});",
      "search for multiple mixed requests in multiple indices with all parameters": "const response = await client.search({\n  requests: [\n    {\n      indexName: 'theIndexName',\n      type: 'facet',\n      facet: 'theFacet',\n      facetQuery: 'theFacetQuery',\n      query: 'theQuery',\n      maxFacetHits: 50,\n    },\n    { indexName: 'theIndexName', query: 'myQuery', hitsPerPage: 50, type: 'default' },\n  ],\n  strategy: 'stopIfEnoughMatches',\n});",
      "search filters accept all of the possible shapes": "const response = await client.search({\n  requests: [\n    {\n      indexName: 'theIndexName',\n      facetFilters: 'mySearch:filters',\n      reRankingApplyFilter: 'mySearch:filters',\n      tagFilters: 'mySearch:filters',\n      numericFilters: 'mySearch:filters',\n      optionalFilters: 'mySearch:filters',\n    },\n    {\n      indexName: 'theIndexName',\n      facetFilters: ['mySearch:filters', ['mySearch:filters', ['mySearch:filters']]],\n      reRankingApplyFilter: ['mySearch:filters', ['mySearch:filters']],\n      tagFilters: ['mySearch:filters', ['mySearch:filters']],\n      numericFilters: ['mySearch:filters', ['mySearch:filters']],\n      optionalFilters: ['mySearch:filters', ['mySearch:filters']],\n    },\n  ],\n});",
      "search filters end to end": "const response = await client.search({\n  requests: [\n    { indexName: 'cts_e2e_search_facet', filters: \"editor:'visual studio' OR editor:neovim\" },\n    { indexName: 'cts_e2e_search_facet', facetFilters: [\"editor:'visual studio'\", 'editor:neovim'] },\n    { indexName: 'cts_e2e_search_facet', facetFilters: [\"editor:'visual studio'\", ['editor:neovim']] },\n    {\n      indexName: 'cts_e2e_search_facet',\n      facetFilters: [\"editor:'visual studio'\", ['editor:neovim', ['editor:goland']]],\n    },\n  ],\n});",
      "search with all search parameters": "const response = await client.search({\n  requests: [\n    {\n      advancedSyntax: true,\n      advancedSyntaxFeatures: ['exactPhrase'],\n      allowTyposOnNumericTokens: true,\n      alternativesAsExact: ['multiWordsSynonym'],\n      analytics: true,\n      analyticsTags: [''],\n      aroundLatLng: '',\n      aroundLatLngViaIP: true,\n      aroundPrecision: 0,\n      aroundRadius: 'all',\n      attributeCriteriaComputedByMinProximity: true,\n      attributesToHighlight: [''],\n      attributesToRetrieve: [''],\n      attributesToSnippet: [''],\n      clickAnalytics: true,\n      decompoundQuery: true,\n      disableExactOnAttributes: [''],\n      disableTypoToleranceOnAttributes: [''],\n      distinct: 0,\n      enableABTest: true,\n      enablePersonalization: true,\n      enableReRanking: true,\n      enableRules: true,\n      exactOnSingleWordQuery: 'attribute',\n      facetFilters: [''],\n      facetingAfterDistinct: true,\n      facets: [''],\n      filters: '',\n      getRankingInfo: true,\n      highlightPostTag: '',\n      highlightPreTag: '',\n      hitsPerPage: 1,\n      ignorePlurals: false,\n      indexName: 'theIndexName',\n      insideBoundingBox: [\n        [47.3165, 4.9665, 47.3424, 5.0201],\n        [40.9234, 2.1185, 38.643, 1.9916],\n      ],\n      insidePolygon: [\n        [47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9],\n        [40.9234, 2.1185, 38.643, 1.9916, 39.2587, 2.0104],\n      ],\n      length: 1,\n      maxValuesPerFacet: 0,\n      minProximity: 1,\n      minWordSizefor1Typo: 0,\n      minWordSizefor2Typos: 0,\n      minimumAroundRadius: 1,\n      naturalLanguages: ['fr'],\n      numericFilters: [''],\n      offset: 0,\n      optionalFilters: [''],\n      optionalWords: [''],\n      page: 0,\n      percentileComputation: true,\n      personalizationImpact: 0,\n      query: '',\n      queryLanguages: ['fr'],\n      queryType: 'prefixAll',\n      ranking: [''],\n      reRankingApplyFilter: [''],\n      relevancyStrictness: 0,\n      removeStopWords: true,\n      removeWordsIfNoResults: 'allOptional',\n      renderingContent: {\n        facetOrdering: { facets: { order: ['a', 'b'] }, values: { a: { order: ['b'], sortRemainingBy: 'count' } } },\n      },\n      replaceSynonymsInHighlight: true,\n      responseFields: [''],\n      restrictHighlightAndSnippetArrays: true,\n      restrictSearchableAttributes: [''],\n      ruleContexts: [''],\n      similarQuery: '',\n      snippetEllipsisText: '',\n      sortFacetValuesBy: '',\n      sumOrFiltersScores: true,\n      synonyms: true,\n      tagFilters: [''],\n      type: 'default',\n      typoTolerance: 'min',\n      userToken: '',\n    },\n  ],\n});"
    },
    "searchDictionaryEntries": {
      "get searchDictionaryEntries results with minimal parameters": "const response = await client.searchDictionaryEntries({\n  dictionaryName: 'stopwords',\n  searchDictionaryEntriesParams: { query: 'about' },\n});",
      "get searchDictionaryEntries results with all parameters": "const response = await client.searchDictionaryEntries({\n  dictionaryName: 'compounds',\n  searchDictionaryEntriesParams: { query: 'foo', page: 4, hitsPerPage: 2, language: 'fr' },\n});"
    },
    "searchForFacetValues": {
      "get searchForFacetValues results with minimal parameters": "const response = await client.searchForFacetValues({ indexName: 'indexName', facetName: 'facetName' });",
      "get searchForFacetValues results with all parameters": "const response = await client.searchForFacetValues({\n  indexName: 'indexName',\n  facetName: 'facetName',\n  searchForFacetValuesRequest: { params: \"query=foo&facetFilters=['bar']\", facetQuery: 'foo', maxFacetHits: 42 },\n});",
      "facetName and facetQuery": "const response = await client.searchForFacetValues({\n  indexName: 'indexName',\n  facetName: 'author',\n  searchForFacetValuesRequest: { facetQuery: 'stephen' },\n});"
    },
    "searchRules": {
      "default": "const response = await client.searchRules({ indexName: 'cts_e2e_browse', searchRulesParams: { query: 'zorro' } });"
    },
    "searchSingleIndex": {
      "search with minimal parameters": "const response = await client.searchSingleIndex({ indexName: 'indexName' });",
      "search with special characters in indexName": "const response = await client.searchSingleIndex({ indexName: 'cts_e2e_space in index' });",
      "search with searchParams": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'myQuery', facetFilters: ['tags:algolia'] },\n});",
      "single search retrieve snippets": "const response = await client.searchSingleIndex({\n  indexName: 'cts_e2e_browse',\n  searchParams: { query: 'batman mask of the phantasm', attributesToRetrieve: ['*'], attributesToSnippet: ['*:20'] },\n});",
      "query": "const response = await client.searchSingleIndex({ indexName: 'indexName', searchParams: { query: 'phone' } });",
      "filters": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { filters: 'country:US AND price.gross < 2.0' },\n});",
      "filters for stores": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'ben', filters: 'categories:politics AND store:Gibert Joseph Saint-Michel' },\n});",
      "filters boolean": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { filters: 'is_available:true' },\n});",
      "distinct": "const response = await client.searchSingleIndex({ indexName: 'indexName', searchParams: { distinct: true } });",
      "filtersNumeric": "const response = await client.searchSingleIndex({ indexName: 'indexName', searchParams: { filters: 'price < 10' } });",
      "filtersTimestamp": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { filters: 'NOT date_timestamp:1514764800 TO 1546300799' },\n});",
      "filtersSumOrFiltersScoresFalse": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: {\n    filters: '(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)',\n    sumOrFiltersScores: false,\n  },\n});",
      "filtersSumOrFiltersScoresTrue": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: {\n    filters: '(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)',\n    sumOrFiltersScores: true,\n  },\n});",
      "filtersStephenKing": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { filters: 'author:\"Stephen King\"' },\n});",
      "filtersNotTags": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'harry', filters: '_tags:non-fiction' },\n});",
      "facetFiltersList": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { facetFilters: ['publisher:Penguin', ['author:Stephen King', 'genre:Horror']] },\n});",
      "facetFiltersBook": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', facetFilters: ['category:Book'] },\n});",
      "facetFiltersAND": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', facetFilters: ['category:Book', 'author:John Doe'] },\n});",
      "facetFiltersOR": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', facetFilters: [['category:Book', 'author:John Doe']] },\n});",
      "facetFiltersCombined": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', facetFilters: ['author:John Doe', ['category:Book', 'category:Movie']] },\n});",
      "facetFiltersNeg": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { facetFilters: 'category:-Ebook' },\n});",
      "filtersAndFacetFilters": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { filters: '(author:\"Stephen King\" OR genre:\"Horror\")', facetFilters: ['publisher:Penguin'] },\n});",
      "facet author genre": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { facets: ['author', 'genre'] },\n});",
      "facet wildcard": "const response = await client.searchSingleIndex({ indexName: 'indexName', searchParams: { facets: ['*'] } });",
      "maxValuesPerFacet": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { maxValuesPerFacet: 1000 },\n});",
      "aroundLatLng": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { aroundLatLng: '40.71, -74.01' },\n});",
      "aroundLatLngViaIP": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { aroundLatLngViaIP: true },\n});",
      "aroundRadius": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { aroundLatLng: '40.71, -74.01', aroundRadius: 1000000 },\n});",
      "insideBoundingBox": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { insideBoundingBox: [[49.067996905313834, 65.73828125, 25.905859247243498, 128.8046875]] },\n});",
      "insidePolygon": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: {\n    insidePolygon: [\n      [\n        42.01, -124.31, 48.835509470063045, -124.40453125000005, 45.01082951668149, -65.95726562500005,\n        31.247243545293433, -81.06578125000004, 25.924152577235226, -97.68234374999997, 32.300311895879545,\n        -117.54828125,\n      ],\n    ],\n  },\n});",
      "optionalFilters": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { optionalFilters: ['can_deliver_quickly:true'] },\n});",
      "optionalFiltersMany": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { optionalFilters: ['brand:Apple<score=3>', 'brand:Samsung<score=2>', 'brand:-Huawei'] },\n});",
      "optionalFiltersSimple": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { optionalFilters: ['brand:Apple<score=2>', 'type:tablet'] },\n});",
      "restrictSearchableAttributes": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { restrictSearchableAttributes: ['title_fr'] },\n});",
      "getRankingInfo": "const response = await client.searchSingleIndex({ indexName: 'indexName', searchParams: { getRankingInfo: true } });",
      "clickAnalytics": "const response = await client.searchSingleIndex({ indexName: 'indexName', searchParams: { clickAnalytics: true } });",
      "clickAnalyticsUserToken": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { clickAnalytics: true, userToken: 'user-1' },\n});",
      "enablePersonalization": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { enablePersonalization: true, userToken: 'user-1' },\n});",
      "userToken": "const response = await client.searchSingleIndex({ indexName: 'indexName', searchParams: { userToken: 'user-1' } });",
      "userToken1234": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', userToken: 'user-1234' },\n});",
      "analyticsTag": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { analyticsTags: ['YOUR_ANALYTICS_TAG'] },\n});",
      "facetFiltersUsers": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { facetFilters: ['user:user42', 'user:public'] },\n});",
      "buildTheQuery": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { filters: \"categoryPageId: Men's Clothing\", hitsPerPage: 50, analyticsTags: ['mens-clothing'] },\n});",
      "attributesToHighlightOverride": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', attributesToHighlight: ['title', 'content'] },\n});",
      "disableTypoToleranceOnAttributes": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', disableTypoToleranceOnAttributes: ['serial_number'] },\n});",
      "search_a_query": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: {\n    query: '',\n    similarQuery: 'Comedy Drama Crime McDormand Macy Buscemi Stormare Presnell Coen',\n    filters: 'year:1991 TO 2001',\n  },\n});",
      "search_everything": "const response = await client.searchSingleIndex({ indexName: 'indexName', searchParams: { query: '' } });",
      "api_filtering_range_example": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'books', filters: 'price:10 TO 20' },\n});",
      "override_retrievable_attributes": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', attributesToRetrieve: ['title', 'content'] },\n});",
      "restrict_searchable_attributes": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', restrictSearchableAttributes: ['title', 'author'] },\n});",
      "override_default_relevancy": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', relevancyStrictness: 70 },\n});",
      "apply_filters": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', sumOrFiltersScores: true },\n});",
      "apply_all_filters": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: {\n    query: 'query',\n    filters:\n      'available = 1 AND (category:Book OR NOT category:Ebook) AND _tags:published AND publication_date:1441745506 TO 1441755506 AND inStock > 0 AND author:\"John Doe\"',\n  },\n});",
      "escape_spaces": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', filters: 'category:\"Books and Comics\"' },\n});",
      "escape_keywords": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', filters: 'keyword:\"OR\"' },\n});",
      "escape_single_quotes": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', filters: 'content:\"It\\'s a wonderful day\"' },\n});",
      "escape_double_quotes": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', filters: 'content:\"She said \"Hello World\"' },\n});",
      "apply_negative_filters": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', optionalFilters: ['category:Book', 'author:-John Doe'] },\n});",
      "apply_negative_filters_restaurants": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', optionalFilters: [\"restaurant:-Bert's Inn\"] },\n});",
      "apply_numeric_filters": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', numericFilters: ['price < 1000', ['inStock = 1', 'deliveryDate < 1441755506']] },\n});",
      "apply_tag_filters": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', tagFilters: ['SciFi', ['Book', 'Movie']] },\n});",
      "facets_all": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', facets: ['*'] },\n});",
      "retrieve_only_some_facets": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', facets: ['category', 'author'] },\n});",
      "override_default_max_values_per_facet": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', maxValuesPerFacet: 20 },\n});",
      "enable_faceting_after_distinct": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', facetingAfterDistinct: true },\n});",
      "sort_facet_values_alphabetically": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', sortFacetValuesBy: 'count' },\n});",
      "override_attributes_to_snippet": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', attributesToSnippet: ['title', 'content:80'] },\n});",
      "override_default_highlight_pre_tag": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', highlightPreTag: '<strong>' },\n});",
      "override_default_highlight_post_tag": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', highlightPostTag: '</strong>' },\n});",
      "override_default_snippet_ellipsis_text": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', snippetEllipsisText: '' },\n});",
      "enable_restrict_highlight_and_snippet_arrays": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', restrictHighlightAndSnippetArrays: false },\n});",
      "access_page": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', page: 0 },\n});",
      "override_default_hits_per_page": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', hitsPerPage: 10 },\n});",
      "get_nth_hit": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', offset: 4 },\n});",
      "get_n_results": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', length: 4 },\n});",
      "override_default_min_word_size_for_one_typo": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', minWordSizefor1Typo: 2 },\n});",
      "override_default_min_word_size_for_two_typos": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', minWordSizefor2Typos: 2 },\n});",
      "override_default_typo_tolerance_mode": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', typoTolerance: false },\n});",
      "disable_typos_on_numeric_tokens_at_search_time": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', allowTyposOnNumericTokens: false },\n});",
      "search_around_a_position": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', aroundLatLng: '40.71, -74.01' },\n});",
      "search_around_server_ip": "const response = await client.searchSingleIndex(\n  { indexName: 'indexName', searchParams: { query: 'query', aroundLatLngViaIP: true } },\n  {\n    headers: {\n      'x-forwarded-for': '94.228.178.246 // should be replaced with the actual IP you would like to search around',\n    },\n  },\n);",
      "set_around_radius": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', aroundRadius: 1000 },\n});",
      "disable_automatic_radius": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', aroundRadius: 'all' },\n});",
      "set_geo_search_precision": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', aroundPrecision: 100 },\n});",
      "set_geo_search_precision_non_linear": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: {\n    query: 'query',\n    aroundPrecision: [\n      { from: 0, value: 25 },\n      { from: 2000, value: 1000 },\n    ],\n  },\n});",
      "set_minimum_geo_search_radius": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', minimumAroundRadius: 1000 },\n});",
      "search_inside_rectangular_area": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: {\n    query: 'query',\n    insideBoundingBox: [[46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625]],\n  },\n});",
      "search_inside_multiple_rectangular_areas": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: {\n    query: 'query',\n    insideBoundingBox: [\n      [46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625],\n      [49.62625916704081, 4.6181640625, 47.715070300900194, 0.482421875],\n    ],\n  },\n});",
      "search_inside_polygon_area": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: {\n    query: 'query',\n    insidePolygon: [\n      [46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625],\n    ],\n  },\n});",
      "search_inside_multiple_polygon_areas": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: {\n    query: 'query',\n    insidePolygon: [\n      [46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625],\n      [\n        49.62625916704081, 4.6181640625, 47.715070300900194, 0.482421875, 45.17210966999772, 1.009765625,\n        50.62626704081, 4.6181640625,\n      ],\n    ],\n  },\n});",
      "set_querylanguages_override": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', removeStopWords: ['ca', 'es'] },\n});",
      "set_querylanguages_with_japanese_query": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', queryLanguages: ['ja', 'en'] },\n});",
      "set_natural_languages": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: '', naturalLanguages: ['fr'] },\n});",
      "override_natural_languages_with_query": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: '', naturalLanguages: ['fr'], removeWordsIfNoResults: 'firstWords' },\n});",
      "enable_decompound_query_search_time": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', decompoundQuery: true },\n});",
      "enable_rules_search_time": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', enableRules: true },\n});",
      "set_rule_contexts": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', ruleContexts: ['front_end', 'website2'] },\n});",
      "enable_personalization": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', enablePersonalization: true },\n});",
      "enable_personalization_with_user_token": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', enablePersonalization: true, userToken: '123456' },\n});",
      "personalization_impact": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', personalizationImpact: 20 },\n});",
      "set_user_token": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', userToken: '123456' },\n});",
      "set_user_token_with_personalization": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', enablePersonalization: true, userToken: '123456' },\n});",
      "override_default_query_type": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', queryType: 'prefixAll' },\n});",
      "override_default_remove_words_if_no_results": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', removeWordsIfNoResults: 'lastWords' },\n});",
      "enable_advanced_syntax_search_time": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', advancedSyntax: true },\n});",
      "overide_default_optional_words": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', optionalWords: ['toyota', '2020 2021'] },\n});",
      "disabling_exact_for_some_attributes_search_time": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', disableExactOnAttributes: ['description'] },\n});",
      "override_default_exact_single_word_query": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', exactOnSingleWordQuery: 'none' },\n});",
      "override_default_aternative_as_exact": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', alternativesAsExact: ['multiWordsSynonym'] },\n});",
      "enable_advanced_syntax_exact_phrase": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', advancedSyntax: true, advancedSyntaxFeatures: ['exactPhrase'] },\n});",
      "enable_advanced_syntax_exclude_words": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', advancedSyntax: true, advancedSyntaxFeatures: ['excludeWords'] },\n});",
      "override_distinct": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', distinct: 0 },\n});",
      "get_ranking_info": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', getRankingInfo: true },\n});",
      "disable_click_analytics": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', clickAnalytics: false },\n});",
      "enable_click_analytics": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', clickAnalytics: true },\n});",
      "disable_analytics": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', analytics: false },\n});",
      "add_analytics_tags": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', analyticsTags: ['front_end', 'website2'] },\n});",
      "disable_synonyms": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', synonyms: false },\n});",
      "override_replace_synonyms_in_highlights": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', replaceSynonymsInHighlight: true },\n});",
      "override_min_proximity": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', minProximity: 2 },\n});",
      "override_default_field": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', responseFields: ['hits', 'facets'] },\n});",
      "override_percentile_computation": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', percentileComputation: false },\n});",
      "set_ab_test": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', enableABTest: false },\n});",
      "set_enable_re_ranking": "const response = await client.searchSingleIndex({\n  indexName: 'indexName',\n  searchParams: { query: 'query', enableReRanking: false },\n});",
      "with algolia user id": "const response = await client.searchSingleIndex(\n  { indexName: 'indexName', searchParams: { query: 'query' } },\n  {\n    headers: { 'X-Algolia-User-ID': 'user1234' },\n  },\n);",
      "mcm with algolia user id": "const response = await client.searchSingleIndex(\n  { indexName: 'playlists', searchParams: { query: 'peace' } },\n  {\n    headers: { 'X-Algolia-User-ID': 'user42' },\n  },\n);"
    },
    "searchSynonyms": {
      "searchSynonyms with minimal parameters": "const response = await client.searchSynonyms({ indexName: 'indexName' });",
      "searchSynonyms with all parameters": "const response = await client.searchSynonyms({\n  indexName: 'indexName',\n  searchSynonymsParams: { query: 'myQuery', type: 'altcorrection1', page: 10, hitsPerPage: 10 },\n});"
    },
    "searchUserIds": {
      "default": "const response = await client.searchUserIds({\n  query: 'test',\n  clusterName: 'theClusterName',\n  page: 5,\n  hitsPerPage: 10,\n});"
    },
    "setClientApiKey": {
      "default": "client.setClientApiKey({ apiKey: 'updated-api-key' });"
    },
    "setDictionarySettings": {
      "get setDictionarySettings results with minimal parameters": "const response = await client.setDictionarySettings({\n  disableStandardEntries: { plurals: { fr: false, en: false, ru: true } },\n});",
      "get setDictionarySettings results with all parameters": "const response = await client.setDictionarySettings({\n  disableStandardEntries: {\n    plurals: { fr: false, en: false, ru: true },\n    stopwords: { fr: false },\n    compounds: { ru: true },\n  },\n});"
    },
    "setSettings": {
      "minimal parameters": "const response = await client.setSettings({\n  indexName: 'cts_e2e_settings',\n  indexSettings: { paginationLimitedTo: 10 },\n  forwardToReplicas: true,\n});",
      "boolean typoTolerance": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { typoTolerance: true },\n  forwardToReplicas: true,\n});",
      "enum typoTolerance": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { typoTolerance: 'min' },\n  forwardToReplicas: true,\n});",
      "ignorePlurals": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { ignorePlurals: true },\n  forwardToReplicas: true,\n});",
      "list of string ignorePlurals": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { ignorePlurals: ['fr'] },\n  forwardToReplicas: true,\n});",
      "removeStopWords boolean": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { removeStopWords: true },\n  forwardToReplicas: true,\n});",
      "removeStopWords list of string": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { removeStopWords: ['fr'] },\n  forwardToReplicas: true,\n});",
      "boolean distinct": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { distinct: true },\n  forwardToReplicas: true,\n});",
      "integer distinct": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { distinct: 1 },\n  forwardToReplicas: true,\n});",
      "distinct company": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { attributeForDistinct: 'company', distinct: true },\n});",
      "distinct design": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { attributeForDistinct: 'design', distinct: true },\n});",
      "distinct true": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { distinct: true } });",
      "distinct section": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { attributeForDistinct: 'section', distinct: true },\n});",
      "attributesForFaceting allergens": "const response = await client.setSettings({\n  indexName: '<YOUR_INDEX_NAME>',\n  indexSettings: { attributesForFaceting: ['allergens'] },\n});",
      "attributesForFaceting availableIn": "const response = await client.setSettings({\n  indexName: '<YOUR_INDEX_NAME>',\n  indexSettings: { attributesForFaceting: ['color', 'availableIn'] },\n});",
      "api_attributes_for_faceting": "const response = await client.setSettings({\n  indexName: '<YOUR_INDEX_NAME>',\n  indexSettings: { attributesForFaceting: ['genre', 'author'] },\n});",
      "api_attributes_for_faceting_searchable": "const response = await client.setSettings({\n  indexName: '<YOUR_INDEX_NAME>',\n  indexSettings: { attributesForFaceting: ['genre', 'searchable(author)'] },\n});",
      "api_attributes_for_filter_only": "const response = await client.setSettings({\n  indexName: '<YOUR_INDEX_NAME>',\n  indexSettings: { attributesForFaceting: ['filterOnly(genre)', 'author'] },\n});",
      "attributesForFaceting categoryPageId": "const response = await client.setSettings({\n  indexName: '<YOUR_INDEX_NAME>',\n  indexSettings: { attributesForFaceting: ['searchable(categoryPageId)'] },\n});",
      "unretrievableAttributes": "const response = await client.setSettings({\n  indexName: '<YOUR_INDEX_NAME>',\n  indexSettings: { unretrievableAttributes: ['visible_by'] },\n});",
      "attributesForFaceting user restricted data": "const response = await client.setSettings({\n  indexName: '<YOUR_INDEX_NAME>',\n  indexSettings: { attributesForFaceting: ['filterOnly(visible_by)'] },\n});",
      "attributesForFaceting optional filters": "const response = await client.setSettings({\n  indexName: '<YOUR_INDEX_NAME>',\n  indexSettings: { attributesForFaceting: ['can_deliver_quickly', 'restaurant'] },\n});",
      "attributesForFaceting redirect index": "const response = await client.setSettings({\n  indexName: '<YOUR_INDEX_NAME>',\n  indexSettings: { attributesForFaceting: ['query_terms'] },\n});",
      "attributesForFaceting multiple consequences": "const response = await client.setSettings({\n  indexName: '<YOUR_INDEX_NAME>',\n  indexSettings: { attributesForFaceting: ['director'] },\n});",
      "attributesForFaceting in-depth optional filters": "const response = await client.setSettings({\n  indexName: '<YOUR_INDEX_NAME>',\n  indexSettings: { attributesForFaceting: ['filterOnly(brand)'] },\n});",
      "mode neuralSearch": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { mode: 'neuralSearch' } });",
      "mode keywordSearch": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { mode: 'keywordSearch' } });",
      "searchableAttributes same priority": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { searchableAttributes: ['title,comments', 'ingredients'] },\n});",
      "searchableAttributes higher priority": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { searchableAttributes: ['title', 'ingredients'] },\n});",
      "customRanking retweets": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { customRanking: ['desc(retweets)', 'desc(likes)'] },\n});",
      "customRanking boosted": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { customRanking: ['desc(boosted)'] },\n});",
      "customRanking pageviews": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { customRanking: ['desc(pageviews)', 'desc(comments)'] },\n});",
      "customRanking applying search parameters for a specific query": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { customRanking: ['desc(nb_airline_liaisons)'], attributesForFaceting: ['city, country'] },\n});",
      "customRanking rounded pageviews": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { customRanking: ['desc(rounded_pageviews)', 'desc(comments)'] },\n});",
      "customRanking price": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { customRanking: ['desc(price)'] },\n});",
      "ranking exhaustive (price)": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: {\n    ranking: ['desc(price)', 'typo', 'geo', 'words', 'filters', 'proximity', 'attribute', 'exact', 'custom'],\n  },\n});",
      "ranking exhaustive (is_popular)": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: {\n    ranking: ['desc(is_popular)', 'typo', 'geo', 'words', 'filters', 'proximity', 'attribute', 'exact', 'custom'],\n  },\n});",
      "ranking standard replica": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { ranking: ['desc(post_date_timestamp)'] },\n});",
      "ranking virtual replica": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { customRanking: ['desc(post_date_timestamp)'] },\n});",
      "customRanking and ranking sort alphabetically": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: {\n    customRanking: ['asc(textual_attribute)'],\n    ranking: ['custom', 'typo', 'geo', 'words', 'filters', 'proximity', 'attribute', 'exact'],\n  },\n});",
      "relevancyStrictness": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { customRanking: ['asc(textual_attribute)'], relevancyStrictness: 0 },\n});",
      "create replica index": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { replicas: ['products_price_desc'] },\n});",
      "create replica index articles": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { replicas: ['articles_date_desc'] },\n});",
      "create virtual replica index": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { replicas: ['virtual(products_price_desc)'] },\n});",
      "unlink replica index": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { replicas: [''] } });",
      "forwardToReplicas": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { searchableAttributes: ['name', 'description'] },\n  forwardToReplicas: true,\n});",
      "maxValuesPerFacet": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { maxValuesPerFacet: 1000 } });",
      "maxFacetHits": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { maxFacetHits: 100 } });",
      "attributesForFaceting complex": "const response = await client.setSettings({\n  indexName: '<YOUR_INDEX_NAME>',\n  indexSettings: { attributesForFaceting: ['actor', 'filterOnly(category)', 'searchable(publisher)'] },\n});",
      "ranking closest dates": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: {\n    ranking: ['asc(date_timestamp)', 'typo', 'geo', 'words', 'filters', 'proximity', 'attribute', 'exact', 'custom'],\n  },\n});",
      "searchableAttributes item variation": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { searchableAttributes: ['design', 'type', 'color'] },\n});",
      "searchableAttributes around location": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: {\n    searchableAttributes: ['name', 'country', 'city', 'iata_code'],\n    customRanking: ['desc(links_count)'],\n  },\n});",
      "attributesToHighlight": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { attributesToHighlight: ['author', 'title', 'content'] },\n});",
      "attributesToHighlightStar": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { attributesToHighlight: ['*'] },\n});",
      "everything": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: {\n    advancedSyntax: true,\n    advancedSyntaxFeatures: ['exactPhrase'],\n    allowCompressionOfIntegerArray: true,\n    allowTyposOnNumericTokens: true,\n    alternativesAsExact: ['singleWordSynonym'],\n    attributeCriteriaComputedByMinProximity: true,\n    attributeForDistinct: 'test',\n    attributesForFaceting: ['algolia'],\n    attributesToHighlight: ['algolia'],\n    attributesToRetrieve: ['algolia'],\n    attributesToSnippet: ['algolia'],\n    attributesToTransliterate: ['algolia'],\n    camelCaseAttributes: ['algolia'],\n    customNormalization: { algolia: { aloglia: 'aglolia' } },\n    customRanking: ['algolia'],\n    decompoundQuery: false,\n    decompoundedAttributes: { algolia: 'aloglia' },\n    disableExactOnAttributes: ['algolia'],\n    disablePrefixOnAttributes: ['algolia'],\n    disableTypoToleranceOnAttributes: ['algolia'],\n    disableTypoToleranceOnWords: ['algolia'],\n    distinct: 3,\n    enablePersonalization: true,\n    enableReRanking: false,\n    enableRules: true,\n    exactOnSingleWordQuery: 'attribute',\n    highlightPreTag: '<span>',\n    highlightPostTag: '</span>',\n    hitsPerPage: 10,\n    ignorePlurals: false,\n    indexLanguages: ['fr'],\n    keepDiacriticsOnCharacters: 'abc',\n    maxFacetHits: 20,\n    maxValuesPerFacet: 30,\n    minProximity: 6,\n    minWordSizefor1Typo: 5,\n    minWordSizefor2Typos: 11,\n    mode: 'neuralSearch',\n    numericAttributesForFiltering: ['algolia'],\n    optionalWords: ['myspace'],\n    paginationLimitedTo: 0,\n    queryLanguages: ['fr'],\n    queryType: 'prefixLast',\n    ranking: ['geo'],\n    reRankingApplyFilter: 'mySearch:filters',\n    relevancyStrictness: 10,\n    removeStopWords: false,\n    removeWordsIfNoResults: 'lastWords',\n    renderingContent: {\n      facetOrdering: { facets: { order: ['a', 'b'] }, values: { a: { order: ['b'], sortRemainingBy: 'count' } } },\n    },\n    replaceSynonymsInHighlight: true,\n    replicas: [''],\n    responseFields: ['algolia'],\n    restrictHighlightAndSnippetArrays: true,\n    searchableAttributes: ['foo'],\n    semanticSearch: { eventSources: ['foo'] },\n    separatorsToIndex: 'bar',\n    snippetEllipsisText: '---',\n    sortFacetValuesBy: 'date',\n    typoTolerance: false,\n    unretrievableAttributes: ['foo'],\n    userData: { user: 'data' },\n  },\n});",
      "searchableAttributesWithCustomRankingsAndAttributesForFaceting": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: {\n    searchableAttributes: ['brand', 'name', 'categories', 'unordered(description)'],\n    customRanking: ['desc(popularity)'],\n    attributesForFaceting: ['searchable(brand)', 'type', 'categories', 'price'],\n  },\n});",
      "searchableAttributesOrdering": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { searchableAttributes: ['unordered(title)', 'cast'] },\n});",
      "searchableAttributesProductReferenceSuffixes": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { searchableAttributes: ['name', 'product_reference', 'product_reference_suffixes'] },\n});",
      "queryLanguageAndIgnorePlurals": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { queryLanguages: ['en'], ignorePlurals: true },\n});",
      "searchableAttributesInMovies": "const response = await client.setSettings({\n  indexName: 'movies',\n  indexSettings: { searchableAttributes: ['title_eng', 'title_fr', 'title_es'] },\n});",
      "disablePrefixOnAttributes": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { disablePrefixOnAttributes: ['serial_number'] },\n});",
      "disableTypoToleranceOnAttributes": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { disableTypoToleranceOnAttributes: ['serial_number'] },\n});",
      "searchableAttributesSimpleExample": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { searchableAttributes: ['serial_number'] },\n});",
      "searchableAttributesSimpleExampleAlt": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { searchableAttributes: ['serial_number', 'serial_number_suffixes'] },\n});",
      "set_searchable_attributes": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: {\n    attributesForFaceting: [\n      'author',\n      'filterOnly(isbn)',\n      'searchable(edition)',\n      'afterDistinct(category)',\n      'afterDistinct(searchable(publisher))',\n    ],\n  },\n});",
      "unretrievable_attributes": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { unretrievableAttributes: ['total_number_of_sales'] },\n});",
      "set_retrievable_attributes": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { attributesToRetrieve: ['author', 'title', 'content'] },\n});",
      "set_all_attributes_as_retrievable": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { attributesToRetrieve: ['*'] },\n});",
      "specify_attributes_not_to_retrieve": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { attributesToRetrieve: ['*', '-SKU', '-internal_desc'] },\n});",
      "neural_search": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { mode: 'neuralSearch' } });",
      "keyword_search": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { mode: 'keywordSearch' } });",
      "set_default_ranking": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { ranking: ['typo', 'geo', 'words', 'filters', 'attribute', 'proximity', 'exact', 'custom'] },\n});",
      "set_ranking_by_attribute_asc": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: {\n    ranking: ['asc(price)', 'typo', 'geo', 'words', 'filters', 'proximity', 'attribute', 'exact', 'custom'],\n  },\n});",
      "set_ranking_by_attribute_desc": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: {\n    ranking: ['desc(price)', 'typo', 'geo', 'words', 'filters', 'proximity', 'attribute', 'exact', 'custom'],\n  },\n});",
      "restrict_searchable_attributes": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { customRanking: ['desc(popularity)', 'asc(price)'] },\n});",
      "set_default_relevancy": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { relevancyStrictness: 90 } });",
      "set_replicas": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { replicas: ['name_of_replica_index1', 'name_of_replica_index2'] },\n});",
      "set_default_max_values_per_facet": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { maxValuesPerFacet: 100 } });",
      "set_default_sort_facet_values_by": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { sortFacetValuesBy: 'alpha' },\n});",
      "set_attributes_to_snippet": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { attributesToSnippet: ['content:80', 'description'] },\n});",
      "set_all_attributes_to_snippet": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { attributesToSnippet: ['*:80'] },\n});",
      "set_default_highlight_pre_tag": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { highlightPreTag: '<em>' } });",
      "set_default_highlight_post_tag": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { highlightPostTag: '</em>' },\n});",
      "set_default_snippet_ellipsis_text": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { snippetEllipsisText: '…' } });",
      "enable_restrict_highlight_and_snippet_arrays_by_default": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { restrictHighlightAndSnippetArrays: true },\n});",
      "set_default_hits_per_page": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { hitsPerPage: 20 } });",
      "set_pagination_limit": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { paginationLimitedTo: 1000 },\n});",
      "set_default_min_word_size_for_one_typo": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { minWordSizefor1Typo: 4 } });",
      "set_default_min_word_size_for_two_typos": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { minWordSizefor2Typos: 4 } });",
      "set_default_typo_tolerance_mode": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { typoTolerance: true } });",
      "disable_typos_on_numeric_tokens_by_default": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { allowTyposOnNumericTokens: false },\n});",
      "disable_typo_tolerance_for_words": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { disableTypoToleranceOnWords: ['wheel', '1X2BCD'] },\n});",
      "set_separators_to_index": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { separatorsToIndex: '+#' } });",
      "set_languages_using_querylanguages": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { queryLanguages: ['es'], removeStopWords: true, ignorePlurals: true },\n});",
      "set_attributes_to_transliterate": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { indexLanguages: ['ja'], attributesToTransliterate: ['name', 'description'] },\n});",
      "set_camel_case_attributes": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { camelCaseAttributes: ['description'] },\n});",
      "set_decompounded_attributes": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { decompoundedAttributes: { de: ['name'] } },\n});",
      "set_decompounded_multiple_attributes": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { decompoundedAttributes: { de: ['name_de', 'description_de'], fi: ['name_fi', 'description_fi'] } },\n});",
      "set_keep_diacritics_on_characters": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { keepDiacriticsOnCharacters: 'øé' },\n});",
      "set_custom_normalization": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { customNormalization: { default: { ä: 'ae' } } },\n});",
      "set_indexlanguages": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { indexLanguages: ['ja'] } });",
      "enable_decompound_query_by_default": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { decompoundQuery: true } });",
      "enable_rules_syntax_by_default": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { enableRules: true } });",
      "enable_personalization_settings": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { enablePersonalization: true },\n});",
      "set_default_query_type": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { queryType: 'prefixLast' } });",
      "set_default_remove_words_if_no_result": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { removeWordsIfNoResults: 'none' },\n});",
      "enable_advanced_syntax_by_default": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { advancedSyntax: true } });",
      "set_default_optional_words": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { optionalWords: ['blue', 'iphone case'] },\n});",
      "disabling_prefix_search_for_some_attributes_by_default": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { disablePrefixOnAttributes: ['sku'] },\n});",
      "disabling_exact_for_some_attributes_by_default": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { disableExactOnAttributes: ['description'] },\n});",
      "set_default_exact_single_word_query": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { exactOnSingleWordQuery: 'attribute' },\n});",
      "set_default_aternative_as_exact": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { alternativesAsExact: ['ignorePlurals', 'singleWordSynonym'] },\n});",
      "set_numeric_attributes_for_filtering": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { numericAttributesForFiltering: ['quantity', 'popularity'] },\n});",
      "enable_compression_of_integer_array": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { allowCompressionOfIntegerArray: true },\n});",
      "set_attributes_for_distinct": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { attributeForDistinct: 'url' },\n});",
      "set_distinct": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { distinct: 1, attributeForDistinct: 'url' },\n});",
      "set_replace_synonyms_in_highlights": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { replaceSynonymsInHighlight: false },\n});",
      "set_min_proximity": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { minProximity: 1 } });",
      "set_default_field": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { responseFields: ['hits', 'hitsPerPage', 'nbPages', 'page'] },\n});",
      "set_max_facet_hits": "const response = await client.setSettings({ indexName: 'theIndexName', indexSettings: { maxFacetHits: 10 } });",
      "set_attribute_criteria_computed_by_min_proximity": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { attributeCriteriaComputedByMinProximity: true },\n});",
      "set_user_data": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: { userData: { extraData: 'This is the custom data that you want to store in your index' } },\n});",
      "set_rendering_content": "const response = await client.setSettings({\n  indexName: 'theIndexName',\n  indexSettings: {\n    renderingContent: {\n      facetOrdering: {\n        facets: { order: ['size', 'brand'] },\n        values: {\n          brand: { order: ['uniqlo'], hide: ['muji'], sortRemainingBy: 'count' },\n          size: { order: ['S', 'M', 'L'], sortRemainingBy: 'hidden' },\n        },\n      },\n    },\n  },\n});"
    },
    "updateApiKey": {
      "default": "const response = await client.updateApiKey({\n  key: 'ALGOLIA_API_KEY',\n  apiKey: { acl: ['search', 'addObject'], validity: 300, maxQueriesPerIPPerHour: 100, maxHitsPerQuery: 20 },\n});"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "const response = await client.waitForApiKey({ key: 'api-key-add-operation-test-javascript', operation: 'add' });",
      "wait for api key - update": "const response = await client.waitForApiKey({\n  key: 'api-key-update-operation-test-javascript',\n  operation: 'update',\n  apiKey: {\n    description: 'my updated api key',\n    acl: ['search', 'addObject', 'deleteObject'],\n    indexes: ['Movies', 'Books'],\n    referers: ['*google.com', '*algolia.com'],\n    validity: 305,\n    maxQueriesPerIPPerHour: 95,\n    maxHitsPerQuery: 20,\n  },\n});",
      "wait for api key - delete": "const response = await client.waitForApiKey({ key: 'api-key-delete-operation-test-javascript', operation: 'delete' });"
    },
    "waitForAppTask": {
      "default": "const response = await client.waitForAppTask({ taskID: 123 });"
    },
    "waitForTask": {
      "default": "const response = await client.waitForTask({ indexName: 'wait-task-javascript', taskID: 123 });"
    },
    "init": {
      "default": "//\nconst client = algoliasearch('ALGOLIA_APPLICATION_ID', 'ALGOLIA_API_KEY');"
    }
  },
  "kotlin": {
    "import": {
      "default": "import com.algolia.client.api.SearchClient\nimport com.algolia.client.configuration.*\nimport com.algolia.client.transport.*\nimport com.algolia.client.extensions.*"
    },
    "addApiKey": {
      "minimal": "var response = client.addApiKey(\n  apiKey = ApiKey(\n    acl = listOf(Acl.entries.first { it.value == \"search\" }, Acl.entries.first { it.value == \"addObject\" }),\n    description = \"my new api key\",\n  ),\n)",
      "all": "var response = client.addApiKey(\n  apiKey = ApiKey(\n    acl = listOf(Acl.entries.first { it.value == \"search\" }, Acl.entries.first { it.value == \"addObject\" }),\n    description = \"my new api key\",\n    validity = 300,\n    maxQueriesPerIPPerHour = 100,\n    maxHitsPerQuery = 20,\n  ),\n)"
    },
    "addOrUpdateObject": {
      "default": "var response = client.addOrUpdateObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\",\n  body = buildJsonObject {\n    put(\n      \"key\",\n      JsonPrimitive(\"value\"),\n    )\n  },\n)"
    },
    "appendSource": {
      "default": "var response = client.appendSource(\n  source = Source(\n    source = \"theSource\",\n    description = \"theDescription\",\n  ),\n)"
    },
    "assignUserId": {
      "simple": "var response = client.assignUserId(\n  xAlgoliaUserID = \"user42\",\n  assignUserIdParams = AssignUserIdParams(\n    cluster = \"d4242-eu\",\n  ),\n)",
      "it should not encode the userID": "var response = client.assignUserId(\n  xAlgoliaUserID = \"user id with spaces\",\n  assignUserIdParams = AssignUserIdParams(\n    cluster = \"cluster with spaces\",\n  ),\n)"
    },
    "batch": {
      "addObject": "var response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = listOf(\n      BatchRequest(\n        action = Action.entries.first { it.value == \"addObject\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"bar\"),\n          )\n          put(\n            \"foo\",\n            JsonPrimitive(\"1\"),\n          )\n        },\n      ),\n      BatchRequest(\n        action = Action.entries.first { it.value == \"addObject\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"baz\"),\n          )\n          put(\n            \"foo\",\n            JsonPrimitive(\"2\"),\n          )\n        },\n      ),\n    ),\n  ),\n)",
      "clear": "var response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = listOf(\n      BatchRequest(\n        action = Action.entries.first { it.value == \"clear\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"value\"),\n          )\n        },\n      ),\n    ),\n  ),\n)",
      "delete": "var response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = listOf(\n      BatchRequest(\n        action = Action.entries.first { it.value == \"delete\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"value\"),\n          )\n        },\n      ),\n    ),\n  ),\n)",
      "deleteObject": "var response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = listOf(\n      BatchRequest(\n        action = Action.entries.first { it.value == \"deleteObject\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"value\"),\n          )\n        },\n      ),\n    ),\n  ),\n)",
      "partialUpdateObject": "var response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = listOf(\n      BatchRequest(\n        action = Action.entries.first { it.value == \"partialUpdateObject\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"value\"),\n          )\n        },\n      ),\n    ),\n  ),\n)",
      "partialUpdateObjectNoCreate": "var response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = listOf(\n      BatchRequest(\n        action = Action.entries.first { it.value == \"partialUpdateObjectNoCreate\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"value\"),\n          )\n        },\n      ),\n    ),\n  ),\n)",
      "updateObject": "var response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = listOf(\n      BatchRequest(\n        action = Action.entries.first { it.value == \"updateObject\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"value\"),\n          )\n        },\n      ),\n    ),\n  ),\n)"
    },
    "batchAssignUserIds": {
      "default": "var response = client.batchAssignUserIds(\n  xAlgoliaUserID = \"userID\",\n  batchAssignUserIdsParams = BatchAssignUserIdsParams(\n    cluster = \"theCluster\",\n    users = listOf(\"user1\", \"user2\"),\n  ),\n)"
    },
    "batchDictionaryEntries": {
      "replace": "var response = client.batchDictionaryEntries(\n  dictionaryName = DictionaryType.entries.first { it.value == \"plurals\" },\n  batchDictionaryEntriesParams = BatchDictionaryEntriesParams(\n    clearExistingDictionaryEntries = true,\n    requests = listOf(\n      BatchDictionaryEntriesRequest(\n        action = DictionaryAction.entries.first { it.value == \"addEntry\" },\n        body = DictionaryEntry(\n          objectID = \"1\",\n          language = SupportedLanguage.entries.first { it.value == \"en\" },\n          word = \"fancy\",\n          words = listOf(\"believe\", \"algolia\"),\n          decomposition = listOf(\"trust\", \"algolia\"),\n          state = DictionaryEntryState.entries.first { it.value == \"enabled\" },\n        ),\n      ),\n    ),\n  ),\n)",
      "delete": "var response = client.batchDictionaryEntries(\n  dictionaryName = DictionaryType.entries.first { it.value == \"plurals\" },\n  batchDictionaryEntriesParams = BatchDictionaryEntriesParams(\n    clearExistingDictionaryEntries = true,\n    requests = listOf(\n      BatchDictionaryEntriesRequest(\n        action = DictionaryAction.entries.first { it.value == \"deleteEntry\" },\n        body = DictionaryEntry(\n          objectID = \"1\",\n        ),\n      ),\n    ),\n  ),\n)",
      "append": "var response = client.batchDictionaryEntries(\n  dictionaryName = DictionaryType.entries.first { it.value == \"stopwords\" },\n  batchDictionaryEntriesParams = BatchDictionaryEntriesParams(\n    requests = listOf(\n      BatchDictionaryEntriesRequest(\n        action = DictionaryAction.entries.first { it.value == \"addEntry\" },\n        body = DictionaryEntry(\n          objectID = \"1\",\n          language = SupportedLanguage.entries.first { it.value == \"en\" },\n          additionalProperties = mapOf(\n            \"additional\" to JsonPrimitive(\"try me\"),\n          ),\n        ),\n      ),\n    ),\n  ),\n)"
    },
    "browse": {
      "browse with minimal parameters": "var response = client.browse(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)",
      "browse with search parameters": "var response = client.browse(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  browseParams = BrowseParamsObject(\n    query = \"myQuery\",\n    facetFilters = FacetFilters.of(listOf(FacetFilters.of(\"tags:algolia\"))),\n  ),\n)",
      "browse allow a cursor in parameters": "var response = client.browse(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  browseParams = BrowseParamsObject(\n    cursor = \"test\",\n  ),\n)"
    },
    "clearObjects": {
      "default": "var response = client.clearObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)"
    },
    "clearRules": {
      "default": "var response = client.clearRules(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)"
    },
    "clearSynonyms": {
      "default": "var response = client.clearSynonyms(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)"
    },
    "customDelete": {
      "allow del method for a custom path with minimal parameters": "var response = client.customDelete(\n  path = \"test/minimal\",\n)",
      "allow del method for a custom path with all parameters": "var response = client.customDelete(\n  path = \"test/all\",\n  parameters = mapOf(\"query\" to \"parameters\"),\n)"
    },
    "customGet": {
      "allow get method for a custom path with minimal parameters": "var response = client.customGet(\n  path = \"test/minimal\",\n)",
      "allow get method for a custom path with all parameters": "var response = client.customGet(\n  path = \"test/all\",\n  parameters = mapOf(\"query\" to \"parameters with space\"),\n)",
      "requestOptions should be escaped too": "var response = client.customGet(\n  path = \"test/all\",\n  parameters = mapOf(\"query\" to \"to be overriden\"),\n  requestOptions = RequestOptions(\n    urlParameters = buildMap {\n      put(\"query\", \"parameters with space\")\n      put(\"and an array\", listOf(\"array\", \"with spaces\"))\n    },\n    headers = buildMap {\n      put(\"x-header-1\", \"spaces are left alone\")\n    },\n  ),\n)"
    },
    "customPost": {
      "allow post method for a custom path with minimal parameters": "var response = client.customPost(\n  path = \"test/minimal\",\n)",
      "allow post method for a custom path with all parameters": "var response = client.customPost(\n  path = \"test/all\",\n  parameters = mapOf(\"query\" to \"parameters\"),\n  body = buildJsonObject {\n    put(\n      \"body\",\n      JsonPrimitive(\"parameters\"),\n    )\n  },\n)",
      "requestOptions can override default query parameters": "var response = client.customPost(\n  path = \"test/requestOptions\",\n  parameters = mapOf(\"query\" to \"parameters\"),\n  body = buildJsonObject {\n    put(\n      \"facet\",\n      JsonPrimitive(\"filters\"),\n    )\n  },\n  requestOptions = RequestOptions(\n    urlParameters = buildMap {\n      put(\"query\", \"myQueryParameter\")\n    },\n  ),\n)",
      "requestOptions merges query parameters with default ones": "var response = client.customPost(\n  path = \"test/requestOptions\",\n  parameters = mapOf(\"query\" to \"parameters\"),\n  body = buildJsonObject {\n    put(\n      \"facet\",\n      JsonPrimitive(\"filters\"),\n    )\n  },\n  requestOptions = RequestOptions(\n    urlParameters = buildMap {\n      put(\"query2\", \"myQueryParameter\")\n    },\n  ),\n)",
      "requestOptions can override default headers": "var response = client.customPost(\n  path = \"test/requestOptions\",\n  parameters = mapOf(\"query\" to \"parameters\"),\n  body = buildJsonObject {\n    put(\n      \"facet\",\n      JsonPrimitive(\"filters\"),\n    )\n  },\n  requestOptions = RequestOptions(\n    headers = buildMap {\n      put(\"x-algolia-api-key\", \"ALGOLIA_API_KEY\")\n    },\n  ),\n)",
      "requestOptions merges headers with default ones": "var response = client.customPost(\n  path = \"test/requestOptions\",\n  parameters = mapOf(\"query\" to \"parameters\"),\n  body = buildJsonObject {\n    put(\n      \"facet\",\n      JsonPrimitive(\"filters\"),\n    )\n  },\n  requestOptions = RequestOptions(\n    headers = buildMap {\n      put(\"x-algolia-api-key\", \"ALGOLIA_API_KEY\")\n    },\n  ),\n)",
      "requestOptions queryParameters accepts booleans": "var response = client.customPost(\n  path = \"test/requestOptions\",\n  parameters = mapOf(\"query\" to \"parameters\"),\n  body = buildJsonObject {\n    put(\n      \"facet\",\n      JsonPrimitive(\"filters\"),\n    )\n  },\n  requestOptions = RequestOptions(\n    urlParameters = buildMap {\n      put(\"isItWorking\", true)\n    },\n  ),\n)",
      "requestOptions queryParameters accepts integers": "var response = client.customPost(\n  path = \"test/requestOptions\",\n  parameters = mapOf(\"query\" to \"parameters\"),\n  body = buildJsonObject {\n    put(\n      \"facet\",\n      JsonPrimitive(\"filters\"),\n    )\n  },\n  requestOptions = RequestOptions(\n    urlParameters = buildMap {\n      put(\"myParam\", 2)\n    },\n  ),\n)",
      "requestOptions queryParameters accepts list of string": "var response = client.customPost(\n  path = \"test/requestOptions\",\n  parameters = mapOf(\"query\" to \"parameters\"),\n  body = buildJsonObject {\n    put(\n      \"facet\",\n      JsonPrimitive(\"filters\"),\n    )\n  },\n  requestOptions = RequestOptions(\n    urlParameters = buildMap {\n      put(\"myParam\", listOf(\"b and c\", \"d\"))\n    },\n  ),\n)",
      "requestOptions queryParameters accepts list of booleans": "var response = client.customPost(\n  path = \"test/requestOptions\",\n  parameters = mapOf(\"query\" to \"parameters\"),\n  body = buildJsonObject {\n    put(\n      \"facet\",\n      JsonPrimitive(\"filters\"),\n    )\n  },\n  requestOptions = RequestOptions(\n    urlParameters = buildMap {\n      put(\"myParam\", listOf(true, true, false))\n    },\n  ),\n)",
      "requestOptions queryParameters accepts list of integers": "var response = client.customPost(\n  path = \"test/requestOptions\",\n  parameters = mapOf(\"query\" to \"parameters\"),\n  body = buildJsonObject {\n    put(\n      \"facet\",\n      JsonPrimitive(\"filters\"),\n    )\n  },\n  requestOptions = RequestOptions(\n    urlParameters = buildMap {\n      put(\"myParam\", listOf(1, 2))\n    },\n  ),\n)"
    },
    "customPut": {
      "allow put method for a custom path with minimal parameters": "var response = client.customPut(\n  path = \"test/minimal\",\n)",
      "allow put method for a custom path with all parameters": "var response = client.customPut(\n  path = \"test/all\",\n  parameters = mapOf(\"query\" to \"parameters\"),\n  body = buildJsonObject {\n    put(\n      \"body\",\n      JsonPrimitive(\"parameters\"),\n    )\n  },\n)"
    },
    "deleteApiKey": {
      "default": "var response = client.deleteApiKey(\n  key = \"myTestApiKey\",\n)"
    },
    "deleteBy": {
      "default": "var response = client.deleteBy(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  deleteByParams = DeleteByParams(\n    filters = \"brand:brandName\",\n  ),\n)"
    },
    "deleteIndex": {
      "default": "var response = client.deleteIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)"
    },
    "deleteObject": {
      "default": "var response = client.deleteObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\",\n)"
    },
    "deleteObjects": {
      "default": "var response = client.deleteObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectIDs = listOf(\"1\", \"2\"),\n)"
    },
    "deleteRule": {
      "delete rule simple case": "var response = client.deleteRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"id1\",\n)",
      "delete rule with simple characters to encode in objectID": "var response = client.deleteRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"test/with/slash\",\n)"
    },
    "deleteSource": {
      "default": "var response = client.deleteSource(\n  source = \"theSource\",\n)"
    },
    "deleteSynonym": {
      "default": "var response = client.deleteSynonym(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"id1\",\n)"
    },
    "generateSecuredApiKey": {
      "api key basic": "var response = client.generateSecuredApiKey(\n  parentApiKey = \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions = SecuredApiKeyRestrictions(\n    validUntil = 2524604400L,\n    restrictIndices = listOf(\"Movies\"),\n  ),\n)",
      "with searchParams": "var response = client.generateSecuredApiKey(\n  parentApiKey = \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions = SecuredApiKeyRestrictions(\n    validUntil = 2524604400L,\n    restrictIndices = listOf(\"Movies\", \"cts_e2e_settings\"),\n    restrictSources = \"192.168.1.0/24\",\n    filters = \"category:Book OR category:Ebook AND _tags:published\",\n    userToken = \"user123\",\n    searchParams = SearchParamsObject(\n      query = \"batman\",\n      typoTolerance = TypoToleranceEnum.entries.first { it.value == \"strict\" },\n      aroundRadius = AroundRadiusAll.entries.first { it.value == \"all\" },\n      mode = Mode.entries.first { it.value == \"neuralSearch\" },\n      hitsPerPage = 10,\n      optionalWords = OptionalWords.of(listOf(\"one\", \"two\")),\n    ),\n  ),\n)",
      "with filters": "var response = client.generateSecuredApiKey(\n  parentApiKey = \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions = SecuredApiKeyRestrictions(\n    filters = \"user:user42 AND user:public AND (visible_by:John OR visible_by:group/Finance)\",\n  ),\n)",
      "with visible_by filter": "var response = client.generateSecuredApiKey(\n  parentApiKey = \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions = SecuredApiKeyRestrictions(\n    filters = \"visible_by:group/Finance\",\n  ),\n)",
      "with userID": "var response = client.generateSecuredApiKey(\n  parentApiKey = \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions = SecuredApiKeyRestrictions(\n    userToken = \"user42\",\n  ),\n)",
      "mcm with filters": "var response = client.generateSecuredApiKey(\n  parentApiKey = \"YourSearchOnlyApiKey\",\n  restrictions = SecuredApiKeyRestrictions(\n    filters = \"user:user42 AND user:public\",\n  ),\n)",
      "mcm with user token": "var response = client.generateSecuredApiKey(\n  parentApiKey = \"YourSearchOnlyApiKey\",\n  restrictions = SecuredApiKeyRestrictions(\n    userToken = \"user42\",\n  ),\n)"
    },
    "getApiKey": {
      "default": "var response = client.getApiKey(\n  key = \"myTestApiKey\",\n)"
    },
    "getAppTask": {
      "default": "var response = client.getAppTask(\n  taskID = 123L,\n)"
    },
    "getDictionaryLanguages": {
      "default": "var response = client.getDictionaryLanguages()"
    },
    "getDictionarySettings": {
      "default": "var response = client.getDictionarySettings()"
    },
    "getLogs": {
      "getLogs with minimal parameters": "var response = client.getLogs()",
      "getLogs with parameters": "var response = client.getLogs(\n  offset = 5,\n  length = 10,\n  indexName = \"<YOUR_INDEX_NAME>\",\n  type = LogType.entries.first { it.value == \"all\" },\n)"
    },
    "getObject": {
      "getObject": "var response = client.getObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\",\n  attributesToRetrieve = listOf(\"attr1\", \"attr2\"),\n)",
      "search with a real object": "var response = client.getObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"Batman and Robin\",\n)"
    },
    "getObjects": {
      "by ID": "var response = client.getObjects(\n  getObjectsParams = GetObjectsParams(\n    requests = listOf(\n      GetObjectsRequest(\n        objectID = \"uniqueID\",\n        indexName = \"<YOUR_INDEX_NAME>\",\n      ),\n    ),\n  ),\n)",
      "multiple IDs": "var response = client.getObjects(\n  getObjectsParams = GetObjectsParams(\n    requests = listOf(\n      GetObjectsRequest(\n        objectID = \"uniqueID1\",\n        indexName = \"<YOUR_INDEX_NAME>\",\n      ),\n      GetObjectsRequest(\n        objectID = \"uniqueID2\",\n        indexName = \"<YOUR_INDEX_NAME>\",\n      ),\n    ),\n  ),\n)",
      "with attributesToRetrieve": "var response = client.getObjects(\n  getObjectsParams = GetObjectsParams(\n    requests = listOf(\n      GetObjectsRequest(\n        attributesToRetrieve = listOf(\"attr1\", \"attr2\"),\n        objectID = \"uniqueID\",\n        indexName = \"<YOUR_INDEX_NAME>\",\n      ),\n    ),\n  ),\n)"
    },
    "getRule": {
      "default": "var response = client.getRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"qr-1725004648916\",\n)"
    },
    "getSettings": {
      "default": "var response = client.getSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)"
    },
    "getSources": {
      "default": "var response = client.getSources()"
    },
    "getSynonym": {
      "default": "var response = client.getSynonym(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"id1\",\n)"
    },
    "getTask": {
      "default": "var response = client.getTask(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  taskID = 123L,\n)"
    },
    "getTopUserIds": {
      "default": "var response = client.getTopUserIds()"
    },
    "getUserId": {
      "default": "var response = client.getUserId(\n  userID = \"uniqueID\",\n)"
    },
    "hasPendingMappings": {
      "hasPendingMappings with minimal parameters": "var response = client.hasPendingMappings()",
      "hasPendingMappings with parameters": "var response = client.hasPendingMappings(\n  getClusters = true,\n)"
    },
    "indexExists": {
      "indexExists": "var response = client.indexExists(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)",
      "indexNotExists": "var response = client.indexExists(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)",
      "indexExistsWithError": "var response = client.indexExists(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)"
    },
    "listApiKeys": {
      "default": "var response = client.listApiKeys()"
    },
    "listClusters": {
      "default": "var response = client.listClusters()"
    },
    "listIndices": {
      "listIndices with minimal parameters": "var response = client.listIndices()",
      "listIndices with parameters": "var response = client.listIndices(\n  page = 8,\n  hitsPerPage = 3,\n)"
    },
    "listUserIds": {
      "listUserIds with minimal parameters": "var response = client.listUserIds()",
      "listUserIds with parameters": "var response = client.listUserIds(\n  page = 8,\n  hitsPerPage = 100,\n)"
    },
    "multipleBatch": {
      "default": "var response = client.multipleBatch(\n  batchParams = BatchParams(\n    requests = listOf(\n      MultipleBatchRequest(\n        action = Action.entries.first { it.value == \"addObject\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"value\"),\n          )\n        },\n        indexName = \"<YOUR_INDEX_NAME>\",\n      ),\n    ),\n  ),\n)"
    },
    "operationIndex": {
      "scopes": "var response = client.operationIndex(\n  indexName = \"<SOURCE_INDEX_NAME>\",\n  operationIndexParams = OperationIndexParams(\n    operation = OperationType.entries.first { it.value == \"move\" },\n    destination = \"<DESTINATION_INDEX_NAME>\",\n    scope = listOf(ScopeType.entries.first { it.value == \"rules\" }, ScopeType.entries.first { it.value == \"settings\" }),\n  ),\n)",
      "copy": "var response = client.operationIndex(\n  indexName = \"<SOURCE_INDEX_NAME>\",\n  operationIndexParams = OperationIndexParams(\n    operation = OperationType.entries.first { it.value == \"copy\" },\n    destination = \"<DESTINATION_INDEX_NAME>\",\n  ),\n)",
      "move": "var response = client.operationIndex(\n  indexName = \"<SOURCE_INDEX_NAME>\",\n  operationIndexParams = OperationIndexParams(\n    operation = OperationType.entries.first { it.value == \"move\" },\n    destination = \"<DESTINATION_INDEX_NAME>\",\n  ),\n)"
    },
    "partialUpdateObject": {
      "Partial update with a new value for a string attribute": "var response = client.partialUpdateObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\",\n  attributesToUpdate = buildJsonObject {\n    put(\n      \"attributeId\",\n      JsonPrimitive(\"new value\"),\n    )\n  },\n)",
      "Partial update with a new value for an integer attribute": "var response = client.partialUpdateObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\",\n  attributesToUpdate = buildJsonObject {\n    put(\n      \"attributeId\",\n      JsonPrimitive(1),\n    )\n  },\n)",
      "Partial update with a new value for a boolean attribute": "var response = client.partialUpdateObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\",\n  attributesToUpdate = buildJsonObject {\n    put(\n      \"attributeId\",\n      JsonPrimitive(true),\n    )\n  },\n)",
      "Partial update with a new value for an array attribute": "var response = client.partialUpdateObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\",\n  attributesToUpdate = buildJsonObject {\n    put(\n      \"attributeId\",\n      JsonArray(\n        listOf(\n          JsonPrimitive(\"one\"),\n          JsonPrimitive(\"two\"),\n          JsonPrimitive(\"three\"),\n        ),\n      ),\n    )\n  },\n)",
      "Partial update with a new value for an object attribute": "var response = client.partialUpdateObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\",\n  attributesToUpdate = buildJsonObject {\n    put(\n      \"attributeId\",\n      buildJsonObject {\n        put(\n          \"nested\",\n          JsonPrimitive(\"value\"),\n        )\n      },\n    )\n  },\n)",
      "with visible_by filter": "var response = client.partialUpdateObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\",\n  attributesToUpdate = buildJsonObject {\n    put(\n      \"visible_by\",\n      JsonArray(\n        listOf(\n          JsonPrimitive(\"Angela\"),\n          JsonPrimitive(\"group/Finance\"),\n          JsonPrimitive(\"group/Shareholders\"),\n        ),\n      ),\n    )\n  },\n)",
      "add men pant": "var response = client.partialUpdateObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"productId\",\n  attributesToUpdate = buildJsonObject {\n    put(\n      \"categoryPageId\",\n      buildJsonObject {\n        put(\n          \"_operation\",\n          JsonPrimitive(\"Add\"),\n        )\n        put(\n          \"value\",\n          JsonPrimitive(\"men-clothing-pants\"),\n        )\n      },\n    )\n  },\n)",
      "remove men pant": "var response = client.partialUpdateObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"productId\",\n  attributesToUpdate = buildJsonObject {\n    put(\n      \"categoryPageId\",\n      buildJsonObject {\n        put(\n          \"_operation\",\n          JsonPrimitive(\"Remove\"),\n        )\n        put(\n          \"value\",\n          JsonPrimitive(\"men-clothing-pants\"),\n        )\n      },\n    )\n  },\n)"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "var response = client.partialUpdateObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objects = listOf(\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"1\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Adam\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"2\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Benoit\"),\n      )\n    },\n  ),\n  createIfNotExists = true,\n)",
      "call partialUpdateObjects with createIfNotExists=false": "var response = client.partialUpdateObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objects = listOf(\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"3\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Cyril\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"4\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"David\"),\n      )\n    },\n  ),\n  createIfNotExists = false,\n)"
    },
    "removeUserId": {
      "default": "var response = client.removeUserId(\n  userID = \"uniqueID\",\n)"
    },
    "replaceAllObjects": {
      "call replaceAllObjects without error": "var response = client.replaceAllObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objects = listOf(\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"1\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Adam\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"2\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Benoit\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"3\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Cyril\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"4\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"David\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"5\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Eva\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"6\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Fiona\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"7\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Gael\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"8\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Hugo\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"9\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Igor\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"10\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Julia\"),\n      )\n    },\n  ),\n  batchSize = 3,\n)",
      "call replaceAllObjects with partial scopes": "var response = client.replaceAllObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objects = listOf(\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"1\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Adam\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"2\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Benoit\"),\n      )\n    },\n  ),\n  batchSize = 77,\n  scopes = listOf(ScopeType.entries.first { it.value == \"settings\" }, ScopeType.entries.first { it.value == \"synonyms\" }),\n)",
      "replaceAllObjects should cleanup on failure": "var response = client.replaceAllObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objects = listOf(\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"fine\"),\n      )\n      put(\n        \"body\",\n        JsonPrimitive(\"small obj\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"toolarge\"),\n      )\n      put(\n        \"body\",\n        JsonPrimitive(\"something bigger than 10KB\"),\n      )\n    },\n  ),\n)"
    },
    "replaceSources": {
      "default": "var response = client.replaceSources(\n  source = listOf(\n    Source(\n      source = \"theSource\",\n      description = \"theDescription\",\n    ),\n  ),\n)"
    },
    "restoreApiKey": {
      "default": "var response = client.restoreApiKey(\n  key = \"ALGOLIA_API_KEY\",\n)"
    },
    "saveObject": {
      "default": "var response = client.saveObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  body = buildJsonObject {\n    put(\n      \"name\",\n      JsonPrimitive(\"Black T-shirt\"),\n    )\n    put(\n      \"color\",\n      JsonPrimitive(\"#000000||black\"),\n    )\n    put(\n      \"availableIn\",\n      JsonPrimitive(\"https://source.unsplash.com/100x100/?paris||Paris\"),\n    )\n    put(\n      \"objectID\",\n      JsonPrimitive(\"myID\"),\n    )\n  },\n)"
    },
    "saveObjects": {
      "call saveObjects without error": "var response = client.saveObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objects = listOf(\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"1\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Adam\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"2\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Benoit\"),\n      )\n    },\n  ),\n)",
      "saveObjects should report errors": "var response = client.saveObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objects = listOf(\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"1\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Adam\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"2\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Benoit\"),\n      )\n    },\n  ),\n)",
      "saveObjectsPlaylist": "var response = client.saveObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objects = listOf(\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"1\"),\n      )\n      put(\n        \"visibility\",\n        JsonPrimitive(\"public\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Hot 100 Billboard Charts\"),\n      )\n      put(\n        \"playlistId\",\n        JsonPrimitive(\"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\"),\n      )\n      put(\n        \"createdAt\",\n        JsonPrimitive(\"1500240452\"),\n      )\n    },\n  ),\n)",
      "saveObjectsPublicUser": "var response = client.saveObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objects = listOf(\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"1\"),\n      )\n      put(\n        \"visibility\",\n        JsonPrimitive(\"public\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Hot 100 Billboard Charts\"),\n      )\n      put(\n        \"playlistId\",\n        JsonPrimitive(\"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\"),\n      )\n      put(\n        \"createdAt\",\n        JsonPrimitive(\"1500240452\"),\n      )\n    },\n  ),\n  waitForTasks = false,\n  batchSize = 1000,\n  requestOptions = RequestOptions(\n    headers = buildMap {\n      put(\"X-Algolia-User-ID\", \"*\")\n    },\n  ),\n)"
    },
    "saveRule": {
      "saveRule with minimal parameters": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"id1\",\n  rule = Rule(\n    objectID = \"id1\",\n    conditions = listOf(\n      Condition(\n        pattern = \"apple\",\n        anchoring = Anchoring.entries.first { it.value == \"contains\" },\n      ),\n    ),\n    consequence = Consequence(\n      params = ConsequenceParams(\n        filters = \"brand:xiaomi\",\n      ),\n    ),\n  ),\n)",
      "saveRule with all parameters": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"id1\",\n  rule = Rule(\n    objectID = \"id1\",\n    conditions = listOf(\n      Condition(\n        pattern = \"apple\",\n        anchoring = Anchoring.entries.first { it.value == \"contains\" },\n        alternatives = false,\n        context = \"search\",\n      ),\n    ),\n    consequence = Consequence(\n      params = ConsequenceParams(\n        filters = \"brand:apple\",\n        query = ConsequenceQueryObject(\n          remove = listOf(\"algolia\"),\n          edits = listOf(\n            Edit(\n              type = EditType.entries.first { it.value == \"remove\" },\n              delete = \"abc\",\n              insert = \"cde\",\n            ),\n            Edit(\n              type = EditType.entries.first { it.value == \"replace\" },\n              delete = \"abc\",\n              insert = \"cde\",\n            ),\n          ),\n        ),\n      ),\n      hide = listOf(\n        ConsequenceHide(\n          objectID = \"321\",\n        ),\n      ),\n      filterPromotes = false,\n      userData = buildJsonObject {\n        put(\n          \"algolia\",\n          JsonPrimitive(\"aloglia\"),\n        )\n      },\n      promote = listOf(\n        PromoteObjectID(\n          objectID = \"abc\",\n          position = 3,\n        ),\n        PromoteObjectIDs(\n          objectIDs = listOf(\"abc\", \"def\"),\n          position = 1,\n        ),\n      ),\n    ),\n    description = \"test\",\n    enabled = true,\n    validity = listOf(\n      TimeRange(\n        from = 1656670273L,\n        until = 1656670277L,\n      ),\n    ),\n  ),\n  forwardToReplicas = true,\n)",
      "b2b catalog": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"article-rule\",\n  rule = Rule(\n    objectID = \"article-rule\",\n    conditions = listOf(\n      Condition(\n        pattern = \"article\",\n        anchoring = Anchoring.entries.first { it.value == \"startsWith\" },\n      ),\n    ),\n    consequence = Consequence(\n      params = ConsequenceParams(\n        query = ConsequenceQueryObject(\n          edits = listOf(\n            Edit(\n              type = EditType.entries.first { it.value == \"remove\" },\n              delete = \"article\",\n            ),\n          ),\n        ),\n        restrictSearchableAttributes = listOf(\"title\", \"book_id\"),\n      ),\n    ),\n  ),\n)",
      "merchandising and promoting": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"director-rule\",\n  rule = Rule(\n    objectID = \"director-rule\",\n    conditions = listOf(\n      Condition(\n        pattern = \"{facet:director} director\",\n        anchoring = Anchoring.entries.first { it.value == \"contains\" },\n      ),\n    ),\n    consequence = Consequence(\n      params = ConsequenceParams(\n        restrictSearchableAttributes = listOf(\"title\", \"book_id\"),\n        automaticFacetFilters = AutomaticFacetFilters.ofListOfAutomaticFacetFilter(\n          listOf(\n            AutomaticFacetFilter(\n              facet = \"director\",\n            ),\n          ),\n        ),\n        query = ConsequenceQueryObject(\n          edits = listOf(\n            Edit(\n              type = EditType.entries.first { it.value == \"remove\" },\n              delete = \"director\",\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n)",
      "harry potter": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"harry-potter-rule\",\n  rule = Rule(\n    objectID = \"harry-potter-rule\",\n    conditions = listOf(\n      Condition(\n        pattern = \"harry potter\",\n        anchoring = Anchoring.entries.first { it.value == \"contains\" },\n      ),\n    ),\n    consequence = Consequence(\n      userData = buildJsonObject {\n        put(\n          \"promo_content\",\n          JsonPrimitive(\"20% OFF on all Harry Potter books!\"),\n        )\n      },\n    ),\n  ),\n)",
      "merchandising empty query": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"clearance-category-filter\",\n  rule = Rule(\n    objectID = \"clearance-category-filter\",\n    conditions = listOf(\n      Condition(\n        pattern = \"\",\n        anchoring = Anchoring.entries.first { it.value == \"is\" },\n        context = \"landing\",\n      ),\n    ),\n    consequence = Consequence(\n      params = ConsequenceParams(\n        optionalFilters = OptionalFilters.of(\"clearance:true\"),\n      ),\n    ),\n  ),\n)",
      "redirect": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"redirect-help-rule\",\n  rule = Rule(\n    objectID = \"redirect-help-rule\",\n    conditions = listOf(\n      Condition(\n        pattern = \"help\",\n        anchoring = Anchoring.entries.first { it.value == \"contains\" },\n      ),\n    ),\n    consequence = Consequence(\n      userData = buildJsonObject {\n        put(\n          \"redirect\",\n          JsonPrimitive(\"https://www.algolia.com/support\"),\n        )\n      },\n    ),\n  ),\n)",
      "promote some results over others": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"tomato-fruit\",\n  rule = Rule(\n    objectID = \"tomato-fruit\",\n    conditions = listOf(\n      Condition(\n        pattern = \"tomato\",\n        anchoring = Anchoring.entries.first { it.value == \"contains\" },\n      ),\n    ),\n    consequence = Consequence(\n      params = ConsequenceParams(\n        optionalFilters = OptionalFilters.of(\"food_group:fruit\"),\n      ),\n    ),\n  ),\n)",
      "promote several hits": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"Promote-Apple-Newest\",\n  rule = Rule(\n    objectID = \"Promote-Apple-Newest\",\n    conditions = listOf(\n      Condition(\n        pattern = \"apple\",\n        anchoring = Anchoring.entries.first { it.value == \"is\" },\n      ),\n    ),\n    consequence = Consequence(\n      promote = listOf(\n        PromoteObjectIDs(\n          objectIDs = listOf(\"iPhone-12345\", \"watch-123\"),\n          position = 0,\n        ),\n      ),\n    ),\n  ),\n)",
      "promote newest release": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"Promote-iPhone-X\",\n  rule = Rule(\n    objectID = \"Promote-iPhone-X\",\n    conditions = listOf(\n      Condition(\n        pattern = \"iPhone\",\n        anchoring = Anchoring.entries.first { it.value == \"contains\" },\n      ),\n    ),\n    consequence = Consequence(\n      promote = listOf(\n        PromoteObjectID(\n          objectID = \"iPhone-12345\",\n          position = 0,\n        ),\n      ),\n    ),\n  ),\n)",
      "promote single item": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"promote-harry-potter-box-set\",\n  rule = Rule(\n    objectID = \"promote-harry-potter-box-set\",\n    conditions = listOf(\n      Condition(\n        pattern = \"Harry Potter\",\n        anchoring = Anchoring.entries.first { it.value == \"contains\" },\n      ),\n    ),\n    consequence = Consequence(\n      promote = listOf(\n        PromoteObjectID(\n          objectID = \"HP-12345\",\n          position = 0,\n        ),\n      ),\n    ),\n  ),\n)",
      "limit search results": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"article-rule\",\n  rule = Rule(\n    objectID = \"article-rule\",\n    conditions = listOf(\n      Condition(\n        pattern = \"article\",\n        anchoring = Anchoring.entries.first { it.value == \"startsWith\" },\n      ),\n    ),\n    consequence = Consequence(\n      params = ConsequenceParams(\n        query = ConsequenceQueryObject(\n          edits = listOf(\n            Edit(\n              type = EditType.entries.first { it.value == \"remove\" },\n              delete = \"article\",\n            ),\n          ),\n        ),\n        restrictSearchableAttributes = listOf(\"title\", \"book_id\"),\n      ),\n    ),\n  ),\n)",
      "query match": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"tagged-brand-rule\",\n  rule = Rule(\n    conditions = listOf(\n      Condition(\n        pattern = \"brand: {facet:brand}\",\n        anchoring = Anchoring.entries.first { it.value == \"contains\" },\n        alternatives = false,\n      ),\n    ),\n    consequence = Consequence(\n      params = ConsequenceParams(\n        automaticFacetFilters = AutomaticFacetFilters.ofListOfAutomaticFacetFilter(\n          listOf(\n            AutomaticFacetFilter(\n              facet = \"brand\",\n            ),\n          ),\n        ),\n        query = ConsequenceQueryObject(\n          remove = listOf(\"brand:\", \"{facet:brand}\"),\n        ),\n      ),\n    ),\n    description = \"filter on brand: {brand}\",\n    objectID = \"tagged-brand-rule\",\n  ),\n)",
      "dynamic filtering": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"color-facets\",\n  rule = Rule(\n    objectID = \"color-facets\",\n    conditions = listOf(\n      Condition(\n        pattern = \"{facet:color}\",\n      ),\n    ),\n    consequence = Consequence(\n      params = ConsequenceParams(\n        automaticFacetFilters = AutomaticFacetFilters.ofListOfAutomaticFacetFilter(\n          listOf(\n            AutomaticFacetFilter(\n              facet = \"color\",\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n)",
      "hide hits": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"hide-12345\",\n  rule = Rule(\n    objectID = \"hide-12345\",\n    conditions = listOf(\n      Condition(\n        pattern = \"cheap\",\n        anchoring = Anchoring.entries.first { it.value == \"contains\" },\n      ),\n    ),\n    consequence = Consequence(\n      hide = listOf(\n        ConsequenceHide(\n          objectID = \"to-hide-12345\",\n        ),\n      ),\n    ),\n  ),\n)",
      "one rule per facet": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"red-color\",\n  rule = Rule(\n    objectID = \"red-color\",\n    conditions = listOf(\n      Condition(\n        pattern = \"red\",\n        anchoring = Anchoring.entries.first { it.value == \"contains\" },\n      ),\n    ),\n    consequence = Consequence(\n      params = ConsequenceParams(\n        query = ConsequenceQueryObject(\n          remove = listOf(\"red\"),\n        ),\n        filters = \"color:red\",\n      ),\n    ),\n  ),\n)",
      "numerical filters": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"cheap\",\n  rule = Rule(\n    objectID = \"cheap\",\n    conditions = listOf(\n      Condition(\n        pattern = \"cheap\",\n        anchoring = Anchoring.entries.first { it.value == \"contains\" },\n      ),\n    ),\n    consequence = Consequence(\n      params = ConsequenceParams(\n        query = ConsequenceQueryObject(\n          remove = listOf(\"cheap\"),\n        ),\n        filters = \"price < 10\",\n      ),\n    ),\n  ),\n)",
      "negative filters": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"gluten-free-rule\",\n  rule = Rule(\n    objectID = \"gluten-free-rule\",\n    conditions = listOf(\n      Condition(\n        pattern = \"gluten-free\",\n        anchoring = Anchoring.entries.first { it.value == \"contains\" },\n      ),\n    ),\n    consequence = Consequence(\n      params = ConsequenceParams(\n        filters = \"NOT allergens:gluten\",\n        query = ConsequenceQueryObject(\n          edits = listOf(\n            Edit(\n              type = EditType.entries.first { it.value == \"remove\" },\n              delete = \"gluten-free\",\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n)",
      "positive filters": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"diet-rule\",\n  rule = Rule(\n    objectID = \"diet-rule\",\n    conditions = listOf(\n      Condition(\n        pattern = \"diet\",\n        anchoring = Anchoring.entries.first { it.value == \"contains\" },\n      ),\n    ),\n    consequence = Consequence(\n      params = ConsequenceParams(\n        filters = \"'low-carb' OR 'low-fat'\",\n        query = ConsequenceQueryObject(\n          edits = listOf(\n            Edit(\n              type = EditType.entries.first { it.value == \"remove\" },\n              delete = \"diet\",\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n)",
      "conditionless": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"diet-rule\",\n  rule = Rule(\n    objectID = \"diet-rule\",\n    consequence = Consequence(\n      params = ConsequenceParams(\n        filters = \"'low-carb' OR 'low-fat'\",\n        query = ConsequenceQueryObject(\n          edits = listOf(\n            Edit(\n              type = EditType.entries.first { it.value == \"remove\" },\n              delete = \"diet\",\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n)",
      "contextual": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"a-rule-id\",\n  rule = Rule(\n    objectID = \"a-rule-id\",\n    conditions = listOf(\n      Condition(\n        context = \"mobile\",\n      ),\n    ),\n    consequence = Consequence(\n      params = ConsequenceParams(\n        filters = \"release_date >= 1577836800\",\n      ),\n    ),\n  ),\n)",
      "saveRule always active rule": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"a-rule-id\",\n  rule = Rule(\n    objectID = \"a-rule-id\",\n    consequence = Consequence(\n      params = ConsequenceParams(\n        aroundRadius = AroundRadius.of(1000),\n      ),\n    ),\n    validity = listOf(\n      TimeRange(\n        from = 1577836800L,\n        until = 1577836800L,\n      ),\n    ),\n  ),\n)"
    },
    "saveRules": {
      "saveRules with minimal parameters": "var response = client.saveRules(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  rules = listOf(\n    Rule(\n      objectID = \"a-rule-id\",\n      conditions = listOf(\n        Condition(\n          pattern = \"smartphone\",\n          anchoring = Anchoring.entries.first { it.value == \"contains\" },\n        ),\n      ),\n      consequence = Consequence(\n        params = ConsequenceParams(\n          filters = \"brand:apple\",\n        ),\n      ),\n    ),\n    Rule(\n      objectID = \"a-second-rule-id\",\n      conditions = listOf(\n        Condition(\n          pattern = \"apple\",\n          anchoring = Anchoring.entries.first { it.value == \"contains\" },\n        ),\n      ),\n      consequence = Consequence(\n        params = ConsequenceParams(\n          filters = \"brand:samsung\",\n        ),\n      ),\n    ),\n  ),\n  forwardToReplicas = false,\n  clearExistingRules = true,\n)",
      "saveRules with all parameters": "var response = client.saveRules(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  rules = listOf(\n    Rule(\n      objectID = \"id1\",\n      conditions = listOf(\n        Condition(\n          pattern = \"apple\",\n          anchoring = Anchoring.entries.first { it.value == \"contains\" },\n          alternatives = false,\n          context = \"search\",\n        ),\n      ),\n      consequence = Consequence(\n        params = ConsequenceParams(\n          filters = \"brand:apple\",\n          query = ConsequenceQueryObject(\n            remove = listOf(\"algolia\"),\n            edits = listOf(\n              Edit(\n                type = EditType.entries.first { it.value == \"remove\" },\n                delete = \"abc\",\n                insert = \"cde\",\n              ),\n              Edit(\n                type = EditType.entries.first { it.value == \"replace\" },\n                delete = \"abc\",\n                insert = \"cde\",\n              ),\n            ),\n          ),\n        ),\n        hide = listOf(\n          ConsequenceHide(\n            objectID = \"321\",\n          ),\n        ),\n        filterPromotes = false,\n        userData = buildJsonObject {\n          put(\n            \"algolia\",\n            JsonPrimitive(\"aloglia\"),\n          )\n        },\n        promote = listOf(\n          PromoteObjectID(\n            objectID = \"abc\",\n            position = 3,\n          ),\n          PromoteObjectIDs(\n            objectIDs = listOf(\"abc\", \"def\"),\n            position = 1,\n          ),\n        ),\n      ),\n      description = \"test\",\n      enabled = true,\n      validity = listOf(\n        TimeRange(\n          from = 1656670273L,\n          until = 1656670277L,\n        ),\n      ),\n    ),\n  ),\n  forwardToReplicas = true,\n  clearExistingRules = true,\n)",
      "dynamic filtering": "var response = client.saveRules(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  rules = listOf(\n    Rule(\n      objectID = \"toaster\",\n      conditions = listOf(\n        Condition(\n          pattern = \"toaster\",\n          anchoring = Anchoring.entries.first { it.value == \"contains\" },\n        ),\n      ),\n      consequence = Consequence(\n        params = ConsequenceParams(\n          query = ConsequenceQueryObject(\n            remove = listOf(\"toaster\"),\n          ),\n          filters = \"product_type:toaster\",\n        ),\n      ),\n    ),\n    Rule(\n      objectID = \"cheap\",\n      conditions = listOf(\n        Condition(\n          pattern = \"cheap\",\n          anchoring = Anchoring.entries.first { it.value == \"contains\" },\n        ),\n      ),\n      consequence = Consequence(\n        params = ConsequenceParams(\n          query = ConsequenceQueryObject(\n            remove = listOf(\"cheap\"),\n          ),\n          filters = \"price < 15\",\n        ),\n      ),\n    ),\n  ),\n)",
      "enhance search results": "var response = client.saveRules(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  rules = listOf(\n    Rule(\n      objectID = \"country\",\n      conditions = listOf(\n        Condition(\n          pattern = \"{facet:country}\",\n          anchoring = Anchoring.entries.first { it.value == \"contains\" },\n        ),\n      ),\n      consequence = Consequence(\n        params = ConsequenceParams(\n          aroundLatLngViaIP = false,\n        ),\n      ),\n    ),\n    Rule(\n      objectID = \"city\",\n      conditions = listOf(\n        Condition(\n          pattern = \"{facet:city}\",\n          anchoring = Anchoring.entries.first { it.value == \"contains\" },\n        ),\n      ),\n      consequence = Consequence(\n        params = ConsequenceParams(\n          aroundLatLngViaIP = false,\n        ),\n      ),\n    ),\n  ),\n)"
    },
    "saveSynonym": {
      "default": "var response = client.saveSynonym(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"id1\",\n  synonymHit = SynonymHit(\n    objectID = \"id1\",\n    type = SynonymType.entries.first { it.value == \"synonym\" },\n    synonyms = listOf(\"car\", \"vehicule\", \"auto\"),\n  ),\n  forwardToReplicas = true,\n)"
    },
    "saveSynonyms": {
      "default": "var response = client.saveSynonyms(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  synonymHit = listOf(\n    SynonymHit(\n      objectID = \"id1\",\n      type = SynonymType.entries.first { it.value == \"synonym\" },\n      synonyms = listOf(\"car\", \"vehicule\", \"auto\"),\n    ),\n    SynonymHit(\n      objectID = \"id2\",\n      type = SynonymType.entries.first { it.value == \"onewaysynonym\" },\n      input = \"iphone\",\n      synonyms = listOf(\"ephone\", \"aphone\", \"yphone\"),\n    ),\n  ),\n  forwardToReplicas = true,\n  replaceExistingSynonyms = true,\n)"
    },
    "search": {
      "withHitsPerPage": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = \"<YOUR_QUERY>\",\n        hitsPerPage = 50,\n      ),\n    ),\n  ),\n)",
      "filterOnly": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = \"<YOUR_QUERY>\",\n        filters = \"actor:Scarlett Johansson\",\n      ),\n    ),\n  ),\n)",
      "filterOr": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = \"<YOUR_QUERY>\",\n        filters = \"actor:Tom Cruise OR actor:Scarlett Johansson\",\n      ),\n    ),\n  ),\n)",
      "filterNot": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = \"<YOUR_QUERY>\",\n        filters = \"NOT actor:Nicolas Cage\",\n      ),\n    ),\n  ),\n)",
      "search for a single hits request with minimal parameters": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n      ),\n    ),\n  ),\n)",
      "search with highlight and snippet results": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = \"vim\",\n        attributesToSnippet = listOf(\"*:20\"),\n        attributesToHighlight = listOf(\"*\"),\n        attributesToRetrieve = listOf(\"*\"),\n      ),\n    ),\n  ),\n)",
      "retrieveFacets": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = \"<YOUR_QUERY>\",\n        facets = listOf(\"author\", \"genre\"),\n      ),\n    ),\n  ),\n)",
      "retrieveFacetsWildcard": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = \"<YOUR_QUERY>\",\n        facets = listOf(\"*\"),\n      ),\n    ),\n  ),\n)",
      "search for a single facet request with minimal parameters": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForFacets(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        type = SearchTypeFacet.entries.first { it.value == \"facet\" },\n        facet = \"editor\",\n      ),\n    ),\n    strategy = SearchStrategy.entries.first { it.value == \"stopIfEnoughMatches\" },\n  ),\n)",
      "search for a single hits request with all parameters": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = \"myQuery\",\n        hitsPerPage = 50,\n        type = SearchTypeDefault.entries.first { it.value == \"default\" },\n      ),\n    ),\n  ),\n)",
      "search for a single facet request with all parameters": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForFacets(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        type = SearchTypeFacet.entries.first { it.value == \"facet\" },\n        facet = \"theFacet\",\n        facetQuery = \"theFacetQuery\",\n        query = \"theQuery\",\n        maxFacetHits = 50,\n      ),\n    ),\n    strategy = SearchStrategy.entries.first { it.value == \"stopIfEnoughMatches\" },\n  ),\n)",
      "search for multiple mixed requests in multiple indices with minimal parameters": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n      ),\n      SearchForFacets(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        type = SearchTypeFacet.entries.first { it.value == \"facet\" },\n        facet = \"theFacet\",\n      ),\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        type = SearchTypeDefault.entries.first { it.value == \"default\" },\n      ),\n    ),\n    strategy = SearchStrategy.entries.first { it.value == \"stopIfEnoughMatches\" },\n  ),\n)",
      "search for multiple mixed requests in multiple indices with all parameters": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForFacets(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        type = SearchTypeFacet.entries.first { it.value == \"facet\" },\n        facet = \"theFacet\",\n        facetQuery = \"theFacetQuery\",\n        query = \"theQuery\",\n        maxFacetHits = 50,\n      ),\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = \"myQuery\",\n        hitsPerPage = 50,\n        type = SearchTypeDefault.entries.first { it.value == \"default\" },\n      ),\n    ),\n    strategy = SearchStrategy.entries.first { it.value == \"stopIfEnoughMatches\" },\n  ),\n)",
      "search filters accept all of the possible shapes": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        facetFilters = FacetFilters.of(\"mySearch:filters\"),\n        reRankingApplyFilter = ReRankingApplyFilter.of(\"mySearch:filters\"),\n        tagFilters = TagFilters.of(\"mySearch:filters\"),\n        numericFilters = NumericFilters.of(\"mySearch:filters\"),\n        optionalFilters = OptionalFilters.of(\"mySearch:filters\"),\n      ),\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        facetFilters = FacetFilters.of(listOf(FacetFilters.of(\"mySearch:filters\"), FacetFilters.of(listOf(FacetFilters.of(\"mySearch:filters\"), FacetFilters.of(listOf(FacetFilters.of(\"mySearch:filters\"))))))),\n        reRankingApplyFilter = ReRankingApplyFilter.of(listOf(ReRankingApplyFilter.of(\"mySearch:filters\"), ReRankingApplyFilter.of(listOf(ReRankingApplyFilter.of(\"mySearch:filters\"))))),\n        tagFilters = TagFilters.of(listOf(TagFilters.of(\"mySearch:filters\"), TagFilters.of(listOf(TagFilters.of(\"mySearch:filters\"))))),\n        numericFilters = NumericFilters.of(listOf(NumericFilters.of(\"mySearch:filters\"), NumericFilters.of(listOf(NumericFilters.of(\"mySearch:filters\"))))),\n        optionalFilters = OptionalFilters.of(listOf(OptionalFilters.of(\"mySearch:filters\"), OptionalFilters.of(listOf(OptionalFilters.of(\"mySearch:filters\"))))),\n      ),\n    ),\n  ),\n)",
      "search filters end to end": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        filters = \"editor:'visual studio' OR editor:neovim\",\n      ),\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        facetFilters = FacetFilters.of(listOf(FacetFilters.of(\"editor:'visual studio'\"), FacetFilters.of(\"editor:neovim\"))),\n      ),\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        facetFilters = FacetFilters.of(listOf(FacetFilters.of(\"editor:'visual studio'\"), FacetFilters.of(listOf(FacetFilters.of(\"editor:neovim\"))))),\n      ),\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        facetFilters = FacetFilters.of(listOf(FacetFilters.of(\"editor:'visual studio'\"), FacetFilters.of(listOf(FacetFilters.of(\"editor:neovim\"), FacetFilters.of(listOf(FacetFilters.of(\"editor:goland\"))))))),\n      ),\n    ),\n  ),\n)",
      "search with all search parameters": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        advancedSyntax = true,\n        advancedSyntaxFeatures = listOf(AdvancedSyntaxFeatures.entries.first { it.value == \"exactPhrase\" }),\n        allowTyposOnNumericTokens = true,\n        alternativesAsExact = listOf(AlternativesAsExact.entries.first { it.value == \"multiWordsSynonym\" }),\n        analytics = true,\n        analyticsTags = listOf(\"\"),\n        aroundLatLng = \"\",\n        aroundLatLngViaIP = true,\n        aroundPrecision = AroundPrecision.of(0),\n        aroundRadius = AroundRadiusAll.entries.first { it.value == \"all\" },\n        attributeCriteriaComputedByMinProximity = true,\n        attributesToHighlight = listOf(\"\"),\n        attributesToRetrieve = listOf(\"\"),\n        attributesToSnippet = listOf(\"\"),\n        clickAnalytics = true,\n        decompoundQuery = true,\n        disableExactOnAttributes = listOf(\"\"),\n        disableTypoToleranceOnAttributes = listOf(\"\"),\n        distinct = Distinct.of(0),\n        enableABTest = true,\n        enablePersonalization = true,\n        enableReRanking = true,\n        enableRules = true,\n        exactOnSingleWordQuery = ExactOnSingleWordQuery.entries.first { it.value == \"attribute\" },\n        facetFilters = FacetFilters.of(listOf(FacetFilters.of(\"\"))),\n        facetingAfterDistinct = true,\n        facets = listOf(\"\"),\n        filters = \"\",\n        getRankingInfo = true,\n        highlightPostTag = \"\",\n        highlightPreTag = \"\",\n        hitsPerPage = 1,\n        ignorePlurals = IgnorePlurals.of(false),\n        indexName = \"<YOUR_INDEX_NAME>\",\n        insideBoundingBox = InsideBoundingBox.of(listOf(listOf(47.3165, 4.9665, 47.3424, 5.0201), listOf(40.9234, 2.1185, 38.643, 1.9916))),\n        insidePolygon = listOf(listOf(47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9), listOf(40.9234, 2.1185, 38.643, 1.9916, 39.2587, 2.0104)),\n        length = 1,\n        maxValuesPerFacet = 0,\n        minProximity = 1,\n        minWordSizefor1Typo = 0,\n        minWordSizefor2Typos = 0,\n        minimumAroundRadius = 1,\n        naturalLanguages = listOf(SupportedLanguage.entries.first { it.value == \"fr\" }),\n        numericFilters = NumericFilters.of(listOf(NumericFilters.of(\"\"))),\n        offset = 0,\n        optionalFilters = OptionalFilters.of(listOf(OptionalFilters.of(\"\"))),\n        optionalWords = OptionalWords.of(listOf(\"\")),\n        page = 0,\n        percentileComputation = true,\n        personalizationImpact = 0,\n        query = \"\",\n        queryLanguages = listOf(SupportedLanguage.entries.first { it.value == \"fr\" }),\n        queryType = QueryType.entries.first { it.value == \"prefixAll\" },\n        ranking = listOf(\"\"),\n        reRankingApplyFilter = ReRankingApplyFilter.of(listOf(ReRankingApplyFilter.of(\"\"))),\n        relevancyStrictness = 0,\n        removeStopWords = RemoveStopWords.of(true),\n        removeWordsIfNoResults = RemoveWordsIfNoResults.entries.first { it.value == \"allOptional\" },\n        renderingContent = RenderingContent(\n          facetOrdering = FacetOrdering(\n            facets = Facets(\n              order = listOf(\"a\", \"b\"),\n            ),\n            values = mapOf(\n              \"a\" to Value(\n                order = listOf(\"b\"),\n                sortRemainingBy = SortRemainingBy.entries.first { it.value == \"count\" },\n              ),\n            ),\n          ),\n        ),\n        replaceSynonymsInHighlight = true,\n        responseFields = listOf(\"\"),\n        restrictHighlightAndSnippetArrays = true,\n        restrictSearchableAttributes = listOf(\"\"),\n        ruleContexts = listOf(\"\"),\n        similarQuery = \"\",\n        snippetEllipsisText = \"\",\n        sortFacetValuesBy = \"\",\n        sumOrFiltersScores = true,\n        synonyms = true,\n        tagFilters = TagFilters.of(listOf(TagFilters.of(\"\"))),\n        type = SearchTypeDefault.entries.first { it.value == \"default\" },\n        typoTolerance = TypoToleranceEnum.entries.first { it.value == \"min\" },\n        userToken = \"\",\n      ),\n    ),\n  ),\n)"
    },
    "searchDictionaryEntries": {
      "get searchDictionaryEntries results with minimal parameters": "var response = client.searchDictionaryEntries(\n  dictionaryName = DictionaryType.entries.first { it.value == \"stopwords\" },\n  searchDictionaryEntriesParams = SearchDictionaryEntriesParams(\n    query = \"about\",\n  ),\n)",
      "get searchDictionaryEntries results with all parameters": "var response = client.searchDictionaryEntries(\n  dictionaryName = DictionaryType.entries.first { it.value == \"compounds\" },\n  searchDictionaryEntriesParams = SearchDictionaryEntriesParams(\n    query = \"foo\",\n    page = 4,\n    hitsPerPage = 2,\n    language = SupportedLanguage.entries.first { it.value == \"fr\" },\n  ),\n)"
    },
    "searchForFacetValues": {
      "get searchForFacetValues results with minimal parameters": "var response = client.searchForFacetValues(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  facetName = \"facetName\",\n)",
      "get searchForFacetValues results with all parameters": "var response = client.searchForFacetValues(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  facetName = \"facetName\",\n  searchForFacetValuesRequest = SearchForFacetValuesRequest(\n    params = \"query=foo&facetFilters=['bar']\",\n    facetQuery = \"foo\",\n    maxFacetHits = 42,\n  ),\n)",
      "facetName and facetQuery": "var response = client.searchForFacetValues(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  facetName = \"author\",\n  searchForFacetValuesRequest = SearchForFacetValuesRequest(\n    facetQuery = \"stephen\",\n  ),\n)"
    },
    "searchRules": {
      "default": "var response = client.searchRules(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchRulesParams = SearchRulesParams(\n    query = \"zorro\",\n  ),\n)"
    },
    "searchSingleIndex": {
      "search with minimal parameters": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)",
      "search with special characters in indexName": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)",
      "search with searchParams": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"myQuery\",\n    facetFilters = FacetFilters.of(listOf(FacetFilters.of(\"tags:algolia\"))),\n  ),\n)",
      "single search retrieve snippets": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"batman mask of the phantasm\",\n    attributesToRetrieve = listOf(\"*\"),\n    attributesToSnippet = listOf(\"*:20\"),\n  ),\n)",
      "query": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"phone\",\n  ),\n)",
      "filters": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    filters = \"country:US AND price.gross < 2.0\",\n  ),\n)",
      "filters for stores": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"ben\",\n    filters = \"categories:politics AND store:Gibert Joseph Saint-Michel\",\n  ),\n)",
      "filters boolean": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    filters = \"is_available:true\",\n  ),\n)",
      "distinct": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    distinct = Distinct.of(true),\n  ),\n)",
      "filtersNumeric": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    filters = \"price < 10\",\n  ),\n)",
      "filtersTimestamp": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    filters = \"NOT date_timestamp:1514764800 TO 1546300799\",\n  ),\n)",
      "filtersSumOrFiltersScoresFalse": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    filters = \"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\",\n    sumOrFiltersScores = false,\n  ),\n)",
      "filtersSumOrFiltersScoresTrue": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    filters = \"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\",\n    sumOrFiltersScores = true,\n  ),\n)",
      "filtersStephenKing": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    filters = \"author:\\\"Stephen King\\\"\",\n  ),\n)",
      "filtersNotTags": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"harry\",\n    filters = \"_tags:non-fiction\",\n  ),\n)",
      "facetFiltersList": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    facetFilters = FacetFilters.of(listOf(FacetFilters.of(\"publisher:Penguin\"), FacetFilters.of(listOf(FacetFilters.of(\"author:Stephen King\"), FacetFilters.of(\"genre:Horror\"))))),\n  ),\n)",
      "facetFiltersBook": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    facetFilters = FacetFilters.of(listOf(FacetFilters.of(\"category:Book\"))),\n  ),\n)",
      "facetFiltersAND": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    facetFilters = FacetFilters.of(listOf(FacetFilters.of(\"category:Book\"), FacetFilters.of(\"author:John Doe\"))),\n  ),\n)",
      "facetFiltersOR": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    facetFilters = FacetFilters.of(listOf(FacetFilters.of(listOf(FacetFilters.of(\"category:Book\"), FacetFilters.of(\"author:John Doe\"))))),\n  ),\n)",
      "facetFiltersCombined": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    facetFilters = FacetFilters.of(listOf(FacetFilters.of(\"author:John Doe\"), FacetFilters.of(listOf(FacetFilters.of(\"category:Book\"), FacetFilters.of(\"category:Movie\"))))),\n  ),\n)",
      "facetFiltersNeg": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    facetFilters = FacetFilters.of(\"category:-Ebook\"),\n  ),\n)",
      "filtersAndFacetFilters": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    filters = \"(author:\\\"Stephen King\\\" OR genre:\\\"Horror\\\")\",\n    facetFilters = FacetFilters.of(listOf(FacetFilters.of(\"publisher:Penguin\"))),\n  ),\n)",
      "facet author genre": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    facets = listOf(\"author\", \"genre\"),\n  ),\n)",
      "facet wildcard": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    facets = listOf(\"*\"),\n  ),\n)",
      "maxValuesPerFacet": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    maxValuesPerFacet = 1000,\n  ),\n)",
      "aroundLatLng": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    aroundLatLng = \"40.71, -74.01\",\n  ),\n)",
      "aroundLatLngViaIP": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    aroundLatLngViaIP = true,\n  ),\n)",
      "aroundRadius": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    aroundLatLng = \"40.71, -74.01\",\n    aroundRadius = AroundRadius.of(1000000),\n  ),\n)",
      "insideBoundingBox": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    insideBoundingBox = InsideBoundingBox.of(listOf(listOf(49.067996905313834, 65.73828125, 25.905859247243498, 128.8046875))),\n  ),\n)",
      "insidePolygon": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    insidePolygon = listOf(listOf(42.01, -124.31, 48.835509470063045, -124.40453125000005, 45.01082951668149, -65.95726562500005, 31.247243545293433, -81.06578125000004, 25.924152577235226, -97.68234374999997, 32.300311895879545, -117.54828125)),\n  ),\n)",
      "optionalFilters": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    optionalFilters = OptionalFilters.of(listOf(OptionalFilters.of(\"can_deliver_quickly:true\"))),\n  ),\n)",
      "optionalFiltersMany": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    optionalFilters = OptionalFilters.of(listOf(OptionalFilters.of(\"brand:Apple<score=3>\"), OptionalFilters.of(\"brand:Samsung<score=2>\"), OptionalFilters.of(\"brand:-Huawei\"))),\n  ),\n)",
      "optionalFiltersSimple": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    optionalFilters = OptionalFilters.of(listOf(OptionalFilters.of(\"brand:Apple<score=2>\"), OptionalFilters.of(\"type:tablet\"))),\n  ),\n)",
      "restrictSearchableAttributes": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    restrictSearchableAttributes = listOf(\"title_fr\"),\n  ),\n)",
      "getRankingInfo": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    getRankingInfo = true,\n  ),\n)",
      "clickAnalytics": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    clickAnalytics = true,\n  ),\n)",
      "clickAnalyticsUserToken": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    clickAnalytics = true,\n    userToken = \"user-1\",\n  ),\n)",
      "enablePersonalization": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    enablePersonalization = true,\n    userToken = \"user-1\",\n  ),\n)",
      "userToken": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    userToken = \"user-1\",\n  ),\n)",
      "userToken1234": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    userToken = \"user-1234\",\n  ),\n)",
      "analyticsTag": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    analyticsTags = listOf(\"YOUR_ANALYTICS_TAG\"),\n  ),\n)",
      "facetFiltersUsers": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    facetFilters = FacetFilters.of(listOf(FacetFilters.of(\"user:user42\"), FacetFilters.of(\"user:public\"))),\n  ),\n)",
      "buildTheQuery": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    filters = \"categoryPageId: Men's Clothing\",\n    hitsPerPage = 50,\n    analyticsTags = listOf(\"mens-clothing\"),\n  ),\n)",
      "attributesToHighlightOverride": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    attributesToHighlight = listOf(\"title\", \"content\"),\n  ),\n)",
      "disableTypoToleranceOnAttributes": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    disableTypoToleranceOnAttributes = listOf(\"serial_number\"),\n  ),\n)",
      "search_a_query": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"\",\n    similarQuery = \"Comedy Drama Crime McDormand Macy Buscemi Stormare Presnell Coen\",\n    filters = \"year:1991 TO 2001\",\n  ),\n)",
      "search_everything": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"\",\n  ),\n)",
      "api_filtering_range_example": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"books\",\n    filters = \"price:10 TO 20\",\n  ),\n)",
      "override_retrievable_attributes": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    attributesToRetrieve = listOf(\"title\", \"content\"),\n  ),\n)",
      "restrict_searchable_attributes": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    restrictSearchableAttributes = listOf(\"title\", \"author\"),\n  ),\n)",
      "override_default_relevancy": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    relevancyStrictness = 70,\n  ),\n)",
      "apply_filters": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    sumOrFiltersScores = true,\n  ),\n)",
      "apply_all_filters": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    filters = \"available = 1 AND (category:Book OR NOT category:Ebook) AND _tags:published AND publication_date:1441745506 TO 1441755506 AND inStock > 0 AND author:\\\"John Doe\\\"\",\n  ),\n)",
      "escape_spaces": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    filters = \"category:\\\"Books and Comics\\\"\",\n  ),\n)",
      "escape_keywords": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    filters = \"keyword:\\\"OR\\\"\",\n  ),\n)",
      "escape_single_quotes": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    filters = \"content:\\\"It's a wonderful day\\\"\",\n  ),\n)",
      "escape_double_quotes": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    filters = \"content:\\\"She said \\\"Hello World\\\"\",\n  ),\n)",
      "apply_negative_filters": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    optionalFilters = OptionalFilters.of(listOf(OptionalFilters.of(\"category:Book\"), OptionalFilters.of(\"author:-John Doe\"))),\n  ),\n)",
      "apply_negative_filters_restaurants": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    optionalFilters = OptionalFilters.of(listOf(OptionalFilters.of(\"restaurant:-Bert's Inn\"))),\n  ),\n)",
      "apply_numeric_filters": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    numericFilters = NumericFilters.of(listOf(NumericFilters.of(\"price < 1000\"), NumericFilters.of(listOf(NumericFilters.of(\"inStock = 1\"), NumericFilters.of(\"deliveryDate < 1441755506\"))))),\n  ),\n)",
      "apply_tag_filters": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    tagFilters = TagFilters.of(listOf(TagFilters.of(\"SciFi\"), TagFilters.of(listOf(TagFilters.of(\"Book\"), TagFilters.of(\"Movie\"))))),\n  ),\n)",
      "facets_all": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    facets = listOf(\"*\"),\n  ),\n)",
      "retrieve_only_some_facets": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    facets = listOf(\"category\", \"author\"),\n  ),\n)",
      "override_default_max_values_per_facet": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    maxValuesPerFacet = 20,\n  ),\n)",
      "enable_faceting_after_distinct": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    facetingAfterDistinct = true,\n  ),\n)",
      "sort_facet_values_alphabetically": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    sortFacetValuesBy = \"count\",\n  ),\n)",
      "override_attributes_to_snippet": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    attributesToSnippet = listOf(\"title\", \"content:80\"),\n  ),\n)",
      "override_default_highlight_pre_tag": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    highlightPreTag = \"<strong>\",\n  ),\n)",
      "override_default_highlight_post_tag": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    highlightPostTag = \"</strong>\",\n  ),\n)",
      "override_default_snippet_ellipsis_text": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    snippetEllipsisText = \"\",\n  ),\n)",
      "enable_restrict_highlight_and_snippet_arrays": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    restrictHighlightAndSnippetArrays = false,\n  ),\n)",
      "access_page": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    page = 0,\n  ),\n)",
      "override_default_hits_per_page": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    hitsPerPage = 10,\n  ),\n)",
      "get_nth_hit": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    offset = 4,\n  ),\n)",
      "get_n_results": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    length = 4,\n  ),\n)",
      "override_default_min_word_size_for_one_typo": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    minWordSizefor1Typo = 2,\n  ),\n)",
      "override_default_min_word_size_for_two_typos": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    minWordSizefor2Typos = 2,\n  ),\n)",
      "override_default_typo_tolerance_mode": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    typoTolerance = TypoTolerance.of(false),\n  ),\n)",
      "disable_typos_on_numeric_tokens_at_search_time": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    allowTyposOnNumericTokens = false,\n  ),\n)",
      "search_around_a_position": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    aroundLatLng = \"40.71, -74.01\",\n  ),\n)",
      "search_around_server_ip": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    aroundLatLngViaIP = true,\n  ),\n  requestOptions = RequestOptions(\n    headers = buildMap {\n      put(\"x-forwarded-for\", \"94.228.178.246 // should be replaced with the actual IP you would like to search around\")\n    },\n  ),\n)",
      "set_around_radius": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    aroundRadius = AroundRadius.of(1000),\n  ),\n)",
      "disable_automatic_radius": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    aroundRadius = AroundRadiusAll.entries.first { it.value == \"all\" },\n  ),\n)",
      "set_geo_search_precision": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    aroundPrecision = AroundPrecision.of(100),\n  ),\n)",
      "set_geo_search_precision_non_linear": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    aroundPrecision = AroundPrecision.of(\n      listOf(\n        Range(\n          from = 0,\n          value = 25,\n        ),\n        Range(\n          from = 2000,\n          value = 1000,\n        ),\n      ),\n    ),\n  ),\n)",
      "set_minimum_geo_search_radius": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    minimumAroundRadius = 1000,\n  ),\n)",
      "search_inside_rectangular_area": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    insideBoundingBox = InsideBoundingBox.of(listOf(listOf(46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625))),\n  ),\n)",
      "search_inside_multiple_rectangular_areas": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    insideBoundingBox = InsideBoundingBox.of(listOf(listOf(46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625), listOf(49.62625916704081, 4.6181640625, 47.715070300900194, 0.482421875))),\n  ),\n)",
      "search_inside_polygon_area": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    insidePolygon = listOf(listOf(46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625)),\n  ),\n)",
      "search_inside_multiple_polygon_areas": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    insidePolygon = listOf(listOf(46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625), listOf(49.62625916704081, 4.6181640625, 47.715070300900194, 0.482421875, 45.17210966999772, 1.009765625, 50.62626704081, 4.6181640625)),\n  ),\n)",
      "set_querylanguages_override": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    removeStopWords = RemoveStopWords.of(listOf(SupportedLanguage.entries.first { it.value == \"ca\" }, SupportedLanguage.entries.first { it.value == \"es\" })),\n  ),\n)",
      "set_querylanguages_with_japanese_query": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    queryLanguages = listOf(SupportedLanguage.entries.first { it.value == \"ja\" }, SupportedLanguage.entries.first { it.value == \"en\" }),\n  ),\n)",
      "set_natural_languages": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"\",\n    naturalLanguages = listOf(SupportedLanguage.entries.first { it.value == \"fr\" }),\n  ),\n)",
      "override_natural_languages_with_query": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"\",\n    naturalLanguages = listOf(SupportedLanguage.entries.first { it.value == \"fr\" }),\n    removeWordsIfNoResults = RemoveWordsIfNoResults.entries.first { it.value == \"firstWords\" },\n  ),\n)",
      "enable_decompound_query_search_time": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    decompoundQuery = true,\n  ),\n)",
      "enable_rules_search_time": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    enableRules = true,\n  ),\n)",
      "set_rule_contexts": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    ruleContexts = listOf(\"front_end\", \"website2\"),\n  ),\n)",
      "enable_personalization": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    enablePersonalization = true,\n  ),\n)",
      "enable_personalization_with_user_token": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    enablePersonalization = true,\n    userToken = \"123456\",\n  ),\n)",
      "personalization_impact": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    personalizationImpact = 20,\n  ),\n)",
      "set_user_token": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    userToken = \"123456\",\n  ),\n)",
      "set_user_token_with_personalization": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    enablePersonalization = true,\n    userToken = \"123456\",\n  ),\n)",
      "override_default_query_type": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    queryType = QueryType.entries.first { it.value == \"prefixAll\" },\n  ),\n)",
      "override_default_remove_words_if_no_results": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    removeWordsIfNoResults = RemoveWordsIfNoResults.entries.first { it.value == \"lastWords\" },\n  ),\n)",
      "enable_advanced_syntax_search_time": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    advancedSyntax = true,\n  ),\n)",
      "overide_default_optional_words": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    optionalWords = OptionalWords.of(listOf(\"toyota\", \"2020 2021\")),\n  ),\n)",
      "disabling_exact_for_some_attributes_search_time": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    disableExactOnAttributes = listOf(\"description\"),\n  ),\n)",
      "override_default_exact_single_word_query": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    exactOnSingleWordQuery = ExactOnSingleWordQuery.entries.first { it.value == \"none\" },\n  ),\n)",
      "override_default_aternative_as_exact": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    alternativesAsExact = listOf(AlternativesAsExact.entries.first { it.value == \"multiWordsSynonym\" }),\n  ),\n)",
      "enable_advanced_syntax_exact_phrase": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    advancedSyntax = true,\n    advancedSyntaxFeatures = listOf(AdvancedSyntaxFeatures.entries.first { it.value == \"exactPhrase\" }),\n  ),\n)",
      "enable_advanced_syntax_exclude_words": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    advancedSyntax = true,\n    advancedSyntaxFeatures = listOf(AdvancedSyntaxFeatures.entries.first { it.value == \"excludeWords\" }),\n  ),\n)",
      "override_distinct": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    distinct = Distinct.of(0),\n  ),\n)",
      "get_ranking_info": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    getRankingInfo = true,\n  ),\n)",
      "disable_click_analytics": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    clickAnalytics = false,\n  ),\n)",
      "enable_click_analytics": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    clickAnalytics = true,\n  ),\n)",
      "disable_analytics": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    analytics = false,\n  ),\n)",
      "add_analytics_tags": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    analyticsTags = listOf(\"front_end\", \"website2\"),\n  ),\n)",
      "disable_synonyms": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    synonyms = false,\n  ),\n)",
      "override_replace_synonyms_in_highlights": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    replaceSynonymsInHighlight = true,\n  ),\n)",
      "override_min_proximity": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    minProximity = 2,\n  ),\n)",
      "override_default_field": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    responseFields = listOf(\"hits\", \"facets\"),\n  ),\n)",
      "override_percentile_computation": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    percentileComputation = false,\n  ),\n)",
      "set_ab_test": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    enableABTest = false,\n  ),\n)",
      "set_enable_re_ranking": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n    enableReRanking = false,\n  ),\n)",
      "with algolia user id": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"query\",\n  ),\n  requestOptions = RequestOptions(\n    headers = buildMap {\n      put(\"X-Algolia-User-ID\", \"user1234\")\n    },\n  ),\n)",
      "mcm with algolia user id": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchParams = SearchParamsObject(\n    query = \"peace\",\n  ),\n  requestOptions = RequestOptions(\n    headers = buildMap {\n      put(\"X-Algolia-User-ID\", \"user42\")\n    },\n  ),\n)"
    },
    "searchSynonyms": {
      "searchSynonyms with minimal parameters": "var response = client.searchSynonyms(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)",
      "searchSynonyms with all parameters": "var response = client.searchSynonyms(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchSynonymsParams = SearchSynonymsParams(\n    query = \"myQuery\",\n    type = SynonymType.entries.first { it.value == \"altcorrection1\" },\n    page = 10,\n    hitsPerPage = 10,\n  ),\n)"
    },
    "searchUserIds": {
      "default": "var response = client.searchUserIds(\n  searchUserIdsParams = SearchUserIdsParams(\n    query = \"test\",\n    clusterName = \"theClusterName\",\n    page = 5,\n    hitsPerPage = 10,\n  ),\n)"
    },
    "setClientApiKey": {
      "default": "client.setClientApiKey(\n  apiKey = \"updated-api-key\",\n)"
    },
    "setDictionarySettings": {
      "get setDictionarySettings results with minimal parameters": "var response = client.setDictionarySettings(\n  dictionarySettingsParams = DictionarySettingsParams(\n    disableStandardEntries = StandardEntries(\n      plurals = mapOf(\"fr\" to false, \"en\" to false, \"ru\" to true),\n    ),\n  ),\n)",
      "get setDictionarySettings results with all parameters": "var response = client.setDictionarySettings(\n  dictionarySettingsParams = DictionarySettingsParams(\n    disableStandardEntries = StandardEntries(\n      plurals = mapOf(\"fr\" to false, \"en\" to false, \"ru\" to true),\n      stopwords = mapOf(\"fr\" to false),\n      compounds = mapOf(\"ru\" to true),\n    ),\n  ),\n)"
    },
    "setSettings": {
      "minimal parameters": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    paginationLimitedTo = 10,\n  ),\n  forwardToReplicas = true,\n)",
      "boolean typoTolerance": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    typoTolerance = TypoTolerance.of(true),\n  ),\n  forwardToReplicas = true,\n)",
      "enum typoTolerance": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    typoTolerance = TypoToleranceEnum.entries.first { it.value == \"min\" },\n  ),\n  forwardToReplicas = true,\n)",
      "ignorePlurals": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    ignorePlurals = IgnorePlurals.of(true),\n  ),\n  forwardToReplicas = true,\n)",
      "list of string ignorePlurals": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    ignorePlurals = IgnorePlurals.of(listOf(SupportedLanguage.entries.first { it.value == \"fr\" })),\n  ),\n  forwardToReplicas = true,\n)",
      "removeStopWords boolean": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    removeStopWords = RemoveStopWords.of(true),\n  ),\n  forwardToReplicas = true,\n)",
      "removeStopWords list of string": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    removeStopWords = RemoveStopWords.of(listOf(SupportedLanguage.entries.first { it.value == \"fr\" })),\n  ),\n  forwardToReplicas = true,\n)",
      "boolean distinct": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    distinct = Distinct.of(true),\n  ),\n  forwardToReplicas = true,\n)",
      "integer distinct": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    distinct = Distinct.of(1),\n  ),\n  forwardToReplicas = true,\n)",
      "distinct company": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributeForDistinct = \"company\",\n    distinct = Distinct.of(true),\n  ),\n)",
      "distinct design": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributeForDistinct = \"design\",\n    distinct = Distinct.of(true),\n  ),\n)",
      "distinct true": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    distinct = Distinct.of(true),\n  ),\n)",
      "distinct section": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributeForDistinct = \"section\",\n    distinct = Distinct.of(true),\n  ),\n)",
      "attributesForFaceting allergens": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesForFaceting = listOf(\"allergens\"),\n  ),\n)",
      "attributesForFaceting availableIn": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesForFaceting = listOf(\"color\", \"availableIn\"),\n  ),\n)",
      "api_attributes_for_faceting": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesForFaceting = listOf(\"genre\", \"author\"),\n  ),\n)",
      "api_attributes_for_faceting_searchable": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesForFaceting = listOf(\"genre\", \"searchable(author)\"),\n  ),\n)",
      "api_attributes_for_filter_only": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesForFaceting = listOf(\"filterOnly(genre)\", \"author\"),\n  ),\n)",
      "attributesForFaceting categoryPageId": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesForFaceting = listOf(\"searchable(categoryPageId)\"),\n  ),\n)",
      "unretrievableAttributes": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    unretrievableAttributes = listOf(\"visible_by\"),\n  ),\n)",
      "attributesForFaceting user restricted data": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesForFaceting = listOf(\"filterOnly(visible_by)\"),\n  ),\n)",
      "attributesForFaceting optional filters": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesForFaceting = listOf(\"can_deliver_quickly\", \"restaurant\"),\n  ),\n)",
      "attributesForFaceting redirect index": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesForFaceting = listOf(\"query_terms\"),\n  ),\n)",
      "attributesForFaceting multiple consequences": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesForFaceting = listOf(\"director\"),\n  ),\n)",
      "attributesForFaceting in-depth optional filters": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesForFaceting = listOf(\"filterOnly(brand)\"),\n  ),\n)",
      "mode neuralSearch": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    mode = Mode.entries.first { it.value == \"neuralSearch\" },\n  ),\n)",
      "mode keywordSearch": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    mode = Mode.entries.first { it.value == \"keywordSearch\" },\n  ),\n)",
      "searchableAttributes same priority": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    searchableAttributes = listOf(\"title,comments\", \"ingredients\"),\n  ),\n)",
      "searchableAttributes higher priority": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    searchableAttributes = listOf(\"title\", \"ingredients\"),\n  ),\n)",
      "customRanking retweets": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    customRanking = listOf(\"desc(retweets)\", \"desc(likes)\"),\n  ),\n)",
      "customRanking boosted": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    customRanking = listOf(\"desc(boosted)\"),\n  ),\n)",
      "customRanking pageviews": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    customRanking = listOf(\"desc(pageviews)\", \"desc(comments)\"),\n  ),\n)",
      "customRanking applying search parameters for a specific query": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    customRanking = listOf(\"desc(nb_airline_liaisons)\"),\n    attributesForFaceting = listOf(\"city, country\"),\n  ),\n)",
      "customRanking rounded pageviews": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    customRanking = listOf(\"desc(rounded_pageviews)\", \"desc(comments)\"),\n  ),\n)",
      "customRanking price": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    customRanking = listOf(\"desc(price)\"),\n  ),\n)",
      "ranking exhaustive (price)": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    ranking = listOf(\"desc(price)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"),\n  ),\n)",
      "ranking exhaustive (is_popular)": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    ranking = listOf(\"desc(is_popular)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"),\n  ),\n)",
      "ranking standard replica": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    ranking = listOf(\"desc(post_date_timestamp)\"),\n  ),\n)",
      "ranking virtual replica": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    customRanking = listOf(\"desc(post_date_timestamp)\"),\n  ),\n)",
      "customRanking and ranking sort alphabetically": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    customRanking = listOf(\"asc(textual_attribute)\"),\n    ranking = listOf(\"custom\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\"),\n  ),\n)",
      "relevancyStrictness": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    customRanking = listOf(\"asc(textual_attribute)\"),\n    relevancyStrictness = 0,\n  ),\n)",
      "create replica index": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    replicas = listOf(\"products_price_desc\"),\n  ),\n)",
      "create replica index articles": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    replicas = listOf(\"articles_date_desc\"),\n  ),\n)",
      "create virtual replica index": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    replicas = listOf(\"virtual(products_price_desc)\"),\n  ),\n)",
      "unlink replica index": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    replicas = listOf(\"\"),\n  ),\n)",
      "forwardToReplicas": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    searchableAttributes = listOf(\"name\", \"description\"),\n  ),\n  forwardToReplicas = true,\n)",
      "maxValuesPerFacet": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    maxValuesPerFacet = 1000,\n  ),\n)",
      "maxFacetHits": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    maxFacetHits = 100,\n  ),\n)",
      "attributesForFaceting complex": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesForFaceting = listOf(\"actor\", \"filterOnly(category)\", \"searchable(publisher)\"),\n  ),\n)",
      "ranking closest dates": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    ranking = listOf(\"asc(date_timestamp)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"),\n  ),\n)",
      "searchableAttributes item variation": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    searchableAttributes = listOf(\"design\", \"type\", \"color\"),\n  ),\n)",
      "searchableAttributes around location": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    searchableAttributes = listOf(\"name\", \"country\", \"city\", \"iata_code\"),\n    customRanking = listOf(\"desc(links_count)\"),\n  ),\n)",
      "attributesToHighlight": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesToHighlight = listOf(\"author\", \"title\", \"content\"),\n  ),\n)",
      "attributesToHighlightStar": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesToHighlight = listOf(\"*\"),\n  ),\n)",
      "everything": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    advancedSyntax = true,\n    advancedSyntaxFeatures = listOf(AdvancedSyntaxFeatures.entries.first { it.value == \"exactPhrase\" }),\n    allowCompressionOfIntegerArray = true,\n    allowTyposOnNumericTokens = true,\n    alternativesAsExact = listOf(AlternativesAsExact.entries.first { it.value == \"singleWordSynonym\" }),\n    attributeCriteriaComputedByMinProximity = true,\n    attributeForDistinct = \"test\",\n    attributesForFaceting = listOf(\"algolia\"),\n    attributesToHighlight = listOf(\"algolia\"),\n    attributesToRetrieve = listOf(\"algolia\"),\n    attributesToSnippet = listOf(\"algolia\"),\n    attributesToTransliterate = listOf(\"algolia\"),\n    camelCaseAttributes = listOf(\"algolia\"),\n    customNormalization = mapOf(\"algolia\" to mapOf(\"aloglia\" to \"aglolia\")),\n    customRanking = listOf(\"algolia\"),\n    decompoundQuery = false,\n    decompoundedAttributes = buildJsonObject {\n      put(\n        \"algolia\",\n        JsonPrimitive(\"aloglia\"),\n      )\n    },\n    disableExactOnAttributes = listOf(\"algolia\"),\n    disablePrefixOnAttributes = listOf(\"algolia\"),\n    disableTypoToleranceOnAttributes = listOf(\"algolia\"),\n    disableTypoToleranceOnWords = listOf(\"algolia\"),\n    distinct = Distinct.of(3),\n    enablePersonalization = true,\n    enableReRanking = false,\n    enableRules = true,\n    exactOnSingleWordQuery = ExactOnSingleWordQuery.entries.first { it.value == \"attribute\" },\n    highlightPreTag = \"<span>\",\n    highlightPostTag = \"</span>\",\n    hitsPerPage = 10,\n    ignorePlurals = IgnorePlurals.of(false),\n    indexLanguages = listOf(SupportedLanguage.entries.first { it.value == \"fr\" }),\n    keepDiacriticsOnCharacters = \"abc\",\n    maxFacetHits = 20,\n    maxValuesPerFacet = 30,\n    minProximity = 6,\n    minWordSizefor1Typo = 5,\n    minWordSizefor2Typos = 11,\n    mode = Mode.entries.first { it.value == \"neuralSearch\" },\n    numericAttributesForFiltering = listOf(\"algolia\"),\n    optionalWords = OptionalWords.of(listOf(\"myspace\")),\n    paginationLimitedTo = 0,\n    queryLanguages = listOf(SupportedLanguage.entries.first { it.value == \"fr\" }),\n    queryType = QueryType.entries.first { it.value == \"prefixLast\" },\n    ranking = listOf(\"geo\"),\n    reRankingApplyFilter = ReRankingApplyFilter.of(\"mySearch:filters\"),\n    relevancyStrictness = 10,\n    removeStopWords = RemoveStopWords.of(false),\n    removeWordsIfNoResults = RemoveWordsIfNoResults.entries.first { it.value == \"lastWords\" },\n    renderingContent = RenderingContent(\n      facetOrdering = FacetOrdering(\n        facets = Facets(\n          order = listOf(\"a\", \"b\"),\n        ),\n        values = mapOf(\n          \"a\" to Value(\n            order = listOf(\"b\"),\n            sortRemainingBy = SortRemainingBy.entries.first { it.value == \"count\" },\n          ),\n        ),\n      ),\n    ),\n    replaceSynonymsInHighlight = true,\n    replicas = listOf(\"\"),\n    responseFields = listOf(\"algolia\"),\n    restrictHighlightAndSnippetArrays = true,\n    searchableAttributes = listOf(\"foo\"),\n    semanticSearch = SemanticSearch(\n      eventSources = listOf(\"foo\"),\n    ),\n    separatorsToIndex = \"bar\",\n    snippetEllipsisText = \"---\",\n    sortFacetValuesBy = \"date\",\n    typoTolerance = TypoTolerance.of(false),\n    unretrievableAttributes = listOf(\"foo\"),\n    userData = buildJsonObject {\n      put(\n        \"user\",\n        JsonPrimitive(\"data\"),\n      )\n    },\n  ),\n)",
      "searchableAttributesWithCustomRankingsAndAttributesForFaceting": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    searchableAttributes = listOf(\"brand\", \"name\", \"categories\", \"unordered(description)\"),\n    customRanking = listOf(\"desc(popularity)\"),\n    attributesForFaceting = listOf(\"searchable(brand)\", \"type\", \"categories\", \"price\"),\n  ),\n)",
      "searchableAttributesOrdering": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    searchableAttributes = listOf(\"unordered(title)\", \"cast\"),\n  ),\n)",
      "searchableAttributesProductReferenceSuffixes": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    searchableAttributes = listOf(\"name\", \"product_reference\", \"product_reference_suffixes\"),\n  ),\n)",
      "queryLanguageAndIgnorePlurals": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    queryLanguages = listOf(SupportedLanguage.entries.first { it.value == \"en\" }),\n    ignorePlurals = IgnorePlurals.of(true),\n  ),\n)",
      "searchableAttributesInMovies": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    searchableAttributes = listOf(\"title_eng\", \"title_fr\", \"title_es\"),\n  ),\n)",
      "disablePrefixOnAttributes": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    disablePrefixOnAttributes = listOf(\"serial_number\"),\n  ),\n)",
      "disableTypoToleranceOnAttributes": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    disableTypoToleranceOnAttributes = listOf(\"serial_number\"),\n  ),\n)",
      "searchableAttributesSimpleExample": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    searchableAttributes = listOf(\"serial_number\"),\n  ),\n)",
      "searchableAttributesSimpleExampleAlt": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    searchableAttributes = listOf(\"serial_number\", \"serial_number_suffixes\"),\n  ),\n)",
      "set_searchable_attributes": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesForFaceting = listOf(\"author\", \"filterOnly(isbn)\", \"searchable(edition)\", \"afterDistinct(category)\", \"afterDistinct(searchable(publisher))\"),\n  ),\n)",
      "unretrievable_attributes": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    unretrievableAttributes = listOf(\"total_number_of_sales\"),\n  ),\n)",
      "set_retrievable_attributes": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesToRetrieve = listOf(\"author\", \"title\", \"content\"),\n  ),\n)",
      "set_all_attributes_as_retrievable": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesToRetrieve = listOf(\"*\"),\n  ),\n)",
      "specify_attributes_not_to_retrieve": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesToRetrieve = listOf(\"*\", \"-SKU\", \"-internal_desc\"),\n  ),\n)",
      "neural_search": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    mode = Mode.entries.first { it.value == \"neuralSearch\" },\n  ),\n)",
      "keyword_search": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    mode = Mode.entries.first { it.value == \"keywordSearch\" },\n  ),\n)",
      "set_default_ranking": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    ranking = listOf(\"typo\", \"geo\", \"words\", \"filters\", \"attribute\", \"proximity\", \"exact\", \"custom\"),\n  ),\n)",
      "set_ranking_by_attribute_asc": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    ranking = listOf(\"asc(price)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"),\n  ),\n)",
      "set_ranking_by_attribute_desc": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    ranking = listOf(\"desc(price)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"),\n  ),\n)",
      "restrict_searchable_attributes": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    customRanking = listOf(\"desc(popularity)\", \"asc(price)\"),\n  ),\n)",
      "set_default_relevancy": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    relevancyStrictness = 90,\n  ),\n)",
      "set_replicas": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    replicas = listOf(\"name_of_replica_index1\", \"name_of_replica_index2\"),\n  ),\n)",
      "set_default_max_values_per_facet": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    maxValuesPerFacet = 100,\n  ),\n)",
      "set_default_sort_facet_values_by": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    sortFacetValuesBy = \"alpha\",\n  ),\n)",
      "set_attributes_to_snippet": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesToSnippet = listOf(\"content:80\", \"description\"),\n  ),\n)",
      "set_all_attributes_to_snippet": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesToSnippet = listOf(\"*:80\"),\n  ),\n)",
      "set_default_highlight_pre_tag": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    highlightPreTag = \"<em>\",\n  ),\n)",
      "set_default_highlight_post_tag": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    highlightPostTag = \"</em>\",\n  ),\n)",
      "set_default_snippet_ellipsis_text": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    snippetEllipsisText = \"…\",\n  ),\n)",
      "enable_restrict_highlight_and_snippet_arrays_by_default": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    restrictHighlightAndSnippetArrays = true,\n  ),\n)",
      "set_default_hits_per_page": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    hitsPerPage = 20,\n  ),\n)",
      "set_pagination_limit": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    paginationLimitedTo = 1000,\n  ),\n)",
      "set_default_min_word_size_for_one_typo": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    minWordSizefor1Typo = 4,\n  ),\n)",
      "set_default_min_word_size_for_two_typos": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    minWordSizefor2Typos = 4,\n  ),\n)",
      "set_default_typo_tolerance_mode": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    typoTolerance = TypoTolerance.of(true),\n  ),\n)",
      "disable_typos_on_numeric_tokens_by_default": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    allowTyposOnNumericTokens = false,\n  ),\n)",
      "disable_typo_tolerance_for_words": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    disableTypoToleranceOnWords = listOf(\"wheel\", \"1X2BCD\"),\n  ),\n)",
      "set_separators_to_index": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    separatorsToIndex = \"+#\",\n  ),\n)",
      "set_languages_using_querylanguages": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    queryLanguages = listOf(SupportedLanguage.entries.first { it.value == \"es\" }),\n    removeStopWords = RemoveStopWords.of(true),\n    ignorePlurals = IgnorePlurals.of(true),\n  ),\n)",
      "set_attributes_to_transliterate": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    indexLanguages = listOf(SupportedLanguage.entries.first { it.value == \"ja\" }),\n    attributesToTransliterate = listOf(\"name\", \"description\"),\n  ),\n)",
      "set_camel_case_attributes": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    camelCaseAttributes = listOf(\"description\"),\n  ),\n)",
      "set_decompounded_attributes": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    decompoundedAttributes = buildJsonObject {\n      put(\n        \"de\",\n        JsonArray(\n          listOf(\n            JsonPrimitive(\"name\"),\n          ),\n        ),\n      )\n    },\n  ),\n)",
      "set_decompounded_multiple_attributes": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    decompoundedAttributes = buildJsonObject {\n      put(\n        \"de\",\n        JsonArray(\n          listOf(\n            JsonPrimitive(\"name_de\"),\n            JsonPrimitive(\"description_de\"),\n          ),\n        ),\n      )\n      put(\n        \"fi\",\n        JsonArray(\n          listOf(\n            JsonPrimitive(\"name_fi\"),\n            JsonPrimitive(\"description_fi\"),\n          ),\n        ),\n      )\n    },\n  ),\n)",
      "set_keep_diacritics_on_characters": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    keepDiacriticsOnCharacters = \"øé\",\n  ),\n)",
      "set_custom_normalization": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    customNormalization = mapOf(\"default\" to mapOf(\"ä\" to \"ae\")),\n  ),\n)",
      "set_indexlanguages": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    indexLanguages = listOf(SupportedLanguage.entries.first { it.value == \"ja\" }),\n  ),\n)",
      "enable_decompound_query_by_default": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    decompoundQuery = true,\n  ),\n)",
      "enable_rules_syntax_by_default": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    enableRules = true,\n  ),\n)",
      "enable_personalization_settings": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    enablePersonalization = true,\n  ),\n)",
      "set_default_query_type": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    queryType = QueryType.entries.first { it.value == \"prefixLast\" },\n  ),\n)",
      "set_default_remove_words_if_no_result": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    removeWordsIfNoResults = RemoveWordsIfNoResults.entries.first { it.value == \"none\" },\n  ),\n)",
      "enable_advanced_syntax_by_default": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    advancedSyntax = true,\n  ),\n)",
      "set_default_optional_words": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    optionalWords = OptionalWords.of(listOf(\"blue\", \"iphone case\")),\n  ),\n)",
      "disabling_prefix_search_for_some_attributes_by_default": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    disablePrefixOnAttributes = listOf(\"sku\"),\n  ),\n)",
      "disabling_exact_for_some_attributes_by_default": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    disableExactOnAttributes = listOf(\"description\"),\n  ),\n)",
      "set_default_exact_single_word_query": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    exactOnSingleWordQuery = ExactOnSingleWordQuery.entries.first { it.value == \"attribute\" },\n  ),\n)",
      "set_default_aternative_as_exact": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    alternativesAsExact = listOf(AlternativesAsExact.entries.first { it.value == \"ignorePlurals\" }, AlternativesAsExact.entries.first { it.value == \"singleWordSynonym\" }),\n  ),\n)",
      "set_numeric_attributes_for_filtering": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    numericAttributesForFiltering = listOf(\"quantity\", \"popularity\"),\n  ),\n)",
      "enable_compression_of_integer_array": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    allowCompressionOfIntegerArray = true,\n  ),\n)",
      "set_attributes_for_distinct": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributeForDistinct = \"url\",\n  ),\n)",
      "set_distinct": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    distinct = Distinct.of(1),\n    attributeForDistinct = \"url\",\n  ),\n)",
      "set_replace_synonyms_in_highlights": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    replaceSynonymsInHighlight = false,\n  ),\n)",
      "set_min_proximity": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    minProximity = 1,\n  ),\n)",
      "set_default_field": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    responseFields = listOf(\"hits\", \"hitsPerPage\", \"nbPages\", \"page\"),\n  ),\n)",
      "set_max_facet_hits": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    maxFacetHits = 10,\n  ),\n)",
      "set_attribute_criteria_computed_by_min_proximity": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributeCriteriaComputedByMinProximity = true,\n  ),\n)",
      "set_user_data": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    userData = buildJsonObject {\n      put(\n        \"extraData\",\n        JsonPrimitive(\"This is the custom data that you want to store in your index\"),\n      )\n    },\n  ),\n)",
      "set_rendering_content": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    renderingContent = RenderingContent(\n      facetOrdering = FacetOrdering(\n        facets = Facets(\n          order = listOf(\"size\", \"brand\"),\n        ),\n        values = mapOf(\n          \"brand\" to Value(\n            order = listOf(\"uniqlo\"),\n            hide = listOf(\"muji\"),\n            sortRemainingBy = SortRemainingBy.entries.first { it.value == \"count\" },\n          ),\n          \"size\" to Value(\n            order = listOf(\"S\", \"M\", \"L\"),\n            sortRemainingBy = SortRemainingBy.entries.first { it.value == \"hidden\" },\n          ),\n        ),\n      ),\n    ),\n  ),\n)"
    },
    "updateApiKey": {
      "default": "var response = client.updateApiKey(\n  key = \"ALGOLIA_API_KEY\",\n  apiKey = ApiKey(\n    acl = listOf(Acl.entries.first { it.value == \"search\" }, Acl.entries.first { it.value == \"addObject\" }),\n    validity = 300,\n    maxQueriesPerIPPerHour = 100,\n    maxHitsPerQuery = 20,\n  ),\n)"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "var response = client.waitForApiKey(\n  key = \"api-key-add-operation-test-kotlin\",\n  operation = ApiKeyOperation.entries.first { it.value == \"add\" },\n)",
      "wait for api key - update": "var response = client.waitForApiKey(\n  key = \"api-key-update-operation-test-kotlin\",\n  operation = ApiKeyOperation.entries.first { it.value == \"update\" },\n  apiKey = ApiKey(\n    description = \"my updated api key\",\n    acl = listOf(Acl.entries.first { it.value == \"search\" }, Acl.entries.first { it.value == \"addObject\" }, Acl.entries.first { it.value == \"deleteObject\" }),\n    indexes = listOf(\"Movies\", \"Books\"),\n    referers = listOf(\"*google.com\", \"*algolia.com\"),\n    validity = 305,\n    maxQueriesPerIPPerHour = 95,\n    maxHitsPerQuery = 20,\n  ),\n)",
      "wait for api key - delete": "var response = client.waitForApiKey(\n  key = \"api-key-delete-operation-test-kotlin\",\n  operation = ApiKeyOperation.entries.first { it.value == \"delete\" },\n)"
    },
    "waitForAppTask": {
      "default": "var response = client.waitForAppTask(\n  taskID = 123L,\n)"
    },
    "waitForTask": {
      "default": "var response = client.waitForTask(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  taskID = 123L,\n)"
    },
    "init": {
      "default": "val client = SearchClient(appId = \"ALGOLIA_APPLICATION_ID\", apiKey = \"ALGOLIA_API_KEY\")"
    }
  },
  "php": {
    "import": {
      "default": "use Algolia\\AlgoliaSearch\\Api\\SearchClient;"
    },
    "addApiKey": {
      "minimal": "$response = $client->addApiKey(\n    ['acl' => [\n        'search',\n\n        'addObject',\n    ],\n        'description' => 'my new api key',\n    ],\n);",
      "all": "$response = $client->addApiKey(\n    ['acl' => [\n        'search',\n\n        'addObject',\n    ],\n        'description' => 'my new api key',\n        'validity' => 300,\n        'maxQueriesPerIPPerHour' => 100,\n        'maxHitsPerQuery' => 20,\n    ],\n);"
    },
    "addOrUpdateObject": {
      "default": "$response = $client->addOrUpdateObject(\n    '<YOUR_INDEX_NAME>',\n    'uniqueID',\n    ['key' => 'value',\n    ],\n);"
    },
    "appendSource": {
      "default": "$response = $client->appendSource(\n    ['source' => 'theSource',\n        'description' => 'theDescription',\n    ],\n);"
    },
    "assignUserId": {
      "simple": "$response = $client->assignUserId(\n    'user42',\n    ['cluster' => 'd4242-eu',\n    ],\n);",
      "it should not encode the userID": "$response = $client->assignUserId(\n    'user id with spaces',\n    ['cluster' => 'cluster with spaces',\n    ],\n);"
    },
    "batch": {
      "addObject": "$response = $client->batch(\n    '<YOUR_INDEX_NAME>',\n    ['requests' => [\n        ['action' => 'addObject',\n            'body' => ['key' => 'bar',\n                'foo' => '1',\n            ],\n        ],\n\n        ['action' => 'addObject',\n            'body' => ['key' => 'baz',\n                'foo' => '2',\n            ],\n        ],\n    ],\n    ],\n);",
      "clear": "$response = $client->batch(\n    '<YOUR_INDEX_NAME>',\n    ['requests' => [\n        ['action' => 'clear',\n            'body' => ['key' => 'value',\n            ],\n        ],\n    ],\n    ],\n);",
      "delete": "$response = $client->batch(\n    '<YOUR_INDEX_NAME>',\n    ['requests' => [\n        ['action' => 'delete',\n            'body' => ['key' => 'value',\n            ],\n        ],\n    ],\n    ],\n);",
      "deleteObject": "$response = $client->batch(\n    '<YOUR_INDEX_NAME>',\n    ['requests' => [\n        ['action' => 'deleteObject',\n            'body' => ['key' => 'value',\n            ],\n        ],\n    ],\n    ],\n);",
      "partialUpdateObject": "$response = $client->batch(\n    '<YOUR_INDEX_NAME>',\n    ['requests' => [\n        ['action' => 'partialUpdateObject',\n            'body' => ['key' => 'value',\n            ],\n        ],\n    ],\n    ],\n);",
      "partialUpdateObjectNoCreate": "$response = $client->batch(\n    '<YOUR_INDEX_NAME>',\n    ['requests' => [\n        ['action' => 'partialUpdateObjectNoCreate',\n            'body' => ['key' => 'value',\n            ],\n        ],\n    ],\n    ],\n);",
      "updateObject": "$response = $client->batch(\n    '<YOUR_INDEX_NAME>',\n    ['requests' => [\n        ['action' => 'updateObject',\n            'body' => ['key' => 'value',\n            ],\n        ],\n    ],\n    ],\n);"
    },
    "batchAssignUserIds": {
      "default": "$response = $client->batchAssignUserIds(\n    'userID',\n    ['cluster' => 'theCluster',\n        'users' => [\n            'user1',\n\n            'user2',\n        ],\n    ],\n);"
    },
    "batchDictionaryEntries": {
      "replace": "$response = $client->batchDictionaryEntries(\n    'plurals',\n    ['clearExistingDictionaryEntries' => true,\n        'requests' => [\n            ['action' => 'addEntry',\n                'body' => ['objectID' => '1',\n                    'language' => 'en',\n                    'word' => 'fancy',\n                    'words' => [\n                        'believe',\n\n                        'algolia',\n                    ],\n                    'decomposition' => [\n                        'trust',\n\n                        'algolia',\n                    ],\n                    'state' => 'enabled',\n                ],\n            ],\n        ],\n    ],\n);",
      "delete": "$response = $client->batchDictionaryEntries(\n    'plurals',\n    ['clearExistingDictionaryEntries' => true,\n        'requests' => [\n            ['action' => 'deleteEntry',\n                'body' => ['objectID' => '1',\n                ],\n            ],\n        ],\n    ],\n);",
      "append": "$response = $client->batchDictionaryEntries(\n    'stopwords',\n    ['requests' => [\n        ['action' => 'addEntry',\n            'body' => ['objectID' => '1',\n                'language' => 'en',\n                'additional' => 'try me',\n            ],\n        ],\n    ],\n    ],\n);"
    },
    "browse": {
      "browse with minimal parameters": "$response = $client->browse(\n    '<YOUR_INDEX_NAME>',\n);",
      "browse with search parameters": "$response = $client->browse(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'myQuery',\n        'facetFilters' => [\n            'tags:algolia',\n        ],\n    ],\n);",
      "browse allow a cursor in parameters": "$response = $client->browse(\n    '<YOUR_INDEX_NAME>',\n    ['cursor' => 'test',\n    ],\n);"
    },
    "clearObjects": {
      "default": "$response = $client->clearObjects(\n    '<YOUR_INDEX_NAME>',\n);"
    },
    "clearRules": {
      "default": "$response = $client->clearRules(\n    '<YOUR_INDEX_NAME>',\n);"
    },
    "clearSynonyms": {
      "default": "$response = $client->clearSynonyms(\n    '<YOUR_INDEX_NAME>',\n);"
    },
    "customDelete": {
      "allow del method for a custom path with minimal parameters": "$response = $client->customDelete(\n    'test/minimal',\n);",
      "allow del method for a custom path with all parameters": "$response = $client->customDelete(\n    'test/all',\n    ['query' => 'parameters',\n    ],\n);"
    },
    "customGet": {
      "allow get method for a custom path with minimal parameters": "$response = $client->customGet(\n    'test/minimal',\n);",
      "allow get method for a custom path with all parameters": "$response = $client->customGet(\n    'test/all',\n    ['query' => 'parameters with space',\n    ],\n);",
      "requestOptions should be escaped too": "$response = $client->customGet(\n    'test/all',\n    ['query' => 'to be overriden',\n    ],\n    [\n        'queryParameters' => [\n            'query' => 'parameters with space',\n            'and an array' => ['array', 'with spaces',\n            ],\n        ],\n        'headers' => [\n            'x-header-1' => 'spaces are left alone',\n        ],\n    ]\n);"
    },
    "customPost": {
      "allow post method for a custom path with minimal parameters": "$response = $client->customPost(\n    'test/minimal',\n);",
      "allow post method for a custom path with all parameters": "$response = $client->customPost(\n    'test/all',\n    ['query' => 'parameters',\n    ],\n    ['body' => 'parameters',\n    ],\n);",
      "requestOptions can override default query parameters": "$response = $client->customPost(\n    'test/requestOptions',\n    ['query' => 'parameters',\n    ],\n    ['facet' => 'filters',\n    ],\n    [\n        'queryParameters' => [\n            'query' => 'myQueryParameter',\n        ], ]\n);",
      "requestOptions merges query parameters with default ones": "$response = $client->customPost(\n    'test/requestOptions',\n    ['query' => 'parameters',\n    ],\n    ['facet' => 'filters',\n    ],\n    [\n        'queryParameters' => [\n            'query2' => 'myQueryParameter',\n        ], ]\n);",
      "requestOptions can override default headers": "$response = $client->customPost(\n    'test/requestOptions',\n    ['query' => 'parameters',\n    ],\n    ['facet' => 'filters',\n    ],\n    [\n        'headers' => [\n            'x-algolia-api-key' => 'ALGOLIA_API_KEY',\n        ],\n    ]\n);",
      "requestOptions merges headers with default ones": "$response = $client->customPost(\n    'test/requestOptions',\n    ['query' => 'parameters',\n    ],\n    ['facet' => 'filters',\n    ],\n    [\n        'headers' => [\n            'x-algolia-api-key' => 'ALGOLIA_API_KEY',\n        ],\n    ]\n);",
      "requestOptions queryParameters accepts booleans": "$response = $client->customPost(\n    'test/requestOptions',\n    ['query' => 'parameters',\n    ],\n    ['facet' => 'filters',\n    ],\n    [\n        'queryParameters' => [\n            'isItWorking' => true,\n        ], ]\n);",
      "requestOptions queryParameters accepts integers": "$response = $client->customPost(\n    'test/requestOptions',\n    ['query' => 'parameters',\n    ],\n    ['facet' => 'filters',\n    ],\n    [\n        'queryParameters' => [\n            'myParam' => 2,\n        ], ]\n);",
      "requestOptions queryParameters accepts list of string": "$response = $client->customPost(\n    'test/requestOptions',\n    ['query' => 'parameters',\n    ],\n    ['facet' => 'filters',\n    ],\n    [\n        'queryParameters' => [\n            'myParam' => ['b and c', 'd',\n            ],\n        ], ]\n);",
      "requestOptions queryParameters accepts list of booleans": "$response = $client->customPost(\n    'test/requestOptions',\n    ['query' => 'parameters',\n    ],\n    ['facet' => 'filters',\n    ],\n    [\n        'queryParameters' => [\n            'myParam' => [true, true, false,\n            ],\n        ], ]\n);",
      "requestOptions queryParameters accepts list of integers": "$response = $client->customPost(\n    'test/requestOptions',\n    ['query' => 'parameters',\n    ],\n    ['facet' => 'filters',\n    ],\n    [\n        'queryParameters' => [\n            'myParam' => [1, 2,\n            ],\n        ], ]\n);"
    },
    "customPut": {
      "allow put method for a custom path with minimal parameters": "$response = $client->customPut(\n    'test/minimal',\n);",
      "allow put method for a custom path with all parameters": "$response = $client->customPut(\n    'test/all',\n    ['query' => 'parameters',\n    ],\n    ['body' => 'parameters',\n    ],\n);"
    },
    "deleteApiKey": {
      "default": "$response = $client->deleteApiKey(\n    'myTestApiKey',\n);"
    },
    "deleteBy": {
      "default": "$response = $client->deleteBy(\n    '<YOUR_INDEX_NAME>',\n    ['filters' => 'brand:brandName',\n    ],\n);"
    },
    "deleteIndex": {
      "default": "$response = $client->deleteIndex(\n    '<YOUR_INDEX_NAME>',\n);"
    },
    "deleteObject": {
      "default": "$response = $client->deleteObject(\n    '<YOUR_INDEX_NAME>',\n    'uniqueID',\n);"
    },
    "deleteObjects": {
      "default": "$response = $client->deleteObjects(\n    '<YOUR_INDEX_NAME>',\n    [\n        '1',\n\n        '2',\n    ],\n);"
    },
    "deleteRule": {
      "delete rule simple case": "$response = $client->deleteRule(\n    '<YOUR_INDEX_NAME>',\n    'id1',\n);",
      "delete rule with simple characters to encode in objectID": "$response = $client->deleteRule(\n    '<YOUR_INDEX_NAME>',\n    'test/with/slash',\n);"
    },
    "deleteSource": {
      "default": "$response = $client->deleteSource(\n    'theSource',\n);"
    },
    "deleteSynonym": {
      "default": "$response = $client->deleteSynonym(\n    '<YOUR_INDEX_NAME>',\n    'id1',\n);"
    },
    "generateSecuredApiKey": {
      "api key basic": "$response = $client->generateSecuredApiKey(\n    '2640659426d5107b6e47d75db9cbaef8',\n    ['validUntil' => 2524604400,\n        'restrictIndices' => [\n            'Movies',\n        ],\n    ],\n);",
      "with searchParams": "$response = $client->generateSecuredApiKey(\n    '2640659426d5107b6e47d75db9cbaef8',\n    ['validUntil' => 2524604400,\n        'restrictIndices' => [\n            'Movies',\n\n            'cts_e2e_settings',\n        ],\n        'restrictSources' => '192.168.1.0/24',\n        'filters' => 'category:Book OR category:Ebook AND _tags:published',\n        'userToken' => 'user123',\n        'searchParams' => ['query' => 'batman',\n            'typoTolerance' => 'strict',\n            'aroundRadius' => 'all',\n            'mode' => 'neuralSearch',\n            'hitsPerPage' => 10,\n            'optionalWords' => [\n                'one',\n\n                'two',\n            ],\n        ],\n    ],\n);",
      "with filters": "$response = $client->generateSecuredApiKey(\n    '2640659426d5107b6e47d75db9cbaef8',\n    ['filters' => 'user:user42 AND user:public AND (visible_by:John OR visible_by:group/Finance)',\n    ],\n);",
      "with visible_by filter": "$response = $client->generateSecuredApiKey(\n    '2640659426d5107b6e47d75db9cbaef8',\n    ['filters' => 'visible_by:group/Finance',\n    ],\n);",
      "with userID": "$response = $client->generateSecuredApiKey(\n    '2640659426d5107b6e47d75db9cbaef8',\n    ['userToken' => 'user42',\n    ],\n);",
      "mcm with filters": "$response = $client->generateSecuredApiKey(\n    'YourSearchOnlyApiKey',\n    ['filters' => 'user:user42 AND user:public',\n    ],\n);",
      "mcm with user token": "$response = $client->generateSecuredApiKey(\n    'YourSearchOnlyApiKey',\n    ['userToken' => 'user42',\n    ],\n);"
    },
    "getApiKey": {
      "default": "$response = $client->getApiKey(\n    'myTestApiKey',\n);"
    },
    "getAppTask": {
      "default": "$response = $client->getAppTask(\n    123,\n);"
    },
    "getDictionaryLanguages": {
      "default": "$response = $client->getDictionaryLanguages();"
    },
    "getDictionarySettings": {
      "default": "$response = $client->getDictionarySettings();"
    },
    "getLogs": {
      "getLogs with minimal parameters": "$response = $client->getLogs();",
      "getLogs with parameters": "$response = $client->getLogs(\n    5,\n    10,\n    '<YOUR_INDEX_NAME>',\n    'all',\n);"
    },
    "getObject": {
      "getObject": "$response = $client->getObject(\n    '<YOUR_INDEX_NAME>',\n    'uniqueID',\n    [\n        'attr1',\n\n        'attr2',\n    ],\n);",
      "search with a real object": "$response = $client->getObject(\n    '<YOUR_INDEX_NAME>',\n    'Batman and Robin',\n);"
    },
    "getObjects": {
      "by ID": "$response = $client->getObjects(\n    ['requests' => [\n        ['objectID' => 'uniqueID',\n            'indexName' => '<YOUR_INDEX_NAME>',\n        ],\n    ],\n    ],\n);",
      "multiple IDs": "$response = $client->getObjects(\n    ['requests' => [\n        ['objectID' => 'uniqueID1',\n            'indexName' => '<YOUR_INDEX_NAME>',\n        ],\n\n        ['objectID' => 'uniqueID2',\n            'indexName' => '<YOUR_INDEX_NAME>',\n        ],\n    ],\n    ],\n);",
      "with attributesToRetrieve": "$response = $client->getObjects(\n    ['requests' => [\n        ['attributesToRetrieve' => [\n            'attr1',\n\n            'attr2',\n        ],\n            'objectID' => 'uniqueID',\n            'indexName' => '<YOUR_INDEX_NAME>',\n        ],\n    ],\n    ],\n);"
    },
    "getRule": {
      "default": "$response = $client->getRule(\n    '<YOUR_INDEX_NAME>',\n    'qr-1725004648916',\n);"
    },
    "getSettings": {
      "default": "$response = $client->getSettings(\n    '<YOUR_INDEX_NAME>',\n);"
    },
    "getSources": {
      "default": "$response = $client->getSources();"
    },
    "getSynonym": {
      "default": "$response = $client->getSynonym(\n    '<YOUR_INDEX_NAME>',\n    'id1',\n);"
    },
    "getTask": {
      "default": "$response = $client->getTask(\n    '<YOUR_INDEX_NAME>',\n    123,\n);"
    },
    "getTopUserIds": {
      "default": "$response = $client->getTopUserIds();"
    },
    "getUserId": {
      "default": "$response = $client->getUserId(\n    'uniqueID',\n);"
    },
    "hasPendingMappings": {
      "hasPendingMappings with minimal parameters": "$response = $client->hasPendingMappings();",
      "hasPendingMappings with parameters": "$response = $client->hasPendingMappings(\n    true,\n);"
    },
    "indexExists": {
      "indexExists": "$response = $client->indexExists(\n    '<YOUR_INDEX_NAME>',\n);",
      "indexNotExists": "$response = $client->indexExists(\n    '<YOUR_INDEX_NAME>',\n);",
      "indexExistsWithError": "$response = $client->indexExists(\n    '<YOUR_INDEX_NAME>',\n);"
    },
    "listApiKeys": {
      "default": "$response = $client->listApiKeys();"
    },
    "listClusters": {
      "default": "$response = $client->listClusters();"
    },
    "listIndices": {
      "listIndices with minimal parameters": "$response = $client->listIndices();",
      "listIndices with parameters": "$response = $client->listIndices(\n    8,\n    3,\n);"
    },
    "listUserIds": {
      "listUserIds with minimal parameters": "$response = $client->listUserIds();",
      "listUserIds with parameters": "$response = $client->listUserIds(\n    8,\n    100,\n);"
    },
    "multipleBatch": {
      "default": "$response = $client->multipleBatch(\n    ['requests' => [\n        ['action' => 'addObject',\n            'body' => ['key' => 'value',\n            ],\n            'indexName' => '<YOUR_INDEX_NAME>',\n        ],\n    ],\n    ],\n);"
    },
    "operationIndex": {
      "scopes": "$response = $client->operationIndex(\n    '<SOURCE_INDEX_NAME>',\n    ['operation' => 'move',\n        'destination' => '<DESTINATION_INDEX_NAME>',\n        'scope' => [\n            'rules',\n\n            'settings',\n        ],\n    ],\n);",
      "copy": "$response = $client->operationIndex(\n    '<SOURCE_INDEX_NAME>',\n    ['operation' => 'copy',\n        'destination' => '<DESTINATION_INDEX_NAME>',\n    ],\n);",
      "move": "$response = $client->operationIndex(\n    '<SOURCE_INDEX_NAME>',\n    ['operation' => 'move',\n        'destination' => '<DESTINATION_INDEX_NAME>',\n    ],\n);"
    },
    "partialUpdateObject": {
      "Partial update with a new value for a string attribute": "$response = $client->partialUpdateObject(\n    '<YOUR_INDEX_NAME>',\n    'uniqueID',\n    ['attributeId' => 'new value',\n    ],\n);",
      "Partial update with a new value for an integer attribute": "$response = $client->partialUpdateObject(\n    '<YOUR_INDEX_NAME>',\n    'uniqueID',\n    ['attributeId' => 1,\n    ],\n);",
      "Partial update with a new value for a boolean attribute": "$response = $client->partialUpdateObject(\n    '<YOUR_INDEX_NAME>',\n    'uniqueID',\n    ['attributeId' => true,\n    ],\n);",
      "Partial update with a new value for an array attribute": "$response = $client->partialUpdateObject(\n    '<YOUR_INDEX_NAME>',\n    'uniqueID',\n    ['attributeId' => [\n        'one',\n\n        'two',\n\n        'three',\n    ],\n    ],\n);",
      "Partial update with a new value for an object attribute": "$response = $client->partialUpdateObject(\n    '<YOUR_INDEX_NAME>',\n    'uniqueID',\n    ['attributeId' => ['nested' => 'value',\n    ],\n    ],\n);",
      "with visible_by filter": "$response = $client->partialUpdateObject(\n    '<YOUR_INDEX_NAME>',\n    'uniqueID',\n    ['visible_by' => [\n        'Angela',\n\n        'group/Finance',\n\n        'group/Shareholders',\n    ],\n    ],\n);",
      "add men pant": "$response = $client->partialUpdateObject(\n    '<YOUR_INDEX_NAME>',\n    'productId',\n    ['categoryPageId' => ['_operation' => 'Add',\n        'value' => 'men-clothing-pants',\n    ],\n    ],\n);",
      "remove men pant": "$response = $client->partialUpdateObject(\n    '<YOUR_INDEX_NAME>',\n    'productId',\n    ['categoryPageId' => ['_operation' => 'Remove',\n        'value' => 'men-clothing-pants',\n    ],\n    ],\n);"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "$response = $client->partialUpdateObjects(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => '1',\n            'name' => 'Adam',\n        ],\n\n        ['objectID' => '2',\n            'name' => 'Benoit',\n        ],\n    ],\n    true,\n);",
      "call partialUpdateObjects with createIfNotExists=false": "$response = $client->partialUpdateObjects(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => '3',\n            'name' => 'Cyril',\n        ],\n\n        ['objectID' => '4',\n            'name' => 'David',\n        ],\n    ],\n    false,\n);"
    },
    "removeUserId": {
      "default": "$response = $client->removeUserId(\n    'uniqueID',\n);"
    },
    "replaceAllObjects": {
      "call replaceAllObjects without error": "$response = $client->replaceAllObjects(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => '1',\n            'name' => 'Adam',\n        ],\n\n        ['objectID' => '2',\n            'name' => 'Benoit',\n        ],\n\n        ['objectID' => '3',\n            'name' => 'Cyril',\n        ],\n\n        ['objectID' => '4',\n            'name' => 'David',\n        ],\n\n        ['objectID' => '5',\n            'name' => 'Eva',\n        ],\n\n        ['objectID' => '6',\n            'name' => 'Fiona',\n        ],\n\n        ['objectID' => '7',\n            'name' => 'Gael',\n        ],\n\n        ['objectID' => '8',\n            'name' => 'Hugo',\n        ],\n\n        ['objectID' => '9',\n            'name' => 'Igor',\n        ],\n\n        ['objectID' => '10',\n            'name' => 'Julia',\n        ],\n    ],\n    3,\n);",
      "call replaceAllObjects with partial scopes": "$response = $client->replaceAllObjects(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => '1',\n            'name' => 'Adam',\n        ],\n\n        ['objectID' => '2',\n            'name' => 'Benoit',\n        ],\n    ],\n    77,\n    [\n        'settings',\n\n        'synonyms',\n    ],\n);",
      "replaceAllObjects should cleanup on failure": "$response = $client->replaceAllObjects(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => 'fine',\n            'body' => 'small obj',\n        ],\n\n        ['objectID' => 'toolarge',\n            'body' => 'something bigger than 10KB',\n        ],\n    ],\n);"
    },
    "replaceSources": {
      "default": "$response = $client->replaceSources(\n    [\n        ['source' => 'theSource',\n            'description' => 'theDescription',\n        ],\n    ],\n);"
    },
    "restoreApiKey": {
      "default": "$response = $client->restoreApiKey(\n    'ALGOLIA_API_KEY',\n);"
    },
    "saveObject": {
      "default": "$response = $client->saveObject(\n    '<YOUR_INDEX_NAME>',\n    ['name' => 'Black T-shirt',\n        'color' => '#000000||black',\n        'availableIn' => 'https://source.unsplash.com/100x100/?paris||Paris',\n        'objectID' => 'myID',\n    ],\n);"
    },
    "saveObjects": {
      "call saveObjects without error": "$response = $client->saveObjects(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => '1',\n            'name' => 'Adam',\n        ],\n\n        ['objectID' => '2',\n            'name' => 'Benoit',\n        ],\n    ],\n);",
      "saveObjects should report errors": "$response = $client->saveObjects(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => '1',\n            'name' => 'Adam',\n        ],\n\n        ['objectID' => '2',\n            'name' => 'Benoit',\n        ],\n    ],\n);",
      "saveObjectsPlaylist": "$response = $client->saveObjects(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => '1',\n            'visibility' => 'public',\n            'name' => 'Hot 100 Billboard Charts',\n            'playlistId' => 'd3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f',\n            'createdAt' => '1500240452',\n        ],\n    ],\n);",
      "saveObjectsPublicUser": "$response = $client->saveObjects(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => '1',\n            'visibility' => 'public',\n            'name' => 'Hot 100 Billboard Charts',\n            'playlistId' => 'd3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f',\n            'createdAt' => '1500240452',\n        ],\n    ],\n    false,\n    1000,\n    [\n        'headers' => [\n            'X-Algolia-User-ID' => '*',\n        ],\n    ]\n);"
    },
    "saveRule": {
      "saveRule with minimal parameters": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'id1',\n    ['objectID' => 'id1',\n        'conditions' => [\n            ['pattern' => 'apple',\n                'anchoring' => 'contains',\n            ],\n        ],\n        'consequence' => ['params' => ['filters' => 'brand:xiaomi',\n        ],\n        ],\n    ],\n);",
      "saveRule with all parameters": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'id1',\n    ['objectID' => 'id1',\n        'conditions' => [\n            ['pattern' => 'apple',\n                'anchoring' => 'contains',\n                'alternatives' => false,\n                'context' => 'search',\n            ],\n        ],\n        'consequence' => ['params' => ['filters' => 'brand:apple',\n            'query' => ['remove' => [\n                'algolia',\n            ],\n                'edits' => [\n                    ['type' => 'remove',\n                        'delete' => 'abc',\n                        'insert' => 'cde',\n                    ],\n\n                    ['type' => 'replace',\n                        'delete' => 'abc',\n                        'insert' => 'cde',\n                    ],\n                ],\n            ],\n        ],\n            'hide' => [\n                ['objectID' => '321',\n                ],\n            ],\n            'filterPromotes' => false,\n            'userData' => ['algolia' => 'aloglia',\n            ],\n            'promote' => [\n                ['objectID' => 'abc',\n                    'position' => 3,\n                ],\n\n                ['objectIDs' => [\n                    'abc',\n\n                    'def',\n                ],\n                    'position' => 1,\n                ],\n            ],\n        ],\n        'description' => 'test',\n        'enabled' => true,\n        'validity' => [\n            ['from' => 1656670273,\n                'until' => 1656670277,\n            ],\n        ],\n    ],\n    true,\n);",
      "b2b catalog": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'article-rule',\n    ['objectID' => 'article-rule',\n        'conditions' => [\n            ['pattern' => 'article',\n                'anchoring' => 'startsWith',\n            ],\n        ],\n        'consequence' => ['params' => ['query' => ['edits' => [\n            ['type' => 'remove',\n                'delete' => 'article',\n            ],\n        ],\n        ],\n            'restrictSearchableAttributes' => [\n                'title',\n\n                'book_id',\n            ],\n        ],\n        ],\n    ],\n);",
      "merchandising and promoting": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'director-rule',\n    ['objectID' => 'director-rule',\n        'conditions' => [\n            ['pattern' => '{facet:director} director',\n                'anchoring' => 'contains',\n            ],\n        ],\n        'consequence' => ['params' => ['restrictSearchableAttributes' => [\n            'title',\n\n            'book_id',\n        ],\n            'automaticFacetFilters' => [\n                ['facet' => 'director',\n                ],\n            ],\n            'query' => ['edits' => [\n                ['type' => 'remove',\n                    'delete' => 'director',\n                ],\n            ],\n            ],\n        ],\n        ],\n    ],\n);",
      "harry potter": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'harry-potter-rule',\n    ['objectID' => 'harry-potter-rule',\n        'conditions' => [\n            ['pattern' => 'harry potter',\n                'anchoring' => 'contains',\n            ],\n        ],\n        'consequence' => ['userData' => ['promo_content' => '20% OFF on all Harry Potter books!',\n        ],\n        ],\n    ],\n);",
      "merchandising empty query": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'clearance-category-filter',\n    ['objectID' => 'clearance-category-filter',\n        'conditions' => [\n            ['pattern' => '',\n                'anchoring' => 'is',\n                'context' => 'landing',\n            ],\n        ],\n        'consequence' => ['params' => ['optionalFilters' => 'clearance:true',\n        ],\n        ],\n    ],\n);",
      "redirect": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'redirect-help-rule',\n    ['objectID' => 'redirect-help-rule',\n        'conditions' => [\n            ['pattern' => 'help',\n                'anchoring' => 'contains',\n            ],\n        ],\n        'consequence' => ['userData' => ['redirect' => 'https://www.algolia.com/support',\n        ],\n        ],\n    ],\n);",
      "promote some results over others": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'tomato-fruit',\n    ['objectID' => 'tomato-fruit',\n        'conditions' => [\n            ['pattern' => 'tomato',\n                'anchoring' => 'contains',\n            ],\n        ],\n        'consequence' => ['params' => ['optionalFilters' => 'food_group:fruit',\n        ],\n        ],\n    ],\n);",
      "promote several hits": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'Promote-Apple-Newest',\n    ['objectID' => 'Promote-Apple-Newest',\n        'conditions' => [\n            ['pattern' => 'apple',\n                'anchoring' => 'is',\n            ],\n        ],\n        'consequence' => ['promote' => [\n            ['objectIDs' => [\n                'iPhone-12345',\n\n                'watch-123',\n            ],\n                'position' => 0,\n            ],\n        ],\n        ],\n    ],\n);",
      "promote newest release": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'Promote-iPhone-X',\n    ['objectID' => 'Promote-iPhone-X',\n        'conditions' => [\n            ['pattern' => 'iPhone',\n                'anchoring' => 'contains',\n            ],\n        ],\n        'consequence' => ['promote' => [\n            ['objectID' => 'iPhone-12345',\n                'position' => 0,\n            ],\n        ],\n        ],\n    ],\n);",
      "promote single item": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'promote-harry-potter-box-set',\n    ['objectID' => 'promote-harry-potter-box-set',\n        'conditions' => [\n            ['pattern' => 'Harry Potter',\n                'anchoring' => 'contains',\n            ],\n        ],\n        'consequence' => ['promote' => [\n            ['objectID' => 'HP-12345',\n                'position' => 0,\n            ],\n        ],\n        ],\n    ],\n);",
      "limit search results": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'article-rule',\n    ['objectID' => 'article-rule',\n        'conditions' => [\n            ['pattern' => 'article',\n                'anchoring' => 'startsWith',\n            ],\n        ],\n        'consequence' => ['params' => ['query' => ['edits' => [\n            ['type' => 'remove',\n                'delete' => 'article',\n            ],\n        ],\n        ],\n            'restrictSearchableAttributes' => [\n                'title',\n\n                'book_id',\n            ],\n        ],\n        ],\n    ],\n);",
      "query match": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'tagged-brand-rule',\n    ['conditions' => [\n        ['pattern' => 'brand: {facet:brand}',\n            'anchoring' => 'contains',\n            'alternatives' => false,\n        ],\n    ],\n        'consequence' => ['params' => ['automaticFacetFilters' => [\n            ['facet' => 'brand',\n            ],\n        ],\n            'query' => ['remove' => [\n                'brand:',\n\n                '{facet:brand}',\n            ],\n            ],\n        ],\n        ],\n        'description' => 'filter on brand: {brand}',\n        'objectID' => 'tagged-brand-rule',\n    ],\n);",
      "dynamic filtering": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'color-facets',\n    ['objectID' => 'color-facets',\n        'conditions' => [\n            ['pattern' => '{facet:color}',\n            ],\n        ],\n        'consequence' => ['params' => ['automaticFacetFilters' => [\n            ['facet' => 'color',\n            ],\n        ],\n        ],\n        ],\n    ],\n);",
      "hide hits": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'hide-12345',\n    ['objectID' => 'hide-12345',\n        'conditions' => [\n            ['pattern' => 'cheap',\n                'anchoring' => 'contains',\n            ],\n        ],\n        'consequence' => ['hide' => [\n            ['objectID' => 'to-hide-12345',\n            ],\n        ],\n        ],\n    ],\n);",
      "one rule per facet": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'red-color',\n    ['objectID' => 'red-color',\n        'conditions' => [\n            ['pattern' => 'red',\n                'anchoring' => 'contains',\n            ],\n        ],\n        'consequence' => ['params' => ['query' => ['remove' => [\n            'red',\n        ],\n        ],\n            'filters' => 'color:red',\n        ],\n        ],\n    ],\n);",
      "numerical filters": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'cheap',\n    ['objectID' => 'cheap',\n        'conditions' => [\n            ['pattern' => 'cheap',\n                'anchoring' => 'contains',\n            ],\n        ],\n        'consequence' => ['params' => ['query' => ['remove' => [\n            'cheap',\n        ],\n        ],\n            'filters' => 'price < 10',\n        ],\n        ],\n    ],\n);",
      "negative filters": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'gluten-free-rule',\n    ['objectID' => 'gluten-free-rule',\n        'conditions' => [\n            ['pattern' => 'gluten-free',\n                'anchoring' => 'contains',\n            ],\n        ],\n        'consequence' => ['params' => ['filters' => 'NOT allergens:gluten',\n            'query' => ['edits' => [\n                ['type' => 'remove',\n                    'delete' => 'gluten-free',\n                ],\n            ],\n            ],\n        ],\n        ],\n    ],\n);",
      "positive filters": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'diet-rule',\n    ['objectID' => 'diet-rule',\n        'conditions' => [\n            ['pattern' => 'diet',\n                'anchoring' => 'contains',\n            ],\n        ],\n        'consequence' => ['params' => ['filters' => \"'low-carb' OR 'low-fat'\",\n            'query' => ['edits' => [\n                ['type' => 'remove',\n                    'delete' => 'diet',\n                ],\n            ],\n            ],\n        ],\n        ],\n    ],\n);",
      "conditionless": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'diet-rule',\n    ['objectID' => 'diet-rule',\n        'consequence' => ['params' => ['filters' => \"'low-carb' OR 'low-fat'\",\n            'query' => ['edits' => [\n                ['type' => 'remove',\n                    'delete' => 'diet',\n                ],\n            ],\n            ],\n        ],\n        ],\n    ],\n);",
      "contextual": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'a-rule-id',\n    ['objectID' => 'a-rule-id',\n        'conditions' => [\n            ['context' => 'mobile',\n            ],\n        ],\n        'consequence' => ['params' => ['filters' => 'release_date >= 1577836800',\n        ],\n        ],\n    ],\n);",
      "saveRule always active rule": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'a-rule-id',\n    ['objectID' => 'a-rule-id',\n        'consequence' => ['params' => ['aroundRadius' => 1000,\n        ],\n        ],\n        'validity' => [\n            ['from' => 1577836800,\n                'until' => 1577836800,\n            ],\n        ],\n    ],\n);"
    },
    "saveRules": {
      "saveRules with minimal parameters": "$response = $client->saveRules(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => 'a-rule-id',\n            'conditions' => [\n                ['pattern' => 'smartphone',\n                    'anchoring' => 'contains',\n                ],\n            ],\n            'consequence' => ['params' => ['filters' => 'brand:apple',\n            ],\n            ],\n        ],\n\n        ['objectID' => 'a-second-rule-id',\n            'conditions' => [\n                ['pattern' => 'apple',\n                    'anchoring' => 'contains',\n                ],\n            ],\n            'consequence' => ['params' => ['filters' => 'brand:samsung',\n            ],\n            ],\n        ],\n    ],\n    false,\n    true,\n);",
      "saveRules with all parameters": "$response = $client->saveRules(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => 'id1',\n            'conditions' => [\n                ['pattern' => 'apple',\n                    'anchoring' => 'contains',\n                    'alternatives' => false,\n                    'context' => 'search',\n                ],\n            ],\n            'consequence' => ['params' => ['filters' => 'brand:apple',\n                'query' => ['remove' => [\n                    'algolia',\n                ],\n                    'edits' => [\n                        ['type' => 'remove',\n                            'delete' => 'abc',\n                            'insert' => 'cde',\n                        ],\n\n                        ['type' => 'replace',\n                            'delete' => 'abc',\n                            'insert' => 'cde',\n                        ],\n                    ],\n                ],\n            ],\n                'hide' => [\n                    ['objectID' => '321',\n                    ],\n                ],\n                'filterPromotes' => false,\n                'userData' => ['algolia' => 'aloglia',\n                ],\n                'promote' => [\n                    ['objectID' => 'abc',\n                        'position' => 3,\n                    ],\n\n                    ['objectIDs' => [\n                        'abc',\n\n                        'def',\n                    ],\n                        'position' => 1,\n                    ],\n                ],\n            ],\n            'description' => 'test',\n            'enabled' => true,\n            'validity' => [\n                ['from' => 1656670273,\n                    'until' => 1656670277,\n                ],\n            ],\n        ],\n    ],\n    true,\n    true,\n);",
      "dynamic filtering": "$response = $client->saveRules(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => 'toaster',\n            'conditions' => [\n                ['pattern' => 'toaster',\n                    'anchoring' => 'contains',\n                ],\n            ],\n            'consequence' => ['params' => ['query' => ['remove' => [\n                'toaster',\n            ],\n            ],\n                'filters' => 'product_type:toaster',\n            ],\n            ],\n        ],\n\n        ['objectID' => 'cheap',\n            'conditions' => [\n                ['pattern' => 'cheap',\n                    'anchoring' => 'contains',\n                ],\n            ],\n            'consequence' => ['params' => ['query' => ['remove' => [\n                'cheap',\n            ],\n            ],\n                'filters' => 'price < 15',\n            ],\n            ],\n        ],\n    ],\n);",
      "enhance search results": "$response = $client->saveRules(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => 'country',\n            'conditions' => [\n                ['pattern' => '{facet:country}',\n                    'anchoring' => 'contains',\n                ],\n            ],\n            'consequence' => ['params' => ['aroundLatLngViaIP' => false,\n            ],\n            ],\n        ],\n\n        ['objectID' => 'city',\n            'conditions' => [\n                ['pattern' => '{facet:city}',\n                    'anchoring' => 'contains',\n                ],\n            ],\n            'consequence' => ['params' => ['aroundLatLngViaIP' => false,\n            ],\n            ],\n        ],\n    ],\n);"
    },
    "saveSynonym": {
      "default": "$response = $client->saveSynonym(\n    '<YOUR_INDEX_NAME>',\n    'id1',\n    ['objectID' => 'id1',\n        'type' => 'synonym',\n        'synonyms' => [\n            'car',\n\n            'vehicule',\n\n            'auto',\n        ],\n    ],\n    true,\n);"
    },
    "saveSynonyms": {
      "default": "$response = $client->saveSynonyms(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => 'id1',\n            'type' => 'synonym',\n            'synonyms' => [\n                'car',\n\n                'vehicule',\n\n                'auto',\n            ],\n        ],\n\n        ['objectID' => 'id2',\n            'type' => 'onewaysynonym',\n            'input' => 'iphone',\n            'synonyms' => [\n                'ephone',\n\n                'aphone',\n\n                'yphone',\n            ],\n        ],\n    ],\n    true,\n    true,\n);"
    },
    "search": {
      "withHitsPerPage": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'query' => '<YOUR_QUERY>',\n            'hitsPerPage' => 50,\n        ],\n    ],\n    ],\n);",
      "filterOnly": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'query' => '<YOUR_QUERY>',\n            'filters' => 'actor:Scarlett Johansson',\n        ],\n    ],\n    ],\n);",
      "filterOr": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'query' => '<YOUR_QUERY>',\n            'filters' => 'actor:Tom Cruise OR actor:Scarlett Johansson',\n        ],\n    ],\n    ],\n);",
      "filterNot": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'query' => '<YOUR_QUERY>',\n            'filters' => 'NOT actor:Nicolas Cage',\n        ],\n    ],\n    ],\n);",
      "search for a single hits request with minimal parameters": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n        ],\n    ],\n    ],\n);",
      "search with highlight and snippet results": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'query' => 'vim',\n            'attributesToSnippet' => [\n                '*:20',\n            ],\n            'attributesToHighlight' => [\n                '*',\n            ],\n            'attributesToRetrieve' => [\n                '*',\n            ],\n        ],\n    ],\n    ],\n);",
      "retrieveFacets": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'query' => '<YOUR_QUERY>',\n            'facets' => [\n                'author',\n\n                'genre',\n            ],\n        ],\n    ],\n    ],\n);",
      "retrieveFacetsWildcard": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'query' => '<YOUR_QUERY>',\n            'facets' => [\n                '*',\n            ],\n        ],\n    ],\n    ],\n);",
      "search for a single facet request with minimal parameters": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'type' => 'facet',\n            'facet' => 'editor',\n        ],\n    ],\n        'strategy' => 'stopIfEnoughMatches',\n    ],\n);",
      "search for a single hits request with all parameters": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'query' => 'myQuery',\n            'hitsPerPage' => 50,\n            'type' => 'default',\n        ],\n    ],\n    ],\n);",
      "search for a single facet request with all parameters": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'type' => 'facet',\n            'facet' => 'theFacet',\n            'facetQuery' => 'theFacetQuery',\n            'query' => 'theQuery',\n            'maxFacetHits' => 50,\n        ],\n    ],\n        'strategy' => 'stopIfEnoughMatches',\n    ],\n);",
      "search for multiple mixed requests in multiple indices with minimal parameters": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n        ],\n\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'type' => 'facet',\n            'facet' => 'theFacet',\n        ],\n\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'type' => 'default',\n        ],\n    ],\n        'strategy' => 'stopIfEnoughMatches',\n    ],\n);",
      "search for multiple mixed requests in multiple indices with all parameters": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'type' => 'facet',\n            'facet' => 'theFacet',\n            'facetQuery' => 'theFacetQuery',\n            'query' => 'theQuery',\n            'maxFacetHits' => 50,\n        ],\n\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'query' => 'myQuery',\n            'hitsPerPage' => 50,\n            'type' => 'default',\n        ],\n    ],\n        'strategy' => 'stopIfEnoughMatches',\n    ],\n);",
      "search filters accept all of the possible shapes": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'facetFilters' => 'mySearch:filters',\n            'reRankingApplyFilter' => 'mySearch:filters',\n            'tagFilters' => 'mySearch:filters',\n            'numericFilters' => 'mySearch:filters',\n            'optionalFilters' => 'mySearch:filters',\n        ],\n\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'facetFilters' => [\n                'mySearch:filters',\n\n                [\n                    'mySearch:filters',\n\n                    [\n                        'mySearch:filters',\n                    ],\n                ],\n            ],\n            'reRankingApplyFilter' => [\n                'mySearch:filters',\n\n                [\n                    'mySearch:filters',\n                ],\n            ],\n            'tagFilters' => [\n                'mySearch:filters',\n\n                [\n                    'mySearch:filters',\n                ],\n            ],\n            'numericFilters' => [\n                'mySearch:filters',\n\n                [\n                    'mySearch:filters',\n                ],\n            ],\n            'optionalFilters' => [\n                'mySearch:filters',\n\n                [\n                    'mySearch:filters',\n                ],\n            ],\n        ],\n    ],\n    ],\n);",
      "search filters end to end": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'filters' => \"editor:'visual studio' OR editor:neovim\",\n        ],\n\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'facetFilters' => [\n                \"editor:'visual studio'\",\n\n                'editor:neovim',\n            ],\n        ],\n\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'facetFilters' => [\n                \"editor:'visual studio'\",\n\n                [\n                    'editor:neovim',\n                ],\n            ],\n        ],\n\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'facetFilters' => [\n                \"editor:'visual studio'\",\n\n                [\n                    'editor:neovim',\n\n                    [\n                        'editor:goland',\n                    ],\n                ],\n            ],\n        ],\n    ],\n    ],\n);",
      "search with all search parameters": "$response = $client->search(\n    ['requests' => [\n        ['advancedSyntax' => true,\n            'advancedSyntaxFeatures' => [\n                'exactPhrase',\n            ],\n            'allowTyposOnNumericTokens' => true,\n            'alternativesAsExact' => [\n                'multiWordsSynonym',\n            ],\n            'analytics' => true,\n            'analyticsTags' => [\n                '',\n            ],\n            'aroundLatLng' => '',\n            'aroundLatLngViaIP' => true,\n            'aroundPrecision' => 0,\n            'aroundRadius' => 'all',\n            'attributeCriteriaComputedByMinProximity' => true,\n            'attributesToHighlight' => [\n                '',\n            ],\n            'attributesToRetrieve' => [\n                '',\n            ],\n            'attributesToSnippet' => [\n                '',\n            ],\n            'clickAnalytics' => true,\n            'decompoundQuery' => true,\n            'disableExactOnAttributes' => [\n                '',\n            ],\n            'disableTypoToleranceOnAttributes' => [\n                '',\n            ],\n            'distinct' => 0,\n            'enableABTest' => true,\n            'enablePersonalization' => true,\n            'enableReRanking' => true,\n            'enableRules' => true,\n            'exactOnSingleWordQuery' => 'attribute',\n            'facetFilters' => [\n                '',\n            ],\n            'facetingAfterDistinct' => true,\n            'facets' => [\n                '',\n            ],\n            'filters' => '',\n            'getRankingInfo' => true,\n            'highlightPostTag' => '',\n            'highlightPreTag' => '',\n            'hitsPerPage' => 1,\n            'ignorePlurals' => false,\n            'indexName' => '<YOUR_INDEX_NAME>',\n            'insideBoundingBox' => [\n                [\n                    47.3165,\n\n                    4.9665,\n\n                    47.3424,\n\n                    5.0201,\n                ],\n\n                [\n                    40.9234,\n\n                    2.1185,\n\n                    38.643,\n\n                    1.9916,\n                ],\n            ],\n            'insidePolygon' => [\n                [\n                    47.3165,\n\n                    4.9665,\n\n                    47.3424,\n\n                    5.0201,\n\n                    47.32,\n\n                    4.9,\n                ],\n\n                [\n                    40.9234,\n\n                    2.1185,\n\n                    38.643,\n\n                    1.9916,\n\n                    39.2587,\n\n                    2.0104,\n                ],\n            ],\n            'length' => 1,\n            'maxValuesPerFacet' => 0,\n            'minProximity' => 1,\n            'minWordSizefor1Typo' => 0,\n            'minWordSizefor2Typos' => 0,\n            'minimumAroundRadius' => 1,\n            'naturalLanguages' => [\n                'fr',\n            ],\n            'numericFilters' => [\n                '',\n            ],\n            'offset' => 0,\n            'optionalFilters' => [\n                '',\n            ],\n            'optionalWords' => [\n                '',\n            ],\n            'page' => 0,\n            'percentileComputation' => true,\n            'personalizationImpact' => 0,\n            'query' => '',\n            'queryLanguages' => [\n                'fr',\n            ],\n            'queryType' => 'prefixAll',\n            'ranking' => [\n                '',\n            ],\n            'reRankingApplyFilter' => [\n                '',\n            ],\n            'relevancyStrictness' => 0,\n            'removeStopWords' => true,\n            'removeWordsIfNoResults' => 'allOptional',\n            'renderingContent' => ['facetOrdering' => ['facets' => ['order' => [\n                'a',\n\n                'b',\n            ],\n            ],\n                'values' => ['a' => ['order' => [\n                    'b',\n                ],\n                    'sortRemainingBy' => 'count',\n                ],\n                ],\n            ],\n            ],\n            'replaceSynonymsInHighlight' => true,\n            'responseFields' => [\n                '',\n            ],\n            'restrictHighlightAndSnippetArrays' => true,\n            'restrictSearchableAttributes' => [\n                '',\n            ],\n            'ruleContexts' => [\n                '',\n            ],\n            'similarQuery' => '',\n            'snippetEllipsisText' => '',\n            'sortFacetValuesBy' => '',\n            'sumOrFiltersScores' => true,\n            'synonyms' => true,\n            'tagFilters' => [\n                '',\n            ],\n            'type' => 'default',\n            'typoTolerance' => 'min',\n            'userToken' => '',\n        ],\n    ],\n    ],\n);"
    },
    "searchDictionaryEntries": {
      "get searchDictionaryEntries results with minimal parameters": "$response = $client->searchDictionaryEntries(\n    'stopwords',\n    ['query' => 'about',\n    ],\n);",
      "get searchDictionaryEntries results with all parameters": "$response = $client->searchDictionaryEntries(\n    'compounds',\n    ['query' => 'foo',\n        'page' => 4,\n        'hitsPerPage' => 2,\n        'language' => 'fr',\n    ],\n);"
    },
    "searchForFacetValues": {
      "get searchForFacetValues results with minimal parameters": "$response = $client->searchForFacetValues(\n    '<YOUR_INDEX_NAME>',\n    'facetName',\n);",
      "get searchForFacetValues results with all parameters": "$response = $client->searchForFacetValues(\n    '<YOUR_INDEX_NAME>',\n    'facetName',\n    ['params' => \"query=foo&facetFilters=['bar']\",\n        'facetQuery' => 'foo',\n        'maxFacetHits' => 42,\n    ],\n);",
      "facetName and facetQuery": "$response = $client->searchForFacetValues(\n    '<YOUR_INDEX_NAME>',\n    'author',\n    ['facetQuery' => 'stephen',\n    ],\n);"
    },
    "searchRules": {
      "default": "$response = $client->searchRules(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'zorro',\n    ],\n);"
    },
    "searchSingleIndex": {
      "search with minimal parameters": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n);",
      "search with special characters in indexName": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n);",
      "search with searchParams": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'myQuery',\n        'facetFilters' => [\n            'tags:algolia',\n        ],\n    ],\n);",
      "single search retrieve snippets": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'batman mask of the phantasm',\n        'attributesToRetrieve' => [\n            '*',\n        ],\n        'attributesToSnippet' => [\n            '*:20',\n        ],\n    ],\n);",
      "query": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'phone',\n    ],\n);",
      "filters": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['filters' => 'country:US AND price.gross < 2.0',\n    ],\n);",
      "filters for stores": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'ben',\n        'filters' => 'categories:politics AND store:Gibert Joseph Saint-Michel',\n    ],\n);",
      "filters boolean": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['filters' => 'is_available:true',\n    ],\n);",
      "distinct": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['distinct' => true,\n    ],\n);",
      "filtersNumeric": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['filters' => 'price < 10',\n    ],\n);",
      "filtersTimestamp": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['filters' => 'NOT date_timestamp:1514764800 TO 1546300799',\n    ],\n);",
      "filtersSumOrFiltersScoresFalse": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['filters' => '(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)',\n        'sumOrFiltersScores' => false,\n    ],\n);",
      "filtersSumOrFiltersScoresTrue": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['filters' => '(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)',\n        'sumOrFiltersScores' => true,\n    ],\n);",
      "filtersStephenKing": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['filters' => 'author:\"Stephen King\"',\n    ],\n);",
      "filtersNotTags": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'harry',\n        'filters' => '_tags:non-fiction',\n    ],\n);",
      "facetFiltersList": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['facetFilters' => [\n        'publisher:Penguin',\n\n        [\n            'author:Stephen King',\n\n            'genre:Horror',\n        ],\n    ],\n    ],\n);",
      "facetFiltersBook": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'facetFilters' => [\n            'category:Book',\n        ],\n    ],\n);",
      "facetFiltersAND": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'facetFilters' => [\n            'category:Book',\n\n            'author:John Doe',\n        ],\n    ],\n);",
      "facetFiltersOR": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'facetFilters' => [\n            [\n                'category:Book',\n\n                'author:John Doe',\n            ],\n        ],\n    ],\n);",
      "facetFiltersCombined": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'facetFilters' => [\n            'author:John Doe',\n\n            [\n                'category:Book',\n\n                'category:Movie',\n            ],\n        ],\n    ],\n);",
      "facetFiltersNeg": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['facetFilters' => 'category:-Ebook',\n    ],\n);",
      "filtersAndFacetFilters": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['filters' => '(author:\"Stephen King\" OR genre:\"Horror\")',\n        'facetFilters' => [\n            'publisher:Penguin',\n        ],\n    ],\n);",
      "facet author genre": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['facets' => [\n        'author',\n\n        'genre',\n    ],\n    ],\n);",
      "facet wildcard": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['facets' => [\n        '*',\n    ],\n    ],\n);",
      "maxValuesPerFacet": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['maxValuesPerFacet' => 1000,\n    ],\n);",
      "aroundLatLng": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['aroundLatLng' => '40.71, -74.01',\n    ],\n);",
      "aroundLatLngViaIP": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['aroundLatLngViaIP' => true,\n    ],\n);",
      "aroundRadius": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['aroundLatLng' => '40.71, -74.01',\n        'aroundRadius' => 1000000,\n    ],\n);",
      "insideBoundingBox": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['insideBoundingBox' => [\n        [\n            49.067996905313834,\n\n            65.73828125,\n\n            25.905859247243498,\n\n            128.8046875,\n        ],\n    ],\n    ],\n);",
      "insidePolygon": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['insidePolygon' => [\n        [\n            42.01,\n\n            -124.31,\n\n            48.835509470063045,\n\n            -124.40453125000005,\n\n            45.01082951668149,\n\n            -65.95726562500005,\n\n            31.247243545293433,\n\n            -81.06578125000004,\n\n            25.924152577235226,\n\n            -97.68234374999997,\n\n            32.300311895879545,\n\n            -117.54828125,\n        ],\n    ],\n    ],\n);",
      "optionalFilters": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['optionalFilters' => [\n        'can_deliver_quickly:true',\n    ],\n    ],\n);",
      "optionalFiltersMany": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['optionalFilters' => [\n        'brand:Apple<score=3>',\n\n        'brand:Samsung<score=2>',\n\n        'brand:-Huawei',\n    ],\n    ],\n);",
      "optionalFiltersSimple": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['optionalFilters' => [\n        'brand:Apple<score=2>',\n\n        'type:tablet',\n    ],\n    ],\n);",
      "restrictSearchableAttributes": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['restrictSearchableAttributes' => [\n        'title_fr',\n    ],\n    ],\n);",
      "getRankingInfo": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['getRankingInfo' => true,\n    ],\n);",
      "clickAnalytics": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['clickAnalytics' => true,\n    ],\n);",
      "clickAnalyticsUserToken": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['clickAnalytics' => true,\n        'userToken' => 'user-1',\n    ],\n);",
      "enablePersonalization": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['enablePersonalization' => true,\n        'userToken' => 'user-1',\n    ],\n);",
      "userToken": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['userToken' => 'user-1',\n    ],\n);",
      "userToken1234": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'userToken' => 'user-1234',\n    ],\n);",
      "analyticsTag": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['analyticsTags' => [\n        'YOUR_ANALYTICS_TAG',\n    ],\n    ],\n);",
      "facetFiltersUsers": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['facetFilters' => [\n        'user:user42',\n\n        'user:public',\n    ],\n    ],\n);",
      "buildTheQuery": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['filters' => \"categoryPageId: Men's Clothing\",\n        'hitsPerPage' => 50,\n        'analyticsTags' => [\n            'mens-clothing',\n        ],\n    ],\n);",
      "attributesToHighlightOverride": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'attributesToHighlight' => [\n            'title',\n\n            'content',\n        ],\n    ],\n);",
      "disableTypoToleranceOnAttributes": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'disableTypoToleranceOnAttributes' => [\n            'serial_number',\n        ],\n    ],\n);",
      "search_a_query": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => '',\n        'similarQuery' => 'Comedy Drama Crime McDormand Macy Buscemi Stormare Presnell Coen',\n        'filters' => 'year:1991 TO 2001',\n    ],\n);",
      "search_everything": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => '',\n    ],\n);",
      "api_filtering_range_example": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'books',\n        'filters' => 'price:10 TO 20',\n    ],\n);",
      "override_retrievable_attributes": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'attributesToRetrieve' => [\n            'title',\n\n            'content',\n        ],\n    ],\n);",
      "restrict_searchable_attributes": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'restrictSearchableAttributes' => [\n            'title',\n\n            'author',\n        ],\n    ],\n);",
      "override_default_relevancy": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'relevancyStrictness' => 70,\n    ],\n);",
      "apply_filters": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'sumOrFiltersScores' => true,\n    ],\n);",
      "apply_all_filters": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'filters' => 'available = 1 AND (category:Book OR NOT category:Ebook) AND _tags:published AND publication_date:1441745506 TO 1441755506 AND inStock > 0 AND author:\"John Doe\"',\n    ],\n);",
      "escape_spaces": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'filters' => 'category:\"Books and Comics\"',\n    ],\n);",
      "escape_keywords": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'filters' => 'keyword:\"OR\"',\n    ],\n);",
      "escape_single_quotes": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'filters' => \"content:\\\"It's a wonderful day\\\"\",\n    ],\n);",
      "escape_double_quotes": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'filters' => 'content:\"She said \"Hello World\"',\n    ],\n);",
      "apply_negative_filters": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'optionalFilters' => [\n            'category:Book',\n\n            'author:-John Doe',\n        ],\n    ],\n);",
      "apply_negative_filters_restaurants": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'optionalFilters' => [\n            \"restaurant:-Bert's Inn\",\n        ],\n    ],\n);",
      "apply_numeric_filters": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'numericFilters' => [\n            'price < 1000',\n\n            [\n                'inStock = 1',\n\n                'deliveryDate < 1441755506',\n            ],\n        ],\n    ],\n);",
      "apply_tag_filters": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'tagFilters' => [\n            'SciFi',\n\n            [\n                'Book',\n\n                'Movie',\n            ],\n        ],\n    ],\n);",
      "facets_all": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'facets' => [\n            '*',\n        ],\n    ],\n);",
      "retrieve_only_some_facets": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'facets' => [\n            'category',\n\n            'author',\n        ],\n    ],\n);",
      "override_default_max_values_per_facet": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'maxValuesPerFacet' => 20,\n    ],\n);",
      "enable_faceting_after_distinct": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'facetingAfterDistinct' => true,\n    ],\n);",
      "sort_facet_values_alphabetically": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'sortFacetValuesBy' => 'count',\n    ],\n);",
      "override_attributes_to_snippet": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'attributesToSnippet' => [\n            'title',\n\n            'content:80',\n        ],\n    ],\n);",
      "override_default_highlight_pre_tag": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'highlightPreTag' => '<strong>',\n    ],\n);",
      "override_default_highlight_post_tag": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'highlightPostTag' => '</strong>',\n    ],\n);",
      "override_default_snippet_ellipsis_text": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'snippetEllipsisText' => '',\n    ],\n);",
      "enable_restrict_highlight_and_snippet_arrays": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'restrictHighlightAndSnippetArrays' => false,\n    ],\n);",
      "access_page": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'page' => 0,\n    ],\n);",
      "override_default_hits_per_page": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'hitsPerPage' => 10,\n    ],\n);",
      "get_nth_hit": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'offset' => 4,\n    ],\n);",
      "get_n_results": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'length' => 4,\n    ],\n);",
      "override_default_min_word_size_for_one_typo": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'minWordSizefor1Typo' => 2,\n    ],\n);",
      "override_default_min_word_size_for_two_typos": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'minWordSizefor2Typos' => 2,\n    ],\n);",
      "override_default_typo_tolerance_mode": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'typoTolerance' => false,\n    ],\n);",
      "disable_typos_on_numeric_tokens_at_search_time": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'allowTyposOnNumericTokens' => false,\n    ],\n);",
      "search_around_a_position": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'aroundLatLng' => '40.71, -74.01',\n    ],\n);",
      "search_around_server_ip": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'aroundLatLngViaIP' => true,\n    ],\n    [\n        'headers' => [\n            'x-forwarded-for' => '94.228.178.246 // should be replaced with the actual IP you would like to search around',\n        ],\n    ]\n);",
      "set_around_radius": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'aroundRadius' => 1000,\n    ],\n);",
      "disable_automatic_radius": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'aroundRadius' => 'all',\n    ],\n);",
      "set_geo_search_precision": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'aroundPrecision' => 100,\n    ],\n);",
      "set_geo_search_precision_non_linear": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'aroundPrecision' => [\n            ['from' => 0,\n                'value' => 25,\n            ],\n\n            ['from' => 2000,\n                'value' => 1000,\n            ],\n        ],\n    ],\n);",
      "set_minimum_geo_search_radius": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'minimumAroundRadius' => 1000,\n    ],\n);",
      "search_inside_rectangular_area": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'insideBoundingBox' => [\n            [\n                46.650828100116044,\n\n                7.123046875,\n\n                45.17210966999772,\n\n                1.009765625,\n            ],\n        ],\n    ],\n);",
      "search_inside_multiple_rectangular_areas": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'insideBoundingBox' => [\n            [\n                46.650828100116044,\n\n                7.123046875,\n\n                45.17210966999772,\n\n                1.009765625,\n            ],\n\n            [\n                49.62625916704081,\n\n                4.6181640625,\n\n                47.715070300900194,\n\n                0.482421875,\n            ],\n        ],\n    ],\n);",
      "search_inside_polygon_area": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'insidePolygon' => [\n            [\n                46.650828100116044,\n\n                7.123046875,\n\n                45.17210966999772,\n\n                1.009765625,\n\n                49.62625916704081,\n\n                4.6181640625,\n            ],\n        ],\n    ],\n);",
      "search_inside_multiple_polygon_areas": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'insidePolygon' => [\n            [\n                46.650828100116044,\n\n                7.123046875,\n\n                45.17210966999772,\n\n                1.009765625,\n\n                49.62625916704081,\n\n                4.6181640625,\n            ],\n\n            [\n                49.62625916704081,\n\n                4.6181640625,\n\n                47.715070300900194,\n\n                0.482421875,\n\n                45.17210966999772,\n\n                1.009765625,\n\n                50.62626704081,\n\n                4.6181640625,\n            ],\n        ],\n    ],\n);",
      "set_querylanguages_override": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'removeStopWords' => [\n            'ca',\n\n            'es',\n        ],\n    ],\n);",
      "set_querylanguages_with_japanese_query": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'queryLanguages' => [\n            'ja',\n\n            'en',\n        ],\n    ],\n);",
      "set_natural_languages": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => '',\n        'naturalLanguages' => [\n            'fr',\n        ],\n    ],\n);",
      "override_natural_languages_with_query": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => '',\n        'naturalLanguages' => [\n            'fr',\n        ],\n        'removeWordsIfNoResults' => 'firstWords',\n    ],\n);",
      "enable_decompound_query_search_time": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'decompoundQuery' => true,\n    ],\n);",
      "enable_rules_search_time": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'enableRules' => true,\n    ],\n);",
      "set_rule_contexts": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'ruleContexts' => [\n            'front_end',\n\n            'website2',\n        ],\n    ],\n);",
      "enable_personalization": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'enablePersonalization' => true,\n    ],\n);",
      "enable_personalization_with_user_token": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'enablePersonalization' => true,\n        'userToken' => '123456',\n    ],\n);",
      "personalization_impact": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'personalizationImpact' => 20,\n    ],\n);",
      "set_user_token": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'userToken' => '123456',\n    ],\n);",
      "set_user_token_with_personalization": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'enablePersonalization' => true,\n        'userToken' => '123456',\n    ],\n);",
      "override_default_query_type": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'queryType' => 'prefixAll',\n    ],\n);",
      "override_default_remove_words_if_no_results": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'removeWordsIfNoResults' => 'lastWords',\n    ],\n);",
      "enable_advanced_syntax_search_time": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'advancedSyntax' => true,\n    ],\n);",
      "overide_default_optional_words": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'optionalWords' => [\n            'toyota',\n\n            '2020 2021',\n        ],\n    ],\n);",
      "disabling_exact_for_some_attributes_search_time": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'disableExactOnAttributes' => [\n            'description',\n        ],\n    ],\n);",
      "override_default_exact_single_word_query": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'exactOnSingleWordQuery' => 'none',\n    ],\n);",
      "override_default_aternative_as_exact": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'alternativesAsExact' => [\n            'multiWordsSynonym',\n        ],\n    ],\n);",
      "enable_advanced_syntax_exact_phrase": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'advancedSyntax' => true,\n        'advancedSyntaxFeatures' => [\n            'exactPhrase',\n        ],\n    ],\n);",
      "enable_advanced_syntax_exclude_words": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'advancedSyntax' => true,\n        'advancedSyntaxFeatures' => [\n            'excludeWords',\n        ],\n    ],\n);",
      "override_distinct": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'distinct' => 0,\n    ],\n);",
      "get_ranking_info": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'getRankingInfo' => true,\n    ],\n);",
      "disable_click_analytics": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'clickAnalytics' => false,\n    ],\n);",
      "enable_click_analytics": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'clickAnalytics' => true,\n    ],\n);",
      "disable_analytics": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'analytics' => false,\n    ],\n);",
      "add_analytics_tags": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'analyticsTags' => [\n            'front_end',\n\n            'website2',\n        ],\n    ],\n);",
      "disable_synonyms": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'synonyms' => false,\n    ],\n);",
      "override_replace_synonyms_in_highlights": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'replaceSynonymsInHighlight' => true,\n    ],\n);",
      "override_min_proximity": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'minProximity' => 2,\n    ],\n);",
      "override_default_field": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'responseFields' => [\n            'hits',\n\n            'facets',\n        ],\n    ],\n);",
      "override_percentile_computation": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'percentileComputation' => false,\n    ],\n);",
      "set_ab_test": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'enableABTest' => false,\n    ],\n);",
      "set_enable_re_ranking": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n        'enableReRanking' => false,\n    ],\n);",
      "with algolia user id": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'query',\n    ],\n    [\n        'headers' => [\n            'X-Algolia-User-ID' => 'user1234',\n        ],\n    ]\n);",
      "mcm with algolia user id": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'peace',\n    ],\n    [\n        'headers' => [\n            'X-Algolia-User-ID' => 'user42',\n        ],\n    ]\n);"
    },
    "searchSynonyms": {
      "searchSynonyms with minimal parameters": "$response = $client->searchSynonyms(\n    '<YOUR_INDEX_NAME>',\n);",
      "searchSynonyms with all parameters": "$response = $client->searchSynonyms(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'myQuery',\n        'type' => 'altcorrection1',\n        'page' => 10,\n        'hitsPerPage' => 10,\n    ],\n);"
    },
    "searchUserIds": {
      "default": "$response = $client->searchUserIds(\n    ['query' => 'test',\n        'clusterName' => 'theClusterName',\n        'page' => 5,\n        'hitsPerPage' => 10,\n    ],\n);"
    },
    "setClientApiKey": {
      "default": "$client->setClientApiKey(\n    'updated-api-key',\n);"
    },
    "setDictionarySettings": {
      "get setDictionarySettings results with minimal parameters": "$response = $client->setDictionarySettings(\n    ['disableStandardEntries' => ['plurals' => ['fr' => false,\n        'en' => false,\n        'ru' => true,\n    ],\n    ],\n    ],\n);",
      "get setDictionarySettings results with all parameters": "$response = $client->setDictionarySettings(\n    ['disableStandardEntries' => ['plurals' => ['fr' => false,\n        'en' => false,\n        'ru' => true,\n    ],\n        'stopwords' => ['fr' => false,\n        ],\n        'compounds' => ['ru' => true,\n        ],\n    ],\n    ],\n);"
    },
    "setSettings": {
      "minimal parameters": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['paginationLimitedTo' => 10,\n    ],\n    true,\n);",
      "boolean typoTolerance": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['typoTolerance' => true,\n    ],\n    true,\n);",
      "enum typoTolerance": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['typoTolerance' => 'min',\n    ],\n    true,\n);",
      "ignorePlurals": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['ignorePlurals' => true,\n    ],\n    true,\n);",
      "list of string ignorePlurals": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['ignorePlurals' => [\n        'fr',\n    ],\n    ],\n    true,\n);",
      "removeStopWords boolean": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['removeStopWords' => true,\n    ],\n    true,\n);",
      "removeStopWords list of string": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['removeStopWords' => [\n        'fr',\n    ],\n    ],\n    true,\n);",
      "boolean distinct": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['distinct' => true,\n    ],\n    true,\n);",
      "integer distinct": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['distinct' => 1,\n    ],\n    true,\n);",
      "distinct company": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributeForDistinct' => 'company',\n        'distinct' => true,\n    ],\n);",
      "distinct design": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributeForDistinct' => 'design',\n        'distinct' => true,\n    ],\n);",
      "distinct true": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['distinct' => true,\n    ],\n);",
      "distinct section": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributeForDistinct' => 'section',\n        'distinct' => true,\n    ],\n);",
      "attributesForFaceting allergens": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesForFaceting' => [\n        'allergens',\n    ],\n    ],\n);",
      "attributesForFaceting availableIn": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesForFaceting' => [\n        'color',\n\n        'availableIn',\n    ],\n    ],\n);",
      "api_attributes_for_faceting": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesForFaceting' => [\n        'genre',\n\n        'author',\n    ],\n    ],\n);",
      "api_attributes_for_faceting_searchable": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesForFaceting' => [\n        'genre',\n\n        'searchable(author)',\n    ],\n    ],\n);",
      "api_attributes_for_filter_only": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesForFaceting' => [\n        'filterOnly(genre)',\n\n        'author',\n    ],\n    ],\n);",
      "attributesForFaceting categoryPageId": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesForFaceting' => [\n        'searchable(categoryPageId)',\n    ],\n    ],\n);",
      "unretrievableAttributes": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['unretrievableAttributes' => [\n        'visible_by',\n    ],\n    ],\n);",
      "attributesForFaceting user restricted data": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesForFaceting' => [\n        'filterOnly(visible_by)',\n    ],\n    ],\n);",
      "attributesForFaceting optional filters": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesForFaceting' => [\n        'can_deliver_quickly',\n\n        'restaurant',\n    ],\n    ],\n);",
      "attributesForFaceting redirect index": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesForFaceting' => [\n        'query_terms',\n    ],\n    ],\n);",
      "attributesForFaceting multiple consequences": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesForFaceting' => [\n        'director',\n    ],\n    ],\n);",
      "attributesForFaceting in-depth optional filters": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesForFaceting' => [\n        'filterOnly(brand)',\n    ],\n    ],\n);",
      "mode neuralSearch": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['mode' => 'neuralSearch',\n    ],\n);",
      "mode keywordSearch": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['mode' => 'keywordSearch',\n    ],\n);",
      "searchableAttributes same priority": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['searchableAttributes' => [\n        'title,comments',\n\n        'ingredients',\n    ],\n    ],\n);",
      "searchableAttributes higher priority": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['searchableAttributes' => [\n        'title',\n\n        'ingredients',\n    ],\n    ],\n);",
      "customRanking retweets": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['customRanking' => [\n        'desc(retweets)',\n\n        'desc(likes)',\n    ],\n    ],\n);",
      "customRanking boosted": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['customRanking' => [\n        'desc(boosted)',\n    ],\n    ],\n);",
      "customRanking pageviews": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['customRanking' => [\n        'desc(pageviews)',\n\n        'desc(comments)',\n    ],\n    ],\n);",
      "customRanking applying search parameters for a specific query": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['customRanking' => [\n        'desc(nb_airline_liaisons)',\n    ],\n        'attributesForFaceting' => [\n            'city, country',\n        ],\n    ],\n);",
      "customRanking rounded pageviews": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['customRanking' => [\n        'desc(rounded_pageviews)',\n\n        'desc(comments)',\n    ],\n    ],\n);",
      "customRanking price": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['customRanking' => [\n        'desc(price)',\n    ],\n    ],\n);",
      "ranking exhaustive (price)": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['ranking' => [\n        'desc(price)',\n\n        'typo',\n\n        'geo',\n\n        'words',\n\n        'filters',\n\n        'proximity',\n\n        'attribute',\n\n        'exact',\n\n        'custom',\n    ],\n    ],\n);",
      "ranking exhaustive (is_popular)": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['ranking' => [\n        'desc(is_popular)',\n\n        'typo',\n\n        'geo',\n\n        'words',\n\n        'filters',\n\n        'proximity',\n\n        'attribute',\n\n        'exact',\n\n        'custom',\n    ],\n    ],\n);",
      "ranking standard replica": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['ranking' => [\n        'desc(post_date_timestamp)',\n    ],\n    ],\n);",
      "ranking virtual replica": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['customRanking' => [\n        'desc(post_date_timestamp)',\n    ],\n    ],\n);",
      "customRanking and ranking sort alphabetically": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['customRanking' => [\n        'asc(textual_attribute)',\n    ],\n        'ranking' => [\n            'custom',\n\n            'typo',\n\n            'geo',\n\n            'words',\n\n            'filters',\n\n            'proximity',\n\n            'attribute',\n\n            'exact',\n        ],\n    ],\n);",
      "relevancyStrictness": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['customRanking' => [\n        'asc(textual_attribute)',\n    ],\n        'relevancyStrictness' => 0,\n    ],\n);",
      "create replica index": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['replicas' => [\n        'products_price_desc',\n    ],\n    ],\n);",
      "create replica index articles": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['replicas' => [\n        'articles_date_desc',\n    ],\n    ],\n);",
      "create virtual replica index": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['replicas' => [\n        'virtual(products_price_desc)',\n    ],\n    ],\n);",
      "unlink replica index": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['replicas' => [\n        '',\n    ],\n    ],\n);",
      "forwardToReplicas": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['searchableAttributes' => [\n        'name',\n\n        'description',\n    ],\n    ],\n    true,\n);",
      "maxValuesPerFacet": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['maxValuesPerFacet' => 1000,\n    ],\n);",
      "maxFacetHits": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['maxFacetHits' => 100,\n    ],\n);",
      "attributesForFaceting complex": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesForFaceting' => [\n        'actor',\n\n        'filterOnly(category)',\n\n        'searchable(publisher)',\n    ],\n    ],\n);",
      "ranking closest dates": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['ranking' => [\n        'asc(date_timestamp)',\n\n        'typo',\n\n        'geo',\n\n        'words',\n\n        'filters',\n\n        'proximity',\n\n        'attribute',\n\n        'exact',\n\n        'custom',\n    ],\n    ],\n);",
      "searchableAttributes item variation": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['searchableAttributes' => [\n        'design',\n\n        'type',\n\n        'color',\n    ],\n    ],\n);",
      "searchableAttributes around location": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['searchableAttributes' => [\n        'name',\n\n        'country',\n\n        'city',\n\n        'iata_code',\n    ],\n        'customRanking' => [\n            'desc(links_count)',\n        ],\n    ],\n);",
      "attributesToHighlight": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesToHighlight' => [\n        'author',\n\n        'title',\n\n        'content',\n    ],\n    ],\n);",
      "attributesToHighlightStar": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesToHighlight' => [\n        '*',\n    ],\n    ],\n);",
      "everything": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['advancedSyntax' => true,\n        'advancedSyntaxFeatures' => [\n            'exactPhrase',\n        ],\n        'allowCompressionOfIntegerArray' => true,\n        'allowTyposOnNumericTokens' => true,\n        'alternativesAsExact' => [\n            'singleWordSynonym',\n        ],\n        'attributeCriteriaComputedByMinProximity' => true,\n        'attributeForDistinct' => 'test',\n        'attributesForFaceting' => [\n            'algolia',\n        ],\n        'attributesToHighlight' => [\n            'algolia',\n        ],\n        'attributesToRetrieve' => [\n            'algolia',\n        ],\n        'attributesToSnippet' => [\n            'algolia',\n        ],\n        'attributesToTransliterate' => [\n            'algolia',\n        ],\n        'camelCaseAttributes' => [\n            'algolia',\n        ],\n        'customNormalization' => ['algolia' => ['aloglia' => 'aglolia',\n        ],\n        ],\n        'customRanking' => [\n            'algolia',\n        ],\n        'decompoundQuery' => false,\n        'decompoundedAttributes' => ['algolia' => 'aloglia',\n        ],\n        'disableExactOnAttributes' => [\n            'algolia',\n        ],\n        'disablePrefixOnAttributes' => [\n            'algolia',\n        ],\n        'disableTypoToleranceOnAttributes' => [\n            'algolia',\n        ],\n        'disableTypoToleranceOnWords' => [\n            'algolia',\n        ],\n        'distinct' => 3,\n        'enablePersonalization' => true,\n        'enableReRanking' => false,\n        'enableRules' => true,\n        'exactOnSingleWordQuery' => 'attribute',\n        'highlightPreTag' => '<span>',\n        'highlightPostTag' => '</span>',\n        'hitsPerPage' => 10,\n        'ignorePlurals' => false,\n        'indexLanguages' => [\n            'fr',\n        ],\n        'keepDiacriticsOnCharacters' => 'abc',\n        'maxFacetHits' => 20,\n        'maxValuesPerFacet' => 30,\n        'minProximity' => 6,\n        'minWordSizefor1Typo' => 5,\n        'minWordSizefor2Typos' => 11,\n        'mode' => 'neuralSearch',\n        'numericAttributesForFiltering' => [\n            'algolia',\n        ],\n        'optionalWords' => [\n            'myspace',\n        ],\n        'paginationLimitedTo' => 0,\n        'queryLanguages' => [\n            'fr',\n        ],\n        'queryType' => 'prefixLast',\n        'ranking' => [\n            'geo',\n        ],\n        'reRankingApplyFilter' => 'mySearch:filters',\n        'relevancyStrictness' => 10,\n        'removeStopWords' => false,\n        'removeWordsIfNoResults' => 'lastWords',\n        'renderingContent' => ['facetOrdering' => ['facets' => ['order' => [\n            'a',\n\n            'b',\n        ],\n        ],\n            'values' => ['a' => ['order' => [\n                'b',\n            ],\n                'sortRemainingBy' => 'count',\n            ],\n            ],\n        ],\n        ],\n        'replaceSynonymsInHighlight' => true,\n        'replicas' => [\n            '',\n        ],\n        'responseFields' => [\n            'algolia',\n        ],\n        'restrictHighlightAndSnippetArrays' => true,\n        'searchableAttributes' => [\n            'foo',\n        ],\n        'semanticSearch' => ['eventSources' => [\n            'foo',\n        ],\n        ],\n        'separatorsToIndex' => 'bar',\n        'snippetEllipsisText' => '---',\n        'sortFacetValuesBy' => 'date',\n        'typoTolerance' => false,\n        'unretrievableAttributes' => [\n            'foo',\n        ],\n        'userData' => ['user' => 'data',\n        ],\n    ],\n);",
      "searchableAttributesWithCustomRankingsAndAttributesForFaceting": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['searchableAttributes' => [\n        'brand',\n\n        'name',\n\n        'categories',\n\n        'unordered(description)',\n    ],\n        'customRanking' => [\n            'desc(popularity)',\n        ],\n        'attributesForFaceting' => [\n            'searchable(brand)',\n\n            'type',\n\n            'categories',\n\n            'price',\n        ],\n    ],\n);",
      "searchableAttributesOrdering": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['searchableAttributes' => [\n        'unordered(title)',\n\n        'cast',\n    ],\n    ],\n);",
      "searchableAttributesProductReferenceSuffixes": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['searchableAttributes' => [\n        'name',\n\n        'product_reference',\n\n        'product_reference_suffixes',\n    ],\n    ],\n);",
      "queryLanguageAndIgnorePlurals": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['queryLanguages' => [\n        'en',\n    ],\n        'ignorePlurals' => true,\n    ],\n);",
      "searchableAttributesInMovies": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['searchableAttributes' => [\n        'title_eng',\n\n        'title_fr',\n\n        'title_es',\n    ],\n    ],\n);",
      "disablePrefixOnAttributes": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['disablePrefixOnAttributes' => [\n        'serial_number',\n    ],\n    ],\n);",
      "disableTypoToleranceOnAttributes": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['disableTypoToleranceOnAttributes' => [\n        'serial_number',\n    ],\n    ],\n);",
      "searchableAttributesSimpleExample": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['searchableAttributes' => [\n        'serial_number',\n    ],\n    ],\n);",
      "searchableAttributesSimpleExampleAlt": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['searchableAttributes' => [\n        'serial_number',\n\n        'serial_number_suffixes',\n    ],\n    ],\n);",
      "set_searchable_attributes": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesForFaceting' => [\n        'author',\n\n        'filterOnly(isbn)',\n\n        'searchable(edition)',\n\n        'afterDistinct(category)',\n\n        'afterDistinct(searchable(publisher))',\n    ],\n    ],\n);",
      "unretrievable_attributes": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['unretrievableAttributes' => [\n        'total_number_of_sales',\n    ],\n    ],\n);",
      "set_retrievable_attributes": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesToRetrieve' => [\n        'author',\n\n        'title',\n\n        'content',\n    ],\n    ],\n);",
      "set_all_attributes_as_retrievable": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesToRetrieve' => [\n        '*',\n    ],\n    ],\n);",
      "specify_attributes_not_to_retrieve": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesToRetrieve' => [\n        '*',\n\n        '-SKU',\n\n        '-internal_desc',\n    ],\n    ],\n);",
      "neural_search": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['mode' => 'neuralSearch',\n    ],\n);",
      "keyword_search": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['mode' => 'keywordSearch',\n    ],\n);",
      "set_default_ranking": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['ranking' => [\n        'typo',\n\n        'geo',\n\n        'words',\n\n        'filters',\n\n        'attribute',\n\n        'proximity',\n\n        'exact',\n\n        'custom',\n    ],\n    ],\n);",
      "set_ranking_by_attribute_asc": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['ranking' => [\n        'asc(price)',\n\n        'typo',\n\n        'geo',\n\n        'words',\n\n        'filters',\n\n        'proximity',\n\n        'attribute',\n\n        'exact',\n\n        'custom',\n    ],\n    ],\n);",
      "set_ranking_by_attribute_desc": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['ranking' => [\n        'desc(price)',\n\n        'typo',\n\n        'geo',\n\n        'words',\n\n        'filters',\n\n        'proximity',\n\n        'attribute',\n\n        'exact',\n\n        'custom',\n    ],\n    ],\n);",
      "restrict_searchable_attributes": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['customRanking' => [\n        'desc(popularity)',\n\n        'asc(price)',\n    ],\n    ],\n);",
      "set_default_relevancy": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['relevancyStrictness' => 90,\n    ],\n);",
      "set_replicas": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['replicas' => [\n        'name_of_replica_index1',\n\n        'name_of_replica_index2',\n    ],\n    ],\n);",
      "set_default_max_values_per_facet": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['maxValuesPerFacet' => 100,\n    ],\n);",
      "set_default_sort_facet_values_by": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['sortFacetValuesBy' => 'alpha',\n    ],\n);",
      "set_attributes_to_snippet": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesToSnippet' => [\n        'content:80',\n\n        'description',\n    ],\n    ],\n);",
      "set_all_attributes_to_snippet": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesToSnippet' => [\n        '*:80',\n    ],\n    ],\n);",
      "set_default_highlight_pre_tag": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['highlightPreTag' => '<em>',\n    ],\n);",
      "set_default_highlight_post_tag": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['highlightPostTag' => '</em>',\n    ],\n);",
      "set_default_snippet_ellipsis_text": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['snippetEllipsisText' => '…',\n    ],\n);",
      "enable_restrict_highlight_and_snippet_arrays_by_default": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['restrictHighlightAndSnippetArrays' => true,\n    ],\n);",
      "set_default_hits_per_page": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['hitsPerPage' => 20,\n    ],\n);",
      "set_pagination_limit": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['paginationLimitedTo' => 1000,\n    ],\n);",
      "set_default_min_word_size_for_one_typo": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['minWordSizefor1Typo' => 4,\n    ],\n);",
      "set_default_min_word_size_for_two_typos": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['minWordSizefor2Typos' => 4,\n    ],\n);",
      "set_default_typo_tolerance_mode": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['typoTolerance' => true,\n    ],\n);",
      "disable_typos_on_numeric_tokens_by_default": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['allowTyposOnNumericTokens' => false,\n    ],\n);",
      "disable_typo_tolerance_for_words": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['disableTypoToleranceOnWords' => [\n        'wheel',\n\n        '1X2BCD',\n    ],\n    ],\n);",
      "set_separators_to_index": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['separatorsToIndex' => '+#',\n    ],\n);",
      "set_languages_using_querylanguages": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['queryLanguages' => [\n        'es',\n    ],\n        'removeStopWords' => true,\n        'ignorePlurals' => true,\n    ],\n);",
      "set_attributes_to_transliterate": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['indexLanguages' => [\n        'ja',\n    ],\n        'attributesToTransliterate' => [\n            'name',\n\n            'description',\n        ],\n    ],\n);",
      "set_camel_case_attributes": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['camelCaseAttributes' => [\n        'description',\n    ],\n    ],\n);",
      "set_decompounded_attributes": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['decompoundedAttributes' => ['de' => [\n        'name',\n    ],\n    ],\n    ],\n);",
      "set_decompounded_multiple_attributes": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['decompoundedAttributes' => ['de' => [\n        'name_de',\n\n        'description_de',\n    ],\n        'fi' => [\n            'name_fi',\n\n            'description_fi',\n        ],\n    ],\n    ],\n);",
      "set_keep_diacritics_on_characters": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['keepDiacriticsOnCharacters' => 'øé',\n    ],\n);",
      "set_custom_normalization": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['customNormalization' => ['default' => ['ä' => 'ae',\n    ],\n    ],\n    ],\n);",
      "set_indexlanguages": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['indexLanguages' => [\n        'ja',\n    ],\n    ],\n);",
      "enable_decompound_query_by_default": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['decompoundQuery' => true,\n    ],\n);",
      "enable_rules_syntax_by_default": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['enableRules' => true,\n    ],\n);",
      "enable_personalization_settings": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['enablePersonalization' => true,\n    ],\n);",
      "set_default_query_type": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['queryType' => 'prefixLast',\n    ],\n);",
      "set_default_remove_words_if_no_result": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['removeWordsIfNoResults' => 'none',\n    ],\n);",
      "enable_advanced_syntax_by_default": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['advancedSyntax' => true,\n    ],\n);",
      "set_default_optional_words": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['optionalWords' => [\n        'blue',\n\n        'iphone case',\n    ],\n    ],\n);",
      "disabling_prefix_search_for_some_attributes_by_default": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['disablePrefixOnAttributes' => [\n        'sku',\n    ],\n    ],\n);",
      "disabling_exact_for_some_attributes_by_default": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['disableExactOnAttributes' => [\n        'description',\n    ],\n    ],\n);",
      "set_default_exact_single_word_query": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['exactOnSingleWordQuery' => 'attribute',\n    ],\n);",
      "set_default_aternative_as_exact": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['alternativesAsExact' => [\n        'ignorePlurals',\n\n        'singleWordSynonym',\n    ],\n    ],\n);",
      "set_numeric_attributes_for_filtering": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['numericAttributesForFiltering' => [\n        'quantity',\n\n        'popularity',\n    ],\n    ],\n);",
      "enable_compression_of_integer_array": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['allowCompressionOfIntegerArray' => true,\n    ],\n);",
      "set_attributes_for_distinct": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributeForDistinct' => 'url',\n    ],\n);",
      "set_distinct": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['distinct' => 1,\n        'attributeForDistinct' => 'url',\n    ],\n);",
      "set_replace_synonyms_in_highlights": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['replaceSynonymsInHighlight' => false,\n    ],\n);",
      "set_min_proximity": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['minProximity' => 1,\n    ],\n);",
      "set_default_field": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['responseFields' => [\n        'hits',\n\n        'hitsPerPage',\n\n        'nbPages',\n\n        'page',\n    ],\n    ],\n);",
      "set_max_facet_hits": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['maxFacetHits' => 10,\n    ],\n);",
      "set_attribute_criteria_computed_by_min_proximity": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributeCriteriaComputedByMinProximity' => true,\n    ],\n);",
      "set_user_data": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['userData' => ['extraData' => 'This is the custom data that you want to store in your index',\n    ],\n    ],\n);",
      "set_rendering_content": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['renderingContent' => ['facetOrdering' => ['facets' => ['order' => [\n        'size',\n\n        'brand',\n    ],\n    ],\n        'values' => ['brand' => ['order' => [\n            'uniqlo',\n        ],\n            'hide' => [\n                'muji',\n            ],\n            'sortRemainingBy' => 'count',\n        ],\n            'size' => ['order' => [\n                'S',\n\n                'M',\n\n                'L',\n            ],\n                'sortRemainingBy' => 'hidden',\n            ],\n        ],\n    ],\n    ],\n    ],\n);"
    },
    "updateApiKey": {
      "default": "$response = $client->updateApiKey(\n    'ALGOLIA_API_KEY',\n    ['acl' => [\n        'search',\n\n        'addObject',\n    ],\n        'validity' => 300,\n        'maxQueriesPerIPPerHour' => 100,\n        'maxHitsPerQuery' => 20,\n    ],\n);"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "$response = $client->waitForApiKey(\n    'api-key-add-operation-test-php',\n    'add',\n);",
      "wait for api key - update": "$response = $client->waitForApiKey(\n    'api-key-update-operation-test-php',\n    'update',\n    ['description' => 'my updated api key',\n        'acl' => [\n            'search',\n\n            'addObject',\n\n            'deleteObject',\n        ],\n        'indexes' => [\n            'Movies',\n\n            'Books',\n        ],\n        'referers' => [\n            '*google.com',\n\n            '*algolia.com',\n        ],\n        'validity' => 305,\n        'maxQueriesPerIPPerHour' => 95,\n        'maxHitsPerQuery' => 20,\n    ],\n);",
      "wait for api key - delete": "$response = $client->waitForApiKey(\n    'api-key-delete-operation-test-php',\n    'delete',\n);"
    },
    "waitForAppTask": {
      "default": "$response = $client->waitForAppTask(\n    123,\n);"
    },
    "waitForTask": {
      "default": "$response = $client->waitForTask(\n    '<YOUR_INDEX_NAME>',\n    123,\n);"
    },
    "init": {
      "default": "$client = SearchClient::create('ALGOLIA_APPLICATION_ID', 'ALGOLIA_API_KEY');"
    }
  },
  "python": {
    "import": {
      "default": "from algoliasearch.search.client import SearchClientSync\nfrom json import loads"
    },
    "addApiKey": {
      "minimal": "response = client.add_api_key(\n    api_key={\n        \"acl\": [\n            \"search\",\n            \"addObject\",\n        ],\n        \"description\": \"my new api key\",\n    },\n)",
      "all": "response = client.add_api_key(\n    api_key={\n        \"acl\": [\n            \"search\",\n            \"addObject\",\n        ],\n        \"description\": \"my new api key\",\n        \"validity\": 300,\n        \"maxQueriesPerIPPerHour\": 100,\n        \"maxHitsPerQuery\": 20,\n    },\n)"
    },
    "addOrUpdateObject": {
      "default": "response = client.add_or_update_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"uniqueID\",\n    body={\n        \"key\": \"value\",\n    },\n)"
    },
    "appendSource": {
      "default": "response = client.append_source(\n    source={\n        \"source\": \"theSource\",\n        \"description\": \"theDescription\",\n    },\n)"
    },
    "assignUserId": {
      "simple": "response = client.assign_user_id(\n    x_algolia_user_id=\"user42\",\n    assign_user_id_params={\n        \"cluster\": \"d4242-eu\",\n    },\n)",
      "it should not encode the userID": "response = client.assign_user_id(\n    x_algolia_user_id=\"user id with spaces\",\n    assign_user_id_params={\n        \"cluster\": \"cluster with spaces\",\n    },\n)"
    },
    "batch": {
      "addObject": "response = client.batch(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    batch_write_params={\n        \"requests\": [\n            {\n                \"action\": \"addObject\",\n                \"body\": {\n                    \"key\": \"bar\",\n                    \"foo\": \"1\",\n                },\n            },\n            {\n                \"action\": \"addObject\",\n                \"body\": {\n                    \"key\": \"baz\",\n                    \"foo\": \"2\",\n                },\n            },\n        ],\n    },\n)",
      "clear": "response = client.batch(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    batch_write_params={\n        \"requests\": [\n            {\n                \"action\": \"clear\",\n                \"body\": {\n                    \"key\": \"value\",\n                },\n            },\n        ],\n    },\n)",
      "delete": "response = client.batch(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    batch_write_params={\n        \"requests\": [\n            {\n                \"action\": \"delete\",\n                \"body\": {\n                    \"key\": \"value\",\n                },\n            },\n        ],\n    },\n)",
      "deleteObject": "response = client.batch(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    batch_write_params={\n        \"requests\": [\n            {\n                \"action\": \"deleteObject\",\n                \"body\": {\n                    \"key\": \"value\",\n                },\n            },\n        ],\n    },\n)",
      "partialUpdateObject": "response = client.batch(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    batch_write_params={\n        \"requests\": [\n            {\n                \"action\": \"partialUpdateObject\",\n                \"body\": {\n                    \"key\": \"value\",\n                },\n            },\n        ],\n    },\n)",
      "partialUpdateObjectNoCreate": "response = client.batch(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    batch_write_params={\n        \"requests\": [\n            {\n                \"action\": \"partialUpdateObjectNoCreate\",\n                \"body\": {\n                    \"key\": \"value\",\n                },\n            },\n        ],\n    },\n)",
      "updateObject": "response = client.batch(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    batch_write_params={\n        \"requests\": [\n            {\n                \"action\": \"updateObject\",\n                \"body\": {\n                    \"key\": \"value\",\n                },\n            },\n        ],\n    },\n)"
    },
    "batchAssignUserIds": {
      "default": "response = client.batch_assign_user_ids(\n    x_algolia_user_id=\"userID\",\n    batch_assign_user_ids_params={\n        \"cluster\": \"theCluster\",\n        \"users\": [\n            \"user1\",\n            \"user2\",\n        ],\n    },\n)"
    },
    "batchDictionaryEntries": {
      "replace": "response = client.batch_dictionary_entries(\n    dictionary_name=\"plurals\",\n    batch_dictionary_entries_params={\n        \"clearExistingDictionaryEntries\": True,\n        \"requests\": [\n            {\n                \"action\": \"addEntry\",\n                \"body\": {\n                    \"objectID\": \"1\",\n                    \"language\": \"en\",\n                    \"word\": \"fancy\",\n                    \"words\": [\n                        \"believe\",\n                        \"algolia\",\n                    ],\n                    \"decomposition\": [\n                        \"trust\",\n                        \"algolia\",\n                    ],\n                    \"state\": \"enabled\",\n                },\n            },\n        ],\n    },\n)",
      "delete": "response = client.batch_dictionary_entries(\n    dictionary_name=\"plurals\",\n    batch_dictionary_entries_params={\n        \"clearExistingDictionaryEntries\": True,\n        \"requests\": [\n            {\n                \"action\": \"deleteEntry\",\n                \"body\": {\n                    \"objectID\": \"1\",\n                },\n            },\n        ],\n    },\n)",
      "append": "response = client.batch_dictionary_entries(\n    dictionary_name=\"stopwords\",\n    batch_dictionary_entries_params={\n        \"requests\": [\n            {\n                \"action\": \"addEntry\",\n                \"body\": {\n                    \"objectID\": \"1\",\n                    \"language\": \"en\",\n                    \"additional\": \"try me\",\n                },\n            },\n        ],\n    },\n)"
    },
    "browse": {
      "browse with minimal parameters": "response = client.browse(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)",
      "browse with search parameters": "response = client.browse(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    browse_params={\n        \"query\": \"myQuery\",\n        \"facetFilters\": [\n            \"tags:algolia\",\n        ],\n    },\n)",
      "browse allow a cursor in parameters": "response = client.browse(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    browse_params={\n        \"cursor\": \"test\",\n    },\n)"
    },
    "clearObjects": {
      "default": "response = client.clear_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)"
    },
    "clearRules": {
      "default": "response = client.clear_rules(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)"
    },
    "clearSynonyms": {
      "default": "response = client.clear_synonyms(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)"
    },
    "customDelete": {
      "allow del method for a custom path with minimal parameters": "response = client.custom_delete(\n    path=\"test/minimal\",\n)",
      "allow del method for a custom path with all parameters": "response = client.custom_delete(\n    path=\"test/all\",\n    parameters={\n        \"query\": \"parameters\",\n    },\n)"
    },
    "customGet": {
      "allow get method for a custom path with minimal parameters": "response = client.custom_get(\n    path=\"test/minimal\",\n)",
      "allow get method for a custom path with all parameters": "response = client.custom_get(\n    path=\"test/all\",\n    parameters={\n        \"query\": \"parameters with space\",\n    },\n)",
      "requestOptions should be escaped too": "response = client.custom_get(\n    path=\"test/all\",\n    parameters={\n        \"query\": \"to be overriden\",\n    },\n    request_options={\n        \"headers\": loads(\"\"\"{\"x-header-1\":\"spaces are left alone\"}\"\"\"),\n        \"query_parameters\": loads(\n            \"\"\"{\"query\":\"parameters with space\",\"and an array\":[\"array\",\"with spaces\"]}\"\"\"\n        ),\n    },\n)"
    },
    "customPost": {
      "allow post method for a custom path with minimal parameters": "response = client.custom_post(\n    path=\"test/minimal\",\n)",
      "allow post method for a custom path with all parameters": "response = client.custom_post(\n    path=\"test/all\",\n    parameters={\n        \"query\": \"parameters\",\n    },\n    body={\n        \"body\": \"parameters\",\n    },\n)",
      "requestOptions can override default query parameters": "response = client.custom_post(\n    path=\"test/requestOptions\",\n    parameters={\n        \"query\": \"parameters\",\n    },\n    body={\n        \"facet\": \"filters\",\n    },\n    request_options={\n        \"query_parameters\": loads(\"\"\"{\"query\":\"myQueryParameter\"}\"\"\"),\n    },\n)",
      "requestOptions merges query parameters with default ones": "response = client.custom_post(\n    path=\"test/requestOptions\",\n    parameters={\n        \"query\": \"parameters\",\n    },\n    body={\n        \"facet\": \"filters\",\n    },\n    request_options={\n        \"query_parameters\": loads(\"\"\"{\"query2\":\"myQueryParameter\"}\"\"\"),\n    },\n)",
      "requestOptions can override default headers": "response = client.custom_post(\n    path=\"test/requestOptions\",\n    parameters={\n        \"query\": \"parameters\",\n    },\n    body={\n        \"facet\": \"filters\",\n    },\n    request_options={\n        \"headers\": loads(\"\"\"{\"x-algolia-api-key\":\"ALGOLIA_API_KEY\"}\"\"\"),\n    },\n)",
      "requestOptions merges headers with default ones": "response = client.custom_post(\n    path=\"test/requestOptions\",\n    parameters={\n        \"query\": \"parameters\",\n    },\n    body={\n        \"facet\": \"filters\",\n    },\n    request_options={\n        \"headers\": loads(\"\"\"{\"x-algolia-api-key\":\"ALGOLIA_API_KEY\"}\"\"\"),\n    },\n)",
      "requestOptions queryParameters accepts booleans": "response = client.custom_post(\n    path=\"test/requestOptions\",\n    parameters={\n        \"query\": \"parameters\",\n    },\n    body={\n        \"facet\": \"filters\",\n    },\n    request_options={\n        \"query_parameters\": loads(\"\"\"{\"isItWorking\":true}\"\"\"),\n    },\n)",
      "requestOptions queryParameters accepts integers": "response = client.custom_post(\n    path=\"test/requestOptions\",\n    parameters={\n        \"query\": \"parameters\",\n    },\n    body={\n        \"facet\": \"filters\",\n    },\n    request_options={\n        \"query_parameters\": loads(\"\"\"{\"myParam\":2}\"\"\"),\n    },\n)",
      "requestOptions queryParameters accepts list of string": "response = client.custom_post(\n    path=\"test/requestOptions\",\n    parameters={\n        \"query\": \"parameters\",\n    },\n    body={\n        \"facet\": \"filters\",\n    },\n    request_options={\n        \"query_parameters\": loads(\"\"\"{\"myParam\":[\"b and c\",\"d\"]}\"\"\"),\n    },\n)",
      "requestOptions queryParameters accepts list of booleans": "response = client.custom_post(\n    path=\"test/requestOptions\",\n    parameters={\n        \"query\": \"parameters\",\n    },\n    body={\n        \"facet\": \"filters\",\n    },\n    request_options={\n        \"query_parameters\": loads(\"\"\"{\"myParam\":[true,true,false]}\"\"\"),\n    },\n)",
      "requestOptions queryParameters accepts list of integers": "response = client.custom_post(\n    path=\"test/requestOptions\",\n    parameters={\n        \"query\": \"parameters\",\n    },\n    body={\n        \"facet\": \"filters\",\n    },\n    request_options={\n        \"query_parameters\": loads(\"\"\"{\"myParam\":[1,2]}\"\"\"),\n    },\n)"
    },
    "customPut": {
      "allow put method for a custom path with minimal parameters": "response = client.custom_put(\n    path=\"test/minimal\",\n)",
      "allow put method for a custom path with all parameters": "response = client.custom_put(\n    path=\"test/all\",\n    parameters={\n        \"query\": \"parameters\",\n    },\n    body={\n        \"body\": \"parameters\",\n    },\n)"
    },
    "deleteApiKey": {
      "default": "response = client.delete_api_key(\n    key=\"myTestApiKey\",\n)"
    },
    "deleteBy": {
      "default": "response = client.delete_by(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    delete_by_params={\n        \"filters\": \"brand:brandName\",\n    },\n)"
    },
    "deleteIndex": {
      "default": "response = client.delete_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)"
    },
    "deleteObject": {
      "default": "response = client.delete_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"uniqueID\",\n)"
    },
    "deleteObjects": {
      "default": "response = client.delete_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_ids=[\n        \"1\",\n        \"2\",\n    ],\n)"
    },
    "deleteRule": {
      "delete rule simple case": "response = client.delete_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"id1\",\n)",
      "delete rule with simple characters to encode in objectID": "response = client.delete_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"test/with/slash\",\n)"
    },
    "deleteSource": {
      "default": "response = client.delete_source(\n    source=\"theSource\",\n)"
    },
    "deleteSynonym": {
      "default": "response = client.delete_synonym(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"id1\",\n)"
    },
    "generateSecuredApiKey": {
      "api key basic": "response = client.generate_secured_api_key(\n    parent_api_key=\"2640659426d5107b6e47d75db9cbaef8\",\n    restrictions={\n        \"validUntil\": 2524604400,\n        \"restrictIndices\": [\n            \"Movies\",\n        ],\n    },\n)",
      "with searchParams": "response = client.generate_secured_api_key(\n    parent_api_key=\"2640659426d5107b6e47d75db9cbaef8\",\n    restrictions={\n        \"validUntil\": 2524604400,\n        \"restrictIndices\": [\n            \"Movies\",\n            \"cts_e2e_settings\",\n        ],\n        \"restrictSources\": \"192.168.1.0/24\",\n        \"filters\": \"category:Book OR category:Ebook AND _tags:published\",\n        \"userToken\": \"user123\",\n        \"searchParams\": {\n            \"query\": \"batman\",\n            \"typoTolerance\": \"strict\",\n            \"aroundRadius\": \"all\",\n            \"mode\": \"neuralSearch\",\n            \"hitsPerPage\": 10,\n            \"optionalWords\": [\n                \"one\",\n                \"two\",\n            ],\n        },\n    },\n)",
      "with filters": "response = client.generate_secured_api_key(\n    parent_api_key=\"2640659426d5107b6e47d75db9cbaef8\",\n    restrictions={\n        \"filters\": \"user:user42 AND user:public AND (visible_by:John OR visible_by:group/Finance)\",\n    },\n)",
      "with visible_by filter": "response = client.generate_secured_api_key(\n    parent_api_key=\"2640659426d5107b6e47d75db9cbaef8\",\n    restrictions={\n        \"filters\": \"visible_by:group/Finance\",\n    },\n)",
      "with userID": "response = client.generate_secured_api_key(\n    parent_api_key=\"2640659426d5107b6e47d75db9cbaef8\",\n    restrictions={\n        \"userToken\": \"user42\",\n    },\n)",
      "mcm with filters": "response = client.generate_secured_api_key(\n    parent_api_key=\"YourSearchOnlyApiKey\",\n    restrictions={\n        \"filters\": \"user:user42 AND user:public\",\n    },\n)",
      "mcm with user token": "response = client.generate_secured_api_key(\n    parent_api_key=\"YourSearchOnlyApiKey\",\n    restrictions={\n        \"userToken\": \"user42\",\n    },\n)"
    },
    "getApiKey": {
      "default": "response = client.get_api_key(\n    key=\"myTestApiKey\",\n)"
    },
    "getAppTask": {
      "default": "response = client.get_app_task(\n    task_id=123,\n)"
    },
    "getDictionaryLanguages": {
      "default": "response = client.get_dictionary_languages()"
    },
    "getDictionarySettings": {
      "default": "response = client.get_dictionary_settings()"
    },
    "getLogs": {
      "getLogs with minimal parameters": "response = client.get_logs()",
      "getLogs with parameters": "response = client.get_logs(\n    offset=5,\n    length=10,\n    index_name=\"<YOUR_INDEX_NAME>\",\n    type=\"all\",\n)"
    },
    "getObject": {
      "getObject": "response = client.get_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"uniqueID\",\n    attributes_to_retrieve=[\n        \"attr1\",\n        \"attr2\",\n    ],\n)",
      "search with a real object": "response = client.get_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"Batman and Robin\",\n)"
    },
    "getObjects": {
      "by ID": "response = client.get_objects(\n    get_objects_params={\n        \"requests\": [\n            {\n                \"objectID\": \"uniqueID\",\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n            },\n        ],\n    },\n)",
      "multiple IDs": "response = client.get_objects(\n    get_objects_params={\n        \"requests\": [\n            {\n                \"objectID\": \"uniqueID1\",\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n            },\n            {\n                \"objectID\": \"uniqueID2\",\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n            },\n        ],\n    },\n)",
      "with attributesToRetrieve": "response = client.get_objects(\n    get_objects_params={\n        \"requests\": [\n            {\n                \"attributesToRetrieve\": [\n                    \"attr1\",\n                    \"attr2\",\n                ],\n                \"objectID\": \"uniqueID\",\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n            },\n        ],\n    },\n)"
    },
    "getRule": {
      "default": "response = client.get_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"qr-1725004648916\",\n)"
    },
    "getSettings": {
      "default": "response = client.get_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)"
    },
    "getSources": {
      "default": "response = client.get_sources()"
    },
    "getSynonym": {
      "default": "response = client.get_synonym(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"id1\",\n)"
    },
    "getTask": {
      "default": "response = client.get_task(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    task_id=123,\n)"
    },
    "getTopUserIds": {
      "default": "response = client.get_top_user_ids()"
    },
    "getUserId": {
      "default": "response = client.get_user_id(\n    user_id=\"uniqueID\",\n)"
    },
    "hasPendingMappings": {
      "hasPendingMappings with minimal parameters": "response = client.has_pending_mappings()",
      "hasPendingMappings with parameters": "response = client.has_pending_mappings(\n    get_clusters=True,\n)"
    },
    "indexExists": {
      "indexExists": "response = client.index_exists(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)",
      "indexNotExists": "response = client.index_exists(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)",
      "indexExistsWithError": "response = client.index_exists(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)"
    },
    "listApiKeys": {
      "default": "response = client.list_api_keys()"
    },
    "listClusters": {
      "default": "response = client.list_clusters()"
    },
    "listIndices": {
      "listIndices with minimal parameters": "response = client.list_indices()",
      "listIndices with parameters": "response = client.list_indices(\n    page=8,\n    hits_per_page=3,\n)"
    },
    "listUserIds": {
      "listUserIds with minimal parameters": "response = client.list_user_ids()",
      "listUserIds with parameters": "response = client.list_user_ids(\n    page=8,\n    hits_per_page=100,\n)"
    },
    "multipleBatch": {
      "default": "response = client.multiple_batch(\n    batch_params={\n        \"requests\": [\n            {\n                \"action\": \"addObject\",\n                \"body\": {\n                    \"key\": \"value\",\n                },\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n            },\n        ],\n    },\n)"
    },
    "operationIndex": {
      "scopes": "response = client.operation_index(\n    index_name=\"<SOURCE_INDEX_NAME>\",\n    operation_index_params={\n        \"operation\": \"move\",\n        \"destination\": \"<DESTINATION_INDEX_NAME>\",\n        \"scope\": [\n            \"rules\",\n            \"settings\",\n        ],\n    },\n)",
      "copy": "response = client.operation_index(\n    index_name=\"<SOURCE_INDEX_NAME>\",\n    operation_index_params={\n        \"operation\": \"copy\",\n        \"destination\": \"<DESTINATION_INDEX_NAME>\",\n    },\n)",
      "move": "response = client.operation_index(\n    index_name=\"<SOURCE_INDEX_NAME>\",\n    operation_index_params={\n        \"operation\": \"move\",\n        \"destination\": \"<DESTINATION_INDEX_NAME>\",\n    },\n)"
    },
    "partialUpdateObject": {
      "Partial update with a new value for a string attribute": "response = client.partial_update_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"uniqueID\",\n    attributes_to_update={\n        \"attributeId\": \"new value\",\n    },\n)",
      "Partial update with a new value for an integer attribute": "response = client.partial_update_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"uniqueID\",\n    attributes_to_update={\n        \"attributeId\": 1,\n    },\n)",
      "Partial update with a new value for a boolean attribute": "response = client.partial_update_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"uniqueID\",\n    attributes_to_update={\n        \"attributeId\": True,\n    },\n)",
      "Partial update with a new value for an array attribute": "response = client.partial_update_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"uniqueID\",\n    attributes_to_update={\n        \"attributeId\": [\n            \"one\",\n            \"two\",\n            \"three\",\n        ],\n    },\n)",
      "Partial update with a new value for an object attribute": "response = client.partial_update_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"uniqueID\",\n    attributes_to_update={\n        \"attributeId\": {\n            \"nested\": \"value\",\n        },\n    },\n)",
      "with visible_by filter": "response = client.partial_update_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"uniqueID\",\n    attributes_to_update={\n        \"visible_by\": [\n            \"Angela\",\n            \"group/Finance\",\n            \"group/Shareholders\",\n        ],\n    },\n)",
      "add men pant": "response = client.partial_update_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"productId\",\n    attributes_to_update={\n        \"categoryPageId\": {\n            \"_operation\": \"Add\",\n            \"value\": \"men-clothing-pants\",\n        },\n    },\n)",
      "remove men pant": "response = client.partial_update_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"productId\",\n    attributes_to_update={\n        \"categoryPageId\": {\n            \"_operation\": \"Remove\",\n            \"value\": \"men-clothing-pants\",\n        },\n    },\n)"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "response = client.partial_update_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    objects=[\n        {\n            \"objectID\": \"1\",\n            \"name\": \"Adam\",\n        },\n        {\n            \"objectID\": \"2\",\n            \"name\": \"Benoit\",\n        },\n    ],\n    create_if_not_exists=True,\n)",
      "call partialUpdateObjects with createIfNotExists=false": "response = client.partial_update_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    objects=[\n        {\n            \"objectID\": \"3\",\n            \"name\": \"Cyril\",\n        },\n        {\n            \"objectID\": \"4\",\n            \"name\": \"David\",\n        },\n    ],\n    create_if_not_exists=False,\n)"
    },
    "removeUserId": {
      "default": "response = client.remove_user_id(\n    user_id=\"uniqueID\",\n)"
    },
    "replaceAllObjects": {
      "call replaceAllObjects without error": "response = client.replace_all_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    objects=[\n        {\n            \"objectID\": \"1\",\n            \"name\": \"Adam\",\n        },\n        {\n            \"objectID\": \"2\",\n            \"name\": \"Benoit\",\n        },\n        {\n            \"objectID\": \"3\",\n            \"name\": \"Cyril\",\n        },\n        {\n            \"objectID\": \"4\",\n            \"name\": \"David\",\n        },\n        {\n            \"objectID\": \"5\",\n            \"name\": \"Eva\",\n        },\n        {\n            \"objectID\": \"6\",\n            \"name\": \"Fiona\",\n        },\n        {\n            \"objectID\": \"7\",\n            \"name\": \"Gael\",\n        },\n        {\n            \"objectID\": \"8\",\n            \"name\": \"Hugo\",\n        },\n        {\n            \"objectID\": \"9\",\n            \"name\": \"Igor\",\n        },\n        {\n            \"objectID\": \"10\",\n            \"name\": \"Julia\",\n        },\n    ],\n    batch_size=3,\n)",
      "call replaceAllObjects with partial scopes": "response = client.replace_all_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    objects=[\n        {\n            \"objectID\": \"1\",\n            \"name\": \"Adam\",\n        },\n        {\n            \"objectID\": \"2\",\n            \"name\": \"Benoit\",\n        },\n    ],\n    batch_size=77,\n    scopes=[\n        \"settings\",\n        \"synonyms\",\n    ],\n)",
      "replaceAllObjects should cleanup on failure": "response = client.replace_all_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    objects=[\n        {\n            \"objectID\": \"fine\",\n            \"body\": \"small obj\",\n        },\n        {\n            \"objectID\": \"toolarge\",\n            \"body\": \"something bigger than 10KB\",\n        },\n    ],\n)"
    },
    "replaceSources": {
      "default": "response = client.replace_sources(\n    source=[\n        {\n            \"source\": \"theSource\",\n            \"description\": \"theDescription\",\n        },\n    ],\n)"
    },
    "restoreApiKey": {
      "default": "response = client.restore_api_key(\n    key=\"ALGOLIA_API_KEY\",\n)"
    },
    "saveObject": {
      "default": "response = client.save_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    body={\n        \"name\": \"Black T-shirt\",\n        \"color\": \"#000000||black\",\n        \"availableIn\": \"https://source.unsplash.com/100x100/?paris||Paris\",\n        \"objectID\": \"myID\",\n    },\n)"
    },
    "saveObjects": {
      "call saveObjects without error": "response = client.save_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    objects=[\n        {\n            \"objectID\": \"1\",\n            \"name\": \"Adam\",\n        },\n        {\n            \"objectID\": \"2\",\n            \"name\": \"Benoit\",\n        },\n    ],\n)",
      "saveObjects should report errors": "response = client.save_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    objects=[\n        {\n            \"objectID\": \"1\",\n            \"name\": \"Adam\",\n        },\n        {\n            \"objectID\": \"2\",\n            \"name\": \"Benoit\",\n        },\n    ],\n)",
      "saveObjectsPlaylist": "response = client.save_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    objects=[\n        {\n            \"objectID\": \"1\",\n            \"visibility\": \"public\",\n            \"name\": \"Hot 100 Billboard Charts\",\n            \"playlistId\": \"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\",\n            \"createdAt\": \"1500240452\",\n        },\n    ],\n)",
      "saveObjectsPublicUser": "response = client.save_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    objects=[\n        {\n            \"objectID\": \"1\",\n            \"visibility\": \"public\",\n            \"name\": \"Hot 100 Billboard Charts\",\n            \"playlistId\": \"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\",\n            \"createdAt\": \"1500240452\",\n        },\n    ],\n    wait_for_tasks=False,\n    batch_size=1000,\n    request_options={\n        \"headers\": loads(\"\"\"{\"X-Algolia-User-ID\":\"*\"}\"\"\"),\n    },\n)"
    },
    "saveRule": {
      "saveRule with minimal parameters": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"id1\",\n    rule={\n        \"objectID\": \"id1\",\n        \"conditions\": [\n            {\n                \"pattern\": \"apple\",\n                \"anchoring\": \"contains\",\n            },\n        ],\n        \"consequence\": {\n            \"params\": {\n                \"filters\": \"brand:xiaomi\",\n            },\n        },\n    },\n)",
      "saveRule with all parameters": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"id1\",\n    rule={\n        \"objectID\": \"id1\",\n        \"conditions\": [\n            {\n                \"pattern\": \"apple\",\n                \"anchoring\": \"contains\",\n                \"alternatives\": False,\n                \"context\": \"search\",\n            },\n        ],\n        \"consequence\": {\n            \"params\": {\n                \"filters\": \"brand:apple\",\n                \"query\": {\n                    \"remove\": [\n                        \"algolia\",\n                    ],\n                    \"edits\": [\n                        {\n                            \"type\": \"remove\",\n                            \"delete\": \"abc\",\n                            \"insert\": \"cde\",\n                        },\n                        {\n                            \"type\": \"replace\",\n                            \"delete\": \"abc\",\n                            \"insert\": \"cde\",\n                        },\n                    ],\n                },\n            },\n            \"hide\": [\n                {\n                    \"objectID\": \"321\",\n                },\n            ],\n            \"filterPromotes\": False,\n            \"userData\": {\n                \"algolia\": \"aloglia\",\n            },\n            \"promote\": [\n                {\n                    \"objectID\": \"abc\",\n                    \"position\": 3,\n                },\n                {\n                    \"objectIDs\": [\n                        \"abc\",\n                        \"def\",\n                    ],\n                    \"position\": 1,\n                },\n            ],\n        },\n        \"description\": \"test\",\n        \"enabled\": True,\n        \"validity\": [\n            {\n                \"from\": 1656670273,\n                \"until\": 1656670277,\n            },\n        ],\n    },\n    forward_to_replicas=True,\n)",
      "b2b catalog": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"article-rule\",\n    rule={\n        \"objectID\": \"article-rule\",\n        \"conditions\": [\n            {\n                \"pattern\": \"article\",\n                \"anchoring\": \"startsWith\",\n            },\n        ],\n        \"consequence\": {\n            \"params\": {\n                \"query\": {\n                    \"edits\": [\n                        {\n                            \"type\": \"remove\",\n                            \"delete\": \"article\",\n                        },\n                    ],\n                },\n                \"restrictSearchableAttributes\": [\n                    \"title\",\n                    \"book_id\",\n                ],\n            },\n        },\n    },\n)",
      "merchandising and promoting": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"director-rule\",\n    rule={\n        \"objectID\": \"director-rule\",\n        \"conditions\": [\n            {\n                \"pattern\": \"{facet:director} director\",\n                \"anchoring\": \"contains\",\n            },\n        ],\n        \"consequence\": {\n            \"params\": {\n                \"restrictSearchableAttributes\": [\n                    \"title\",\n                    \"book_id\",\n                ],\n                \"automaticFacetFilters\": [\n                    {\n                        \"facet\": \"director\",\n                    },\n                ],\n                \"query\": {\n                    \"edits\": [\n                        {\n                            \"type\": \"remove\",\n                            \"delete\": \"director\",\n                        },\n                    ],\n                },\n            },\n        },\n    },\n)",
      "harry potter": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"harry-potter-rule\",\n    rule={\n        \"objectID\": \"harry-potter-rule\",\n        \"conditions\": [\n            {\n                \"pattern\": \"harry potter\",\n                \"anchoring\": \"contains\",\n            },\n        ],\n        \"consequence\": {\n            \"userData\": {\n                \"promo_content\": \"20% OFF on all Harry Potter books!\",\n            },\n        },\n    },\n)",
      "merchandising empty query": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"clearance-category-filter\",\n    rule={\n        \"objectID\": \"clearance-category-filter\",\n        \"conditions\": [\n            {\n                \"pattern\": \"\",\n                \"anchoring\": \"is\",\n                \"context\": \"landing\",\n            },\n        ],\n        \"consequence\": {\n            \"params\": {\n                \"optionalFilters\": \"clearance:true\",\n            },\n        },\n    },\n)",
      "redirect": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"redirect-help-rule\",\n    rule={\n        \"objectID\": \"redirect-help-rule\",\n        \"conditions\": [\n            {\n                \"pattern\": \"help\",\n                \"anchoring\": \"contains\",\n            },\n        ],\n        \"consequence\": {\n            \"userData\": {\n                \"redirect\": \"https://www.algolia.com/support\",\n            },\n        },\n    },\n)",
      "promote some results over others": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"tomato-fruit\",\n    rule={\n        \"objectID\": \"tomato-fruit\",\n        \"conditions\": [\n            {\n                \"pattern\": \"tomato\",\n                \"anchoring\": \"contains\",\n            },\n        ],\n        \"consequence\": {\n            \"params\": {\n                \"optionalFilters\": \"food_group:fruit\",\n            },\n        },\n    },\n)",
      "promote several hits": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"Promote-Apple-Newest\",\n    rule={\n        \"objectID\": \"Promote-Apple-Newest\",\n        \"conditions\": [\n            {\n                \"pattern\": \"apple\",\n                \"anchoring\": \"is\",\n            },\n        ],\n        \"consequence\": {\n            \"promote\": [\n                {\n                    \"objectIDs\": [\n                        \"iPhone-12345\",\n                        \"watch-123\",\n                    ],\n                    \"position\": 0,\n                },\n            ],\n        },\n    },\n)",
      "promote newest release": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"Promote-iPhone-X\",\n    rule={\n        \"objectID\": \"Promote-iPhone-X\",\n        \"conditions\": [\n            {\n                \"pattern\": \"iPhone\",\n                \"anchoring\": \"contains\",\n            },\n        ],\n        \"consequence\": {\n            \"promote\": [\n                {\n                    \"objectID\": \"iPhone-12345\",\n                    \"position\": 0,\n                },\n            ],\n        },\n    },\n)",
      "promote single item": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"promote-harry-potter-box-set\",\n    rule={\n        \"objectID\": \"promote-harry-potter-box-set\",\n        \"conditions\": [\n            {\n                \"pattern\": \"Harry Potter\",\n                \"anchoring\": \"contains\",\n            },\n        ],\n        \"consequence\": {\n            \"promote\": [\n                {\n                    \"objectID\": \"HP-12345\",\n                    \"position\": 0,\n                },\n            ],\n        },\n    },\n)",
      "limit search results": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"article-rule\",\n    rule={\n        \"objectID\": \"article-rule\",\n        \"conditions\": [\n            {\n                \"pattern\": \"article\",\n                \"anchoring\": \"startsWith\",\n            },\n        ],\n        \"consequence\": {\n            \"params\": {\n                \"query\": {\n                    \"edits\": [\n                        {\n                            \"type\": \"remove\",\n                            \"delete\": \"article\",\n                        },\n                    ],\n                },\n                \"restrictSearchableAttributes\": [\n                    \"title\",\n                    \"book_id\",\n                ],\n            },\n        },\n    },\n)",
      "query match": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"tagged-brand-rule\",\n    rule={\n        \"conditions\": [\n            {\n                \"pattern\": \"brand: {facet:brand}\",\n                \"anchoring\": \"contains\",\n                \"alternatives\": False,\n            },\n        ],\n        \"consequence\": {\n            \"params\": {\n                \"automaticFacetFilters\": [\n                    {\n                        \"facet\": \"brand\",\n                    },\n                ],\n                \"query\": {\n                    \"remove\": [\n                        \"brand:\",\n                        \"{facet:brand}\",\n                    ],\n                },\n            },\n        },\n        \"description\": \"filter on brand: {brand}\",\n        \"objectID\": \"tagged-brand-rule\",\n    },\n)",
      "dynamic filtering": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"color-facets\",\n    rule={\n        \"objectID\": \"color-facets\",\n        \"conditions\": [\n            {\n                \"pattern\": \"{facet:color}\",\n            },\n        ],\n        \"consequence\": {\n            \"params\": {\n                \"automaticFacetFilters\": [\n                    {\n                        \"facet\": \"color\",\n                    },\n                ],\n            },\n        },\n    },\n)",
      "hide hits": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"hide-12345\",\n    rule={\n        \"objectID\": \"hide-12345\",\n        \"conditions\": [\n            {\n                \"pattern\": \"cheap\",\n                \"anchoring\": \"contains\",\n            },\n        ],\n        \"consequence\": {\n            \"hide\": [\n                {\n                    \"objectID\": \"to-hide-12345\",\n                },\n            ],\n        },\n    },\n)",
      "one rule per facet": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"red-color\",\n    rule={\n        \"objectID\": \"red-color\",\n        \"conditions\": [\n            {\n                \"pattern\": \"red\",\n                \"anchoring\": \"contains\",\n            },\n        ],\n        \"consequence\": {\n            \"params\": {\n                \"query\": {\n                    \"remove\": [\n                        \"red\",\n                    ],\n                },\n                \"filters\": \"color:red\",\n            },\n        },\n    },\n)",
      "numerical filters": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"cheap\",\n    rule={\n        \"objectID\": \"cheap\",\n        \"conditions\": [\n            {\n                \"pattern\": \"cheap\",\n                \"anchoring\": \"contains\",\n            },\n        ],\n        \"consequence\": {\n            \"params\": {\n                \"query\": {\n                    \"remove\": [\n                        \"cheap\",\n                    ],\n                },\n                \"filters\": \"price < 10\",\n            },\n        },\n    },\n)",
      "negative filters": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"gluten-free-rule\",\n    rule={\n        \"objectID\": \"gluten-free-rule\",\n        \"conditions\": [\n            {\n                \"pattern\": \"gluten-free\",\n                \"anchoring\": \"contains\",\n            },\n        ],\n        \"consequence\": {\n            \"params\": {\n                \"filters\": \"NOT allergens:gluten\",\n                \"query\": {\n                    \"edits\": [\n                        {\n                            \"type\": \"remove\",\n                            \"delete\": \"gluten-free\",\n                        },\n                    ],\n                },\n            },\n        },\n    },\n)",
      "positive filters": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"diet-rule\",\n    rule={\n        \"objectID\": \"diet-rule\",\n        \"conditions\": [\n            {\n                \"pattern\": \"diet\",\n                \"anchoring\": \"contains\",\n            },\n        ],\n        \"consequence\": {\n            \"params\": {\n                \"filters\": \"'low-carb' OR 'low-fat'\",\n                \"query\": {\n                    \"edits\": [\n                        {\n                            \"type\": \"remove\",\n                            \"delete\": \"diet\",\n                        },\n                    ],\n                },\n            },\n        },\n    },\n)",
      "conditionless": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"diet-rule\",\n    rule={\n        \"objectID\": \"diet-rule\",\n        \"consequence\": {\n            \"params\": {\n                \"filters\": \"'low-carb' OR 'low-fat'\",\n                \"query\": {\n                    \"edits\": [\n                        {\n                            \"type\": \"remove\",\n                            \"delete\": \"diet\",\n                        },\n                    ],\n                },\n            },\n        },\n    },\n)",
      "contextual": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"a-rule-id\",\n    rule={\n        \"objectID\": \"a-rule-id\",\n        \"conditions\": [\n            {\n                \"context\": \"mobile\",\n            },\n        ],\n        \"consequence\": {\n            \"params\": {\n                \"filters\": \"release_date >= 1577836800\",\n            },\n        },\n    },\n)",
      "saveRule always active rule": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"a-rule-id\",\n    rule={\n        \"objectID\": \"a-rule-id\",\n        \"consequence\": {\n            \"params\": {\n                \"aroundRadius\": 1000,\n            },\n        },\n        \"validity\": [\n            {\n                \"from\": 1577836800,\n                \"until\": 1577836800,\n            },\n        ],\n    },\n)"
    },
    "saveRules": {
      "saveRules with minimal parameters": "response = client.save_rules(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    rules=[\n        {\n            \"objectID\": \"a-rule-id\",\n            \"conditions\": [\n                {\n                    \"pattern\": \"smartphone\",\n                    \"anchoring\": \"contains\",\n                },\n            ],\n            \"consequence\": {\n                \"params\": {\n                    \"filters\": \"brand:apple\",\n                },\n            },\n        },\n        {\n            \"objectID\": \"a-second-rule-id\",\n            \"conditions\": [\n                {\n                    \"pattern\": \"apple\",\n                    \"anchoring\": \"contains\",\n                },\n            ],\n            \"consequence\": {\n                \"params\": {\n                    \"filters\": \"brand:samsung\",\n                },\n            },\n        },\n    ],\n    forward_to_replicas=False,\n    clear_existing_rules=True,\n)",
      "saveRules with all parameters": "response = client.save_rules(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    rules=[\n        {\n            \"objectID\": \"id1\",\n            \"conditions\": [\n                {\n                    \"pattern\": \"apple\",\n                    \"anchoring\": \"contains\",\n                    \"alternatives\": False,\n                    \"context\": \"search\",\n                },\n            ],\n            \"consequence\": {\n                \"params\": {\n                    \"filters\": \"brand:apple\",\n                    \"query\": {\n                        \"remove\": [\n                            \"algolia\",\n                        ],\n                        \"edits\": [\n                            {\n                                \"type\": \"remove\",\n                                \"delete\": \"abc\",\n                                \"insert\": \"cde\",\n                            },\n                            {\n                                \"type\": \"replace\",\n                                \"delete\": \"abc\",\n                                \"insert\": \"cde\",\n                            },\n                        ],\n                    },\n                },\n                \"hide\": [\n                    {\n                        \"objectID\": \"321\",\n                    },\n                ],\n                \"filterPromotes\": False,\n                \"userData\": {\n                    \"algolia\": \"aloglia\",\n                },\n                \"promote\": [\n                    {\n                        \"objectID\": \"abc\",\n                        \"position\": 3,\n                    },\n                    {\n                        \"objectIDs\": [\n                            \"abc\",\n                            \"def\",\n                        ],\n                        \"position\": 1,\n                    },\n                ],\n            },\n            \"description\": \"test\",\n            \"enabled\": True,\n            \"validity\": [\n                {\n                    \"from\": 1656670273,\n                    \"until\": 1656670277,\n                },\n            ],\n        },\n    ],\n    forward_to_replicas=True,\n    clear_existing_rules=True,\n)",
      "dynamic filtering": "response = client.save_rules(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    rules=[\n        {\n            \"objectID\": \"toaster\",\n            \"conditions\": [\n                {\n                    \"pattern\": \"toaster\",\n                    \"anchoring\": \"contains\",\n                },\n            ],\n            \"consequence\": {\n                \"params\": {\n                    \"query\": {\n                        \"remove\": [\n                            \"toaster\",\n                        ],\n                    },\n                    \"filters\": \"product_type:toaster\",\n                },\n            },\n        },\n        {\n            \"objectID\": \"cheap\",\n            \"conditions\": [\n                {\n                    \"pattern\": \"cheap\",\n                    \"anchoring\": \"contains\",\n                },\n            ],\n            \"consequence\": {\n                \"params\": {\n                    \"query\": {\n                        \"remove\": [\n                            \"cheap\",\n                        ],\n                    },\n                    \"filters\": \"price < 15\",\n                },\n            },\n        },\n    ],\n)",
      "enhance search results": "response = client.save_rules(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    rules=[\n        {\n            \"objectID\": \"country\",\n            \"conditions\": [\n                {\n                    \"pattern\": \"{facet:country}\",\n                    \"anchoring\": \"contains\",\n                },\n            ],\n            \"consequence\": {\n                \"params\": {\n                    \"aroundLatLngViaIP\": False,\n                },\n            },\n        },\n        {\n            \"objectID\": \"city\",\n            \"conditions\": [\n                {\n                    \"pattern\": \"{facet:city}\",\n                    \"anchoring\": \"contains\",\n                },\n            ],\n            \"consequence\": {\n                \"params\": {\n                    \"aroundLatLngViaIP\": False,\n                },\n            },\n        },\n    ],\n)"
    },
    "saveSynonym": {
      "default": "response = client.save_synonym(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"id1\",\n    synonym_hit={\n        \"objectID\": \"id1\",\n        \"type\": \"synonym\",\n        \"synonyms\": [\n            \"car\",\n            \"vehicule\",\n            \"auto\",\n        ],\n    },\n    forward_to_replicas=True,\n)"
    },
    "saveSynonyms": {
      "default": "response = client.save_synonyms(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    synonym_hit=[\n        {\n            \"objectID\": \"id1\",\n            \"type\": \"synonym\",\n            \"synonyms\": [\n                \"car\",\n                \"vehicule\",\n                \"auto\",\n            ],\n        },\n        {\n            \"objectID\": \"id2\",\n            \"type\": \"onewaysynonym\",\n            \"input\": \"iphone\",\n            \"synonyms\": [\n                \"ephone\",\n                \"aphone\",\n                \"yphone\",\n            ],\n        },\n    ],\n    forward_to_replicas=True,\n    replace_existing_synonyms=True,\n)"
    },
    "search": {
      "withHitsPerPage": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"query\": \"<YOUR_QUERY>\",\n                \"hitsPerPage\": 50,\n            },\n        ],\n    },\n)",
      "filterOnly": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"query\": \"<YOUR_QUERY>\",\n                \"filters\": \"actor:Scarlett Johansson\",\n            },\n        ],\n    },\n)",
      "filterOr": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"query\": \"<YOUR_QUERY>\",\n                \"filters\": \"actor:Tom Cruise OR actor:Scarlett Johansson\",\n            },\n        ],\n    },\n)",
      "filterNot": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"query\": \"<YOUR_QUERY>\",\n                \"filters\": \"NOT actor:Nicolas Cage\",\n            },\n        ],\n    },\n)",
      "search for a single hits request with minimal parameters": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n            },\n        ],\n    },\n)",
      "search with highlight and snippet results": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"query\": \"vim\",\n                \"attributesToSnippet\": [\n                    \"*:20\",\n                ],\n                \"attributesToHighlight\": [\n                    \"*\",\n                ],\n                \"attributesToRetrieve\": [\n                    \"*\",\n                ],\n            },\n        ],\n    },\n)",
      "retrieveFacets": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"query\": \"<YOUR_QUERY>\",\n                \"facets\": [\n                    \"author\",\n                    \"genre\",\n                ],\n            },\n        ],\n    },\n)",
      "retrieveFacetsWildcard": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"query\": \"<YOUR_QUERY>\",\n                \"facets\": [\n                    \"*\",\n                ],\n            },\n        ],\n    },\n)",
      "search for a single facet request with minimal parameters": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"type\": \"facet\",\n                \"facet\": \"editor\",\n            },\n        ],\n        \"strategy\": \"stopIfEnoughMatches\",\n    },\n)",
      "search for a single hits request with all parameters": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"query\": \"myQuery\",\n                \"hitsPerPage\": 50,\n                \"type\": \"default\",\n            },\n        ],\n    },\n)",
      "search for a single facet request with all parameters": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"type\": \"facet\",\n                \"facet\": \"theFacet\",\n                \"facetQuery\": \"theFacetQuery\",\n                \"query\": \"theQuery\",\n                \"maxFacetHits\": 50,\n            },\n        ],\n        \"strategy\": \"stopIfEnoughMatches\",\n    },\n)",
      "search for multiple mixed requests in multiple indices with minimal parameters": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n            },\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"type\": \"facet\",\n                \"facet\": \"theFacet\",\n            },\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"type\": \"default\",\n            },\n        ],\n        \"strategy\": \"stopIfEnoughMatches\",\n    },\n)",
      "search for multiple mixed requests in multiple indices with all parameters": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"type\": \"facet\",\n                \"facet\": \"theFacet\",\n                \"facetQuery\": \"theFacetQuery\",\n                \"query\": \"theQuery\",\n                \"maxFacetHits\": 50,\n            },\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"query\": \"myQuery\",\n                \"hitsPerPage\": 50,\n                \"type\": \"default\",\n            },\n        ],\n        \"strategy\": \"stopIfEnoughMatches\",\n    },\n)",
      "search filters accept all of the possible shapes": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"facetFilters\": \"mySearch:filters\",\n                \"reRankingApplyFilter\": \"mySearch:filters\",\n                \"tagFilters\": \"mySearch:filters\",\n                \"numericFilters\": \"mySearch:filters\",\n                \"optionalFilters\": \"mySearch:filters\",\n            },\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"facetFilters\": [\n                    \"mySearch:filters\",\n                    [\n                        \"mySearch:filters\",\n                        [\n                            \"mySearch:filters\",\n                        ],\n                    ],\n                ],\n                \"reRankingApplyFilter\": [\n                    \"mySearch:filters\",\n                    [\n                        \"mySearch:filters\",\n                    ],\n                ],\n                \"tagFilters\": [\n                    \"mySearch:filters\",\n                    [\n                        \"mySearch:filters\",\n                    ],\n                ],\n                \"numericFilters\": [\n                    \"mySearch:filters\",\n                    [\n                        \"mySearch:filters\",\n                    ],\n                ],\n                \"optionalFilters\": [\n                    \"mySearch:filters\",\n                    [\n                        \"mySearch:filters\",\n                    ],\n                ],\n            },\n        ],\n    },\n)",
      "search filters end to end": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"filters\": \"editor:'visual studio' OR editor:neovim\",\n            },\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"facetFilters\": [\n                    \"editor:'visual studio'\",\n                    \"editor:neovim\",\n                ],\n            },\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"facetFilters\": [\n                    \"editor:'visual studio'\",\n                    [\n                        \"editor:neovim\",\n                    ],\n                ],\n            },\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"facetFilters\": [\n                    \"editor:'visual studio'\",\n                    [\n                        \"editor:neovim\",\n                        [\n                            \"editor:goland\",\n                        ],\n                    ],\n                ],\n            },\n        ],\n    },\n)",
      "search with all search parameters": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"advancedSyntax\": True,\n                \"advancedSyntaxFeatures\": [\n                    \"exactPhrase\",\n                ],\n                \"allowTyposOnNumericTokens\": True,\n                \"alternativesAsExact\": [\n                    \"multiWordsSynonym\",\n                ],\n                \"analytics\": True,\n                \"analyticsTags\": [\n                    \"\",\n                ],\n                \"aroundLatLng\": \"\",\n                \"aroundLatLngViaIP\": True,\n                \"aroundPrecision\": 0,\n                \"aroundRadius\": \"all\",\n                \"attributeCriteriaComputedByMinProximity\": True,\n                \"attributesToHighlight\": [\n                    \"\",\n                ],\n                \"attributesToRetrieve\": [\n                    \"\",\n                ],\n                \"attributesToSnippet\": [\n                    \"\",\n                ],\n                \"clickAnalytics\": True,\n                \"decompoundQuery\": True,\n                \"disableExactOnAttributes\": [\n                    \"\",\n                ],\n                \"disableTypoToleranceOnAttributes\": [\n                    \"\",\n                ],\n                \"distinct\": 0,\n                \"enableABTest\": True,\n                \"enablePersonalization\": True,\n                \"enableReRanking\": True,\n                \"enableRules\": True,\n                \"exactOnSingleWordQuery\": \"attribute\",\n                \"facetFilters\": [\n                    \"\",\n                ],\n                \"facetingAfterDistinct\": True,\n                \"facets\": [\n                    \"\",\n                ],\n                \"filters\": \"\",\n                \"getRankingInfo\": True,\n                \"highlightPostTag\": \"\",\n                \"highlightPreTag\": \"\",\n                \"hitsPerPage\": 1,\n                \"ignorePlurals\": False,\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"insideBoundingBox\": [\n                    [\n                        47.3165,\n                        4.9665,\n                        47.3424,\n                        5.0201,\n                    ],\n                    [\n                        40.9234,\n                        2.1185,\n                        38.643,\n                        1.9916,\n                    ],\n                ],\n                \"insidePolygon\": [\n                    [\n                        47.3165,\n                        4.9665,\n                        47.3424,\n                        5.0201,\n                        47.32,\n                        4.9,\n                    ],\n                    [\n                        40.9234,\n                        2.1185,\n                        38.643,\n                        1.9916,\n                        39.2587,\n                        2.0104,\n                    ],\n                ],\n                \"length\": 1,\n                \"maxValuesPerFacet\": 0,\n                \"minProximity\": 1,\n                \"minWordSizefor1Typo\": 0,\n                \"minWordSizefor2Typos\": 0,\n                \"minimumAroundRadius\": 1,\n                \"naturalLanguages\": [\n                    \"fr\",\n                ],\n                \"numericFilters\": [\n                    \"\",\n                ],\n                \"offset\": 0,\n                \"optionalFilters\": [\n                    \"\",\n                ],\n                \"optionalWords\": [\n                    \"\",\n                ],\n                \"page\": 0,\n                \"percentileComputation\": True,\n                \"personalizationImpact\": 0,\n                \"query\": \"\",\n                \"queryLanguages\": [\n                    \"fr\",\n                ],\n                \"queryType\": \"prefixAll\",\n                \"ranking\": [\n                    \"\",\n                ],\n                \"reRankingApplyFilter\": [\n                    \"\",\n                ],\n                \"relevancyStrictness\": 0,\n                \"removeStopWords\": True,\n                \"removeWordsIfNoResults\": \"allOptional\",\n                \"renderingContent\": {\n                    \"facetOrdering\": {\n                        \"facets\": {\n                            \"order\": [\n                                \"a\",\n                                \"b\",\n                            ],\n                        },\n                        \"values\": {\n                            \"a\": {\n                                \"order\": [\n                                    \"b\",\n                                ],\n                                \"sortRemainingBy\": \"count\",\n                            },\n                        },\n                    },\n                },\n                \"replaceSynonymsInHighlight\": True,\n                \"responseFields\": [\n                    \"\",\n                ],\n                \"restrictHighlightAndSnippetArrays\": True,\n                \"restrictSearchableAttributes\": [\n                    \"\",\n                ],\n                \"ruleContexts\": [\n                    \"\",\n                ],\n                \"similarQuery\": \"\",\n                \"snippetEllipsisText\": \"\",\n                \"sortFacetValuesBy\": \"\",\n                \"sumOrFiltersScores\": True,\n                \"synonyms\": True,\n                \"tagFilters\": [\n                    \"\",\n                ],\n                \"type\": \"default\",\n                \"typoTolerance\": \"min\",\n                \"userToken\": \"\",\n            },\n        ],\n    },\n)"
    },
    "searchDictionaryEntries": {
      "get searchDictionaryEntries results with minimal parameters": "response = client.search_dictionary_entries(\n    dictionary_name=\"stopwords\",\n    search_dictionary_entries_params={\n        \"query\": \"about\",\n    },\n)",
      "get searchDictionaryEntries results with all parameters": "response = client.search_dictionary_entries(\n    dictionary_name=\"compounds\",\n    search_dictionary_entries_params={\n        \"query\": \"foo\",\n        \"page\": 4,\n        \"hitsPerPage\": 2,\n        \"language\": \"fr\",\n    },\n)"
    },
    "searchForFacetValues": {
      "get searchForFacetValues results with minimal parameters": "response = client.search_for_facet_values(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    facet_name=\"facetName\",\n)",
      "get searchForFacetValues results with all parameters": "response = client.search_for_facet_values(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    facet_name=\"facetName\",\n    search_for_facet_values_request={\n        \"params\": \"query=foo&facetFilters=['bar']\",\n        \"facetQuery\": \"foo\",\n        \"maxFacetHits\": 42,\n    },\n)",
      "facetName and facetQuery": "response = client.search_for_facet_values(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    facet_name=\"author\",\n    search_for_facet_values_request={\n        \"facetQuery\": \"stephen\",\n    },\n)"
    },
    "searchRules": {
      "default": "response = client.search_rules(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_rules_params={\n        \"query\": \"zorro\",\n    },\n)"
    },
    "searchSingleIndex": {
      "search with minimal parameters": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)",
      "search with special characters in indexName": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)",
      "search with searchParams": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"myQuery\",\n        \"facetFilters\": [\n            \"tags:algolia\",\n        ],\n    },\n)",
      "single search retrieve snippets": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"batman mask of the phantasm\",\n        \"attributesToRetrieve\": [\n            \"*\",\n        ],\n        \"attributesToSnippet\": [\n            \"*:20\",\n        ],\n    },\n)",
      "query": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"phone\",\n    },\n)",
      "filters": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"filters\": \"country:US AND price.gross < 2.0\",\n    },\n)",
      "filters for stores": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"ben\",\n        \"filters\": \"categories:politics AND store:Gibert Joseph Saint-Michel\",\n    },\n)",
      "filters boolean": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"filters\": \"is_available:true\",\n    },\n)",
      "distinct": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"distinct\": True,\n    },\n)",
      "filtersNumeric": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"filters\": \"price < 10\",\n    },\n)",
      "filtersTimestamp": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"filters\": \"NOT date_timestamp:1514764800 TO 1546300799\",\n    },\n)",
      "filtersSumOrFiltersScoresFalse": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"filters\": \"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\",\n        \"sumOrFiltersScores\": False,\n    },\n)",
      "filtersSumOrFiltersScoresTrue": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"filters\": \"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\",\n        \"sumOrFiltersScores\": True,\n    },\n)",
      "filtersStephenKing": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"filters\": 'author:\"Stephen King\"',\n    },\n)",
      "filtersNotTags": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"harry\",\n        \"filters\": \"_tags:non-fiction\",\n    },\n)",
      "facetFiltersList": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"facetFilters\": [\n            \"publisher:Penguin\",\n            [\n                \"author:Stephen King\",\n                \"genre:Horror\",\n            ],\n        ],\n    },\n)",
      "facetFiltersBook": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"facetFilters\": [\n            \"category:Book\",\n        ],\n    },\n)",
      "facetFiltersAND": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"facetFilters\": [\n            \"category:Book\",\n            \"author:John Doe\",\n        ],\n    },\n)",
      "facetFiltersOR": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"facetFilters\": [\n            [\n                \"category:Book\",\n                \"author:John Doe\",\n            ],\n        ],\n    },\n)",
      "facetFiltersCombined": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"facetFilters\": [\n            \"author:John Doe\",\n            [\n                \"category:Book\",\n                \"category:Movie\",\n            ],\n        ],\n    },\n)",
      "facetFiltersNeg": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"facetFilters\": \"category:-Ebook\",\n    },\n)",
      "filtersAndFacetFilters": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"filters\": '(author:\"Stephen King\" OR genre:\"Horror\")',\n        \"facetFilters\": [\n            \"publisher:Penguin\",\n        ],\n    },\n)",
      "facet author genre": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"facets\": [\n            \"author\",\n            \"genre\",\n        ],\n    },\n)",
      "facet wildcard": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"facets\": [\n            \"*\",\n        ],\n    },\n)",
      "maxValuesPerFacet": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"maxValuesPerFacet\": 1000,\n    },\n)",
      "aroundLatLng": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"aroundLatLng\": \"40.71, -74.01\",\n    },\n)",
      "aroundLatLngViaIP": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"aroundLatLngViaIP\": True,\n    },\n)",
      "aroundRadius": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"aroundLatLng\": \"40.71, -74.01\",\n        \"aroundRadius\": 1000000,\n    },\n)",
      "insideBoundingBox": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"insideBoundingBox\": [\n            [\n                49.067996905313834,\n                65.73828125,\n                25.905859247243498,\n                128.8046875,\n            ],\n        ],\n    },\n)",
      "insidePolygon": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"insidePolygon\": [\n            [\n                42.01,\n                -124.31,\n                48.835509470063045,\n                -124.40453125000005,\n                45.01082951668149,\n                -65.95726562500005,\n                31.247243545293433,\n                -81.06578125000004,\n                25.924152577235226,\n                -97.68234374999997,\n                32.300311895879545,\n                -117.54828125,\n            ],\n        ],\n    },\n)",
      "optionalFilters": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"optionalFilters\": [\n            \"can_deliver_quickly:true\",\n        ],\n    },\n)",
      "optionalFiltersMany": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"optionalFilters\": [\n            \"brand:Apple<score=3>\",\n            \"brand:Samsung<score=2>\",\n            \"brand:-Huawei\",\n        ],\n    },\n)",
      "optionalFiltersSimple": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"optionalFilters\": [\n            \"brand:Apple<score=2>\",\n            \"type:tablet\",\n        ],\n    },\n)",
      "restrictSearchableAttributes": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"restrictSearchableAttributes\": [\n            \"title_fr\",\n        ],\n    },\n)",
      "getRankingInfo": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"getRankingInfo\": True,\n    },\n)",
      "clickAnalytics": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"clickAnalytics\": True,\n    },\n)",
      "clickAnalyticsUserToken": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"clickAnalytics\": True,\n        \"userToken\": \"user-1\",\n    },\n)",
      "enablePersonalization": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"enablePersonalization\": True,\n        \"userToken\": \"user-1\",\n    },\n)",
      "userToken": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"userToken\": \"user-1\",\n    },\n)",
      "userToken1234": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"userToken\": \"user-1234\",\n    },\n)",
      "analyticsTag": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"analyticsTags\": [\n            \"YOUR_ANALYTICS_TAG\",\n        ],\n    },\n)",
      "facetFiltersUsers": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"facetFilters\": [\n            \"user:user42\",\n            \"user:public\",\n        ],\n    },\n)",
      "buildTheQuery": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"filters\": \"categoryPageId: Men's Clothing\",\n        \"hitsPerPage\": 50,\n        \"analyticsTags\": [\n            \"mens-clothing\",\n        ],\n    },\n)",
      "attributesToHighlightOverride": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"attributesToHighlight\": [\n            \"title\",\n            \"content\",\n        ],\n    },\n)",
      "disableTypoToleranceOnAttributes": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"disableTypoToleranceOnAttributes\": [\n            \"serial_number\",\n        ],\n    },\n)",
      "search_a_query": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"\",\n        \"similarQuery\": \"Comedy Drama Crime McDormand Macy Buscemi Stormare Presnell Coen\",\n        \"filters\": \"year:1991 TO 2001\",\n    },\n)",
      "search_everything": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"\",\n    },\n)",
      "api_filtering_range_example": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"books\",\n        \"filters\": \"price:10 TO 20\",\n    },\n)",
      "override_retrievable_attributes": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"attributesToRetrieve\": [\n            \"title\",\n            \"content\",\n        ],\n    },\n)",
      "restrict_searchable_attributes": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"restrictSearchableAttributes\": [\n            \"title\",\n            \"author\",\n        ],\n    },\n)",
      "override_default_relevancy": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"relevancyStrictness\": 70,\n    },\n)",
      "apply_filters": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"sumOrFiltersScores\": True,\n    },\n)",
      "apply_all_filters": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"filters\": 'available = 1 AND (category:Book OR NOT category:Ebook) AND _tags:published AND publication_date:1441745506 TO 1441755506 AND inStock > 0 AND author:\"John Doe\"',\n    },\n)",
      "escape_spaces": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"filters\": 'category:\"Books and Comics\"',\n    },\n)",
      "escape_keywords": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"filters\": 'keyword:\"OR\"',\n    },\n)",
      "escape_single_quotes": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"filters\": 'content:\"It\\'s a wonderful day\"',\n    },\n)",
      "escape_double_quotes": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"filters\": 'content:\"She said \"Hello World\"',\n    },\n)",
      "apply_negative_filters": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"optionalFilters\": [\n            \"category:Book\",\n            \"author:-John Doe\",\n        ],\n    },\n)",
      "apply_negative_filters_restaurants": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"optionalFilters\": [\n            \"restaurant:-Bert's Inn\",\n        ],\n    },\n)",
      "apply_numeric_filters": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"numericFilters\": [\n            \"price < 1000\",\n            [\n                \"inStock = 1\",\n                \"deliveryDate < 1441755506\",\n            ],\n        ],\n    },\n)",
      "apply_tag_filters": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"tagFilters\": [\n            \"SciFi\",\n            [\n                \"Book\",\n                \"Movie\",\n            ],\n        ],\n    },\n)",
      "facets_all": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"facets\": [\n            \"*\",\n        ],\n    },\n)",
      "retrieve_only_some_facets": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"facets\": [\n            \"category\",\n            \"author\",\n        ],\n    },\n)",
      "override_default_max_values_per_facet": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"maxValuesPerFacet\": 20,\n    },\n)",
      "enable_faceting_after_distinct": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"facetingAfterDistinct\": True,\n    },\n)",
      "sort_facet_values_alphabetically": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"sortFacetValuesBy\": \"count\",\n    },\n)",
      "override_attributes_to_snippet": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"attributesToSnippet\": [\n            \"title\",\n            \"content:80\",\n        ],\n    },\n)",
      "override_default_highlight_pre_tag": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"highlightPreTag\": \"<strong>\",\n    },\n)",
      "override_default_highlight_post_tag": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"highlightPostTag\": \"</strong>\",\n    },\n)",
      "override_default_snippet_ellipsis_text": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"snippetEllipsisText\": \"\",\n    },\n)",
      "enable_restrict_highlight_and_snippet_arrays": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"restrictHighlightAndSnippetArrays\": False,\n    },\n)",
      "access_page": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"page\": 0,\n    },\n)",
      "override_default_hits_per_page": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"hitsPerPage\": 10,\n    },\n)",
      "get_nth_hit": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"offset\": 4,\n    },\n)",
      "get_n_results": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"length\": 4,\n    },\n)",
      "override_default_min_word_size_for_one_typo": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"minWordSizefor1Typo\": 2,\n    },\n)",
      "override_default_min_word_size_for_two_typos": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"minWordSizefor2Typos\": 2,\n    },\n)",
      "override_default_typo_tolerance_mode": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"typoTolerance\": False,\n    },\n)",
      "disable_typos_on_numeric_tokens_at_search_time": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"allowTyposOnNumericTokens\": False,\n    },\n)",
      "search_around_a_position": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"aroundLatLng\": \"40.71, -74.01\",\n    },\n)",
      "search_around_server_ip": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"aroundLatLngViaIP\": True,\n    },\n    request_options={\n        \"headers\": loads(\n            \"\"\"{\"x-forwarded-for\":\"94.228.178.246 // should be replaced with the actual IP you would like to search around\"}\"\"\"\n        ),\n    },\n)",
      "set_around_radius": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"aroundRadius\": 1000,\n    },\n)",
      "disable_automatic_radius": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"aroundRadius\": \"all\",\n    },\n)",
      "set_geo_search_precision": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"aroundPrecision\": 100,\n    },\n)",
      "set_geo_search_precision_non_linear": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"aroundPrecision\": [\n            {\n                \"from\": 0,\n                \"value\": 25,\n            },\n            {\n                \"from\": 2000,\n                \"value\": 1000,\n            },\n        ],\n    },\n)",
      "set_minimum_geo_search_radius": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"minimumAroundRadius\": 1000,\n    },\n)",
      "search_inside_rectangular_area": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"insideBoundingBox\": [\n            [\n                46.650828100116044,\n                7.123046875,\n                45.17210966999772,\n                1.009765625,\n            ],\n        ],\n    },\n)",
      "search_inside_multiple_rectangular_areas": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"insideBoundingBox\": [\n            [\n                46.650828100116044,\n                7.123046875,\n                45.17210966999772,\n                1.009765625,\n            ],\n            [\n                49.62625916704081,\n                4.6181640625,\n                47.715070300900194,\n                0.482421875,\n            ],\n        ],\n    },\n)",
      "search_inside_polygon_area": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"insidePolygon\": [\n            [\n                46.650828100116044,\n                7.123046875,\n                45.17210966999772,\n                1.009765625,\n                49.62625916704081,\n                4.6181640625,\n            ],\n        ],\n    },\n)",
      "search_inside_multiple_polygon_areas": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"insidePolygon\": [\n            [\n                46.650828100116044,\n                7.123046875,\n                45.17210966999772,\n                1.009765625,\n                49.62625916704081,\n                4.6181640625,\n            ],\n            [\n                49.62625916704081,\n                4.6181640625,\n                47.715070300900194,\n                0.482421875,\n                45.17210966999772,\n                1.009765625,\n                50.62626704081,\n                4.6181640625,\n            ],\n        ],\n    },\n)",
      "set_querylanguages_override": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"removeStopWords\": [\n            \"ca\",\n            \"es\",\n        ],\n    },\n)",
      "set_querylanguages_with_japanese_query": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"queryLanguages\": [\n            \"ja\",\n            \"en\",\n        ],\n    },\n)",
      "set_natural_languages": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"\",\n        \"naturalLanguages\": [\n            \"fr\",\n        ],\n    },\n)",
      "override_natural_languages_with_query": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"\",\n        \"naturalLanguages\": [\n            \"fr\",\n        ],\n        \"removeWordsIfNoResults\": \"firstWords\",\n    },\n)",
      "enable_decompound_query_search_time": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"decompoundQuery\": True,\n    },\n)",
      "enable_rules_search_time": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"enableRules\": True,\n    },\n)",
      "set_rule_contexts": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"ruleContexts\": [\n            \"front_end\",\n            \"website2\",\n        ],\n    },\n)",
      "enable_personalization": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"enablePersonalization\": True,\n    },\n)",
      "enable_personalization_with_user_token": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"enablePersonalization\": True,\n        \"userToken\": \"123456\",\n    },\n)",
      "personalization_impact": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"personalizationImpact\": 20,\n    },\n)",
      "set_user_token": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"userToken\": \"123456\",\n    },\n)",
      "set_user_token_with_personalization": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"enablePersonalization\": True,\n        \"userToken\": \"123456\",\n    },\n)",
      "override_default_query_type": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"queryType\": \"prefixAll\",\n    },\n)",
      "override_default_remove_words_if_no_results": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"removeWordsIfNoResults\": \"lastWords\",\n    },\n)",
      "enable_advanced_syntax_search_time": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"advancedSyntax\": True,\n    },\n)",
      "overide_default_optional_words": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"optionalWords\": [\n            \"toyota\",\n            \"2020 2021\",\n        ],\n    },\n)",
      "disabling_exact_for_some_attributes_search_time": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"disableExactOnAttributes\": [\n            \"description\",\n        ],\n    },\n)",
      "override_default_exact_single_word_query": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"exactOnSingleWordQuery\": \"none\",\n    },\n)",
      "override_default_aternative_as_exact": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"alternativesAsExact\": [\n            \"multiWordsSynonym\",\n        ],\n    },\n)",
      "enable_advanced_syntax_exact_phrase": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"advancedSyntax\": True,\n        \"advancedSyntaxFeatures\": [\n            \"exactPhrase\",\n        ],\n    },\n)",
      "enable_advanced_syntax_exclude_words": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"advancedSyntax\": True,\n        \"advancedSyntaxFeatures\": [\n            \"excludeWords\",\n        ],\n    },\n)",
      "override_distinct": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"distinct\": 0,\n    },\n)",
      "get_ranking_info": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"getRankingInfo\": True,\n    },\n)",
      "disable_click_analytics": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"clickAnalytics\": False,\n    },\n)",
      "enable_click_analytics": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"clickAnalytics\": True,\n    },\n)",
      "disable_analytics": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"analytics\": False,\n    },\n)",
      "add_analytics_tags": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"analyticsTags\": [\n            \"front_end\",\n            \"website2\",\n        ],\n    },\n)",
      "disable_synonyms": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"synonyms\": False,\n    },\n)",
      "override_replace_synonyms_in_highlights": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"replaceSynonymsInHighlight\": True,\n    },\n)",
      "override_min_proximity": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"minProximity\": 2,\n    },\n)",
      "override_default_field": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"responseFields\": [\n            \"hits\",\n            \"facets\",\n        ],\n    },\n)",
      "override_percentile_computation": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"percentileComputation\": False,\n    },\n)",
      "set_ab_test": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"enableABTest\": False,\n    },\n)",
      "set_enable_re_ranking": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n        \"enableReRanking\": False,\n    },\n)",
      "with algolia user id": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"query\",\n    },\n    request_options={\n        \"headers\": loads(\"\"\"{\"X-Algolia-User-ID\":\"user1234\"}\"\"\"),\n    },\n)",
      "mcm with algolia user id": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_params={\n        \"query\": \"peace\",\n    },\n    request_options={\n        \"headers\": loads(\"\"\"{\"X-Algolia-User-ID\":\"user42\"}\"\"\"),\n    },\n)"
    },
    "searchSynonyms": {
      "searchSynonyms with minimal parameters": "response = client.search_synonyms(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)",
      "searchSynonyms with all parameters": "response = client.search_synonyms(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_synonyms_params={\n        \"query\": \"myQuery\",\n        \"type\": \"altcorrection1\",\n        \"page\": 10,\n        \"hitsPerPage\": 10,\n    },\n)"
    },
    "searchUserIds": {
      "default": "response = client.search_user_ids(\n    search_user_ids_params={\n        \"query\": \"test\",\n        \"clusterName\": \"theClusterName\",\n        \"page\": 5,\n        \"hitsPerPage\": 10,\n    },\n)"
    },
    "setClientApiKey": {
      "default": "client.set_client_api_key(\n    api_key=\"updated-api-key\",\n)"
    },
    "setDictionarySettings": {
      "get setDictionarySettings results with minimal parameters": "response = client.set_dictionary_settings(\n    dictionary_settings_params={\n        \"disableStandardEntries\": {\n            \"plurals\": {\n                \"fr\": False,\n                \"en\": False,\n                \"ru\": True,\n            },\n        },\n    },\n)",
      "get setDictionarySettings results with all parameters": "response = client.set_dictionary_settings(\n    dictionary_settings_params={\n        \"disableStandardEntries\": {\n            \"plurals\": {\n                \"fr\": False,\n                \"en\": False,\n                \"ru\": True,\n            },\n            \"stopwords\": {\n                \"fr\": False,\n            },\n            \"compounds\": {\n                \"ru\": True,\n            },\n        },\n    },\n)"
    },
    "setSettings": {
      "minimal parameters": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"paginationLimitedTo\": 10,\n    },\n    forward_to_replicas=True,\n)",
      "boolean typoTolerance": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"typoTolerance\": True,\n    },\n    forward_to_replicas=True,\n)",
      "enum typoTolerance": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"typoTolerance\": \"min\",\n    },\n    forward_to_replicas=True,\n)",
      "ignorePlurals": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"ignorePlurals\": True,\n    },\n    forward_to_replicas=True,\n)",
      "list of string ignorePlurals": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"ignorePlurals\": [\n            \"fr\",\n        ],\n    },\n    forward_to_replicas=True,\n)",
      "removeStopWords boolean": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"removeStopWords\": True,\n    },\n    forward_to_replicas=True,\n)",
      "removeStopWords list of string": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"removeStopWords\": [\n            \"fr\",\n        ],\n    },\n    forward_to_replicas=True,\n)",
      "boolean distinct": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"distinct\": True,\n    },\n    forward_to_replicas=True,\n)",
      "integer distinct": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"distinct\": 1,\n    },\n    forward_to_replicas=True,\n)",
      "distinct company": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributeForDistinct\": \"company\",\n        \"distinct\": True,\n    },\n)",
      "distinct design": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributeForDistinct\": \"design\",\n        \"distinct\": True,\n    },\n)",
      "distinct true": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"distinct\": True,\n    },\n)",
      "distinct section": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributeForDistinct\": \"section\",\n        \"distinct\": True,\n    },\n)",
      "attributesForFaceting allergens": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesForFaceting\": [\n            \"allergens\",\n        ],\n    },\n)",
      "attributesForFaceting availableIn": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesForFaceting\": [\n            \"color\",\n            \"availableIn\",\n        ],\n    },\n)",
      "api_attributes_for_faceting": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesForFaceting\": [\n            \"genre\",\n            \"author\",\n        ],\n    },\n)",
      "api_attributes_for_faceting_searchable": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesForFaceting\": [\n            \"genre\",\n            \"searchable(author)\",\n        ],\n    },\n)",
      "api_attributes_for_filter_only": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesForFaceting\": [\n            \"filterOnly(genre)\",\n            \"author\",\n        ],\n    },\n)",
      "attributesForFaceting categoryPageId": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesForFaceting\": [\n            \"searchable(categoryPageId)\",\n        ],\n    },\n)",
      "unretrievableAttributes": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"unretrievableAttributes\": [\n            \"visible_by\",\n        ],\n    },\n)",
      "attributesForFaceting user restricted data": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesForFaceting\": [\n            \"filterOnly(visible_by)\",\n        ],\n    },\n)",
      "attributesForFaceting optional filters": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesForFaceting\": [\n            \"can_deliver_quickly\",\n            \"restaurant\",\n        ],\n    },\n)",
      "attributesForFaceting redirect index": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesForFaceting\": [\n            \"query_terms\",\n        ],\n    },\n)",
      "attributesForFaceting multiple consequences": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesForFaceting\": [\n            \"director\",\n        ],\n    },\n)",
      "attributesForFaceting in-depth optional filters": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesForFaceting\": [\n            \"filterOnly(brand)\",\n        ],\n    },\n)",
      "mode neuralSearch": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"mode\": \"neuralSearch\",\n    },\n)",
      "mode keywordSearch": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"mode\": \"keywordSearch\",\n    },\n)",
      "searchableAttributes same priority": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"searchableAttributes\": [\n            \"title,comments\",\n            \"ingredients\",\n        ],\n    },\n)",
      "searchableAttributes higher priority": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"searchableAttributes\": [\n            \"title\",\n            \"ingredients\",\n        ],\n    },\n)",
      "customRanking retweets": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"customRanking\": [\n            \"desc(retweets)\",\n            \"desc(likes)\",\n        ],\n    },\n)",
      "customRanking boosted": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"customRanking\": [\n            \"desc(boosted)\",\n        ],\n    },\n)",
      "customRanking pageviews": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"customRanking\": [\n            \"desc(pageviews)\",\n            \"desc(comments)\",\n        ],\n    },\n)",
      "customRanking applying search parameters for a specific query": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"customRanking\": [\n            \"desc(nb_airline_liaisons)\",\n        ],\n        \"attributesForFaceting\": [\n            \"city, country\",\n        ],\n    },\n)",
      "customRanking rounded pageviews": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"customRanking\": [\n            \"desc(rounded_pageviews)\",\n            \"desc(comments)\",\n        ],\n    },\n)",
      "customRanking price": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"customRanking\": [\n            \"desc(price)\",\n        ],\n    },\n)",
      "ranking exhaustive (price)": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"ranking\": [\n            \"desc(price)\",\n            \"typo\",\n            \"geo\",\n            \"words\",\n            \"filters\",\n            \"proximity\",\n            \"attribute\",\n            \"exact\",\n            \"custom\",\n        ],\n    },\n)",
      "ranking exhaustive (is_popular)": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"ranking\": [\n            \"desc(is_popular)\",\n            \"typo\",\n            \"geo\",\n            \"words\",\n            \"filters\",\n            \"proximity\",\n            \"attribute\",\n            \"exact\",\n            \"custom\",\n        ],\n    },\n)",
      "ranking standard replica": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"ranking\": [\n            \"desc(post_date_timestamp)\",\n        ],\n    },\n)",
      "ranking virtual replica": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"customRanking\": [\n            \"desc(post_date_timestamp)\",\n        ],\n    },\n)",
      "customRanking and ranking sort alphabetically": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"customRanking\": [\n            \"asc(textual_attribute)\",\n        ],\n        \"ranking\": [\n            \"custom\",\n            \"typo\",\n            \"geo\",\n            \"words\",\n            \"filters\",\n            \"proximity\",\n            \"attribute\",\n            \"exact\",\n        ],\n    },\n)",
      "relevancyStrictness": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"customRanking\": [\n            \"asc(textual_attribute)\",\n        ],\n        \"relevancyStrictness\": 0,\n    },\n)",
      "create replica index": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"replicas\": [\n            \"products_price_desc\",\n        ],\n    },\n)",
      "create replica index articles": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"replicas\": [\n            \"articles_date_desc\",\n        ],\n    },\n)",
      "create virtual replica index": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"replicas\": [\n            \"virtual(products_price_desc)\",\n        ],\n    },\n)",
      "unlink replica index": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"replicas\": [\n            \"\",\n        ],\n    },\n)",
      "forwardToReplicas": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"searchableAttributes\": [\n            \"name\",\n            \"description\",\n        ],\n    },\n    forward_to_replicas=True,\n)",
      "maxValuesPerFacet": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"maxValuesPerFacet\": 1000,\n    },\n)",
      "maxFacetHits": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"maxFacetHits\": 100,\n    },\n)",
      "attributesForFaceting complex": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesForFaceting\": [\n            \"actor\",\n            \"filterOnly(category)\",\n            \"searchable(publisher)\",\n        ],\n    },\n)",
      "ranking closest dates": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"ranking\": [\n            \"asc(date_timestamp)\",\n            \"typo\",\n            \"geo\",\n            \"words\",\n            \"filters\",\n            \"proximity\",\n            \"attribute\",\n            \"exact\",\n            \"custom\",\n        ],\n    },\n)",
      "searchableAttributes item variation": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"searchableAttributes\": [\n            \"design\",\n            \"type\",\n            \"color\",\n        ],\n    },\n)",
      "searchableAttributes around location": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"searchableAttributes\": [\n            \"name\",\n            \"country\",\n            \"city\",\n            \"iata_code\",\n        ],\n        \"customRanking\": [\n            \"desc(links_count)\",\n        ],\n    },\n)",
      "attributesToHighlight": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesToHighlight\": [\n            \"author\",\n            \"title\",\n            \"content\",\n        ],\n    },\n)",
      "attributesToHighlightStar": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesToHighlight\": [\n            \"*\",\n        ],\n    },\n)",
      "everything": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"advancedSyntax\": True,\n        \"advancedSyntaxFeatures\": [\n            \"exactPhrase\",\n        ],\n        \"allowCompressionOfIntegerArray\": True,\n        \"allowTyposOnNumericTokens\": True,\n        \"alternativesAsExact\": [\n            \"singleWordSynonym\",\n        ],\n        \"attributeCriteriaComputedByMinProximity\": True,\n        \"attributeForDistinct\": \"test\",\n        \"attributesForFaceting\": [\n            \"algolia\",\n        ],\n        \"attributesToHighlight\": [\n            \"algolia\",\n        ],\n        \"attributesToRetrieve\": [\n            \"algolia\",\n        ],\n        \"attributesToSnippet\": [\n            \"algolia\",\n        ],\n        \"attributesToTransliterate\": [\n            \"algolia\",\n        ],\n        \"camelCaseAttributes\": [\n            \"algolia\",\n        ],\n        \"customNormalization\": {\n            \"algolia\": {\n                \"aloglia\": \"aglolia\",\n            },\n        },\n        \"customRanking\": [\n            \"algolia\",\n        ],\n        \"decompoundQuery\": False,\n        \"decompoundedAttributes\": {\n            \"algolia\": \"aloglia\",\n        },\n        \"disableExactOnAttributes\": [\n            \"algolia\",\n        ],\n        \"disablePrefixOnAttributes\": [\n            \"algolia\",\n        ],\n        \"disableTypoToleranceOnAttributes\": [\n            \"algolia\",\n        ],\n        \"disableTypoToleranceOnWords\": [\n            \"algolia\",\n        ],\n        \"distinct\": 3,\n        \"enablePersonalization\": True,\n        \"enableReRanking\": False,\n        \"enableRules\": True,\n        \"exactOnSingleWordQuery\": \"attribute\",\n        \"highlightPreTag\": \"<span>\",\n        \"highlightPostTag\": \"</span>\",\n        \"hitsPerPage\": 10,\n        \"ignorePlurals\": False,\n        \"indexLanguages\": [\n            \"fr\",\n        ],\n        \"keepDiacriticsOnCharacters\": \"abc\",\n        \"maxFacetHits\": 20,\n        \"maxValuesPerFacet\": 30,\n        \"minProximity\": 6,\n        \"minWordSizefor1Typo\": 5,\n        \"minWordSizefor2Typos\": 11,\n        \"mode\": \"neuralSearch\",\n        \"numericAttributesForFiltering\": [\n            \"algolia\",\n        ],\n        \"optionalWords\": [\n            \"myspace\",\n        ],\n        \"paginationLimitedTo\": 0,\n        \"queryLanguages\": [\n            \"fr\",\n        ],\n        \"queryType\": \"prefixLast\",\n        \"ranking\": [\n            \"geo\",\n        ],\n        \"reRankingApplyFilter\": \"mySearch:filters\",\n        \"relevancyStrictness\": 10,\n        \"removeStopWords\": False,\n        \"removeWordsIfNoResults\": \"lastWords\",\n        \"renderingContent\": {\n            \"facetOrdering\": {\n                \"facets\": {\n                    \"order\": [\n                        \"a\",\n                        \"b\",\n                    ],\n                },\n                \"values\": {\n                    \"a\": {\n                        \"order\": [\n                            \"b\",\n                        ],\n                        \"sortRemainingBy\": \"count\",\n                    },\n                },\n            },\n        },\n        \"replaceSynonymsInHighlight\": True,\n        \"replicas\": [\n            \"\",\n        ],\n        \"responseFields\": [\n            \"algolia\",\n        ],\n        \"restrictHighlightAndSnippetArrays\": True,\n        \"searchableAttributes\": [\n            \"foo\",\n        ],\n        \"semanticSearch\": {\n            \"eventSources\": [\n                \"foo\",\n            ],\n        },\n        \"separatorsToIndex\": \"bar\",\n        \"snippetEllipsisText\": \"---\",\n        \"sortFacetValuesBy\": \"date\",\n        \"typoTolerance\": False,\n        \"unretrievableAttributes\": [\n            \"foo\",\n        ],\n        \"userData\": {\n            \"user\": \"data\",\n        },\n    },\n)",
      "searchableAttributesWithCustomRankingsAndAttributesForFaceting": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"searchableAttributes\": [\n            \"brand\",\n            \"name\",\n            \"categories\",\n            \"unordered(description)\",\n        ],\n        \"customRanking\": [\n            \"desc(popularity)\",\n        ],\n        \"attributesForFaceting\": [\n            \"searchable(brand)\",\n            \"type\",\n            \"categories\",\n            \"price\",\n        ],\n    },\n)",
      "searchableAttributesOrdering": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"searchableAttributes\": [\n            \"unordered(title)\",\n            \"cast\",\n        ],\n    },\n)",
      "searchableAttributesProductReferenceSuffixes": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"searchableAttributes\": [\n            \"name\",\n            \"product_reference\",\n            \"product_reference_suffixes\",\n        ],\n    },\n)",
      "queryLanguageAndIgnorePlurals": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"queryLanguages\": [\n            \"en\",\n        ],\n        \"ignorePlurals\": True,\n    },\n)",
      "searchableAttributesInMovies": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"searchableAttributes\": [\n            \"title_eng\",\n            \"title_fr\",\n            \"title_es\",\n        ],\n    },\n)",
      "disablePrefixOnAttributes": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"disablePrefixOnAttributes\": [\n            \"serial_number\",\n        ],\n    },\n)",
      "disableTypoToleranceOnAttributes": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"disableTypoToleranceOnAttributes\": [\n            \"serial_number\",\n        ],\n    },\n)",
      "searchableAttributesSimpleExample": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"searchableAttributes\": [\n            \"serial_number\",\n        ],\n    },\n)",
      "searchableAttributesSimpleExampleAlt": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"searchableAttributes\": [\n            \"serial_number\",\n            \"serial_number_suffixes\",\n        ],\n    },\n)",
      "set_searchable_attributes": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesForFaceting\": [\n            \"author\",\n            \"filterOnly(isbn)\",\n            \"searchable(edition)\",\n            \"afterDistinct(category)\",\n            \"afterDistinct(searchable(publisher))\",\n        ],\n    },\n)",
      "unretrievable_attributes": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"unretrievableAttributes\": [\n            \"total_number_of_sales\",\n        ],\n    },\n)",
      "set_retrievable_attributes": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesToRetrieve\": [\n            \"author\",\n            \"title\",\n            \"content\",\n        ],\n    },\n)",
      "set_all_attributes_as_retrievable": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesToRetrieve\": [\n            \"*\",\n        ],\n    },\n)",
      "specify_attributes_not_to_retrieve": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesToRetrieve\": [\n            \"*\",\n            \"-SKU\",\n            \"-internal_desc\",\n        ],\n    },\n)",
      "neural_search": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"mode\": \"neuralSearch\",\n    },\n)",
      "keyword_search": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"mode\": \"keywordSearch\",\n    },\n)",
      "set_default_ranking": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"ranking\": [\n            \"typo\",\n            \"geo\",\n            \"words\",\n            \"filters\",\n            \"attribute\",\n            \"proximity\",\n            \"exact\",\n            \"custom\",\n        ],\n    },\n)",
      "set_ranking_by_attribute_asc": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"ranking\": [\n            \"asc(price)\",\n            \"typo\",\n            \"geo\",\n            \"words\",\n            \"filters\",\n            \"proximity\",\n            \"attribute\",\n            \"exact\",\n            \"custom\",\n        ],\n    },\n)",
      "set_ranking_by_attribute_desc": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"ranking\": [\n            \"desc(price)\",\n            \"typo\",\n            \"geo\",\n            \"words\",\n            \"filters\",\n            \"proximity\",\n            \"attribute\",\n            \"exact\",\n            \"custom\",\n        ],\n    },\n)",
      "restrict_searchable_attributes": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"customRanking\": [\n            \"desc(popularity)\",\n            \"asc(price)\",\n        ],\n    },\n)",
      "set_default_relevancy": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"relevancyStrictness\": 90,\n    },\n)",
      "set_replicas": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"replicas\": [\n            \"name_of_replica_index1\",\n            \"name_of_replica_index2\",\n        ],\n    },\n)",
      "set_default_max_values_per_facet": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"maxValuesPerFacet\": 100,\n    },\n)",
      "set_default_sort_facet_values_by": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"sortFacetValuesBy\": \"alpha\",\n    },\n)",
      "set_attributes_to_snippet": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesToSnippet\": [\n            \"content:80\",\n            \"description\",\n        ],\n    },\n)",
      "set_all_attributes_to_snippet": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesToSnippet\": [\n            \"*:80\",\n        ],\n    },\n)",
      "set_default_highlight_pre_tag": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"highlightPreTag\": \"<em>\",\n    },\n)",
      "set_default_highlight_post_tag": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"highlightPostTag\": \"</em>\",\n    },\n)",
      "set_default_snippet_ellipsis_text": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"snippetEllipsisText\": \"…\",\n    },\n)",
      "enable_restrict_highlight_and_snippet_arrays_by_default": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"restrictHighlightAndSnippetArrays\": True,\n    },\n)",
      "set_default_hits_per_page": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"hitsPerPage\": 20,\n    },\n)",
      "set_pagination_limit": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"paginationLimitedTo\": 1000,\n    },\n)",
      "set_default_min_word_size_for_one_typo": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"minWordSizefor1Typo\": 4,\n    },\n)",
      "set_default_min_word_size_for_two_typos": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"minWordSizefor2Typos\": 4,\n    },\n)",
      "set_default_typo_tolerance_mode": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"typoTolerance\": True,\n    },\n)",
      "disable_typos_on_numeric_tokens_by_default": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"allowTyposOnNumericTokens\": False,\n    },\n)",
      "disable_typo_tolerance_for_words": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"disableTypoToleranceOnWords\": [\n            \"wheel\",\n            \"1X2BCD\",\n        ],\n    },\n)",
      "set_separators_to_index": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"separatorsToIndex\": \"+#\",\n    },\n)",
      "set_languages_using_querylanguages": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"queryLanguages\": [\n            \"es\",\n        ],\n        \"removeStopWords\": True,\n        \"ignorePlurals\": True,\n    },\n)",
      "set_attributes_to_transliterate": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"indexLanguages\": [\n            \"ja\",\n        ],\n        \"attributesToTransliterate\": [\n            \"name\",\n            \"description\",\n        ],\n    },\n)",
      "set_camel_case_attributes": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"camelCaseAttributes\": [\n            \"description\",\n        ],\n    },\n)",
      "set_decompounded_attributes": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"decompoundedAttributes\": {\n            \"de\": [\n                \"name\",\n            ],\n        },\n    },\n)",
      "set_decompounded_multiple_attributes": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"decompoundedAttributes\": {\n            \"de\": [\n                \"name_de\",\n                \"description_de\",\n            ],\n            \"fi\": [\n                \"name_fi\",\n                \"description_fi\",\n            ],\n        },\n    },\n)",
      "set_keep_diacritics_on_characters": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"keepDiacriticsOnCharacters\": \"øé\",\n    },\n)",
      "set_custom_normalization": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"customNormalization\": {\n            \"default\": {\n                \"ä\": \"ae\",\n            },\n        },\n    },\n)",
      "set_indexlanguages": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"indexLanguages\": [\n            \"ja\",\n        ],\n    },\n)",
      "enable_decompound_query_by_default": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"decompoundQuery\": True,\n    },\n)",
      "enable_rules_syntax_by_default": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"enableRules\": True,\n    },\n)",
      "enable_personalization_settings": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"enablePersonalization\": True,\n    },\n)",
      "set_default_query_type": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"queryType\": \"prefixLast\",\n    },\n)",
      "set_default_remove_words_if_no_result": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"removeWordsIfNoResults\": \"none\",\n    },\n)",
      "enable_advanced_syntax_by_default": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"advancedSyntax\": True,\n    },\n)",
      "set_default_optional_words": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"optionalWords\": [\n            \"blue\",\n            \"iphone case\",\n        ],\n    },\n)",
      "disabling_prefix_search_for_some_attributes_by_default": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"disablePrefixOnAttributes\": [\n            \"sku\",\n        ],\n    },\n)",
      "disabling_exact_for_some_attributes_by_default": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"disableExactOnAttributes\": [\n            \"description\",\n        ],\n    },\n)",
      "set_default_exact_single_word_query": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"exactOnSingleWordQuery\": \"attribute\",\n    },\n)",
      "set_default_aternative_as_exact": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"alternativesAsExact\": [\n            \"ignorePlurals\",\n            \"singleWordSynonym\",\n        ],\n    },\n)",
      "set_numeric_attributes_for_filtering": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"numericAttributesForFiltering\": [\n            \"quantity\",\n            \"popularity\",\n        ],\n    },\n)",
      "enable_compression_of_integer_array": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"allowCompressionOfIntegerArray\": True,\n    },\n)",
      "set_attributes_for_distinct": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributeForDistinct\": \"url\",\n    },\n)",
      "set_distinct": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"distinct\": 1,\n        \"attributeForDistinct\": \"url\",\n    },\n)",
      "set_replace_synonyms_in_highlights": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"replaceSynonymsInHighlight\": False,\n    },\n)",
      "set_min_proximity": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"minProximity\": 1,\n    },\n)",
      "set_default_field": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"responseFields\": [\n            \"hits\",\n            \"hitsPerPage\",\n            \"nbPages\",\n            \"page\",\n        ],\n    },\n)",
      "set_max_facet_hits": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"maxFacetHits\": 10,\n    },\n)",
      "set_attribute_criteria_computed_by_min_proximity": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributeCriteriaComputedByMinProximity\": True,\n    },\n)",
      "set_user_data": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"userData\": {\n            \"extraData\": \"This is the custom data that you want to store in your index\",\n        },\n    },\n)",
      "set_rendering_content": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"renderingContent\": {\n            \"facetOrdering\": {\n                \"facets\": {\n                    \"order\": [\n                        \"size\",\n                        \"brand\",\n                    ],\n                },\n                \"values\": {\n                    \"brand\": {\n                        \"order\": [\n                            \"uniqlo\",\n                        ],\n                        \"hide\": [\n                            \"muji\",\n                        ],\n                        \"sortRemainingBy\": \"count\",\n                    },\n                    \"size\": {\n                        \"order\": [\n                            \"S\",\n                            \"M\",\n                            \"L\",\n                        ],\n                        \"sortRemainingBy\": \"hidden\",\n                    },\n                },\n            },\n        },\n    },\n)"
    },
    "updateApiKey": {
      "default": "response = client.update_api_key(\n    key=\"ALGOLIA_API_KEY\",\n    api_key={\n        \"acl\": [\n            \"search\",\n            \"addObject\",\n        ],\n        \"validity\": 300,\n        \"maxQueriesPerIPPerHour\": 100,\n        \"maxHitsPerQuery\": 20,\n    },\n)"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "response = client.wait_for_api_key(\n    key=\"api-key-add-operation-test-python\",\n    operation=\"add\",\n)",
      "wait for api key - update": "response = client.wait_for_api_key(\n    key=\"api-key-update-operation-test-python\",\n    operation=\"update\",\n    api_key={\n        \"description\": \"my updated api key\",\n        \"acl\": [\n            \"search\",\n            \"addObject\",\n            \"deleteObject\",\n        ],\n        \"indexes\": [\n            \"Movies\",\n            \"Books\",\n        ],\n        \"referers\": [\n            \"*google.com\",\n            \"*algolia.com\",\n        ],\n        \"validity\": 305,\n        \"maxQueriesPerIPPerHour\": 95,\n        \"maxHitsPerQuery\": 20,\n    },\n)",
      "wait for api key - delete": "response = client.wait_for_api_key(\n    key=\"api-key-delete-operation-test-python\",\n    operation=\"delete\",\n)"
    },
    "waitForAppTask": {
      "default": "response = client.wait_for_app_task(\n    task_id=123,\n)"
    },
    "waitForTask": {
      "default": "response = client.wait_for_task(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    task_id=123,\n)"
    },
    "init": {
      "default": "# In an asynchronous context, you can use SearchClient instead, which exposes the exact same methods.\nclient = SearchClientSync(\"ALGOLIA_APPLICATION_ID\", \"ALGOLIA_API_KEY\")"
    }
  },
  "ruby": {
    "import": {
      "default": "require \"algolia\""
    },
    "addApiKey": {
      "minimal": "response = client.add_api_key(\n  Algolia::Search::ApiKey.new(acl: [\"search\", \"addObject\"], description: \"my new api key\")\n)",
      "all": "response = client.add_api_key(\n  Algolia::Search::ApiKey.new(\n    acl: [\"search\", \"addObject\"],\n    description: \"my new api key\",\n    validity: 300,\n    max_queries_per_ip_per_hour: 100,\n    max_hits_per_query: 20\n  )\n)"
    },
    "addOrUpdateObject": {
      "default": "response = client.add_or_update_object(\"<YOUR_INDEX_NAME>\", \"uniqueID\", {key: \"value\"})"
    },
    "appendSource": {
      "default": "response = client.append_source(Algolia::Search::Source.new(source: \"theSource\", description: \"theDescription\"))"
    },
    "assignUserId": {
      "simple": "response = client.assign_user_id(\"user42\", Algolia::Search::AssignUserIdParams.new(cluster: \"d4242-eu\"))",
      "it should not encode the userID": "response = client.assign_user_id(\n  \"user id with spaces\",\n  Algolia::Search::AssignUserIdParams.new(cluster: \"cluster with spaces\")\n)"
    },
    "batch": {
      "addObject": "response = client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::BatchWriteParams.new(\n    requests: [\n      Algolia::Search::BatchRequest.new(action: \"addObject\", body: {key: \"bar\", foo: \"1\"}),\n      Algolia::Search::BatchRequest.new(action: \"addObject\", body: {key: \"baz\", foo: \"2\"})\n    ]\n  )\n)",
      "clear": "response = client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::BatchWriteParams.new(\n    requests: [Algolia::Search::BatchRequest.new(action: \"clear\", body: {key: \"value\"})]\n  )\n)",
      "delete": "response = client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::BatchWriteParams.new(\n    requests: [Algolia::Search::BatchRequest.new(action: \"delete\", body: {key: \"value\"})]\n  )\n)",
      "deleteObject": "response = client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::BatchWriteParams.new(\n    requests: [Algolia::Search::BatchRequest.new(action: \"deleteObject\", body: {key: \"value\"})]\n  )\n)",
      "partialUpdateObject": "response = client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::BatchWriteParams.new(\n    requests: [Algolia::Search::BatchRequest.new(action: \"partialUpdateObject\", body: {key: \"value\"})]\n  )\n)",
      "partialUpdateObjectNoCreate": "response = client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::BatchWriteParams.new(\n    requests: [Algolia::Search::BatchRequest.new(action: \"partialUpdateObjectNoCreate\", body: {key: \"value\"})]\n  )\n)",
      "updateObject": "response = client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::BatchWriteParams.new(\n    requests: [Algolia::Search::BatchRequest.new(action: \"updateObject\", body: {key: \"value\"})]\n  )\n)"
    },
    "batchAssignUserIds": {
      "default": "response = client.batch_assign_user_ids(\n  \"userID\",\n  Algolia::Search::BatchAssignUserIdsParams.new(cluster: \"theCluster\", users: [\"user1\", \"user2\"])\n)"
    },
    "batchDictionaryEntries": {
      "replace": "response = client.batch_dictionary_entries(\n  \"plurals\",\n  Algolia::Search::BatchDictionaryEntriesParams.new(\n    clear_existing_dictionary_entries: true,\n    requests: [\n      Algolia::Search::BatchDictionaryEntriesRequest.new(\n        action: \"addEntry\",\n        body: Algolia::Search::DictionaryEntry.new(\n          algolia_object_id: \"1\",\n          language: \"en\",\n          word: \"fancy\",\n          words: [\"believe\", \"algolia\"],\n          decomposition: [\"trust\", \"algolia\"],\n          state: \"enabled\"\n        )\n      )\n    ]\n  )\n)",
      "delete": "response = client.batch_dictionary_entries(\n  \"plurals\",\n  Algolia::Search::BatchDictionaryEntriesParams.new(\n    clear_existing_dictionary_entries: true,\n    requests: [\n      Algolia::Search::BatchDictionaryEntriesRequest.new(\n        action: \"deleteEntry\",\n        body: Algolia::Search::DictionaryEntry.new(algolia_object_id: \"1\")\n      )\n    ]\n  )\n)",
      "append": "response = client.batch_dictionary_entries(\n  \"stopwords\",\n  Algolia::Search::BatchDictionaryEntriesParams.new(\n    requests: [\n      Algolia::Search::BatchDictionaryEntriesRequest.new(\n        action: \"addEntry\",\n        body: Algolia::Search::DictionaryEntry.new(algolia_object_id: \"1\", language: \"en\", additional: \"try me\")\n      )\n    ]\n  )\n)"
    },
    "browse": {
      "browse with minimal parameters": "response = client.browse(\"<YOUR_INDEX_NAME>\")",
      "browse with search parameters": "response = client.browse(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::BrowseParamsObject.new(query: \"myQuery\", facet_filters: [\"tags:algolia\"])\n)",
      "browse allow a cursor in parameters": "response = client.browse(\"<YOUR_INDEX_NAME>\", Algolia::Search::BrowseParamsObject.new(cursor: \"test\"))"
    },
    "clearObjects": {
      "default": "response = client.clear_objects(\"<YOUR_INDEX_NAME>\")"
    },
    "clearRules": {
      "default": "response = client.clear_rules(\"<YOUR_INDEX_NAME>\")"
    },
    "clearSynonyms": {
      "default": "response = client.clear_synonyms(\"<YOUR_INDEX_NAME>\")"
    },
    "customDelete": {
      "allow del method for a custom path with minimal parameters": "response = client.custom_delete(\"test/minimal\")",
      "allow del method for a custom path with all parameters": "response = client.custom_delete(\"test/all\", {query: \"parameters\"})"
    },
    "customGet": {
      "allow get method for a custom path with minimal parameters": "response = client.custom_get(\"test/minimal\")",
      "allow get method for a custom path with all parameters": "response = client.custom_get(\"test/all\", {query: \"parameters with space\"})",
      "requestOptions should be escaped too": "response = client.custom_get(\n  \"test/all\",\n  {query: \"to be overriden\"},\n  {\n    :header_params => {\"x-header-1\" => \"spaces are left alone\"},\n    :query_params => JSON.parse(\n      \"{\\\"query\\\":\\\"parameters with space\\\",\\\"and an array\\\":[\\\"array\\\",\\\"with spaces\\\"]}\",\n      :symbolize_names => true\n    )\n  }\n)"
    },
    "customPost": {
      "allow post method for a custom path with minimal parameters": "response = client.custom_post(\"test/minimal\")",
      "allow post method for a custom path with all parameters": "response = client.custom_post(\"test/all\", {query: \"parameters\"}, {body: \"parameters\"})",
      "requestOptions can override default query parameters": "response = client.custom_post(\n  \"test/requestOptions\",\n  {query: \"parameters\"},\n  {facet: \"filters\"},\n  {:query_params => JSON.parse(\"{\\\"query\\\":\\\"myQueryParameter\\\"}\", :symbolize_names => true)}\n)",
      "requestOptions merges query parameters with default ones": "response = client.custom_post(\n  \"test/requestOptions\",\n  {query: \"parameters\"},\n  {facet: \"filters\"},\n  {:query_params => JSON.parse(\"{\\\"query2\\\":\\\"myQueryParameter\\\"}\", :symbolize_names => true)}\n)",
      "requestOptions can override default headers": "response = client.custom_post(\n  \"test/requestOptions\",\n  {query: \"parameters\"},\n  {facet: \"filters\"},\n  {:header_params => {\"x-algolia-api-key\" => \"ALGOLIA_API_KEY\"}}\n)",
      "requestOptions merges headers with default ones": "response = client.custom_post(\n  \"test/requestOptions\",\n  {query: \"parameters\"},\n  {facet: \"filters\"},\n  {:header_params => {\"x-algolia-api-key\" => \"ALGOLIA_API_KEY\"}}\n)",
      "requestOptions queryParameters accepts booleans": "response = client.custom_post(\n  \"test/requestOptions\",\n  {query: \"parameters\"},\n  {facet: \"filters\"},\n  {:query_params => JSON.parse(\"{\\\"isItWorking\\\":true}\", :symbolize_names => true)}\n)",
      "requestOptions queryParameters accepts integers": "response = client.custom_post(\n  \"test/requestOptions\",\n  {query: \"parameters\"},\n  {facet: \"filters\"},\n  {:query_params => JSON.parse(\"{\\\"myParam\\\":2}\", :symbolize_names => true)}\n)",
      "requestOptions queryParameters accepts list of string": "response = client.custom_post(\n  \"test/requestOptions\",\n  {query: \"parameters\"},\n  {facet: \"filters\"},\n  {:query_params => JSON.parse(\"{\\\"myParam\\\":[\\\"b and c\\\",\\\"d\\\"]}\", :symbolize_names => true)}\n)",
      "requestOptions queryParameters accepts list of booleans": "response = client.custom_post(\n  \"test/requestOptions\",\n  {query: \"parameters\"},\n  {facet: \"filters\"},\n  {:query_params => JSON.parse(\"{\\\"myParam\\\":[true,true,false]}\", :symbolize_names => true)}\n)",
      "requestOptions queryParameters accepts list of integers": "response = client.custom_post(\n  \"test/requestOptions\",\n  {query: \"parameters\"},\n  {facet: \"filters\"},\n  {:query_params => JSON.parse(\"{\\\"myParam\\\":[1,2]}\", :symbolize_names => true)}\n)"
    },
    "customPut": {
      "allow put method for a custom path with minimal parameters": "response = client.custom_put(\"test/minimal\")",
      "allow put method for a custom path with all parameters": "response = client.custom_put(\"test/all\", {query: \"parameters\"}, {body: \"parameters\"})"
    },
    "deleteApiKey": {
      "default": "response = client.delete_api_key(\"myTestApiKey\")"
    },
    "deleteBy": {
      "default": "response = client.delete_by(\"<YOUR_INDEX_NAME>\", Algolia::Search::DeleteByParams.new(filters: \"brand:brandName\"))"
    },
    "deleteIndex": {
      "default": "response = client.delete_index(\"<YOUR_INDEX_NAME>\")"
    },
    "deleteObject": {
      "default": "response = client.delete_object(\"<YOUR_INDEX_NAME>\", \"uniqueID\")"
    },
    "deleteObjects": {
      "default": "response = client.delete_objects(\"<YOUR_INDEX_NAME>\", [\"1\", \"2\"])"
    },
    "deleteRule": {
      "delete rule simple case": "response = client.delete_rule(\"<YOUR_INDEX_NAME>\", \"id1\")",
      "delete rule with simple characters to encode in objectID": "response = client.delete_rule(\"<YOUR_INDEX_NAME>\", \"test/with/slash\")"
    },
    "deleteSource": {
      "default": "response = client.delete_source(\"theSource\")"
    },
    "deleteSynonym": {
      "default": "response = client.delete_synonym(\"<YOUR_INDEX_NAME>\", \"id1\")"
    },
    "generateSecuredApiKey": {
      "api key basic": "response = client.generate_secured_api_key(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  Algolia::Search::SecuredApiKeyRestrictions.new(valid_until: 2524604400, restrict_indices: [\"Movies\"])\n)",
      "with searchParams": "response = client.generate_secured_api_key(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  Algolia::Search::SecuredApiKeyRestrictions.new(\n    valid_until: 2524604400,\n    restrict_indices: [\"Movies\", \"cts_e2e_settings\"],\n    restrict_sources: \"192.168.1.0/24\",\n    filters: \"category:Book OR category:Ebook AND _tags:published\",\n    user_token: \"user123\",\n    search_params: Algolia::Search::SearchParamsObject.new(\n      query: \"batman\",\n      typo_tolerance: \"strict\",\n      around_radius: \"all\",\n      mode: \"neuralSearch\",\n      hits_per_page: 10,\n      optional_words: [\"one\", \"two\"]\n    )\n  )\n)",
      "with filters": "response = client.generate_secured_api_key(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  Algolia::Search::SecuredApiKeyRestrictions.new(\n    filters: \"user:user42 AND user:public AND (visible_by:John OR visible_by:group/Finance)\"\n  )\n)",
      "with visible_by filter": "response = client.generate_secured_api_key(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  Algolia::Search::SecuredApiKeyRestrictions.new(filters: \"visible_by:group/Finance\")\n)",
      "with userID": "response = client.generate_secured_api_key(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  Algolia::Search::SecuredApiKeyRestrictions.new(user_token: \"user42\")\n)",
      "mcm with filters": "response = client.generate_secured_api_key(\n  \"YourSearchOnlyApiKey\",\n  Algolia::Search::SecuredApiKeyRestrictions.new(filters: \"user:user42 AND user:public\")\n)",
      "mcm with user token": "response = client.generate_secured_api_key(\n  \"YourSearchOnlyApiKey\",\n  Algolia::Search::SecuredApiKeyRestrictions.new(user_token: \"user42\")\n)"
    },
    "getApiKey": {
      "default": "response = client.get_api_key(\"myTestApiKey\")"
    },
    "getAppTask": {
      "default": "response = client.get_app_task(123)"
    },
    "getDictionaryLanguages": {
      "default": "response = client.get_dictionary_languages"
    },
    "getDictionarySettings": {
      "default": "response = client.get_dictionary_settings"
    },
    "getLogs": {
      "getLogs with minimal parameters": "response = client.get_logs",
      "getLogs with parameters": "response = client.get_logs(5, 10, \"<YOUR_INDEX_NAME>\", \"all\")"
    },
    "getObject": {
      "getObject": "response = client.get_object(\"<YOUR_INDEX_NAME>\", \"uniqueID\", [\"attr1\", \"attr2\"])",
      "search with a real object": "response = client.get_object(\"<YOUR_INDEX_NAME>\", \"Batman and Robin\")"
    },
    "getObjects": {
      "by ID": "response = client.get_objects(\n  Algolia::Search::GetObjectsParams.new(\n    requests: [Algolia::Search::GetObjectsRequest.new(algolia_object_id: \"uniqueID\", index_name: \"<YOUR_INDEX_NAME>\")]\n  )\n)",
      "multiple IDs": "response = client.get_objects(\n  Algolia::Search::GetObjectsParams.new(\n    requests: [\n      Algolia::Search::GetObjectsRequest.new(algolia_object_id: \"uniqueID1\", index_name: \"<YOUR_INDEX_NAME>\"),\n      Algolia::Search::GetObjectsRequest.new(algolia_object_id: \"uniqueID2\", index_name: \"<YOUR_INDEX_NAME>\")\n    ]\n  )\n)",
      "with attributesToRetrieve": "response = client.get_objects(\n  Algolia::Search::GetObjectsParams.new(\n    requests: [\n      Algolia::Search::GetObjectsRequest.new(\n        attributes_to_retrieve: [\"attr1\", \"attr2\"],\n        algolia_object_id: \"uniqueID\",\n        index_name: \"<YOUR_INDEX_NAME>\"\n      )\n    ]\n  )\n)"
    },
    "getRule": {
      "default": "response = client.get_rule(\"<YOUR_INDEX_NAME>\", \"qr-1725004648916\")"
    },
    "getSettings": {
      "default": "response = client.get_settings(\"<YOUR_INDEX_NAME>\")"
    },
    "getSources": {
      "default": "response = client.get_sources"
    },
    "getSynonym": {
      "default": "response = client.get_synonym(\"<YOUR_INDEX_NAME>\", \"id1\")"
    },
    "getTask": {
      "default": "response = client.get_task(\"<YOUR_INDEX_NAME>\", 123)"
    },
    "getTopUserIds": {
      "default": "response = client.get_top_user_ids"
    },
    "getUserId": {
      "default": "response = client.get_user_id(\"uniqueID\")"
    },
    "hasPendingMappings": {
      "hasPendingMappings with minimal parameters": "response = client.has_pending_mappings",
      "hasPendingMappings with parameters": "response = client.has_pending_mappings(true)"
    },
    "indexExists": {
      "indexExists": "response = client.index_exists(\"<YOUR_INDEX_NAME>\")",
      "indexNotExists": "response = client.index_exists(\"<YOUR_INDEX_NAME>\")",
      "indexExistsWithError": "response = client.index_exists(\"<YOUR_INDEX_NAME>\")"
    },
    "listApiKeys": {
      "default": "response = client.list_api_keys"
    },
    "listClusters": {
      "default": "response = client.list_clusters"
    },
    "listIndices": {
      "listIndices with minimal parameters": "response = client.list_indices",
      "listIndices with parameters": "response = client.list_indices(8, 3)"
    },
    "listUserIds": {
      "listUserIds with minimal parameters": "response = client.list_user_ids",
      "listUserIds with parameters": "response = client.list_user_ids(8, 100)"
    },
    "multipleBatch": {
      "default": "response = client.multiple_batch(\n  Algolia::Search::BatchParams.new(\n    requests: [\n      Algolia::Search::MultipleBatchRequest.new(\n        action: \"addObject\",\n        body: {key: \"value\"},\n        index_name: \"<YOUR_INDEX_NAME>\"\n      )\n    ]\n  )\n)"
    },
    "operationIndex": {
      "scopes": "response = client.operation_index(\n  \"<SOURCE_INDEX_NAME>\",\n  Algolia::Search::OperationIndexParams.new(\n    operation: \"move\",\n    destination: \"<DESTINATION_INDEX_NAME>\",\n    scope: [\"rules\", \"settings\"]\n  )\n)",
      "copy": "response = client.operation_index(\n  \"<SOURCE_INDEX_NAME>\",\n  Algolia::Search::OperationIndexParams.new(operation: \"copy\", destination: \"<DESTINATION_INDEX_NAME>\")\n)",
      "move": "response = client.operation_index(\n  \"<SOURCE_INDEX_NAME>\",\n  Algolia::Search::OperationIndexParams.new(operation: \"move\", destination: \"<DESTINATION_INDEX_NAME>\")\n)"
    },
    "partialUpdateObject": {
      "Partial update with a new value for a string attribute": "response = client.partial_update_object(\"<YOUR_INDEX_NAME>\", \"uniqueID\", {attributeId: \"new value\"})",
      "Partial update with a new value for an integer attribute": "response = client.partial_update_object(\"<YOUR_INDEX_NAME>\", \"uniqueID\", {attributeId: 1})",
      "Partial update with a new value for a boolean attribute": "response = client.partial_update_object(\"<YOUR_INDEX_NAME>\", \"uniqueID\", {attributeId: true})",
      "Partial update with a new value for an array attribute": "response = client.partial_update_object(\"<YOUR_INDEX_NAME>\", \"uniqueID\", {attributeId: [\"one\", \"two\", \"three\"]})",
      "Partial update with a new value for an object attribute": "response = client.partial_update_object(\"<YOUR_INDEX_NAME>\", \"uniqueID\", {attributeId: {nested: \"value\"}})",
      "with visible_by filter": "response = client.partial_update_object(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  {visible_by: [\"Angela\", \"group/Finance\", \"group/Shareholders\"]}\n)",
      "add men pant": "response = client.partial_update_object(\n  \"<YOUR_INDEX_NAME>\",\n  \"productId\",\n  {categoryPageId: {_operation: \"Add\", value: \"men-clothing-pants\"}}\n)",
      "remove men pant": "response = client.partial_update_object(\n  \"<YOUR_INDEX_NAME>\",\n  \"productId\",\n  {categoryPageId: {_operation: \"Remove\", value: \"men-clothing-pants\"}}\n)"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "response = client.partial_update_objects(\n  \"<YOUR_INDEX_NAME>\",\n  [{objectID: \"1\", name: \"Adam\"}, {objectID: \"2\", name: \"Benoit\"}],\n  true\n)",
      "call partialUpdateObjects with createIfNotExists=false": "response = client.partial_update_objects(\n  \"<YOUR_INDEX_NAME>\",\n  [{objectID: \"3\", name: \"Cyril\"}, {objectID: \"4\", name: \"David\"}],\n  false\n)"
    },
    "removeUserId": {
      "default": "response = client.remove_user_id(\"uniqueID\")"
    },
    "replaceAllObjects": {
      "call replaceAllObjects without error": "response = client.replace_all_objects(\n  \"<YOUR_INDEX_NAME>\",\n  [\n    {objectID: \"1\", name: \"Adam\"},\n    {objectID: \"2\", name: \"Benoit\"},\n    {objectID: \"3\", name: \"Cyril\"},\n    {objectID: \"4\", name: \"David\"},\n    {objectID: \"5\", name: \"Eva\"},\n    {objectID: \"6\", name: \"Fiona\"},\n    {objectID: \"7\", name: \"Gael\"},\n    {objectID: \"8\", name: \"Hugo\"},\n    {objectID: \"9\", name: \"Igor\"},\n    {objectID: \"10\", name: \"Julia\"}\n  ],\n  3\n)",
      "call replaceAllObjects with partial scopes": "response = client.replace_all_objects(\n  \"<YOUR_INDEX_NAME>\",\n  [{objectID: \"1\", name: \"Adam\"}, {objectID: \"2\", name: \"Benoit\"}],\n  77,\n  [\"settings\", \"synonyms\"]\n)",
      "replaceAllObjects should cleanup on failure": "response = client.replace_all_objects(\n  \"<YOUR_INDEX_NAME>\",\n  [{objectID: \"fine\", body: \"small obj\"}, {objectID: \"toolarge\", body: \"something bigger than 10KB\"}]\n)"
    },
    "replaceSources": {
      "default": "response = client.replace_sources([Algolia::Search::Source.new(source: \"theSource\", description: \"theDescription\")])"
    },
    "restoreApiKey": {
      "default": "response = client.restore_api_key(\"ALGOLIA_API_KEY\")"
    },
    "saveObject": {
      "default": "response = client.save_object(\n  \"<YOUR_INDEX_NAME>\",\n  {\n    name: \"Black T-shirt\",\n    color: \"#000000||black\",\n    availableIn: \"https://source.unsplash.com/100x100/?paris||Paris\",\n    objectID: \"myID\"\n  }\n)"
    },
    "saveObjects": {
      "call saveObjects without error": "response = client.save_objects(\n  \"<YOUR_INDEX_NAME>\",\n  [{objectID: \"1\", name: \"Adam\"}, {objectID: \"2\", name: \"Benoit\"}]\n)",
      "saveObjects should report errors": "response = client.save_objects(\n  \"<YOUR_INDEX_NAME>\",\n  [{objectID: \"1\", name: \"Adam\"}, {objectID: \"2\", name: \"Benoit\"}]\n)",
      "saveObjectsPlaylist": "response = client.save_objects(\n  \"<YOUR_INDEX_NAME>\",\n  [\n    {\n      objectID: \"1\",\n      visibility: \"public\",\n      name: \"Hot 100 Billboard Charts\",\n      playlistId: \"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\",\n      createdAt: \"1500240452\"\n    }\n  ]\n)",
      "saveObjectsPublicUser": "response = client.save_objects(\n  \"<YOUR_INDEX_NAME>\",\n  [\n    {\n      objectID: \"1\",\n      visibility: \"public\",\n      name: \"Hot 100 Billboard Charts\",\n      playlistId: \"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\",\n      createdAt: \"1500240452\"\n    }\n  ],\n  false,\n  1000,\n  {:header_params => {\"X-Algolia-User-ID\" => \"*\"}}\n)"
    },
    "saveRule": {
      "saveRule with minimal parameters": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"id1\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"id1\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"apple\", anchoring: \"contains\")],\n    consequence: Algolia::Search::Consequence.new(\n      params: Algolia::Search::ConsequenceParams.new(filters: \"brand:xiaomi\")\n    )\n  )\n)",
      "saveRule with all parameters": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"id1\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"id1\",\n    conditions: [\n      Algolia::Search::Condition.new(pattern: \"apple\", anchoring: \"contains\", alternatives: false, context: \"search\")\n    ],\n    consequence: Algolia::Search::Consequence.new(\n      params: Algolia::Search::ConsequenceParams.new(\n        filters: \"brand:apple\",\n        query: Algolia::Search::ConsequenceQueryObject.new(\n          remove: [\"algolia\"],\n          edits: [\n            Algolia::Search::Edit.new(type: \"remove\", delete: \"abc\", insert: \"cde\"),\n            Algolia::Search::Edit.new(type: \"replace\", delete: \"abc\", insert: \"cde\")\n          ]\n        )\n      ),\n      hide: [Algolia::Search::ConsequenceHide.new(algolia_object_id: \"321\")],\n      filter_promotes: false,\n      user_data: {algolia: \"aloglia\"},\n      promote: [\n        Algolia::Search::PromoteObjectID.new(algolia_object_id: \"abc\", position: 3),\n        Algolia::Search::PromoteObjectIDs.new(object_ids: [\"abc\", \"def\"], position: 1)\n      ]\n    ),\n    description: \"test\",\n    enabled: true,\n    validity: [Algolia::Search::TimeRange.new(from: 1656670273, _until: 1656670277)]\n  ),\n  true\n)",
      "b2b catalog": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"article-rule\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"article-rule\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"article\", anchoring: \"startsWith\")],\n    consequence: Algolia::Search::Consequence.new(\n      params: Algolia::Search::ConsequenceParams.new(\n        query: Algolia::Search::ConsequenceQueryObject.new(\n          edits: [Algolia::Search::Edit.new(type: \"remove\", delete: \"article\")]\n        ),\n        restrict_searchable_attributes: [\"title\", \"book_id\"]\n      )\n    )\n  )\n)",
      "merchandising and promoting": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"director-rule\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"director-rule\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"{facet:director} director\", anchoring: \"contains\")],\n    consequence: Algolia::Search::Consequence.new(\n      params: Algolia::Search::ConsequenceParams.new(\n        restrict_searchable_attributes: [\"title\", \"book_id\"],\n        automatic_facet_filters: [Algolia::Search::AutomaticFacetFilter.new(facet: \"director\")],\n        query: Algolia::Search::ConsequenceQueryObject.new(\n          edits: [Algolia::Search::Edit.new(type: \"remove\", delete: \"director\")]\n        )\n      )\n    )\n  )\n)",
      "harry potter": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"harry-potter-rule\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"harry-potter-rule\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"harry potter\", anchoring: \"contains\")],\n    consequence: Algolia::Search::Consequence.new(user_data: {promo_content: \"20% OFF on all Harry Potter books!\"})\n  )\n)",
      "merchandising empty query": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"clearance-category-filter\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"clearance-category-filter\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"\", anchoring: \"is\", context: \"landing\")],\n    consequence: Algolia::Search::Consequence.new(\n      params: Algolia::Search::ConsequenceParams.new(optional_filters: \"clearance:true\")\n    )\n  )\n)",
      "redirect": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"redirect-help-rule\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"redirect-help-rule\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"help\", anchoring: \"contains\")],\n    consequence: Algolia::Search::Consequence.new(user_data: {redirect: \"https://www.algolia.com/support\"})\n  )\n)",
      "promote some results over others": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"tomato-fruit\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"tomato-fruit\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"tomato\", anchoring: \"contains\")],\n    consequence: Algolia::Search::Consequence.new(\n      params: Algolia::Search::ConsequenceParams.new(optional_filters: \"food_group:fruit\")\n    )\n  )\n)",
      "promote several hits": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"Promote-Apple-Newest\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"Promote-Apple-Newest\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"apple\", anchoring: \"is\")],\n    consequence: Algolia::Search::Consequence.new(\n      promote: [Algolia::Search::PromoteObjectIDs.new(object_ids: [\"iPhone-12345\", \"watch-123\"], position: 0)]\n    )\n  )\n)",
      "promote newest release": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"Promote-iPhone-X\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"Promote-iPhone-X\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"iPhone\", anchoring: \"contains\")],\n    consequence: Algolia::Search::Consequence.new(\n      promote: [Algolia::Search::PromoteObjectID.new(algolia_object_id: \"iPhone-12345\", position: 0)]\n    )\n  )\n)",
      "promote single item": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"promote-harry-potter-box-set\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"promote-harry-potter-box-set\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"Harry Potter\", anchoring: \"contains\")],\n    consequence: Algolia::Search::Consequence.new(\n      promote: [Algolia::Search::PromoteObjectID.new(algolia_object_id: \"HP-12345\", position: 0)]\n    )\n  )\n)",
      "limit search results": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"article-rule\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"article-rule\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"article\", anchoring: \"startsWith\")],\n    consequence: Algolia::Search::Consequence.new(\n      params: Algolia::Search::ConsequenceParams.new(\n        query: Algolia::Search::ConsequenceQueryObject.new(\n          edits: [Algolia::Search::Edit.new(type: \"remove\", delete: \"article\")]\n        ),\n        restrict_searchable_attributes: [\"title\", \"book_id\"]\n      )\n    )\n  )\n)",
      "query match": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"tagged-brand-rule\",\n  Algolia::Search::Rule.new(\n    conditions: [\n      Algolia::Search::Condition.new(pattern: \"brand: {facet:brand}\", anchoring: \"contains\", alternatives: false)\n    ],\n    consequence: Algolia::Search::Consequence.new(\n      params: Algolia::Search::ConsequenceParams.new(\n        automatic_facet_filters: [Algolia::Search::AutomaticFacetFilter.new(facet: \"brand\")],\n        query: Algolia::Search::ConsequenceQueryObject.new(remove: [\"brand:\", \"{facet:brand}\"])\n      )\n    ),\n    description: \"filter on brand: {brand}\",\n    algolia_object_id: \"tagged-brand-rule\"\n  )\n)",
      "dynamic filtering": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"color-facets\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"color-facets\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"{facet:color}\")],\n    consequence: Algolia::Search::Consequence.new(\n      params: Algolia::Search::ConsequenceParams.new(\n        automatic_facet_filters: [Algolia::Search::AutomaticFacetFilter.new(facet: \"color\")]\n      )\n    )\n  )\n)",
      "hide hits": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"hide-12345\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"hide-12345\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"cheap\", anchoring: \"contains\")],\n    consequence: Algolia::Search::Consequence.new(\n      hide: [Algolia::Search::ConsequenceHide.new(algolia_object_id: \"to-hide-12345\")]\n    )\n  )\n)",
      "one rule per facet": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"red-color\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"red-color\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"red\", anchoring: \"contains\")],\n    consequence: Algolia::Search::Consequence.new(\n      params: Algolia::Search::ConsequenceParams.new(\n        query: Algolia::Search::ConsequenceQueryObject.new(remove: [\"red\"]),\n        filters: \"color:red\"\n      )\n    )\n  )\n)",
      "numerical filters": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"cheap\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"cheap\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"cheap\", anchoring: \"contains\")],\n    consequence: Algolia::Search::Consequence.new(\n      params: Algolia::Search::ConsequenceParams.new(\n        query: Algolia::Search::ConsequenceQueryObject.new(remove: [\"cheap\"]),\n        filters: \"price < 10\"\n      )\n    )\n  )\n)",
      "negative filters": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"gluten-free-rule\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"gluten-free-rule\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"gluten-free\", anchoring: \"contains\")],\n    consequence: Algolia::Search::Consequence.new(\n      params: Algolia::Search::ConsequenceParams.new(\n        filters: \"NOT allergens:gluten\",\n        query: Algolia::Search::ConsequenceQueryObject.new(\n          edits: [Algolia::Search::Edit.new(type: \"remove\", delete: \"gluten-free\")]\n        )\n      )\n    )\n  )\n)",
      "positive filters": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"diet-rule\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"diet-rule\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"diet\", anchoring: \"contains\")],\n    consequence: Algolia::Search::Consequence.new(\n      params: Algolia::Search::ConsequenceParams.new(\n        filters: \"'low-carb' OR 'low-fat'\",\n        query: Algolia::Search::ConsequenceQueryObject.new(\n          edits: [Algolia::Search::Edit.new(type: \"remove\", delete: \"diet\")]\n        )\n      )\n    )\n  )\n)",
      "conditionless": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"diet-rule\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"diet-rule\",\n    consequence: Algolia::Search::Consequence.new(\n      params: Algolia::Search::ConsequenceParams.new(\n        filters: \"'low-carb' OR 'low-fat'\",\n        query: Algolia::Search::ConsequenceQueryObject.new(\n          edits: [Algolia::Search::Edit.new(type: \"remove\", delete: \"diet\")]\n        )\n      )\n    )\n  )\n)",
      "contextual": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"a-rule-id\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"a-rule-id\",\n    conditions: [Algolia::Search::Condition.new(context: \"mobile\")],\n    consequence: Algolia::Search::Consequence.new(\n      params: Algolia::Search::ConsequenceParams.new(filters: \"release_date >= 1577836800\")\n    )\n  )\n)",
      "saveRule always active rule": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"a-rule-id\",\n  Algolia::Search::Rule.new(\n    algolia_object_id: \"a-rule-id\",\n    consequence: Algolia::Search::Consequence.new(params: Algolia::Search::ConsequenceParams.new(around_radius: 1000)),\n    validity: [Algolia::Search::TimeRange.new(from: 1577836800, _until: 1577836800)]\n  )\n)"
    },
    "saveRules": {
      "saveRules with minimal parameters": "response = client.save_rules(\n  \"<YOUR_INDEX_NAME>\",\n  [\n    Algolia::Search::Rule.new(\n      algolia_object_id: \"a-rule-id\",\n      conditions: [Algolia::Search::Condition.new(pattern: \"smartphone\", anchoring: \"contains\")],\n      consequence: Algolia::Search::Consequence.new(\n        params: Algolia::Search::ConsequenceParams.new(filters: \"brand:apple\")\n      )\n    ),\n    Algolia::Search::Rule.new(\n      algolia_object_id: \"a-second-rule-id\",\n      conditions: [Algolia::Search::Condition.new(pattern: \"apple\", anchoring: \"contains\")],\n      consequence: Algolia::Search::Consequence.new(\n        params: Algolia::Search::ConsequenceParams.new(filters: \"brand:samsung\")\n      )\n    )\n  ],\n  false,\n  true\n)",
      "saveRules with all parameters": "response = client.save_rules(\n  \"<YOUR_INDEX_NAME>\",\n  [\n    Algolia::Search::Rule.new(\n      algolia_object_id: \"id1\",\n      conditions: [\n        Algolia::Search::Condition.new(\n          pattern: \"apple\",\n          anchoring: \"contains\",\n          alternatives: false,\n          context: \"search\"\n        )\n      ],\n      consequence: Algolia::Search::Consequence.new(\n        params: Algolia::Search::ConsequenceParams.new(\n          filters: \"brand:apple\",\n          query: Algolia::Search::ConsequenceQueryObject.new(\n            remove: [\"algolia\"],\n            edits: [\n              Algolia::Search::Edit.new(type: \"remove\", delete: \"abc\", insert: \"cde\"),\n              Algolia::Search::Edit.new(type: \"replace\", delete: \"abc\", insert: \"cde\")\n            ]\n          )\n        ),\n        hide: [Algolia::Search::ConsequenceHide.new(algolia_object_id: \"321\")],\n        filter_promotes: false,\n        user_data: {algolia: \"aloglia\"},\n        promote: [\n          Algolia::Search::PromoteObjectID.new(algolia_object_id: \"abc\", position: 3),\n          Algolia::Search::PromoteObjectIDs.new(object_ids: [\"abc\", \"def\"], position: 1)\n        ]\n      ),\n      description: \"test\",\n      enabled: true,\n      validity: [Algolia::Search::TimeRange.new(from: 1656670273, _until: 1656670277)]\n    )\n  ],\n  true,\n  true\n)",
      "dynamic filtering": "response = client.save_rules(\n  \"<YOUR_INDEX_NAME>\",\n  [\n    Algolia::Search::Rule.new(\n      algolia_object_id: \"toaster\",\n      conditions: [Algolia::Search::Condition.new(pattern: \"toaster\", anchoring: \"contains\")],\n      consequence: Algolia::Search::Consequence.new(\n        params: Algolia::Search::ConsequenceParams.new(\n          query: Algolia::Search::ConsequenceQueryObject.new(remove: [\"toaster\"]),\n          filters: \"product_type:toaster\"\n        )\n      )\n    ),\n    Algolia::Search::Rule.new(\n      algolia_object_id: \"cheap\",\n      conditions: [Algolia::Search::Condition.new(pattern: \"cheap\", anchoring: \"contains\")],\n      consequence: Algolia::Search::Consequence.new(\n        params: Algolia::Search::ConsequenceParams.new(\n          query: Algolia::Search::ConsequenceQueryObject.new(remove: [\"cheap\"]),\n          filters: \"price < 15\"\n        )\n      )\n    )\n  ]\n)",
      "enhance search results": "response = client.save_rules(\n  \"<YOUR_INDEX_NAME>\",\n  [\n    Algolia::Search::Rule.new(\n      algolia_object_id: \"country\",\n      conditions: [Algolia::Search::Condition.new(pattern: \"{facet:country}\", anchoring: \"contains\")],\n      consequence: Algolia::Search::Consequence.new(\n        params: Algolia::Search::ConsequenceParams.new(around_lat_lng_via_ip: false)\n      )\n    ),\n    Algolia::Search::Rule.new(\n      algolia_object_id: \"city\",\n      conditions: [Algolia::Search::Condition.new(pattern: \"{facet:city}\", anchoring: \"contains\")],\n      consequence: Algolia::Search::Consequence.new(\n        params: Algolia::Search::ConsequenceParams.new(around_lat_lng_via_ip: false)\n      )\n    )\n  ]\n)"
    },
    "saveSynonym": {
      "default": "response = client.save_synonym(\n  \"<YOUR_INDEX_NAME>\",\n  \"id1\",\n  Algolia::Search::SynonymHit.new(algolia_object_id: \"id1\", type: \"synonym\", synonyms: [\"car\", \"vehicule\", \"auto\"]),\n  true\n)"
    },
    "saveSynonyms": {
      "default": "response = client.save_synonyms(\n  \"<YOUR_INDEX_NAME>\",\n  [\n    Algolia::Search::SynonymHit.new(algolia_object_id: \"id1\", type: \"synonym\", synonyms: [\"car\", \"vehicule\", \"auto\"]),\n    Algolia::Search::SynonymHit.new(\n      algolia_object_id: \"id2\",\n      type: \"onewaysynonym\",\n      input: \"iphone\",\n      synonyms: [\"ephone\", \"aphone\", \"yphone\"]\n    )\n  ],\n  true,\n  true\n)"
    },
    "search": {
      "withHitsPerPage": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(index_name: \"<YOUR_INDEX_NAME>\", query: \"<YOUR_QUERY>\", hits_per_page: 50)\n    ]\n  )\n)",
      "filterOnly": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        filters: \"actor:Scarlett Johansson\"\n      )\n    ]\n  )\n)",
      "filterOr": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        filters: \"actor:Tom Cruise OR actor:Scarlett Johansson\"\n      )\n    ]\n  )\n)",
      "filterNot": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        filters: \"NOT actor:Nicolas Cage\"\n      )\n    ]\n  )\n)",
      "search for a single hits request with minimal parameters": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [Algolia::Search::SearchForHits.new(index_name: \"<YOUR_INDEX_NAME>\")]\n  )\n)",
      "search with highlight and snippet results": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        query: \"vim\",\n        attributes_to_snippet: [\"*:20\"],\n        attributes_to_highlight: [\"*\"],\n        attributes_to_retrieve: [\"*\"]\n      )\n    ]\n  )\n)",
      "retrieveFacets": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        facets: [\"author\", \"genre\"]\n      )\n    ]\n  )\n)",
      "retrieveFacetsWildcard": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(index_name: \"<YOUR_INDEX_NAME>\", query: \"<YOUR_QUERY>\", facets: [\"*\"])\n    ]\n  )\n)",
      "search for a single facet request with minimal parameters": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [Algolia::Search::SearchForFacets.new(index_name: \"<YOUR_INDEX_NAME>\", type: \"facet\", facet: \"editor\")],\n    strategy: \"stopIfEnoughMatches\"\n  )\n)",
      "search for a single hits request with all parameters": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        query: \"myQuery\",\n        hits_per_page: 50,\n        type: \"default\"\n      )\n    ]\n  )\n)",
      "search for a single facet request with all parameters": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForFacets.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        type: \"facet\",\n        facet: \"theFacet\",\n        facet_query: \"theFacetQuery\",\n        query: \"theQuery\",\n        max_facet_hits: 50\n      )\n    ],\n    strategy: \"stopIfEnoughMatches\"\n  )\n)",
      "search for multiple mixed requests in multiple indices with minimal parameters": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(index_name: \"<YOUR_INDEX_NAME>\"),\n      Algolia::Search::SearchForFacets.new(index_name: \"<YOUR_INDEX_NAME>\", type: \"facet\", facet: \"theFacet\"),\n      Algolia::Search::SearchForHits.new(index_name: \"<YOUR_INDEX_NAME>\", type: \"default\")\n    ],\n    strategy: \"stopIfEnoughMatches\"\n  )\n)",
      "search for multiple mixed requests in multiple indices with all parameters": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForFacets.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        type: \"facet\",\n        facet: \"theFacet\",\n        facet_query: \"theFacetQuery\",\n        query: \"theQuery\",\n        max_facet_hits: 50\n      ),\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        query: \"myQuery\",\n        hits_per_page: 50,\n        type: \"default\"\n      )\n    ],\n    strategy: \"stopIfEnoughMatches\"\n  )\n)",
      "search filters accept all of the possible shapes": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        facet_filters: \"mySearch:filters\",\n        re_ranking_apply_filter: \"mySearch:filters\",\n        tag_filters: \"mySearch:filters\",\n        numeric_filters: \"mySearch:filters\",\n        optional_filters: \"mySearch:filters\"\n      ),\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        facet_filters: [\"mySearch:filters\", [\"mySearch:filters\", [\"mySearch:filters\"]]],\n        re_ranking_apply_filter: [\"mySearch:filters\", [\"mySearch:filters\"]],\n        tag_filters: [\"mySearch:filters\", [\"mySearch:filters\"]],\n        numeric_filters: [\"mySearch:filters\", [\"mySearch:filters\"]],\n        optional_filters: [\"mySearch:filters\", [\"mySearch:filters\"]]\n      )\n    ]\n  )\n)",
      "search filters end to end": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        filters: \"editor:'visual studio' OR editor:neovim\"\n      ),\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        facet_filters: [\"editor:'visual studio'\", \"editor:neovim\"]\n      ),\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        facet_filters: [\"editor:'visual studio'\", [\"editor:neovim\"]]\n      ),\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        facet_filters: [\"editor:'visual studio'\", [\"editor:neovim\", [\"editor:goland\"]]]\n      )\n    ]\n  )\n)",
      "search with all search parameters": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(\n        advanced_syntax: true,\n        advanced_syntax_features: [\"exactPhrase\"],\n        allow_typos_on_numeric_tokens: true,\n        alternatives_as_exact: [\"multiWordsSynonym\"],\n        analytics: true,\n        analytics_tags: [\"\"],\n        around_lat_lng: \"\",\n        around_lat_lng_via_ip: true,\n        around_precision: 0,\n        around_radius: \"all\",\n        attribute_criteria_computed_by_min_proximity: true,\n        attributes_to_highlight: [\"\"],\n        attributes_to_retrieve: [\"\"],\n        attributes_to_snippet: [\"\"],\n        click_analytics: true,\n        decompound_query: true,\n        disable_exact_on_attributes: [\"\"],\n        disable_typo_tolerance_on_attributes: [\"\"],\n        distinct: 0,\n        enable_ab_test: true,\n        enable_personalization: true,\n        enable_re_ranking: true,\n        enable_rules: true,\n        exact_on_single_word_query: \"attribute\",\n        facet_filters: [\"\"],\n        faceting_after_distinct: true,\n        facets: [\"\"],\n        filters: \"\",\n        get_ranking_info: true,\n        highlight_post_tag: \"\",\n        highlight_pre_tag: \"\",\n        hits_per_page: 1,\n        ignore_plurals: false,\n        index_name: \"<YOUR_INDEX_NAME>\",\n        inside_bounding_box: [[47.3165, 4.9665, 47.3424, 5.0201], [40.9234, 2.1185, 38.643, 1.9916]],\n        inside_polygon: [\n          [47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9],\n          [40.9234, 2.1185, 38.643, 1.9916, 39.2587, 2.0104]\n        ],\n        length: 1,\n        max_values_per_facet: 0,\n        min_proximity: 1,\n        min_word_sizefor1_typo: 0,\n        min_word_sizefor2_typos: 0,\n        minimum_around_radius: 1,\n        natural_languages: [\"fr\"],\n        numeric_filters: [\"\"],\n        offset: 0,\n        optional_filters: [\"\"],\n        optional_words: [\"\"],\n        page: 0,\n        percentile_computation: true,\n        personalization_impact: 0,\n        query: \"\",\n        query_languages: [\"fr\"],\n        query_type: \"prefixAll\",\n        ranking: [\"\"],\n        re_ranking_apply_filter: [\"\"],\n        relevancy_strictness: 0,\n        remove_stop_words: true,\n        remove_words_if_no_results: \"allOptional\",\n        rendering_content: Algolia::Search::RenderingContent.new(\n          facet_ordering: Algolia::Search::FacetOrdering.new(\n            facets: Algolia::Search::Facets.new(order: [\"a\", \"b\"]),\n            values: {a: Algolia::Search::Value.new(order: [\"b\"], sort_remaining_by: \"count\")}\n          )\n        ),\n        replace_synonyms_in_highlight: true,\n        response_fields: [\"\"],\n        restrict_highlight_and_snippet_arrays: true,\n        restrict_searchable_attributes: [\"\"],\n        rule_contexts: [\"\"],\n        similar_query: \"\",\n        snippet_ellipsis_text: \"\",\n        sort_facet_values_by: \"\",\n        sum_or_filters_scores: true,\n        synonyms: true,\n        tag_filters: [\"\"],\n        type: \"default\",\n        typo_tolerance: \"min\",\n        user_token: \"\"\n      )\n    ]\n  )\n)"
    },
    "searchDictionaryEntries": {
      "get searchDictionaryEntries results with minimal parameters": "response = client.search_dictionary_entries(\n  \"stopwords\",\n  Algolia::Search::SearchDictionaryEntriesParams.new(query: \"about\")\n)",
      "get searchDictionaryEntries results with all parameters": "response = client.search_dictionary_entries(\n  \"compounds\",\n  Algolia::Search::SearchDictionaryEntriesParams.new(query: \"foo\", page: 4, hits_per_page: 2, language: \"fr\")\n)"
    },
    "searchForFacetValues": {
      "get searchForFacetValues results with minimal parameters": "response = client.search_for_facet_values(\"<YOUR_INDEX_NAME>\", \"facetName\")",
      "get searchForFacetValues results with all parameters": "response = client.search_for_facet_values(\n  \"<YOUR_INDEX_NAME>\",\n  \"facetName\",\n  Algolia::Search::SearchForFacetValuesRequest.new(\n    params: \"query=foo&facetFilters=['bar']\",\n    facet_query: \"foo\",\n    max_facet_hits: 42\n  )\n)",
      "facetName and facetQuery": "response = client.search_for_facet_values(\n  \"<YOUR_INDEX_NAME>\",\n  \"author\",\n  Algolia::Search::SearchForFacetValuesRequest.new(facet_query: \"stephen\")\n)"
    },
    "searchRules": {
      "default": "response = client.search_rules(\"<YOUR_INDEX_NAME>\", Algolia::Search::SearchRulesParams.new(query: \"zorro\"))"
    },
    "searchSingleIndex": {
      "search with minimal parameters": "response = client.search_single_index(\"<YOUR_INDEX_NAME>\")",
      "search with special characters in indexName": "response = client.search_single_index(\"<YOUR_INDEX_NAME>\")",
      "search with searchParams": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"myQuery\", facet_filters: [\"tags:algolia\"])\n)",
      "single search retrieve snippets": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    query: \"batman mask of the phantasm\",\n    attributes_to_retrieve: [\"*\"],\n    attributes_to_snippet: [\"*:20\"]\n  )\n)",
      "query": "response = client.search_single_index(\"<YOUR_INDEX_NAME>\", Algolia::Search::SearchParamsObject.new(query: \"phone\"))",
      "filters": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(filters: \"country:US AND price.gross < 2.0\")\n)",
      "filters for stores": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    query: \"ben\",\n    filters: \"categories:politics AND store:Gibert Joseph Saint-Michel\"\n  )\n)",
      "filters boolean": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(filters: \"is_available:true\")\n)",
      "distinct": "response = client.search_single_index(\"<YOUR_INDEX_NAME>\", Algolia::Search::SearchParamsObject.new(distinct: true))",
      "filtersNumeric": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(filters: \"price < 10\")\n)",
      "filtersTimestamp": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(filters: \"NOT date_timestamp:1514764800 TO 1546300799\")\n)",
      "filtersSumOrFiltersScoresFalse": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    filters: \"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\",\n    sum_or_filters_scores: false\n  )\n)",
      "filtersSumOrFiltersScoresTrue": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    filters: \"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\",\n    sum_or_filters_scores: true\n  )\n)",
      "filtersStephenKing": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(filters: \"author:\\\"Stephen King\\\"\")\n)",
      "filtersNotTags": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"harry\", filters: \"_tags:non-fiction\")\n)",
      "facetFiltersList": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    facet_filters: [\"publisher:Penguin\", [\"author:Stephen King\", \"genre:Horror\"]]\n  )\n)",
      "facetFiltersBook": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", facet_filters: [\"category:Book\"])\n)",
      "facetFiltersAND": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", facet_filters: [\"category:Book\", \"author:John Doe\"])\n)",
      "facetFiltersOR": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", facet_filters: [[\"category:Book\", \"author:John Doe\"]])\n)",
      "facetFiltersCombined": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    query: \"query\",\n    facet_filters: [\"author:John Doe\", [\"category:Book\", \"category:Movie\"]]\n  )\n)",
      "facetFiltersNeg": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(facet_filters: \"category:-Ebook\")\n)",
      "filtersAndFacetFilters": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    filters: \"(author:\\\"Stephen King\\\" OR genre:\\\"Horror\\\")\",\n    facet_filters: [\"publisher:Penguin\"]\n  )\n)",
      "facet author genre": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(facets: [\"author\", \"genre\"])\n)",
      "facet wildcard": "response = client.search_single_index(\"<YOUR_INDEX_NAME>\", Algolia::Search::SearchParamsObject.new(facets: [\"*\"]))",
      "maxValuesPerFacet": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(max_values_per_facet: 1000)\n)",
      "aroundLatLng": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(around_lat_lng: \"40.71, -74.01\")\n)",
      "aroundLatLngViaIP": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(around_lat_lng_via_ip: true)\n)",
      "aroundRadius": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(around_lat_lng: \"40.71, -74.01\", around_radius: 1000000)\n)",
      "insideBoundingBox": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    inside_bounding_box: [[49.067996905313834, 65.73828125, 25.905859247243498, 128.8046875]]\n  )\n)",
      "insidePolygon": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    inside_polygon: [\n      [\n        42.01,\n        -124.31,\n        48.835509470063045,\n        -124.40453125000005,\n        45.01082951668149,\n        -65.95726562500005,\n        31.247243545293433,\n        -81.06578125000004,\n        25.924152577235226,\n        -97.68234374999997,\n        32.300311895879545,\n        -117.54828125\n      ]\n    ]\n  )\n)",
      "optionalFilters": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(optional_filters: [\"can_deliver_quickly:true\"])\n)",
      "optionalFiltersMany": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    optional_filters: [\"brand:Apple<score=3>\", \"brand:Samsung<score=2>\", \"brand:-Huawei\"]\n  )\n)",
      "optionalFiltersSimple": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(optional_filters: [\"brand:Apple<score=2>\", \"type:tablet\"])\n)",
      "restrictSearchableAttributes": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(restrict_searchable_attributes: [\"title_fr\"])\n)",
      "getRankingInfo": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(get_ranking_info: true)\n)",
      "clickAnalytics": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(click_analytics: true)\n)",
      "clickAnalyticsUserToken": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(click_analytics: true, user_token: \"user-1\")\n)",
      "enablePersonalization": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(enable_personalization: true, user_token: \"user-1\")\n)",
      "userToken": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(user_token: \"user-1\")\n)",
      "userToken1234": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", user_token: \"user-1234\")\n)",
      "analyticsTag": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(analytics_tags: [\"YOUR_ANALYTICS_TAG\"])\n)",
      "facetFiltersUsers": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(facet_filters: [\"user:user42\", \"user:public\"])\n)",
      "buildTheQuery": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    filters: \"categoryPageId: Men's Clothing\",\n    hits_per_page: 50,\n    analytics_tags: [\"mens-clothing\"]\n  )\n)",
      "attributesToHighlightOverride": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", attributes_to_highlight: [\"title\", \"content\"])\n)",
      "disableTypoToleranceOnAttributes": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", disable_typo_tolerance_on_attributes: [\"serial_number\"])\n)",
      "search_a_query": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    query: \"\",\n    similar_query: \"Comedy Drama Crime McDormand Macy Buscemi Stormare Presnell Coen\",\n    filters: \"year:1991 TO 2001\"\n  )\n)",
      "search_everything": "response = client.search_single_index(\"<YOUR_INDEX_NAME>\", Algolia::Search::SearchParamsObject.new(query: \"\"))",
      "api_filtering_range_example": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"books\", filters: \"price:10 TO 20\")\n)",
      "override_retrievable_attributes": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", attributes_to_retrieve: [\"title\", \"content\"])\n)",
      "restrict_searchable_attributes": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", restrict_searchable_attributes: [\"title\", \"author\"])\n)",
      "override_default_relevancy": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", relevancy_strictness: 70)\n)",
      "apply_filters": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", sum_or_filters_scores: true)\n)",
      "apply_all_filters": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    query: \"query\",\n    filters: \"available = 1 AND (category:Book OR NOT category:Ebook) AND _tags:published AND publication_date:1441745506 TO 1441755506 AND inStock > 0 AND author:\\\"John Doe\\\"\"\n  )\n)",
      "escape_spaces": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", filters: \"category:\\\"Books and Comics\\\"\")\n)",
      "escape_keywords": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", filters: \"keyword:\\\"OR\\\"\")\n)",
      "escape_single_quotes": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", filters: \"content:\\\"It's a wonderful day\\\"\")\n)",
      "escape_double_quotes": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", filters: \"content:\\\"She said \\\"Hello World\\\"\")\n)",
      "apply_negative_filters": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", optional_filters: [\"category:Book\", \"author:-John Doe\"])\n)",
      "apply_negative_filters_restaurants": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", optional_filters: [\"restaurant:-Bert's Inn\"])\n)",
      "apply_numeric_filters": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    query: \"query\",\n    numeric_filters: [\"price < 1000\", [\"inStock = 1\", \"deliveryDate < 1441755506\"]]\n  )\n)",
      "apply_tag_filters": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", tag_filters: [\"SciFi\", [\"Book\", \"Movie\"]])\n)",
      "facets_all": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", facets: [\"*\"])\n)",
      "retrieve_only_some_facets": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", facets: [\"category\", \"author\"])\n)",
      "override_default_max_values_per_facet": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", max_values_per_facet: 20)\n)",
      "enable_faceting_after_distinct": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", faceting_after_distinct: true)\n)",
      "sort_facet_values_alphabetically": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", sort_facet_values_by: \"count\")\n)",
      "override_attributes_to_snippet": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", attributes_to_snippet: [\"title\", \"content:80\"])\n)",
      "override_default_highlight_pre_tag": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", highlight_pre_tag: \"<strong>\")\n)",
      "override_default_highlight_post_tag": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", highlight_post_tag: \"</strong>\")\n)",
      "override_default_snippet_ellipsis_text": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", snippet_ellipsis_text: \"\")\n)",
      "enable_restrict_highlight_and_snippet_arrays": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", restrict_highlight_and_snippet_arrays: false)\n)",
      "access_page": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", page: 0)\n)",
      "override_default_hits_per_page": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", hits_per_page: 10)\n)",
      "get_nth_hit": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", offset: 4)\n)",
      "get_n_results": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", length: 4)\n)",
      "override_default_min_word_size_for_one_typo": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", min_word_sizefor1_typo: 2)\n)",
      "override_default_min_word_size_for_two_typos": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", min_word_sizefor2_typos: 2)\n)",
      "override_default_typo_tolerance_mode": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", typo_tolerance: false)\n)",
      "disable_typos_on_numeric_tokens_at_search_time": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", allow_typos_on_numeric_tokens: false)\n)",
      "search_around_a_position": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", around_lat_lng: \"40.71, -74.01\")\n)",
      "search_around_server_ip": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", around_lat_lng_via_ip: true),\n  {\n    :header_params => {\n      \"x-forwarded-for\" => \"94.228.178.246 // should be replaced with the actual IP you would like to search around\"\n    }\n  }\n)",
      "set_around_radius": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", around_radius: 1000)\n)",
      "disable_automatic_radius": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", around_radius: \"all\")\n)",
      "set_geo_search_precision": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", around_precision: 100)\n)",
      "set_geo_search_precision_non_linear": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    query: \"query\",\n    around_precision: [\n      Algolia::Search::Range.new(from: 0, value: 25),\n      Algolia::Search::Range.new(from: 2000, value: 1000)\n    ]\n  )\n)",
      "set_minimum_geo_search_radius": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", minimum_around_radius: 1000)\n)",
      "search_inside_rectangular_area": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    query: \"query\",\n    inside_bounding_box: [[46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625]]\n  )\n)",
      "search_inside_multiple_rectangular_areas": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    query: \"query\",\n    inside_bounding_box: [\n      [46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625],\n      [49.62625916704081, 4.6181640625, 47.715070300900194, 0.482421875]\n    ]\n  )\n)",
      "search_inside_polygon_area": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    query: \"query\",\n    inside_polygon: [\n      [46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625]\n    ]\n  )\n)",
      "search_inside_multiple_polygon_areas": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    query: \"query\",\n    inside_polygon: [\n      [46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625],\n      [\n        49.62625916704081,\n        4.6181640625,\n        47.715070300900194,\n        0.482421875,\n        45.17210966999772,\n        1.009765625,\n        50.62626704081,\n        4.6181640625\n      ]\n    ]\n  )\n)",
      "set_querylanguages_override": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", remove_stop_words: [\"ca\", \"es\"])\n)",
      "set_querylanguages_with_japanese_query": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", query_languages: [\"ja\", \"en\"])\n)",
      "set_natural_languages": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"\", natural_languages: [\"fr\"])\n)",
      "override_natural_languages_with_query": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    query: \"\",\n    natural_languages: [\"fr\"],\n    remove_words_if_no_results: \"firstWords\"\n  )\n)",
      "enable_decompound_query_search_time": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", decompound_query: true)\n)",
      "enable_rules_search_time": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", enable_rules: true)\n)",
      "set_rule_contexts": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", rule_contexts: [\"front_end\", \"website2\"])\n)",
      "enable_personalization": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", enable_personalization: true)\n)",
      "enable_personalization_with_user_token": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", enable_personalization: true, user_token: \"123456\")\n)",
      "personalization_impact": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", personalization_impact: 20)\n)",
      "set_user_token": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", user_token: \"123456\")\n)",
      "set_user_token_with_personalization": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", enable_personalization: true, user_token: \"123456\")\n)",
      "override_default_query_type": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", query_type: \"prefixAll\")\n)",
      "override_default_remove_words_if_no_results": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", remove_words_if_no_results: \"lastWords\")\n)",
      "enable_advanced_syntax_search_time": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", advanced_syntax: true)\n)",
      "overide_default_optional_words": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", optional_words: [\"toyota\", \"2020 2021\"])\n)",
      "disabling_exact_for_some_attributes_search_time": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", disable_exact_on_attributes: [\"description\"])\n)",
      "override_default_exact_single_word_query": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", exact_on_single_word_query: \"none\")\n)",
      "override_default_aternative_as_exact": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", alternatives_as_exact: [\"multiWordsSynonym\"])\n)",
      "enable_advanced_syntax_exact_phrase": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    query: \"query\",\n    advanced_syntax: true,\n    advanced_syntax_features: [\"exactPhrase\"]\n  )\n)",
      "enable_advanced_syntax_exclude_words": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(\n    query: \"query\",\n    advanced_syntax: true,\n    advanced_syntax_features: [\"excludeWords\"]\n  )\n)",
      "override_distinct": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", distinct: 0)\n)",
      "get_ranking_info": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", get_ranking_info: true)\n)",
      "disable_click_analytics": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", click_analytics: false)\n)",
      "enable_click_analytics": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", click_analytics: true)\n)",
      "disable_analytics": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", analytics: false)\n)",
      "add_analytics_tags": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", analytics_tags: [\"front_end\", \"website2\"])\n)",
      "disable_synonyms": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", synonyms: false)\n)",
      "override_replace_synonyms_in_highlights": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", replace_synonyms_in_highlight: true)\n)",
      "override_min_proximity": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", min_proximity: 2)\n)",
      "override_default_field": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", response_fields: [\"hits\", \"facets\"])\n)",
      "override_percentile_computation": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", percentile_computation: false)\n)",
      "set_ab_test": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", enable_ab_test: false)\n)",
      "set_enable_re_ranking": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\", enable_re_ranking: false)\n)",
      "with algolia user id": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"query\"),\n  {:header_params => {\"X-Algolia-User-ID\" => \"user1234\"}}\n)",
      "mcm with algolia user id": "response = client.search_single_index(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchParamsObject.new(query: \"peace\"),\n  {:header_params => {\"X-Algolia-User-ID\" => \"user42\"}}\n)"
    },
    "searchSynonyms": {
      "searchSynonyms with minimal parameters": "response = client.search_synonyms(\"<YOUR_INDEX_NAME>\")",
      "searchSynonyms with all parameters": "response = client.search_synonyms(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::SearchSynonymsParams.new(query: \"myQuery\", type: \"altcorrection1\", page: 10, hits_per_page: 10)\n)"
    },
    "searchUserIds": {
      "default": "response = client.search_user_ids(\n  Algolia::Search::SearchUserIdsParams.new(query: \"test\", cluster_name: \"theClusterName\", page: 5, hits_per_page: 10)\n)"
    },
    "setClientApiKey": {
      "default": "client.set_client_api_key(\"updated-api-key\")"
    },
    "setDictionarySettings": {
      "get setDictionarySettings results with minimal parameters": "response = client.set_dictionary_settings(\n  Algolia::Search::DictionarySettingsParams.new(\n    disable_standard_entries: Algolia::Search::StandardEntries.new(plurals: {fr: false, en: false, ru: true})\n  )\n)",
      "get setDictionarySettings results with all parameters": "response = client.set_dictionary_settings(\n  Algolia::Search::DictionarySettingsParams.new(\n    disable_standard_entries: Algolia::Search::StandardEntries.new(\n      plurals: {fr: false, en: false, ru: true},\n      stopwords: {fr: false},\n      compounds: {ru: true}\n    )\n  )\n)"
    },
    "setSettings": {
      "minimal parameters": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(pagination_limited_to: 10),\n  true\n)",
      "boolean typoTolerance": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(typo_tolerance: true), true)",
      "enum typoTolerance": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(typo_tolerance: \"min\"), true)",
      "ignorePlurals": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(ignore_plurals: true), true)",
      "list of string ignorePlurals": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(ignore_plurals: [\"fr\"]), true)",
      "removeStopWords boolean": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(remove_stop_words: true), true)",
      "removeStopWords list of string": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(remove_stop_words: [\"fr\"]),\n  true\n)",
      "boolean distinct": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(distinct: true), true)",
      "integer distinct": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(distinct: 1), true)",
      "distinct company": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attribute_for_distinct: \"company\", distinct: true)\n)",
      "distinct design": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attribute_for_distinct: \"design\", distinct: true)\n)",
      "distinct true": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(distinct: true))",
      "distinct section": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attribute_for_distinct: \"section\", distinct: true)\n)",
      "attributesForFaceting allergens": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_for_faceting: [\"allergens\"])\n)",
      "attributesForFaceting availableIn": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_for_faceting: [\"color\", \"availableIn\"])\n)",
      "api_attributes_for_faceting": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_for_faceting: [\"genre\", \"author\"])\n)",
      "api_attributes_for_faceting_searchable": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_for_faceting: [\"genre\", \"searchable(author)\"])\n)",
      "api_attributes_for_filter_only": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_for_faceting: [\"filterOnly(genre)\", \"author\"])\n)",
      "attributesForFaceting categoryPageId": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_for_faceting: [\"searchable(categoryPageId)\"])\n)",
      "unretrievableAttributes": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(unretrievable_attributes: [\"visible_by\"])\n)",
      "attributesForFaceting user restricted data": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_for_faceting: [\"filterOnly(visible_by)\"])\n)",
      "attributesForFaceting optional filters": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_for_faceting: [\"can_deliver_quickly\", \"restaurant\"])\n)",
      "attributesForFaceting redirect index": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_for_faceting: [\"query_terms\"])\n)",
      "attributesForFaceting multiple consequences": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_for_faceting: [\"director\"])\n)",
      "attributesForFaceting in-depth optional filters": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_for_faceting: [\"filterOnly(brand)\"])\n)",
      "mode neuralSearch": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(mode: \"neuralSearch\"))",
      "mode keywordSearch": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(mode: \"keywordSearch\"))",
      "searchableAttributes same priority": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(searchable_attributes: [\"title,comments\", \"ingredients\"])\n)",
      "searchableAttributes higher priority": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(searchable_attributes: [\"title\", \"ingredients\"])\n)",
      "customRanking retweets": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(custom_ranking: [\"desc(retweets)\", \"desc(likes)\"])\n)",
      "customRanking boosted": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(custom_ranking: [\"desc(boosted)\"])\n)",
      "customRanking pageviews": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(custom_ranking: [\"desc(pageviews)\", \"desc(comments)\"])\n)",
      "customRanking applying search parameters for a specific query": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    custom_ranking: [\"desc(nb_airline_liaisons)\"],\n    attributes_for_faceting: [\"city, country\"]\n  )\n)",
      "customRanking rounded pageviews": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(custom_ranking: [\"desc(rounded_pageviews)\", \"desc(comments)\"])\n)",
      "customRanking price": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(custom_ranking: [\"desc(price)\"])\n)",
      "ranking exhaustive (price)": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    ranking: [\"desc(price)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"]\n  )\n)",
      "ranking exhaustive (is_popular)": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    ranking: [\"desc(is_popular)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"]\n  )\n)",
      "ranking standard replica": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(ranking: [\"desc(post_date_timestamp)\"])\n)",
      "ranking virtual replica": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(custom_ranking: [\"desc(post_date_timestamp)\"])\n)",
      "customRanking and ranking sort alphabetically": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    custom_ranking: [\"asc(textual_attribute)\"],\n    ranking: [\"custom\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\"]\n  )\n)",
      "relevancyStrictness": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(custom_ranking: [\"asc(textual_attribute)\"], relevancy_strictness: 0)\n)",
      "create replica index": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(replicas: [\"products_price_desc\"])\n)",
      "create replica index articles": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(replicas: [\"articles_date_desc\"])\n)",
      "create virtual replica index": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(replicas: [\"virtual(products_price_desc)\"])\n)",
      "unlink replica index": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(replicas: [\"\"]))",
      "forwardToReplicas": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(searchable_attributes: [\"name\", \"description\"]),\n  true\n)",
      "maxValuesPerFacet": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(max_values_per_facet: 1000))",
      "maxFacetHits": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(max_facet_hits: 100))",
      "attributesForFaceting complex": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    attributes_for_faceting: [\"actor\", \"filterOnly(category)\", \"searchable(publisher)\"]\n  )\n)",
      "ranking closest dates": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    ranking: [\"asc(date_timestamp)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"]\n  )\n)",
      "searchableAttributes item variation": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(searchable_attributes: [\"design\", \"type\", \"color\"])\n)",
      "searchableAttributes around location": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    searchable_attributes: [\"name\", \"country\", \"city\", \"iata_code\"],\n    custom_ranking: [\"desc(links_count)\"]\n  )\n)",
      "attributesToHighlight": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_to_highlight: [\"author\", \"title\", \"content\"])\n)",
      "attributesToHighlightStar": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_to_highlight: [\"*\"])\n)",
      "everything": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    advanced_syntax: true,\n    advanced_syntax_features: [\"exactPhrase\"],\n    allow_compression_of_integer_array: true,\n    allow_typos_on_numeric_tokens: true,\n    alternatives_as_exact: [\"singleWordSynonym\"],\n    attribute_criteria_computed_by_min_proximity: true,\n    attribute_for_distinct: \"test\",\n    attributes_for_faceting: [\"algolia\"],\n    attributes_to_highlight: [\"algolia\"],\n    attributes_to_retrieve: [\"algolia\"],\n    attributes_to_snippet: [\"algolia\"],\n    attributes_to_transliterate: [\"algolia\"],\n    camel_case_attributes: [\"algolia\"],\n    custom_normalization: {algolia: {aloglia: \"aglolia\"}},\n    custom_ranking: [\"algolia\"],\n    decompound_query: false,\n    decompounded_attributes: {algolia: \"aloglia\"},\n    disable_exact_on_attributes: [\"algolia\"],\n    disable_prefix_on_attributes: [\"algolia\"],\n    disable_typo_tolerance_on_attributes: [\"algolia\"],\n    disable_typo_tolerance_on_words: [\"algolia\"],\n    distinct: 3,\n    enable_personalization: true,\n    enable_re_ranking: false,\n    enable_rules: true,\n    exact_on_single_word_query: \"attribute\",\n    highlight_pre_tag: \"<span>\",\n    highlight_post_tag: \"</span>\",\n    hits_per_page: 10,\n    ignore_plurals: false,\n    index_languages: [\"fr\"],\n    keep_diacritics_on_characters: \"abc\",\n    max_facet_hits: 20,\n    max_values_per_facet: 30,\n    min_proximity: 6,\n    min_word_sizefor1_typo: 5,\n    min_word_sizefor2_typos: 11,\n    mode: \"neuralSearch\",\n    numeric_attributes_for_filtering: [\"algolia\"],\n    optional_words: [\"myspace\"],\n    pagination_limited_to: 0,\n    query_languages: [\"fr\"],\n    query_type: \"prefixLast\",\n    ranking: [\"geo\"],\n    re_ranking_apply_filter: \"mySearch:filters\",\n    relevancy_strictness: 10,\n    remove_stop_words: false,\n    remove_words_if_no_results: \"lastWords\",\n    rendering_content: Algolia::Search::RenderingContent.new(\n      facet_ordering: Algolia::Search::FacetOrdering.new(\n        facets: Algolia::Search::Facets.new(order: [\"a\", \"b\"]),\n        values: {a: Algolia::Search::Value.new(order: [\"b\"], sort_remaining_by: \"count\")}\n      )\n    ),\n    replace_synonyms_in_highlight: true,\n    replicas: [\"\"],\n    response_fields: [\"algolia\"],\n    restrict_highlight_and_snippet_arrays: true,\n    searchable_attributes: [\"foo\"],\n    semantic_search: Algolia::Search::SemanticSearch.new(event_sources: [\"foo\"]),\n    separators_to_index: \"bar\",\n    snippet_ellipsis_text: \"---\",\n    sort_facet_values_by: \"date\",\n    typo_tolerance: false,\n    unretrievable_attributes: [\"foo\"],\n    user_data: {user: \"data\"}\n  )\n)",
      "searchableAttributesWithCustomRankingsAndAttributesForFaceting": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    searchable_attributes: [\"brand\", \"name\", \"categories\", \"unordered(description)\"],\n    custom_ranking: [\"desc(popularity)\"],\n    attributes_for_faceting: [\"searchable(brand)\", \"type\", \"categories\", \"price\"]\n  )\n)",
      "searchableAttributesOrdering": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(searchable_attributes: [\"unordered(title)\", \"cast\"])\n)",
      "searchableAttributesProductReferenceSuffixes": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    searchable_attributes: [\"name\", \"product_reference\", \"product_reference_suffixes\"]\n  )\n)",
      "queryLanguageAndIgnorePlurals": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(query_languages: [\"en\"], ignore_plurals: true)\n)",
      "searchableAttributesInMovies": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(searchable_attributes: [\"title_eng\", \"title_fr\", \"title_es\"])\n)",
      "disablePrefixOnAttributes": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(disable_prefix_on_attributes: [\"serial_number\"])\n)",
      "disableTypoToleranceOnAttributes": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(disable_typo_tolerance_on_attributes: [\"serial_number\"])\n)",
      "searchableAttributesSimpleExample": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(searchable_attributes: [\"serial_number\"])\n)",
      "searchableAttributesSimpleExampleAlt": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(searchable_attributes: [\"serial_number\", \"serial_number_suffixes\"])\n)",
      "set_searchable_attributes": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    attributes_for_faceting: [\n      \"author\",\n      \"filterOnly(isbn)\",\n      \"searchable(edition)\",\n      \"afterDistinct(category)\",\n      \"afterDistinct(searchable(publisher))\"\n    ]\n  )\n)",
      "unretrievable_attributes": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(unretrievable_attributes: [\"total_number_of_sales\"])\n)",
      "set_retrievable_attributes": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_to_retrieve: [\"author\", \"title\", \"content\"])\n)",
      "set_all_attributes_as_retrievable": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(attributes_to_retrieve: [\"*\"]))",
      "specify_attributes_not_to_retrieve": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_to_retrieve: [\"*\", \"-SKU\", \"-internal_desc\"])\n)",
      "neural_search": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(mode: \"neuralSearch\"))",
      "keyword_search": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(mode: \"keywordSearch\"))",
      "set_default_ranking": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    ranking: [\"typo\", \"geo\", \"words\", \"filters\", \"attribute\", \"proximity\", \"exact\", \"custom\"]\n  )\n)",
      "set_ranking_by_attribute_asc": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    ranking: [\"asc(price)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"]\n  )\n)",
      "set_ranking_by_attribute_desc": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    ranking: [\"desc(price)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"]\n  )\n)",
      "restrict_searchable_attributes": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(custom_ranking: [\"desc(popularity)\", \"asc(price)\"])\n)",
      "set_default_relevancy": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(relevancy_strictness: 90))",
      "set_replicas": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(replicas: [\"name_of_replica_index1\", \"name_of_replica_index2\"])\n)",
      "set_default_max_values_per_facet": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(max_values_per_facet: 100))",
      "set_default_sort_facet_values_by": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(sort_facet_values_by: \"alpha\"))",
      "set_attributes_to_snippet": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_to_snippet: [\"content:80\", \"description\"])\n)",
      "set_all_attributes_to_snippet": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attributes_to_snippet: [\"*:80\"])\n)",
      "set_default_highlight_pre_tag": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(highlight_pre_tag: \"<em>\"))",
      "set_default_highlight_post_tag": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(highlight_post_tag: \"</em>\"))",
      "set_default_snippet_ellipsis_text": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(snippet_ellipsis_text: \"…\"))",
      "enable_restrict_highlight_and_snippet_arrays_by_default": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(restrict_highlight_and_snippet_arrays: true)\n)",
      "set_default_hits_per_page": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(hits_per_page: 20))",
      "set_pagination_limit": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(pagination_limited_to: 1000))",
      "set_default_min_word_size_for_one_typo": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(min_word_sizefor1_typo: 4))",
      "set_default_min_word_size_for_two_typos": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(min_word_sizefor2_typos: 4))",
      "set_default_typo_tolerance_mode": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(typo_tolerance: true))",
      "disable_typos_on_numeric_tokens_by_default": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(allow_typos_on_numeric_tokens: false)\n)",
      "disable_typo_tolerance_for_words": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(disable_typo_tolerance_on_words: [\"wheel\", \"1X2BCD\"])\n)",
      "set_separators_to_index": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(separators_to_index: \"+#\"))",
      "set_languages_using_querylanguages": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(query_languages: [\"es\"], remove_stop_words: true, ignore_plurals: true)\n)",
      "set_attributes_to_transliterate": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(index_languages: [\"ja\"], attributes_to_transliterate: [\"name\", \"description\"])\n)",
      "set_camel_case_attributes": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(camel_case_attributes: [\"description\"])\n)",
      "set_decompounded_attributes": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(decompounded_attributes: {de: [\"name\"]})\n)",
      "set_decompounded_multiple_attributes": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    decompounded_attributes: {de: [\"name_de\", \"description_de\"], fi: [\"name_fi\", \"description_fi\"]}\n  )\n)",
      "set_keep_diacritics_on_characters": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(keep_diacritics_on_characters: \"øé\")\n)",
      "set_custom_normalization": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(custom_normalization: {default: {ä: \"ae\"}})\n)",
      "set_indexlanguages": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(index_languages: [\"ja\"]))",
      "enable_decompound_query_by_default": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(decompound_query: true))",
      "enable_rules_syntax_by_default": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(enable_rules: true))",
      "enable_personalization_settings": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(enable_personalization: true))",
      "set_default_query_type": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(query_type: \"prefixLast\"))",
      "set_default_remove_words_if_no_result": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(remove_words_if_no_results: \"none\")\n)",
      "enable_advanced_syntax_by_default": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(advanced_syntax: true))",
      "set_default_optional_words": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(optional_words: [\"blue\", \"iphone case\"])\n)",
      "disabling_prefix_search_for_some_attributes_by_default": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(disable_prefix_on_attributes: [\"sku\"])\n)",
      "disabling_exact_for_some_attributes_by_default": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(disable_exact_on_attributes: [\"description\"])\n)",
      "set_default_exact_single_word_query": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(exact_on_single_word_query: \"attribute\")\n)",
      "set_default_aternative_as_exact": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(alternatives_as_exact: [\"ignorePlurals\", \"singleWordSynonym\"])\n)",
      "set_numeric_attributes_for_filtering": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(numeric_attributes_for_filtering: [\"quantity\", \"popularity\"])\n)",
      "enable_compression_of_integer_array": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(allow_compression_of_integer_array: true)\n)",
      "set_attributes_for_distinct": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(attribute_for_distinct: \"url\"))",
      "set_distinct": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(distinct: 1, attribute_for_distinct: \"url\")\n)",
      "set_replace_synonyms_in_highlights": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(replace_synonyms_in_highlight: false)\n)",
      "set_min_proximity": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(min_proximity: 1))",
      "set_default_field": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(response_fields: [\"hits\", \"hitsPerPage\", \"nbPages\", \"page\"])\n)",
      "set_max_facet_hits": "response = client.set_settings(\"<YOUR_INDEX_NAME>\", Algolia::Search::IndexSettings.new(max_facet_hits: 10))",
      "set_attribute_criteria_computed_by_min_proximity": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(attribute_criteria_computed_by_min_proximity: true)\n)",
      "set_user_data": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    user_data: {extraData: \"This is the custom data that you want to store in your index\"}\n  )\n)",
      "set_rendering_content": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    rendering_content: Algolia::Search::RenderingContent.new(\n      facet_ordering: Algolia::Search::FacetOrdering.new(\n        facets: Algolia::Search::Facets.new(order: [\"size\", \"brand\"]),\n        values: {\n          brand: Algolia::Search::Value.new(order: [\"uniqlo\"], hide: [\"muji\"], sort_remaining_by: \"count\"),\n          size: Algolia::Search::Value.new(order: [\"S\", \"M\", \"L\"], sort_remaining_by: \"hidden\")\n        }\n      )\n    )\n  )\n)"
    },
    "updateApiKey": {
      "default": "response = client.update_api_key(\n  \"ALGOLIA_API_KEY\",\n  Algolia::Search::ApiKey.new(\n    acl: [\"search\", \"addObject\"],\n    validity: 300,\n    max_queries_per_ip_per_hour: 100,\n    max_hits_per_query: 20\n  )\n)"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "response = client.wait_for_api_key(\"api-key-add-operation-test-ruby\", \"add\")",
      "wait for api key - update": "response = client.wait_for_api_key(\n  \"api-key-update-operation-test-ruby\",\n  \"update\",\n  Algolia::Search::ApiKey.new(\n    description: \"my updated api key\",\n    acl: [\"search\", \"addObject\", \"deleteObject\"],\n    indexes: [\"Movies\", \"Books\"],\n    referers: [\"*google.com\", \"*algolia.com\"],\n    validity: 305,\n    max_queries_per_ip_per_hour: 95,\n    max_hits_per_query: 20\n  )\n)",
      "wait for api key - delete": "response = client.wait_for_api_key(\"api-key-delete-operation-test-ruby\", \"delete\")"
    },
    "waitForAppTask": {
      "default": "response = client.wait_for_app_task(123)"
    },
    "waitForTask": {
      "default": "response = client.wait_for_task(\"<YOUR_INDEX_NAME>\", 123)"
    },
    "init": {
      "default": "client = Algolia::SearchClient.create(\"ALGOLIA_APPLICATION_ID\", \"ALGOLIA_API_KEY\")"
    }
  },
  "scala": {
    "import": {
      "default": "import algoliasearch.api.SearchClient\nimport algoliasearch.config.*\nimport algoliasearch.extension.SearchClientExtensions"
    },
    "addApiKey": {
      "minimal": "val response = Await.result(\n  client.addApiKey(\n    apiKey = ApiKey(\n      acl = Seq(Acl.withName(\"search\"), Acl.withName(\"addObject\")),\n      description = Some(\"my new api key\")\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "all": "val response = Await.result(\n  client.addApiKey(\n    apiKey = ApiKey(\n      acl = Seq(Acl.withName(\"search\"), Acl.withName(\"addObject\")),\n      description = Some(\"my new api key\"),\n      validity = Some(300),\n      maxQueriesPerIPPerHour = Some(100),\n      maxHitsPerQuery = Some(20)\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "addOrUpdateObject": {
      "default": "val response = Await.result(\n  client.addOrUpdateObject(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"uniqueID\",\n    body = JObject(List(JField(\"key\", JString(\"value\"))))\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "appendSource": {
      "default": "val response = Await.result(\n  client.appendSource(\n    source = Source(\n      source = \"theSource\",\n      description = Some(\"theDescription\")\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "assignUserId": {
      "simple": "val response = Await.result(\n  client.assignUserId(\n    xAlgoliaUserID = \"user42\",\n    assignUserIdParams = AssignUserIdParams(\n      cluster = \"d4242-eu\"\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "it should not encode the userID": "val response = Await.result(\n  client.assignUserId(\n    xAlgoliaUserID = \"user id with spaces\",\n    assignUserIdParams = AssignUserIdParams(\n      cluster = \"cluster with spaces\"\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "batch": {
      "addObject": "val response = Await.result(\n  client.batch(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    batchWriteParams = BatchWriteParams(\n      requests = Seq(\n        BatchRequest(\n          action = Action.withName(\"addObject\"),\n          body = JObject(List(JField(\"key\", JString(\"bar\")), JField(\"foo\", JString(\"1\"))))\n        ),\n        BatchRequest(\n          action = Action.withName(\"addObject\"),\n          body = JObject(List(JField(\"key\", JString(\"baz\")), JField(\"foo\", JString(\"2\"))))\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "clear": "val response = Await.result(\n  client.batch(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    batchWriteParams = BatchWriteParams(\n      requests = Seq(\n        BatchRequest(\n          action = Action.withName(\"clear\"),\n          body = JObject(List(JField(\"key\", JString(\"value\"))))\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "delete": "val response = Await.result(\n  client.batch(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    batchWriteParams = BatchWriteParams(\n      requests = Seq(\n        BatchRequest(\n          action = Action.withName(\"delete\"),\n          body = JObject(List(JField(\"key\", JString(\"value\"))))\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "deleteObject": "val response = Await.result(\n  client.batch(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    batchWriteParams = BatchWriteParams(\n      requests = Seq(\n        BatchRequest(\n          action = Action.withName(\"deleteObject\"),\n          body = JObject(List(JField(\"key\", JString(\"value\"))))\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "partialUpdateObject": "val response = Await.result(\n  client.batch(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    batchWriteParams = BatchWriteParams(\n      requests = Seq(\n        BatchRequest(\n          action = Action.withName(\"partialUpdateObject\"),\n          body = JObject(List(JField(\"key\", JString(\"value\"))))\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "partialUpdateObjectNoCreate": "val response = Await.result(\n  client.batch(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    batchWriteParams = BatchWriteParams(\n      requests = Seq(\n        BatchRequest(\n          action = Action.withName(\"partialUpdateObjectNoCreate\"),\n          body = JObject(List(JField(\"key\", JString(\"value\"))))\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "updateObject": "val response = Await.result(\n  client.batch(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    batchWriteParams = BatchWriteParams(\n      requests = Seq(\n        BatchRequest(\n          action = Action.withName(\"updateObject\"),\n          body = JObject(List(JField(\"key\", JString(\"value\"))))\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "batchAssignUserIds": {
      "default": "val response = Await.result(\n  client.batchAssignUserIds(\n    xAlgoliaUserID = \"userID\",\n    batchAssignUserIdsParams = BatchAssignUserIdsParams(\n      cluster = \"theCluster\",\n      users = Seq(\"user1\", \"user2\")\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "batchDictionaryEntries": {
      "replace": "val response = Await.result(\n  client.batchDictionaryEntries(\n    dictionaryName = DictionaryType.withName(\"plurals\"),\n    batchDictionaryEntriesParams = BatchDictionaryEntriesParams(\n      clearExistingDictionaryEntries = Some(true),\n      requests = Seq(\n        BatchDictionaryEntriesRequest(\n          action = DictionaryAction.withName(\"addEntry\"),\n          body = DictionaryEntry(\n            objectID = \"1\",\n            language = Some(SupportedLanguage.withName(\"en\")),\n            word = Some(\"fancy\"),\n            words = Some(Seq(\"believe\", \"algolia\")),\n            decomposition = Some(Seq(\"trust\", \"algolia\")),\n            state = Some(DictionaryEntryState.withName(\"enabled\"))\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "delete": "val response = Await.result(\n  client.batchDictionaryEntries(\n    dictionaryName = DictionaryType.withName(\"plurals\"),\n    batchDictionaryEntriesParams = BatchDictionaryEntriesParams(\n      clearExistingDictionaryEntries = Some(true),\n      requests = Seq(\n        BatchDictionaryEntriesRequest(\n          action = DictionaryAction.withName(\"deleteEntry\"),\n          body = DictionaryEntry(\n            objectID = \"1\"\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "append": "val response = Await.result(\n  client.batchDictionaryEntries(\n    dictionaryName = DictionaryType.withName(\"stopwords\"),\n    batchDictionaryEntriesParams = BatchDictionaryEntriesParams(\n      requests = Seq(\n        BatchDictionaryEntriesRequest(\n          action = DictionaryAction.withName(\"addEntry\"),\n          body = DictionaryEntry(\n            objectID = \"1\",\n            language = Some(SupportedLanguage.withName(\"en\")),\n            additionalProperties = Some(List(JField(\"additional\", JString(\"try me\"))))\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "browse": {
      "browse with minimal parameters": "val response = Await.result(\n  client.browse(\n    indexName = \"<YOUR_INDEX_NAME>\"\n  ),\n  Duration(100, \"sec\")\n)",
      "browse with search parameters": "val response = Await.result(\n  client.browse(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    browseParams = Some(\n      BrowseParamsObject(\n        query = Some(\"myQuery\"),\n        facetFilters = Some(FacetFilters(Seq(FacetFilters(\"tags:algolia\"))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "browse allow a cursor in parameters": "val response = Await.result(\n  client.browse(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    browseParams = Some(\n      BrowseParamsObject(\n        cursor = Some(\"test\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "clearObjects": {
      "default": "val response = Await.result(\n  client.clearObjects(\n    indexName = \"<YOUR_INDEX_NAME>\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "clearRules": {
      "default": "val response = Await.result(\n  client.clearRules(\n    indexName = \"<YOUR_INDEX_NAME>\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "clearSynonyms": {
      "default": "val response = Await.result(\n  client.clearSynonyms(\n    indexName = \"<YOUR_INDEX_NAME>\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "customDelete": {
      "allow del method for a custom path with minimal parameters": "val response = Await.result(\n  client.customDelete[JObject](\n    path = \"test/minimal\"\n  ),\n  Duration(100, \"sec\")\n)",
      "allow del method for a custom path with all parameters": "val response = Await.result(\n  client.customDelete[JObject](\n    path = \"test/all\",\n    parameters = Some(Map(\"query\" -> \"parameters\"))\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "customGet": {
      "allow get method for a custom path with minimal parameters": "val response = Await.result(\n  client.customGet[JObject](\n    path = \"test/minimal\"\n  ),\n  Duration(100, \"sec\")\n)",
      "allow get method for a custom path with all parameters": "val response = Await.result(\n  client.customGet[JObject](\n    path = \"test/all\",\n    parameters = Some(Map(\"query\" -> \"parameters with space\"))\n  ),\n  Duration(100, \"sec\")\n)",
      "requestOptions should be escaped too": "val response = Await.result(\n  client.customGet[JObject](\n    path = \"test/all\",\n    parameters = Some(Map(\"query\" -> \"to be overriden\")),\n    requestOptions = Some(\n      RequestOptions\n        .builder()\n        .withQueryParameter(\"query\", \"parameters with space\")\n        .withQueryParameter(\"and an array\", Seq(\"array\", \"with spaces\"))\n        .withHeader(\"x-header-1\", \"spaces are left alone\")\n        .build()\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "customPost": {
      "allow post method for a custom path with minimal parameters": "val response = Await.result(\n  client.customPost[JObject](\n    path = \"test/minimal\"\n  ),\n  Duration(100, \"sec\")\n)",
      "allow post method for a custom path with all parameters": "val response = Await.result(\n  client.customPost[JObject](\n    path = \"test/all\",\n    parameters = Some(Map(\"query\" -> \"parameters\")),\n    body = Some(JObject(List(JField(\"body\", JString(\"parameters\")))))\n  ),\n  Duration(100, \"sec\")\n)",
      "requestOptions can override default query parameters": "val response = Await.result(\n  client.customPost[JObject](\n    path = \"test/requestOptions\",\n    parameters = Some(Map(\"query\" -> \"parameters\")),\n    body = Some(JObject(List(JField(\"facet\", JString(\"filters\"))))),\n    requestOptions = Some(\n      RequestOptions\n        .builder()\n        .withQueryParameter(\"query\", \"myQueryParameter\")\n        .build()\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "requestOptions merges query parameters with default ones": "val response = Await.result(\n  client.customPost[JObject](\n    path = \"test/requestOptions\",\n    parameters = Some(Map(\"query\" -> \"parameters\")),\n    body = Some(JObject(List(JField(\"facet\", JString(\"filters\"))))),\n    requestOptions = Some(\n      RequestOptions\n        .builder()\n        .withQueryParameter(\"query2\", \"myQueryParameter\")\n        .build()\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "requestOptions can override default headers": "val response = Await.result(\n  client.customPost[JObject](\n    path = \"test/requestOptions\",\n    parameters = Some(Map(\"query\" -> \"parameters\")),\n    body = Some(JObject(List(JField(\"facet\", JString(\"filters\"))))),\n    requestOptions = Some(\n      RequestOptions\n        .builder()\n        .withHeader(\"x-algolia-api-key\", \"ALGOLIA_API_KEY\")\n        .build()\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "requestOptions merges headers with default ones": "val response = Await.result(\n  client.customPost[JObject](\n    path = \"test/requestOptions\",\n    parameters = Some(Map(\"query\" -> \"parameters\")),\n    body = Some(JObject(List(JField(\"facet\", JString(\"filters\"))))),\n    requestOptions = Some(\n      RequestOptions\n        .builder()\n        .withHeader(\"x-algolia-api-key\", \"ALGOLIA_API_KEY\")\n        .build()\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "requestOptions queryParameters accepts booleans": "val response = Await.result(\n  client.customPost[JObject](\n    path = \"test/requestOptions\",\n    parameters = Some(Map(\"query\" -> \"parameters\")),\n    body = Some(JObject(List(JField(\"facet\", JString(\"filters\"))))),\n    requestOptions = Some(\n      RequestOptions\n        .builder()\n        .withQueryParameter(\"isItWorking\", true)\n        .build()\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "requestOptions queryParameters accepts integers": "val response = Await.result(\n  client.customPost[JObject](\n    path = \"test/requestOptions\",\n    parameters = Some(Map(\"query\" -> \"parameters\")),\n    body = Some(JObject(List(JField(\"facet\", JString(\"filters\"))))),\n    requestOptions = Some(\n      RequestOptions\n        .builder()\n        .withQueryParameter(\"myParam\", 2)\n        .build()\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "requestOptions queryParameters accepts list of string": "val response = Await.result(\n  client.customPost[JObject](\n    path = \"test/requestOptions\",\n    parameters = Some(Map(\"query\" -> \"parameters\")),\n    body = Some(JObject(List(JField(\"facet\", JString(\"filters\"))))),\n    requestOptions = Some(\n      RequestOptions\n        .builder()\n        .withQueryParameter(\"myParam\", Seq(\"b and c\", \"d\"))\n        .build()\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "requestOptions queryParameters accepts list of booleans": "val response = Await.result(\n  client.customPost[JObject](\n    path = \"test/requestOptions\",\n    parameters = Some(Map(\"query\" -> \"parameters\")),\n    body = Some(JObject(List(JField(\"facet\", JString(\"filters\"))))),\n    requestOptions = Some(\n      RequestOptions\n        .builder()\n        .withQueryParameter(\"myParam\", Seq(true, true, false))\n        .build()\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "requestOptions queryParameters accepts list of integers": "val response = Await.result(\n  client.customPost[JObject](\n    path = \"test/requestOptions\",\n    parameters = Some(Map(\"query\" -> \"parameters\")),\n    body = Some(JObject(List(JField(\"facet\", JString(\"filters\"))))),\n    requestOptions = Some(\n      RequestOptions\n        .builder()\n        .withQueryParameter(\"myParam\", Seq(1, 2))\n        .build()\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "customPut": {
      "allow put method for a custom path with minimal parameters": "val response = Await.result(\n  client.customPut[JObject](\n    path = \"test/minimal\"\n  ),\n  Duration(100, \"sec\")\n)",
      "allow put method for a custom path with all parameters": "val response = Await.result(\n  client.customPut[JObject](\n    path = \"test/all\",\n    parameters = Some(Map(\"query\" -> \"parameters\")),\n    body = Some(JObject(List(JField(\"body\", JString(\"parameters\")))))\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "deleteApiKey": {
      "default": "val response = Await.result(\n  client.deleteApiKey(\n    key = \"myTestApiKey\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "deleteBy": {
      "default": "val response = Await.result(\n  client.deleteBy(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    deleteByParams = DeleteByParams(\n      filters = Some(\"brand:brandName\")\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "deleteIndex": {
      "default": "val response = Await.result(\n  client.deleteIndex(\n    indexName = \"<YOUR_INDEX_NAME>\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "deleteObject": {
      "default": "val response = Await.result(\n  client.deleteObject(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"uniqueID\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "deleteObjects": {
      "default": "val response = Await.result(\n  client.deleteObjects(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectIDs = Seq(\"1\", \"2\")\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "deleteRule": {
      "delete rule simple case": "val response = Await.result(\n  client.deleteRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"id1\"\n  ),\n  Duration(100, \"sec\")\n)",
      "delete rule with simple characters to encode in objectID": "val response = Await.result(\n  client.deleteRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"test/with/slash\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "deleteSource": {
      "default": "val response = Await.result(\n  client.deleteSource(\n    source = \"theSource\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "deleteSynonym": {
      "default": "val response = Await.result(\n  client.deleteSynonym(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"id1\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "generateSecuredApiKey": {
      "api key basic": "val response = client.generateSecuredApiKey(\n  parentApiKey = \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions = SecuredApiKeyRestrictions(\n    validUntil = Some(2524604400L),\n    restrictIndices = Some(Seq(\"Movies\"))\n  )\n)",
      "with searchParams": "val response = client.generateSecuredApiKey(\n  parentApiKey = \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions = SecuredApiKeyRestrictions(\n    validUntil = Some(2524604400L),\n    restrictIndices = Some(Seq(\"Movies\", \"cts_e2e_settings\")),\n    restrictSources = Some(\"192.168.1.0/24\"),\n    filters = Some(\"category:Book OR category:Ebook AND _tags:published\"),\n    userToken = Some(\"user123\"),\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"batman\"),\n        typoTolerance = Some(TypoToleranceEnum.withName(\"strict\")),\n        aroundRadius = Some(AroundRadiusAll.withName(\"all\")),\n        mode = Some(Mode.withName(\"neuralSearch\")),\n        hitsPerPage = Some(10),\n        optionalWords = Some(OptionalWords(Seq(\"one\", \"two\")))\n      )\n    )\n  )\n)",
      "with filters": "val response = client.generateSecuredApiKey(\n  parentApiKey = \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions = SecuredApiKeyRestrictions(\n    filters = Some(\"user:user42 AND user:public AND (visible_by:John OR visible_by:group/Finance)\")\n  )\n)",
      "with visible_by filter": "val response = client.generateSecuredApiKey(\n  parentApiKey = \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions = SecuredApiKeyRestrictions(\n    filters = Some(\"visible_by:group/Finance\")\n  )\n)",
      "with userID": "val response = client.generateSecuredApiKey(\n  parentApiKey = \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions = SecuredApiKeyRestrictions(\n    userToken = Some(\"user42\")\n  )\n)",
      "mcm with filters": "val response = client.generateSecuredApiKey(\n  parentApiKey = \"YourSearchOnlyApiKey\",\n  restrictions = SecuredApiKeyRestrictions(\n    filters = Some(\"user:user42 AND user:public\")\n  )\n)",
      "mcm with user token": "val response = client.generateSecuredApiKey(\n  parentApiKey = \"YourSearchOnlyApiKey\",\n  restrictions = SecuredApiKeyRestrictions(\n    userToken = Some(\"user42\")\n  )\n)"
    },
    "getApiKey": {
      "default": "val response = Await.result(\n  client.getApiKey(\n    key = \"myTestApiKey\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "getAppTask": {
      "default": "val response = Await.result(\n  client.getAppTask(\n    taskID = 123L\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "getDictionaryLanguages": {
      "default": "val response = Await.result(\n  client.getDictionaryLanguages(\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "getDictionarySettings": {
      "default": "val response = Await.result(\n  client.getDictionarySettings(\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "getLogs": {
      "getLogs with minimal parameters": "val response = Await.result(\n  client.getLogs(\n  ),\n  Duration(100, \"sec\")\n)",
      "getLogs with parameters": "val response = Await.result(\n  client.getLogs(\n    offset = Some(5),\n    length = Some(10),\n    indexName = Some(\"<YOUR_INDEX_NAME>\"),\n    `type` = Some(LogType.withName(\"all\"))\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "getObject": {
      "getObject": "val response = Await.result(\n  client.getObject(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"uniqueID\",\n    attributesToRetrieve = Some(Seq(\"attr1\", \"attr2\"))\n  ),\n  Duration(100, \"sec\")\n)",
      "search with a real object": "val response = Await.result(\n  client.getObject(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"Batman and Robin\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "getObjects": {
      "by ID": "val response = Await.result(\n  client.getObjects(\n    getObjectsParams = GetObjectsParams(\n      requests = Seq(\n        GetObjectsRequest(\n          objectID = \"uniqueID\",\n          indexName = \"<YOUR_INDEX_NAME>\"\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "multiple IDs": "val response = Await.result(\n  client.getObjects(\n    getObjectsParams = GetObjectsParams(\n      requests = Seq(\n        GetObjectsRequest(\n          objectID = \"uniqueID1\",\n          indexName = \"<YOUR_INDEX_NAME>\"\n        ),\n        GetObjectsRequest(\n          objectID = \"uniqueID2\",\n          indexName = \"<YOUR_INDEX_NAME>\"\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "with attributesToRetrieve": "val response = Await.result(\n  client.getObjects(\n    getObjectsParams = GetObjectsParams(\n      requests = Seq(\n        GetObjectsRequest(\n          attributesToRetrieve = Some(Seq(\"attr1\", \"attr2\")),\n          objectID = \"uniqueID\",\n          indexName = \"<YOUR_INDEX_NAME>\"\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "getRule": {
      "default": "val response = Await.result(\n  client.getRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"qr-1725004648916\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "getSettings": {
      "default": "val response = Await.result(\n  client.getSettings(\n    indexName = \"<YOUR_INDEX_NAME>\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "getSources": {
      "default": "val response = Await.result(\n  client.getSources(\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "getSynonym": {
      "default": "val response = Await.result(\n  client.getSynonym(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"id1\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "getTask": {
      "default": "val response = Await.result(\n  client.getTask(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    taskID = 123L\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "getTopUserIds": {
      "default": "val response = Await.result(\n  client.getTopUserIds(\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "getUserId": {
      "default": "val response = Await.result(\n  client.getUserId(\n    userID = \"uniqueID\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "hasPendingMappings": {
      "hasPendingMappings with minimal parameters": "val response = Await.result(\n  client.hasPendingMappings(\n  ),\n  Duration(100, \"sec\")\n)",
      "hasPendingMappings with parameters": "val response = Await.result(\n  client.hasPendingMappings(\n    getClusters = Some(true)\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "indexExists": {
      "indexExists": "val response = Await.result(\n  client.indexExists(\n    indexName = \"<YOUR_INDEX_NAME>\"\n  ),\n  Duration(100, \"sec\")\n)",
      "indexNotExists": "val response = Await.result(\n  client.indexExists(\n    indexName = \"<YOUR_INDEX_NAME>\"\n  ),\n  Duration(100, \"sec\")\n)",
      "indexExistsWithError": "val response = Await.result(\n  client.indexExists(\n    indexName = \"<YOUR_INDEX_NAME>\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "listApiKeys": {
      "default": "val response = Await.result(\n  client.listApiKeys(\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "listClusters": {
      "default": "val response = Await.result(\n  client.listClusters(\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "listIndices": {
      "listIndices with minimal parameters": "val response = Await.result(\n  client.listIndices(\n  ),\n  Duration(100, \"sec\")\n)",
      "listIndices with parameters": "val response = Await.result(\n  client.listIndices(\n    page = Some(8),\n    hitsPerPage = Some(3)\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "listUserIds": {
      "listUserIds with minimal parameters": "val response = Await.result(\n  client.listUserIds(\n  ),\n  Duration(100, \"sec\")\n)",
      "listUserIds with parameters": "val response = Await.result(\n  client.listUserIds(\n    page = Some(8),\n    hitsPerPage = Some(100)\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "multipleBatch": {
      "default": "val response = Await.result(\n  client.multipleBatch(\n    batchParams = BatchParams(\n      requests = Seq(\n        MultipleBatchRequest(\n          action = Action.withName(\"addObject\"),\n          body = Some(JObject(List(JField(\"key\", JString(\"value\"))))),\n          indexName = \"<YOUR_INDEX_NAME>\"\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "operationIndex": {
      "scopes": "val response = Await.result(\n  client.operationIndex(\n    indexName = \"<SOURCE_INDEX_NAME>\",\n    operationIndexParams = OperationIndexParams(\n      operation = OperationType.withName(\"move\"),\n      destination = \"<DESTINATION_INDEX_NAME>\",\n      scope = Some(Seq(ScopeType.withName(\"rules\"), ScopeType.withName(\"settings\")))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "copy": "val response = Await.result(\n  client.operationIndex(\n    indexName = \"<SOURCE_INDEX_NAME>\",\n    operationIndexParams = OperationIndexParams(\n      operation = OperationType.withName(\"copy\"),\n      destination = \"<DESTINATION_INDEX_NAME>\"\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "move": "val response = Await.result(\n  client.operationIndex(\n    indexName = \"<SOURCE_INDEX_NAME>\",\n    operationIndexParams = OperationIndexParams(\n      operation = OperationType.withName(\"move\"),\n      destination = \"<DESTINATION_INDEX_NAME>\"\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "partialUpdateObject": {
      "Partial update with a new value for a string attribute": "val response = Await.result(\n  client.partialUpdateObject(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"uniqueID\",\n    attributesToUpdate = JObject(List(JField(\"attributeId\", JString(\"new value\"))))\n  ),\n  Duration(100, \"sec\")\n)",
      "Partial update with a new value for an integer attribute": "val response = Await.result(\n  client.partialUpdateObject(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"uniqueID\",\n    attributesToUpdate = JObject(List(JField(\"attributeId\", JInt(1))))\n  ),\n  Duration(100, \"sec\")\n)",
      "Partial update with a new value for a boolean attribute": "val response = Await.result(\n  client.partialUpdateObject(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"uniqueID\",\n    attributesToUpdate = JObject(List(JField(\"attributeId\", JBool(true))))\n  ),\n  Duration(100, \"sec\")\n)",
      "Partial update with a new value for an array attribute": "val response = Await.result(\n  client.partialUpdateObject(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"uniqueID\",\n    attributesToUpdate =\n      JObject(List(JField(\"attributeId\", JArray(List(JString(\"one\"), JString(\"two\"), JString(\"three\"))))))\n  ),\n  Duration(100, \"sec\")\n)",
      "Partial update with a new value for an object attribute": "val response = Await.result(\n  client.partialUpdateObject(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"uniqueID\",\n    attributesToUpdate = JObject(List(JField(\"attributeId\", JObject(List(JField(\"nested\", JString(\"value\")))))))\n  ),\n  Duration(100, \"sec\")\n)",
      "with visible_by filter": "val response = Await.result(\n  client.partialUpdateObject(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"uniqueID\",\n    attributesToUpdate = JObject(\n      List(\n        JField(\n          \"visible_by\",\n          JArray(List(JString(\"Angela\"), JString(\"group/Finance\"), JString(\"group/Shareholders\")))\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "add men pant": "val response = Await.result(\n  client.partialUpdateObject(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"productId\",\n    attributesToUpdate = JObject(\n      List(\n        JField(\n          \"categoryPageId\",\n          JObject(List(JField(\"_operation\", JString(\"Add\")), JField(\"value\", JString(\"men-clothing-pants\"))))\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "remove men pant": "val response = Await.result(\n  client.partialUpdateObject(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"productId\",\n    attributesToUpdate = JObject(\n      List(\n        JField(\n          \"categoryPageId\",\n          JObject(List(JField(\"_operation\", JString(\"Remove\")), JField(\"value\", JString(\"men-clothing-pants\"))))\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "val response = Await.result(\n  client.partialUpdateObjects(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objects = Seq(\n      JObject(List(JField(\"objectID\", JString(\"1\")), JField(\"name\", JString(\"Adam\")))),\n      JObject(List(JField(\"objectID\", JString(\"2\")), JField(\"name\", JString(\"Benoit\"))))\n    ),\n    createIfNotExists = true\n  ),\n  Duration(100, \"sec\")\n)",
      "call partialUpdateObjects with createIfNotExists=false": "val response = Await.result(\n  client.partialUpdateObjects(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objects = Seq(\n      JObject(List(JField(\"objectID\", JString(\"3\")), JField(\"name\", JString(\"Cyril\")))),\n      JObject(List(JField(\"objectID\", JString(\"4\")), JField(\"name\", JString(\"David\"))))\n    ),\n    createIfNotExists = false\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "removeUserId": {
      "default": "val response = Await.result(\n  client.removeUserId(\n    userID = \"uniqueID\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "replaceAllObjects": {
      "call replaceAllObjects without error": "val response = Await.result(\n  client.replaceAllObjects(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objects = Seq(\n      JObject(List(JField(\"objectID\", JString(\"1\")), JField(\"name\", JString(\"Adam\")))),\n      JObject(List(JField(\"objectID\", JString(\"2\")), JField(\"name\", JString(\"Benoit\")))),\n      JObject(List(JField(\"objectID\", JString(\"3\")), JField(\"name\", JString(\"Cyril\")))),\n      JObject(List(JField(\"objectID\", JString(\"4\")), JField(\"name\", JString(\"David\")))),\n      JObject(List(JField(\"objectID\", JString(\"5\")), JField(\"name\", JString(\"Eva\")))),\n      JObject(List(JField(\"objectID\", JString(\"6\")), JField(\"name\", JString(\"Fiona\")))),\n      JObject(List(JField(\"objectID\", JString(\"7\")), JField(\"name\", JString(\"Gael\")))),\n      JObject(List(JField(\"objectID\", JString(\"8\")), JField(\"name\", JString(\"Hugo\")))),\n      JObject(List(JField(\"objectID\", JString(\"9\")), JField(\"name\", JString(\"Igor\")))),\n      JObject(List(JField(\"objectID\", JString(\"10\")), JField(\"name\", JString(\"Julia\"))))\n    ),\n    batchSize = 3\n  ),\n  Duration(100, \"sec\")\n)",
      "call replaceAllObjects with partial scopes": "val response = Await.result(\n  client.replaceAllObjects(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objects = Seq(\n      JObject(List(JField(\"objectID\", JString(\"1\")), JField(\"name\", JString(\"Adam\")))),\n      JObject(List(JField(\"objectID\", JString(\"2\")), JField(\"name\", JString(\"Benoit\"))))\n    ),\n    batchSize = 77,\n    scopes = Some(Seq(ScopeType.withName(\"settings\"), ScopeType.withName(\"synonyms\")))\n  ),\n  Duration(100, \"sec\")\n)",
      "replaceAllObjects should cleanup on failure": "val response = Await.result(\n  client.replaceAllObjects(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objects = Seq(\n      JObject(List(JField(\"objectID\", JString(\"fine\")), JField(\"body\", JString(\"small obj\")))),\n      JObject(List(JField(\"objectID\", JString(\"toolarge\")), JField(\"body\", JString(\"something bigger than 10KB\"))))\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "replaceSources": {
      "default": "val response = Await.result(\n  client.replaceSources(\n    source = Seq(\n      Source(\n        source = \"theSource\",\n        description = Some(\"theDescription\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "restoreApiKey": {
      "default": "val response = Await.result(\n  client.restoreApiKey(\n    key = \"ALGOLIA_API_KEY\"\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "saveObject": {
      "default": "val response = Await.result(\n  client.saveObject(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    body = JObject(\n      List(\n        JField(\"name\", JString(\"Black T-shirt\")),\n        JField(\"color\", JString(\"#000000||black\")),\n        JField(\"availableIn\", JString(\"https://source.unsplash.com/100x100/?paris||Paris\")),\n        JField(\"objectID\", JString(\"myID\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "saveObjects": {
      "call saveObjects without error": "val response = Await.result(\n  client.saveObjects(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objects = Seq(\n      JObject(List(JField(\"objectID\", JString(\"1\")), JField(\"name\", JString(\"Adam\")))),\n      JObject(List(JField(\"objectID\", JString(\"2\")), JField(\"name\", JString(\"Benoit\"))))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "saveObjects should report errors": "val response = Await.result(\n  client.saveObjects(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objects = Seq(\n      JObject(List(JField(\"objectID\", JString(\"1\")), JField(\"name\", JString(\"Adam\")))),\n      JObject(List(JField(\"objectID\", JString(\"2\")), JField(\"name\", JString(\"Benoit\"))))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "saveObjectsPlaylist": "val response = Await.result(\n  client.saveObjects(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objects = Seq(\n      JObject(\n        List(\n          JField(\"objectID\", JString(\"1\")),\n          JField(\"visibility\", JString(\"public\")),\n          JField(\"name\", JString(\"Hot 100 Billboard Charts\")),\n          JField(\"playlistId\", JString(\"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\")),\n          JField(\"createdAt\", JString(\"1500240452\"))\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "saveObjectsPublicUser": "val response = Await.result(\n  client.saveObjects(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objects = Seq(\n      JObject(\n        List(\n          JField(\"objectID\", JString(\"1\")),\n          JField(\"visibility\", JString(\"public\")),\n          JField(\"name\", JString(\"Hot 100 Billboard Charts\")),\n          JField(\"playlistId\", JString(\"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\")),\n          JField(\"createdAt\", JString(\"1500240452\"))\n        )\n      )\n    ),\n    waitForTasks = false,\n    batchSize = 1000,\n    requestOptions = Some(\n      RequestOptions\n        .builder()\n        .withHeader(\"X-Algolia-User-ID\", \"*\")\n        .build()\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "saveRule": {
      "saveRule with minimal parameters": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"id1\",\n    rule = Rule(\n      objectID = \"id1\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"apple\"),\n            anchoring = Some(Anchoring.withName(\"contains\"))\n          )\n        )\n      ),\n      consequence = Consequence(\n        params = Some(\n          ConsequenceParams(\n            filters = Some(\"brand:xiaomi\")\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "saveRule with all parameters": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"id1\",\n    rule = Rule(\n      objectID = \"id1\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"apple\"),\n            anchoring = Some(Anchoring.withName(\"contains\")),\n            alternatives = Some(false),\n            context = Some(\"search\")\n          )\n        )\n      ),\n      consequence = Consequence(\n        params = Some(\n          ConsequenceParams(\n            filters = Some(\"brand:apple\"),\n            query = Some(\n              ConsequenceQueryObject(\n                remove = Some(Seq(\"algolia\")),\n                edits = Some(\n                  Seq(\n                    Edit(\n                      `type` = Some(EditType.withName(\"remove\")),\n                      delete = Some(\"abc\"),\n                      insert = Some(\"cde\")\n                    ),\n                    Edit(\n                      `type` = Some(EditType.withName(\"replace\")),\n                      delete = Some(\"abc\"),\n                      insert = Some(\"cde\")\n                    )\n                  )\n                )\n              )\n            )\n          )\n        ),\n        hide = Some(\n          Seq(\n            ConsequenceHide(\n              objectID = \"321\"\n            )\n          )\n        ),\n        filterPromotes = Some(false),\n        userData = Some(JObject(List(JField(\"algolia\", JString(\"aloglia\"))))),\n        promote = Some(\n          Seq(\n            PromoteObjectID(\n              objectID = \"abc\",\n              position = 3\n            ),\n            PromoteObjectIDs(\n              objectIDs = Seq(\"abc\", \"def\"),\n              position = 1\n            )\n          )\n        )\n      ),\n      description = Some(\"test\"),\n      enabled = Some(true),\n      validity = Some(\n        Seq(\n          TimeRange(\n            from = 1656670273L,\n            until = 1656670277L\n          )\n        )\n      )\n    ),\n    forwardToReplicas = Some(true)\n  ),\n  Duration(100, \"sec\")\n)",
      "b2b catalog": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"article-rule\",\n    rule = Rule(\n      objectID = \"article-rule\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"article\"),\n            anchoring = Some(Anchoring.withName(\"startsWith\"))\n          )\n        )\n      ),\n      consequence = Consequence(\n        params = Some(\n          ConsequenceParams(\n            query = Some(\n              ConsequenceQueryObject(\n                edits = Some(\n                  Seq(\n                    Edit(\n                      `type` = Some(EditType.withName(\"remove\")),\n                      delete = Some(\"article\")\n                    )\n                  )\n                )\n              )\n            ),\n            restrictSearchableAttributes = Some(Seq(\"title\", \"book_id\"))\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "merchandising and promoting": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"director-rule\",\n    rule = Rule(\n      objectID = \"director-rule\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"{facet:director} director\"),\n            anchoring = Some(Anchoring.withName(\"contains\"))\n          )\n        )\n      ),\n      consequence = Consequence(\n        params = Some(\n          ConsequenceParams(\n            restrictSearchableAttributes = Some(Seq(\"title\", \"book_id\")),\n            automaticFacetFilters = Some(\n              AutomaticFacetFilters(\n                Seq(\n                  AutomaticFacetFilter(\n                    facet = \"director\"\n                  )\n                )\n              )\n            ),\n            query = Some(\n              ConsequenceQueryObject(\n                edits = Some(\n                  Seq(\n                    Edit(\n                      `type` = Some(EditType.withName(\"remove\")),\n                      delete = Some(\"director\")\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "harry potter": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"harry-potter-rule\",\n    rule = Rule(\n      objectID = \"harry-potter-rule\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"harry potter\"),\n            anchoring = Some(Anchoring.withName(\"contains\"))\n          )\n        )\n      ),\n      consequence = Consequence(\n        userData = Some(JObject(List(JField(\"promo_content\", JString(\"20% OFF on all Harry Potter books!\")))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "merchandising empty query": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"clearance-category-filter\",\n    rule = Rule(\n      objectID = \"clearance-category-filter\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"\"),\n            anchoring = Some(Anchoring.withName(\"is\")),\n            context = Some(\"landing\")\n          )\n        )\n      ),\n      consequence = Consequence(\n        params = Some(\n          ConsequenceParams(\n            optionalFilters = Some(OptionalFilters(\"clearance:true\"))\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "redirect": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"redirect-help-rule\",\n    rule = Rule(\n      objectID = \"redirect-help-rule\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"help\"),\n            anchoring = Some(Anchoring.withName(\"contains\"))\n          )\n        )\n      ),\n      consequence = Consequence(\n        userData = Some(JObject(List(JField(\"redirect\", JString(\"https://www.algolia.com/support\")))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "promote some results over others": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"tomato-fruit\",\n    rule = Rule(\n      objectID = \"tomato-fruit\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"tomato\"),\n            anchoring = Some(Anchoring.withName(\"contains\"))\n          )\n        )\n      ),\n      consequence = Consequence(\n        params = Some(\n          ConsequenceParams(\n            optionalFilters = Some(OptionalFilters(\"food_group:fruit\"))\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "promote several hits": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"Promote-Apple-Newest\",\n    rule = Rule(\n      objectID = \"Promote-Apple-Newest\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"apple\"),\n            anchoring = Some(Anchoring.withName(\"is\"))\n          )\n        )\n      ),\n      consequence = Consequence(\n        promote = Some(\n          Seq(\n            PromoteObjectIDs(\n              objectIDs = Seq(\"iPhone-12345\", \"watch-123\"),\n              position = 0\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "promote newest release": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"Promote-iPhone-X\",\n    rule = Rule(\n      objectID = \"Promote-iPhone-X\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"iPhone\"),\n            anchoring = Some(Anchoring.withName(\"contains\"))\n          )\n        )\n      ),\n      consequence = Consequence(\n        promote = Some(\n          Seq(\n            PromoteObjectID(\n              objectID = \"iPhone-12345\",\n              position = 0\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "promote single item": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"promote-harry-potter-box-set\",\n    rule = Rule(\n      objectID = \"promote-harry-potter-box-set\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"Harry Potter\"),\n            anchoring = Some(Anchoring.withName(\"contains\"))\n          )\n        )\n      ),\n      consequence = Consequence(\n        promote = Some(\n          Seq(\n            PromoteObjectID(\n              objectID = \"HP-12345\",\n              position = 0\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "limit search results": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"article-rule\",\n    rule = Rule(\n      objectID = \"article-rule\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"article\"),\n            anchoring = Some(Anchoring.withName(\"startsWith\"))\n          )\n        )\n      ),\n      consequence = Consequence(\n        params = Some(\n          ConsequenceParams(\n            query = Some(\n              ConsequenceQueryObject(\n                edits = Some(\n                  Seq(\n                    Edit(\n                      `type` = Some(EditType.withName(\"remove\")),\n                      delete = Some(\"article\")\n                    )\n                  )\n                )\n              )\n            ),\n            restrictSearchableAttributes = Some(Seq(\"title\", \"book_id\"))\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "query match": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"tagged-brand-rule\",\n    rule = Rule(\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"brand: {facet:brand}\"),\n            anchoring = Some(Anchoring.withName(\"contains\")),\n            alternatives = Some(false)\n          )\n        )\n      ),\n      consequence = Consequence(\n        params = Some(\n          ConsequenceParams(\n            automaticFacetFilters = Some(\n              AutomaticFacetFilters(\n                Seq(\n                  AutomaticFacetFilter(\n                    facet = \"brand\"\n                  )\n                )\n              )\n            ),\n            query = Some(\n              ConsequenceQueryObject(\n                remove = Some(Seq(\"brand:\", \"{facet:brand}\"))\n              )\n            )\n          )\n        )\n      ),\n      description = Some(\"filter on brand: {brand}\"),\n      objectID = \"tagged-brand-rule\"\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "dynamic filtering": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"color-facets\",\n    rule = Rule(\n      objectID = \"color-facets\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"{facet:color}\")\n          )\n        )\n      ),\n      consequence = Consequence(\n        params = Some(\n          ConsequenceParams(\n            automaticFacetFilters = Some(\n              AutomaticFacetFilters(\n                Seq(\n                  AutomaticFacetFilter(\n                    facet = \"color\"\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "hide hits": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"hide-12345\",\n    rule = Rule(\n      objectID = \"hide-12345\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"cheap\"),\n            anchoring = Some(Anchoring.withName(\"contains\"))\n          )\n        )\n      ),\n      consequence = Consequence(\n        hide = Some(\n          Seq(\n            ConsequenceHide(\n              objectID = \"to-hide-12345\"\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "one rule per facet": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"red-color\",\n    rule = Rule(\n      objectID = \"red-color\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"red\"),\n            anchoring = Some(Anchoring.withName(\"contains\"))\n          )\n        )\n      ),\n      consequence = Consequence(\n        params = Some(\n          ConsequenceParams(\n            query = Some(\n              ConsequenceQueryObject(\n                remove = Some(Seq(\"red\"))\n              )\n            ),\n            filters = Some(\"color:red\")\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "numerical filters": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"cheap\",\n    rule = Rule(\n      objectID = \"cheap\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"cheap\"),\n            anchoring = Some(Anchoring.withName(\"contains\"))\n          )\n        )\n      ),\n      consequence = Consequence(\n        params = Some(\n          ConsequenceParams(\n            query = Some(\n              ConsequenceQueryObject(\n                remove = Some(Seq(\"cheap\"))\n              )\n            ),\n            filters = Some(\"price < 10\")\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "negative filters": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"gluten-free-rule\",\n    rule = Rule(\n      objectID = \"gluten-free-rule\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"gluten-free\"),\n            anchoring = Some(Anchoring.withName(\"contains\"))\n          )\n        )\n      ),\n      consequence = Consequence(\n        params = Some(\n          ConsequenceParams(\n            filters = Some(\"NOT allergens:gluten\"),\n            query = Some(\n              ConsequenceQueryObject(\n                edits = Some(\n                  Seq(\n                    Edit(\n                      `type` = Some(EditType.withName(\"remove\")),\n                      delete = Some(\"gluten-free\")\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "positive filters": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"diet-rule\",\n    rule = Rule(\n      objectID = \"diet-rule\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"diet\"),\n            anchoring = Some(Anchoring.withName(\"contains\"))\n          )\n        )\n      ),\n      consequence = Consequence(\n        params = Some(\n          ConsequenceParams(\n            filters = Some(\"'low-carb' OR 'low-fat'\"),\n            query = Some(\n              ConsequenceQueryObject(\n                edits = Some(\n                  Seq(\n                    Edit(\n                      `type` = Some(EditType.withName(\"remove\")),\n                      delete = Some(\"diet\")\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "conditionless": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"diet-rule\",\n    rule = Rule(\n      objectID = \"diet-rule\",\n      consequence = Consequence(\n        params = Some(\n          ConsequenceParams(\n            filters = Some(\"'low-carb' OR 'low-fat'\"),\n            query = Some(\n              ConsequenceQueryObject(\n                edits = Some(\n                  Seq(\n                    Edit(\n                      `type` = Some(EditType.withName(\"remove\")),\n                      delete = Some(\"diet\")\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "contextual": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"a-rule-id\",\n    rule = Rule(\n      objectID = \"a-rule-id\",\n      conditions = Some(\n        Seq(\n          Condition(\n            context = Some(\"mobile\")\n          )\n        )\n      ),\n      consequence = Consequence(\n        params = Some(\n          ConsequenceParams(\n            filters = Some(\"release_date >= 1577836800\")\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "saveRule always active rule": "val response = Await.result(\n  client.saveRule(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"a-rule-id\",\n    rule = Rule(\n      objectID = \"a-rule-id\",\n      consequence = Consequence(\n        params = Some(\n          ConsequenceParams(\n            aroundRadius = Some(AroundRadius(1000))\n          )\n        )\n      ),\n      validity = Some(\n        Seq(\n          TimeRange(\n            from = 1577836800L,\n            until = 1577836800L\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "saveRules": {
      "saveRules with minimal parameters": "val response = Await.result(\n  client.saveRules(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    rules = Seq(\n      Rule(\n        objectID = \"a-rule-id\",\n        conditions = Some(\n          Seq(\n            Condition(\n              pattern = Some(\"smartphone\"),\n              anchoring = Some(Anchoring.withName(\"contains\"))\n            )\n          )\n        ),\n        consequence = Consequence(\n          params = Some(\n            ConsequenceParams(\n              filters = Some(\"brand:apple\")\n            )\n          )\n        )\n      ),\n      Rule(\n        objectID = \"a-second-rule-id\",\n        conditions = Some(\n          Seq(\n            Condition(\n              pattern = Some(\"apple\"),\n              anchoring = Some(Anchoring.withName(\"contains\"))\n            )\n          )\n        ),\n        consequence = Consequence(\n          params = Some(\n            ConsequenceParams(\n              filters = Some(\"brand:samsung\")\n            )\n          )\n        )\n      )\n    ),\n    forwardToReplicas = Some(false),\n    clearExistingRules = Some(true)\n  ),\n  Duration(100, \"sec\")\n)",
      "saveRules with all parameters": "val response = Await.result(\n  client.saveRules(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    rules = Seq(\n      Rule(\n        objectID = \"id1\",\n        conditions = Some(\n          Seq(\n            Condition(\n              pattern = Some(\"apple\"),\n              anchoring = Some(Anchoring.withName(\"contains\")),\n              alternatives = Some(false),\n              context = Some(\"search\")\n            )\n          )\n        ),\n        consequence = Consequence(\n          params = Some(\n            ConsequenceParams(\n              filters = Some(\"brand:apple\"),\n              query = Some(\n                ConsequenceQueryObject(\n                  remove = Some(Seq(\"algolia\")),\n                  edits = Some(\n                    Seq(\n                      Edit(\n                        `type` = Some(EditType.withName(\"remove\")),\n                        delete = Some(\"abc\"),\n                        insert = Some(\"cde\")\n                      ),\n                      Edit(\n                        `type` = Some(EditType.withName(\"replace\")),\n                        delete = Some(\"abc\"),\n                        insert = Some(\"cde\")\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          ),\n          hide = Some(\n            Seq(\n              ConsequenceHide(\n                objectID = \"321\"\n              )\n            )\n          ),\n          filterPromotes = Some(false),\n          userData = Some(JObject(List(JField(\"algolia\", JString(\"aloglia\"))))),\n          promote = Some(\n            Seq(\n              PromoteObjectID(\n                objectID = \"abc\",\n                position = 3\n              ),\n              PromoteObjectIDs(\n                objectIDs = Seq(\"abc\", \"def\"),\n                position = 1\n              )\n            )\n          )\n        ),\n        description = Some(\"test\"),\n        enabled = Some(true),\n        validity = Some(\n          Seq(\n            TimeRange(\n              from = 1656670273L,\n              until = 1656670277L\n            )\n          )\n        )\n      )\n    ),\n    forwardToReplicas = Some(true),\n    clearExistingRules = Some(true)\n  ),\n  Duration(100, \"sec\")\n)",
      "dynamic filtering": "val response = Await.result(\n  client.saveRules(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    rules = Seq(\n      Rule(\n        objectID = \"toaster\",\n        conditions = Some(\n          Seq(\n            Condition(\n              pattern = Some(\"toaster\"),\n              anchoring = Some(Anchoring.withName(\"contains\"))\n            )\n          )\n        ),\n        consequence = Consequence(\n          params = Some(\n            ConsequenceParams(\n              query = Some(\n                ConsequenceQueryObject(\n                  remove = Some(Seq(\"toaster\"))\n                )\n              ),\n              filters = Some(\"product_type:toaster\")\n            )\n          )\n        )\n      ),\n      Rule(\n        objectID = \"cheap\",\n        conditions = Some(\n          Seq(\n            Condition(\n              pattern = Some(\"cheap\"),\n              anchoring = Some(Anchoring.withName(\"contains\"))\n            )\n          )\n        ),\n        consequence = Consequence(\n          params = Some(\n            ConsequenceParams(\n              query = Some(\n                ConsequenceQueryObject(\n                  remove = Some(Seq(\"cheap\"))\n                )\n              ),\n              filters = Some(\"price < 15\")\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enhance search results": "val response = Await.result(\n  client.saveRules(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    rules = Seq(\n      Rule(\n        objectID = \"country\",\n        conditions = Some(\n          Seq(\n            Condition(\n              pattern = Some(\"{facet:country}\"),\n              anchoring = Some(Anchoring.withName(\"contains\"))\n            )\n          )\n        ),\n        consequence = Consequence(\n          params = Some(\n            ConsequenceParams(\n              aroundLatLngViaIP = Some(false)\n            )\n          )\n        )\n      ),\n      Rule(\n        objectID = \"city\",\n        conditions = Some(\n          Seq(\n            Condition(\n              pattern = Some(\"{facet:city}\"),\n              anchoring = Some(Anchoring.withName(\"contains\"))\n            )\n          )\n        ),\n        consequence = Consequence(\n          params = Some(\n            ConsequenceParams(\n              aroundLatLngViaIP = Some(false)\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "saveSynonym": {
      "default": "val response = Await.result(\n  client.saveSynonym(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    objectID = \"id1\",\n    synonymHit = SynonymHit(\n      objectID = \"id1\",\n      `type` = SynonymType.withName(\"synonym\"),\n      synonyms = Some(Seq(\"car\", \"vehicule\", \"auto\"))\n    ),\n    forwardToReplicas = Some(true)\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "saveSynonyms": {
      "default": "val response = Await.result(\n  client.saveSynonyms(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    synonymHit = Seq(\n      SynonymHit(\n        objectID = \"id1\",\n        `type` = SynonymType.withName(\"synonym\"),\n        synonyms = Some(Seq(\"car\", \"vehicule\", \"auto\"))\n      ),\n      SynonymHit(\n        objectID = \"id2\",\n        `type` = SynonymType.withName(\"onewaysynonym\"),\n        input = Some(\"iphone\"),\n        synonyms = Some(Seq(\"ephone\", \"aphone\", \"yphone\"))\n      )\n    ),\n    forwardToReplicas = Some(true),\n    replaceExistingSynonyms = Some(true)\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "search": {
      "withHitsPerPage": "val response = Await.result(\n  client.search(\n    searchMethodParams = SearchMethodParams(\n      requests = Seq(\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          query = Some(\"<YOUR_QUERY>\"),\n          hitsPerPage = Some(50)\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "filterOnly": "val response = Await.result(\n  client.search(\n    searchMethodParams = SearchMethodParams(\n      requests = Seq(\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          query = Some(\"<YOUR_QUERY>\"),\n          filters = Some(\"actor:Scarlett Johansson\")\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "filterOr": "val response = Await.result(\n  client.search(\n    searchMethodParams = SearchMethodParams(\n      requests = Seq(\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          query = Some(\"<YOUR_QUERY>\"),\n          filters = Some(\"actor:Tom Cruise OR actor:Scarlett Johansson\")\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "filterNot": "val response = Await.result(\n  client.search(\n    searchMethodParams = SearchMethodParams(\n      requests = Seq(\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          query = Some(\"<YOUR_QUERY>\"),\n          filters = Some(\"NOT actor:Nicolas Cage\")\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search for a single hits request with minimal parameters": "val response = Await.result(\n  client.search(\n    searchMethodParams = SearchMethodParams(\n      requests = Seq(\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\"\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search with highlight and snippet results": "val response = Await.result(\n  client.search(\n    searchMethodParams = SearchMethodParams(\n      requests = Seq(\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          query = Some(\"vim\"),\n          attributesToSnippet = Some(Seq(\"*:20\")),\n          attributesToHighlight = Some(Seq(\"*\")),\n          attributesToRetrieve = Some(Seq(\"*\"))\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "retrieveFacets": "val response = Await.result(\n  client.search(\n    searchMethodParams = SearchMethodParams(\n      requests = Seq(\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          query = Some(\"<YOUR_QUERY>\"),\n          facets = Some(Seq(\"author\", \"genre\"))\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "retrieveFacetsWildcard": "val response = Await.result(\n  client.search(\n    searchMethodParams = SearchMethodParams(\n      requests = Seq(\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          query = Some(\"<YOUR_QUERY>\"),\n          facets = Some(Seq(\"*\"))\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search for a single facet request with minimal parameters": "val response = Await.result(\n  client.search(\n    searchMethodParams = SearchMethodParams(\n      requests = Seq(\n        SearchForFacets(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          `type` = SearchTypeFacet.withName(\"facet\"),\n          facet = \"editor\"\n        )\n      ),\n      strategy = Some(SearchStrategy.withName(\"stopIfEnoughMatches\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search for a single hits request with all parameters": "val response = Await.result(\n  client.search(\n    searchMethodParams = SearchMethodParams(\n      requests = Seq(\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          query = Some(\"myQuery\"),\n          hitsPerPage = Some(50),\n          `type` = Some(SearchTypeDefault.withName(\"default\"))\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search for a single facet request with all parameters": "val response = Await.result(\n  client.search(\n    searchMethodParams = SearchMethodParams(\n      requests = Seq(\n        SearchForFacets(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          `type` = SearchTypeFacet.withName(\"facet\"),\n          facet = \"theFacet\",\n          facetQuery = Some(\"theFacetQuery\"),\n          query = Some(\"theQuery\"),\n          maxFacetHits = Some(50)\n        )\n      ),\n      strategy = Some(SearchStrategy.withName(\"stopIfEnoughMatches\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search for multiple mixed requests in multiple indices with minimal parameters": "val response = Await.result(\n  client.search(\n    searchMethodParams = SearchMethodParams(\n      requests = Seq(\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\"\n        ),\n        SearchForFacets(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          `type` = SearchTypeFacet.withName(\"facet\"),\n          facet = \"theFacet\"\n        ),\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          `type` = Some(SearchTypeDefault.withName(\"default\"))\n        )\n      ),\n      strategy = Some(SearchStrategy.withName(\"stopIfEnoughMatches\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search for multiple mixed requests in multiple indices with all parameters": "val response = Await.result(\n  client.search(\n    searchMethodParams = SearchMethodParams(\n      requests = Seq(\n        SearchForFacets(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          `type` = SearchTypeFacet.withName(\"facet\"),\n          facet = \"theFacet\",\n          facetQuery = Some(\"theFacetQuery\"),\n          query = Some(\"theQuery\"),\n          maxFacetHits = Some(50)\n        ),\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          query = Some(\"myQuery\"),\n          hitsPerPage = Some(50),\n          `type` = Some(SearchTypeDefault.withName(\"default\"))\n        )\n      ),\n      strategy = Some(SearchStrategy.withName(\"stopIfEnoughMatches\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search filters accept all of the possible shapes": "val response = Await.result(\n  client.search(\n    searchMethodParams = SearchMethodParams(\n      requests = Seq(\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          facetFilters = Some(FacetFilters(\"mySearch:filters\")),\n          reRankingApplyFilter = Some(ReRankingApplyFilter(\"mySearch:filters\")),\n          tagFilters = Some(TagFilters(\"mySearch:filters\")),\n          numericFilters = Some(NumericFilters(\"mySearch:filters\")),\n          optionalFilters = Some(OptionalFilters(\"mySearch:filters\"))\n        ),\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          facetFilters = Some(\n            FacetFilters(\n              Seq(\n                FacetFilters(\"mySearch:filters\"),\n                FacetFilters(\n                  Seq(FacetFilters(\"mySearch:filters\"), FacetFilters(Seq(FacetFilters(\"mySearch:filters\"))))\n                )\n              )\n            )\n          ),\n          reRankingApplyFilter = Some(\n            ReRankingApplyFilter(\n              Seq(\n                ReRankingApplyFilter(\"mySearch:filters\"),\n                ReRankingApplyFilter(Seq(ReRankingApplyFilter(\"mySearch:filters\")))\n              )\n            )\n          ),\n          tagFilters =\n            Some(TagFilters(Seq(TagFilters(\"mySearch:filters\"), TagFilters(Seq(TagFilters(\"mySearch:filters\")))))),\n          numericFilters = Some(\n            NumericFilters(\n              Seq(NumericFilters(\"mySearch:filters\"), NumericFilters(Seq(NumericFilters(\"mySearch:filters\"))))\n            )\n          ),\n          optionalFilters = Some(\n            OptionalFilters(\n              Seq(OptionalFilters(\"mySearch:filters\"), OptionalFilters(Seq(OptionalFilters(\"mySearch:filters\"))))\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search filters end to end": "val response = Await.result(\n  client.search(\n    searchMethodParams = SearchMethodParams(\n      requests = Seq(\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          filters = Some(\"editor:'visual studio' OR editor:neovim\")\n        ),\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          facetFilters =\n            Some(FacetFilters(Seq(FacetFilters(\"editor:'visual studio'\"), FacetFilters(\"editor:neovim\"))))\n        ),\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          facetFilters = Some(\n            FacetFilters(\n              Seq(FacetFilters(\"editor:'visual studio'\"), FacetFilters(Seq(FacetFilters(\"editor:neovim\"))))\n            )\n          )\n        ),\n        SearchForHits(\n          indexName = \"<YOUR_INDEX_NAME>\",\n          facetFilters = Some(\n            FacetFilters(\n              Seq(\n                FacetFilters(\"editor:'visual studio'\"),\n                FacetFilters(Seq(FacetFilters(\"editor:neovim\"), FacetFilters(Seq(FacetFilters(\"editor:goland\")))))\n              )\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search with all search parameters": "val response = Await.result(\n  client.search(\n    searchMethodParams = SearchMethodParams(\n      requests = Seq(\n        SearchForHits(\n          advancedSyntax = Some(true),\n          advancedSyntaxFeatures = Some(Seq(AdvancedSyntaxFeatures.withName(\"exactPhrase\"))),\n          allowTyposOnNumericTokens = Some(true),\n          alternativesAsExact = Some(Seq(AlternativesAsExact.withName(\"multiWordsSynonym\"))),\n          analytics = Some(true),\n          analyticsTags = Some(Seq(\"\")),\n          aroundLatLng = Some(\"\"),\n          aroundLatLngViaIP = Some(true),\n          aroundPrecision = Some(AroundPrecision(0)),\n          aroundRadius = Some(AroundRadiusAll.withName(\"all\")),\n          attributeCriteriaComputedByMinProximity = Some(true),\n          attributesToHighlight = Some(Seq(\"\")),\n          attributesToRetrieve = Some(Seq(\"\")),\n          attributesToSnippet = Some(Seq(\"\")),\n          clickAnalytics = Some(true),\n          decompoundQuery = Some(true),\n          disableExactOnAttributes = Some(Seq(\"\")),\n          disableTypoToleranceOnAttributes = Some(Seq(\"\")),\n          distinct = Some(Distinct(0)),\n          enableABTest = Some(true),\n          enablePersonalization = Some(true),\n          enableReRanking = Some(true),\n          enableRules = Some(true),\n          exactOnSingleWordQuery = Some(ExactOnSingleWordQuery.withName(\"attribute\")),\n          facetFilters = Some(FacetFilters(Seq(FacetFilters(\"\")))),\n          facetingAfterDistinct = Some(true),\n          facets = Some(Seq(\"\")),\n          filters = Some(\"\"),\n          getRankingInfo = Some(true),\n          highlightPostTag = Some(\"\"),\n          highlightPreTag = Some(\"\"),\n          hitsPerPage = Some(1),\n          ignorePlurals = Some(IgnorePlurals(false)),\n          indexName = \"<YOUR_INDEX_NAME>\",\n          insideBoundingBox = Some(\n            InsideBoundingBox(Seq(Seq(47.3165, 4.9665, 47.3424, 5.0201), Seq(40.9234, 2.1185, 38.643, 1.9916)))\n          ),\n          insidePolygon = Some(\n            Seq(\n              Seq(47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9),\n              Seq(40.9234, 2.1185, 38.643, 1.9916, 39.2587, 2.0104)\n            )\n          ),\n          length = Some(1),\n          maxValuesPerFacet = Some(0),\n          minProximity = Some(1),\n          minWordSizefor1Typo = Some(0),\n          minWordSizefor2Typos = Some(0),\n          minimumAroundRadius = Some(1),\n          naturalLanguages = Some(Seq(SupportedLanguage.withName(\"fr\"))),\n          numericFilters = Some(NumericFilters(Seq(NumericFilters(\"\")))),\n          offset = Some(0),\n          optionalFilters = Some(OptionalFilters(Seq(OptionalFilters(\"\")))),\n          optionalWords = Some(OptionalWords(Seq(\"\"))),\n          page = Some(0),\n          percentileComputation = Some(true),\n          personalizationImpact = Some(0),\n          query = Some(\"\"),\n          queryLanguages = Some(Seq(SupportedLanguage.withName(\"fr\"))),\n          queryType = Some(QueryType.withName(\"prefixAll\")),\n          ranking = Some(Seq(\"\")),\n          reRankingApplyFilter = Some(ReRankingApplyFilter(Seq(ReRankingApplyFilter(\"\")))),\n          relevancyStrictness = Some(0),\n          removeStopWords = Some(RemoveStopWords(true)),\n          removeWordsIfNoResults = Some(RemoveWordsIfNoResults.withName(\"allOptional\")),\n          renderingContent = Some(\n            RenderingContent(\n              facetOrdering = Some(\n                FacetOrdering(\n                  facets = Some(\n                    Facets(\n                      order = Some(Seq(\"a\", \"b\"))\n                    )\n                  ),\n                  values = Some(\n                    Map(\n                      \"a\" -> Value(\n                        order = Some(Seq(\"b\")),\n                        sortRemainingBy = Some(SortRemainingBy.withName(\"count\"))\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          ),\n          replaceSynonymsInHighlight = Some(true),\n          responseFields = Some(Seq(\"\")),\n          restrictHighlightAndSnippetArrays = Some(true),\n          restrictSearchableAttributes = Some(Seq(\"\")),\n          ruleContexts = Some(Seq(\"\")),\n          similarQuery = Some(\"\"),\n          snippetEllipsisText = Some(\"\"),\n          sortFacetValuesBy = Some(\"\"),\n          sumOrFiltersScores = Some(true),\n          synonyms = Some(true),\n          tagFilters = Some(TagFilters(Seq(TagFilters(\"\")))),\n          `type` = Some(SearchTypeDefault.withName(\"default\")),\n          typoTolerance = Some(TypoToleranceEnum.withName(\"min\")),\n          userToken = Some(\"\")\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "searchDictionaryEntries": {
      "get searchDictionaryEntries results with minimal parameters": "val response = Await.result(\n  client.searchDictionaryEntries(\n    dictionaryName = DictionaryType.withName(\"stopwords\"),\n    searchDictionaryEntriesParams = SearchDictionaryEntriesParams(\n      query = \"about\"\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "get searchDictionaryEntries results with all parameters": "val response = Await.result(\n  client.searchDictionaryEntries(\n    dictionaryName = DictionaryType.withName(\"compounds\"),\n    searchDictionaryEntriesParams = SearchDictionaryEntriesParams(\n      query = \"foo\",\n      page = Some(4),\n      hitsPerPage = Some(2),\n      language = Some(SupportedLanguage.withName(\"fr\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "searchForFacetValues": {
      "get searchForFacetValues results with minimal parameters": "val response = Await.result(\n  client.searchForFacetValues(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    facetName = \"facetName\"\n  ),\n  Duration(100, \"sec\")\n)",
      "get searchForFacetValues results with all parameters": "val response = Await.result(\n  client.searchForFacetValues(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    facetName = \"facetName\",\n    searchForFacetValuesRequest = Some(\n      SearchForFacetValuesRequest(\n        params = Some(\"query=foo&facetFilters=['bar']\"),\n        facetQuery = Some(\"foo\"),\n        maxFacetHits = Some(42)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "facetName and facetQuery": "val response = Await.result(\n  client.searchForFacetValues(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    facetName = \"author\",\n    searchForFacetValuesRequest = Some(\n      SearchForFacetValuesRequest(\n        facetQuery = Some(\"stephen\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "searchRules": {
      "default": "val response = Await.result(\n  client.searchRules(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchRulesParams = Some(\n      SearchRulesParams(\n        query = Some(\"zorro\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "searchSingleIndex": {
      "search with minimal parameters": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\"\n  ),\n  Duration(100, \"sec\")\n)",
      "search with special characters in indexName": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\"\n  ),\n  Duration(100, \"sec\")\n)",
      "search with searchParams": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"myQuery\"),\n        facetFilters = Some(FacetFilters(Seq(FacetFilters(\"tags:algolia\"))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "single search retrieve snippets": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"batman mask of the phantasm\"),\n        attributesToRetrieve = Some(Seq(\"*\")),\n        attributesToSnippet = Some(Seq(\"*:20\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "query": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"phone\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "filters": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        filters = Some(\"country:US AND price.gross < 2.0\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "filters for stores": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"ben\"),\n        filters = Some(\"categories:politics AND store:Gibert Joseph Saint-Michel\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "filters boolean": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        filters = Some(\"is_available:true\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "distinct": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        distinct = Some(Distinct(true))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "filtersNumeric": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        filters = Some(\"price < 10\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "filtersTimestamp": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        filters = Some(\"NOT date_timestamp:1514764800 TO 1546300799\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "filtersSumOrFiltersScoresFalse": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        filters = Some(\"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\"),\n        sumOrFiltersScores = Some(false)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "filtersSumOrFiltersScoresTrue": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        filters = Some(\"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\"),\n        sumOrFiltersScores = Some(true)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "filtersStephenKing": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        filters = Some(\"author:\\\"Stephen King\\\"\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "filtersNotTags": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"harry\"),\n        filters = Some(\"_tags:non-fiction\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "facetFiltersList": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        facetFilters = Some(\n          FacetFilters(\n            Seq(\n              FacetFilters(\"publisher:Penguin\"),\n              FacetFilters(Seq(FacetFilters(\"author:Stephen King\"), FacetFilters(\"genre:Horror\")))\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "facetFiltersBook": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        facetFilters = Some(FacetFilters(Seq(FacetFilters(\"category:Book\"))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "facetFiltersAND": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        facetFilters = Some(FacetFilters(Seq(FacetFilters(\"category:Book\"), FacetFilters(\"author:John Doe\"))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "facetFiltersOR": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        facetFilters =\n          Some(FacetFilters(Seq(FacetFilters(Seq(FacetFilters(\"category:Book\"), FacetFilters(\"author:John Doe\"))))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "facetFiltersCombined": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        facetFilters = Some(\n          FacetFilters(\n            Seq(\n              FacetFilters(\"author:John Doe\"),\n              FacetFilters(Seq(FacetFilters(\"category:Book\"), FacetFilters(\"category:Movie\")))\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "facetFiltersNeg": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        facetFilters = Some(FacetFilters(\"category:-Ebook\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "filtersAndFacetFilters": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        filters = Some(\"(author:\\\"Stephen King\\\" OR genre:\\\"Horror\\\")\"),\n        facetFilters = Some(FacetFilters(Seq(FacetFilters(\"publisher:Penguin\"))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "facet author genre": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        facets = Some(Seq(\"author\", \"genre\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "facet wildcard": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        facets = Some(Seq(\"*\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "maxValuesPerFacet": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        maxValuesPerFacet = Some(1000)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "aroundLatLng": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        aroundLatLng = Some(\"40.71, -74.01\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "aroundLatLngViaIP": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        aroundLatLngViaIP = Some(true)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "aroundRadius": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        aroundLatLng = Some(\"40.71, -74.01\"),\n        aroundRadius = Some(AroundRadius(1000000))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "insideBoundingBox": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        insideBoundingBox =\n          Some(InsideBoundingBox(Seq(Seq(49.067996905313834, 65.73828125, 25.905859247243498, 128.8046875))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "insidePolygon": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        insidePolygon = Some(\n          Seq(\n            Seq(42.01, -124.31, 48.835509470063045, -124.40453125000005, 45.01082951668149, -65.95726562500005,\n              31.247243545293433, -81.06578125000004, 25.924152577235226, -97.68234374999997, 32.300311895879545,\n              -117.54828125)\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "optionalFilters": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        optionalFilters = Some(OptionalFilters(Seq(OptionalFilters(\"can_deliver_quickly:true\"))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "optionalFiltersMany": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        optionalFilters = Some(\n          OptionalFilters(\n            Seq(\n              OptionalFilters(\"brand:Apple<score=3>\"),\n              OptionalFilters(\"brand:Samsung<score=2>\"),\n              OptionalFilters(\"brand:-Huawei\")\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "optionalFiltersSimple": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        optionalFilters =\n          Some(OptionalFilters(Seq(OptionalFilters(\"brand:Apple<score=2>\"), OptionalFilters(\"type:tablet\"))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "restrictSearchableAttributes": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        restrictSearchableAttributes = Some(Seq(\"title_fr\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "getRankingInfo": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        getRankingInfo = Some(true)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "clickAnalytics": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        clickAnalytics = Some(true)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "clickAnalyticsUserToken": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        clickAnalytics = Some(true),\n        userToken = Some(\"user-1\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enablePersonalization": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        enablePersonalization = Some(true),\n        userToken = Some(\"user-1\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "userToken": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        userToken = Some(\"user-1\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "userToken1234": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        userToken = Some(\"user-1234\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "analyticsTag": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        analyticsTags = Some(Seq(\"YOUR_ANALYTICS_TAG\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "facetFiltersUsers": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        facetFilters = Some(FacetFilters(Seq(FacetFilters(\"user:user42\"), FacetFilters(\"user:public\"))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "buildTheQuery": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        filters = Some(\"categoryPageId: Men's Clothing\"),\n        hitsPerPage = Some(50),\n        analyticsTags = Some(Seq(\"mens-clothing\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "attributesToHighlightOverride": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        attributesToHighlight = Some(Seq(\"title\", \"content\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "disableTypoToleranceOnAttributes": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        disableTypoToleranceOnAttributes = Some(Seq(\"serial_number\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search_a_query": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"\"),\n        similarQuery = Some(\"Comedy Drama Crime McDormand Macy Buscemi Stormare Presnell Coen\"),\n        filters = Some(\"year:1991 TO 2001\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search_everything": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "api_filtering_range_example": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"books\"),\n        filters = Some(\"price:10 TO 20\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_retrievable_attributes": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        attributesToRetrieve = Some(Seq(\"title\", \"content\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "restrict_searchable_attributes": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        restrictSearchableAttributes = Some(Seq(\"title\", \"author\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_default_relevancy": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        relevancyStrictness = Some(70)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "apply_filters": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        sumOrFiltersScores = Some(true)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "apply_all_filters": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        filters = Some(\n          \"available = 1 AND (category:Book OR NOT category:Ebook) AND _tags:published AND publication_date:1441745506 TO 1441755506 AND inStock > 0 AND author:\\\"John Doe\\\"\"\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "escape_spaces": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        filters = Some(\"category:\\\"Books and Comics\\\"\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "escape_keywords": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        filters = Some(\"keyword:\\\"OR\\\"\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "escape_single_quotes": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        filters = Some(\"content:\\\"It's a wonderful day\\\"\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "escape_double_quotes": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        filters = Some(\"content:\\\"She said \\\"Hello World\\\"\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "apply_negative_filters": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        optionalFilters =\n          Some(OptionalFilters(Seq(OptionalFilters(\"category:Book\"), OptionalFilters(\"author:-John Doe\"))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "apply_negative_filters_restaurants": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        optionalFilters = Some(OptionalFilters(Seq(OptionalFilters(\"restaurant:-Bert's Inn\"))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "apply_numeric_filters": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        numericFilters = Some(\n          NumericFilters(\n            Seq(\n              NumericFilters(\"price < 1000\"),\n              NumericFilters(Seq(NumericFilters(\"inStock = 1\"), NumericFilters(\"deliveryDate < 1441755506\")))\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "apply_tag_filters": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        tagFilters =\n          Some(TagFilters(Seq(TagFilters(\"SciFi\"), TagFilters(Seq(TagFilters(\"Book\"), TagFilters(\"Movie\"))))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "facets_all": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        facets = Some(Seq(\"*\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "retrieve_only_some_facets": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        facets = Some(Seq(\"category\", \"author\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_default_max_values_per_facet": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        maxValuesPerFacet = Some(20)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enable_faceting_after_distinct": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        facetingAfterDistinct = Some(true)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "sort_facet_values_alphabetically": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        sortFacetValuesBy = Some(\"count\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_attributes_to_snippet": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        attributesToSnippet = Some(Seq(\"title\", \"content:80\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_default_highlight_pre_tag": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        highlightPreTag = Some(\"<strong>\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_default_highlight_post_tag": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        highlightPostTag = Some(\"</strong>\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_default_snippet_ellipsis_text": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        snippetEllipsisText = Some(\"\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enable_restrict_highlight_and_snippet_arrays": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        restrictHighlightAndSnippetArrays = Some(false)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "access_page": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        page = Some(0)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_default_hits_per_page": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        hitsPerPage = Some(10)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "get_nth_hit": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        offset = Some(4)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "get_n_results": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        length = Some(4)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_default_min_word_size_for_one_typo": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        minWordSizefor1Typo = Some(2)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_default_min_word_size_for_two_typos": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        minWordSizefor2Typos = Some(2)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_default_typo_tolerance_mode": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        typoTolerance = Some(TypoTolerance(false))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "disable_typos_on_numeric_tokens_at_search_time": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        allowTyposOnNumericTokens = Some(false)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search_around_a_position": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        aroundLatLng = Some(\"40.71, -74.01\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search_around_server_ip": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        aroundLatLngViaIP = Some(true)\n      )\n    ),\n    requestOptions = Some(\n      RequestOptions\n        .builder()\n        .withHeader(\n          \"x-forwarded-for\",\n          \"94.228.178.246 // should be replaced with the actual IP you would like to search around\"\n        )\n        .build()\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_around_radius": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        aroundRadius = Some(AroundRadius(1000))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "disable_automatic_radius": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        aroundRadius = Some(AroundRadiusAll.withName(\"all\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_geo_search_precision": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        aroundPrecision = Some(AroundPrecision(100))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_geo_search_precision_non_linear": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        aroundPrecision = Some(\n          AroundPrecision(\n            Seq(\n              Range(\n                from = Some(0),\n                value = Some(25)\n              ),\n              Range(\n                from = Some(2000),\n                value = Some(1000)\n              )\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_minimum_geo_search_radius": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        minimumAroundRadius = Some(1000)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search_inside_rectangular_area": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        insideBoundingBox =\n          Some(InsideBoundingBox(Seq(Seq(46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search_inside_multiple_rectangular_areas": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        insideBoundingBox = Some(\n          InsideBoundingBox(\n            Seq(\n              Seq(46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625),\n              Seq(49.62625916704081, 4.6181640625, 47.715070300900194, 0.482421875)\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search_inside_polygon_area": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        insidePolygon = Some(\n          Seq(Seq(46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625))\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "search_inside_multiple_polygon_areas": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        insidePolygon = Some(\n          Seq(\n            Seq(46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625),\n            Seq(49.62625916704081, 4.6181640625, 47.715070300900194, 0.482421875, 45.17210966999772, 1.009765625,\n              50.62626704081, 4.6181640625)\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_querylanguages_override": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        removeStopWords =\n          Some(RemoveStopWords(Seq(SupportedLanguage.withName(\"ca\"), SupportedLanguage.withName(\"es\"))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_querylanguages_with_japanese_query": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        queryLanguages = Some(Seq(SupportedLanguage.withName(\"ja\"), SupportedLanguage.withName(\"en\")))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_natural_languages": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"\"),\n        naturalLanguages = Some(Seq(SupportedLanguage.withName(\"fr\")))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_natural_languages_with_query": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"\"),\n        naturalLanguages = Some(Seq(SupportedLanguage.withName(\"fr\"))),\n        removeWordsIfNoResults = Some(RemoveWordsIfNoResults.withName(\"firstWords\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enable_decompound_query_search_time": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        decompoundQuery = Some(true)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enable_rules_search_time": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        enableRules = Some(true)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_rule_contexts": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        ruleContexts = Some(Seq(\"front_end\", \"website2\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enable_personalization": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        enablePersonalization = Some(true)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enable_personalization_with_user_token": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        enablePersonalization = Some(true),\n        userToken = Some(\"123456\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "personalization_impact": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        personalizationImpact = Some(20)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_user_token": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        userToken = Some(\"123456\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_user_token_with_personalization": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        enablePersonalization = Some(true),\n        userToken = Some(\"123456\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_default_query_type": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        queryType = Some(QueryType.withName(\"prefixAll\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_default_remove_words_if_no_results": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        removeWordsIfNoResults = Some(RemoveWordsIfNoResults.withName(\"lastWords\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enable_advanced_syntax_search_time": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        advancedSyntax = Some(true)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "overide_default_optional_words": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        optionalWords = Some(OptionalWords(Seq(\"toyota\", \"2020 2021\")))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "disabling_exact_for_some_attributes_search_time": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        disableExactOnAttributes = Some(Seq(\"description\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_default_exact_single_word_query": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        exactOnSingleWordQuery = Some(ExactOnSingleWordQuery.withName(\"none\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_default_aternative_as_exact": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        alternativesAsExact = Some(Seq(AlternativesAsExact.withName(\"multiWordsSynonym\")))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enable_advanced_syntax_exact_phrase": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        advancedSyntax = Some(true),\n        advancedSyntaxFeatures = Some(Seq(AdvancedSyntaxFeatures.withName(\"exactPhrase\")))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enable_advanced_syntax_exclude_words": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        advancedSyntax = Some(true),\n        advancedSyntaxFeatures = Some(Seq(AdvancedSyntaxFeatures.withName(\"excludeWords\")))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_distinct": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        distinct = Some(Distinct(0))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "get_ranking_info": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        getRankingInfo = Some(true)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "disable_click_analytics": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        clickAnalytics = Some(false)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enable_click_analytics": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        clickAnalytics = Some(true)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "disable_analytics": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        analytics = Some(false)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "add_analytics_tags": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        analyticsTags = Some(Seq(\"front_end\", \"website2\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "disable_synonyms": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        synonyms = Some(false)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_replace_synonyms_in_highlights": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        replaceSynonymsInHighlight = Some(true)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_min_proximity": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        minProximity = Some(2)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_default_field": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        responseFields = Some(Seq(\"hits\", \"facets\"))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "override_percentile_computation": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        percentileComputation = Some(false)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_ab_test": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        enableABTest = Some(false)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_enable_re_ranking": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\"),\n        enableReRanking = Some(false)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "with algolia user id": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"query\")\n      )\n    ),\n    requestOptions = Some(\n      RequestOptions\n        .builder()\n        .withHeader(\"X-Algolia-User-ID\", \"user1234\")\n        .build()\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "mcm with algolia user id": "val response = Await.result(\n  client.searchSingleIndex(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchParams = Some(\n      SearchParamsObject(\n        query = Some(\"peace\")\n      )\n    ),\n    requestOptions = Some(\n      RequestOptions\n        .builder()\n        .withHeader(\"X-Algolia-User-ID\", \"user42\")\n        .build()\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "searchSynonyms": {
      "searchSynonyms with minimal parameters": "val response = Await.result(\n  client.searchSynonyms(\n    indexName = \"<YOUR_INDEX_NAME>\"\n  ),\n  Duration(100, \"sec\")\n)",
      "searchSynonyms with all parameters": "val response = Await.result(\n  client.searchSynonyms(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    searchSynonymsParams = Some(\n      SearchSynonymsParams(\n        query = Some(\"myQuery\"),\n        `type` = Some(SynonymType.withName(\"altcorrection1\")),\n        page = Some(10),\n        hitsPerPage = Some(10)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "searchUserIds": {
      "default": "val response = Await.result(\n  client.searchUserIds(\n    searchUserIdsParams = SearchUserIdsParams(\n      query = \"test\",\n      clusterName = Some(\"theClusterName\"),\n      page = Some(5),\n      hitsPerPage = Some(10)\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "setClientApiKey": {
      "default": "client.setClientApiKey(\n  apiKey = \"updated-api-key\"\n)"
    },
    "setDictionarySettings": {
      "get setDictionarySettings results with minimal parameters": "val response = Await.result(\n  client.setDictionarySettings(\n    dictionarySettingsParams = DictionarySettingsParams(\n      disableStandardEntries = StandardEntries(\n        plurals = Some(Map(\"fr\" -> false, \"en\" -> false, \"ru\" -> true))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "get setDictionarySettings results with all parameters": "val response = Await.result(\n  client.setDictionarySettings(\n    dictionarySettingsParams = DictionarySettingsParams(\n      disableStandardEntries = StandardEntries(\n        plurals = Some(Map(\"fr\" -> false, \"en\" -> false, \"ru\" -> true)),\n        stopwords = Some(Map(\"fr\" -> false)),\n        compounds = Some(Map(\"ru\" -> true))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "setSettings": {
      "minimal parameters": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      paginationLimitedTo = Some(10)\n    ),\n    forwardToReplicas = Some(true)\n  ),\n  Duration(100, \"sec\")\n)",
      "boolean typoTolerance": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      typoTolerance = Some(TypoTolerance(true))\n    ),\n    forwardToReplicas = Some(true)\n  ),\n  Duration(100, \"sec\")\n)",
      "enum typoTolerance": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      typoTolerance = Some(TypoToleranceEnum.withName(\"min\"))\n    ),\n    forwardToReplicas = Some(true)\n  ),\n  Duration(100, \"sec\")\n)",
      "ignorePlurals": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      ignorePlurals = Some(IgnorePlurals(true))\n    ),\n    forwardToReplicas = Some(true)\n  ),\n  Duration(100, \"sec\")\n)",
      "list of string ignorePlurals": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      ignorePlurals = Some(IgnorePlurals(Seq(SupportedLanguage.withName(\"fr\"))))\n    ),\n    forwardToReplicas = Some(true)\n  ),\n  Duration(100, \"sec\")\n)",
      "removeStopWords boolean": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      removeStopWords = Some(RemoveStopWords(true))\n    ),\n    forwardToReplicas = Some(true)\n  ),\n  Duration(100, \"sec\")\n)",
      "removeStopWords list of string": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      removeStopWords = Some(RemoveStopWords(Seq(SupportedLanguage.withName(\"fr\"))))\n    ),\n    forwardToReplicas = Some(true)\n  ),\n  Duration(100, \"sec\")\n)",
      "boolean distinct": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      distinct = Some(Distinct(true))\n    ),\n    forwardToReplicas = Some(true)\n  ),\n  Duration(100, \"sec\")\n)",
      "integer distinct": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      distinct = Some(Distinct(1))\n    ),\n    forwardToReplicas = Some(true)\n  ),\n  Duration(100, \"sec\")\n)",
      "distinct company": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributeForDistinct = Some(\"company\"),\n      distinct = Some(Distinct(true))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "distinct design": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributeForDistinct = Some(\"design\"),\n      distinct = Some(Distinct(true))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "distinct true": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      distinct = Some(Distinct(true))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "distinct section": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributeForDistinct = Some(\"section\"),\n      distinct = Some(Distinct(true))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "attributesForFaceting allergens": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesForFaceting = Some(Seq(\"allergens\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "attributesForFaceting availableIn": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesForFaceting = Some(Seq(\"color\", \"availableIn\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "api_attributes_for_faceting": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesForFaceting = Some(Seq(\"genre\", \"author\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "api_attributes_for_faceting_searchable": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesForFaceting = Some(Seq(\"genre\", \"searchable(author)\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "api_attributes_for_filter_only": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesForFaceting = Some(Seq(\"filterOnly(genre)\", \"author\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "attributesForFaceting categoryPageId": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesForFaceting = Some(Seq(\"searchable(categoryPageId)\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "unretrievableAttributes": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      unretrievableAttributes = Some(Seq(\"visible_by\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "attributesForFaceting user restricted data": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesForFaceting = Some(Seq(\"filterOnly(visible_by)\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "attributesForFaceting optional filters": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesForFaceting = Some(Seq(\"can_deliver_quickly\", \"restaurant\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "attributesForFaceting redirect index": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesForFaceting = Some(Seq(\"query_terms\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "attributesForFaceting multiple consequences": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesForFaceting = Some(Seq(\"director\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "attributesForFaceting in-depth optional filters": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesForFaceting = Some(Seq(\"filterOnly(brand)\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "mode neuralSearch": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      mode = Some(Mode.withName(\"neuralSearch\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "mode keywordSearch": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      mode = Some(Mode.withName(\"keywordSearch\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "searchableAttributes same priority": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      searchableAttributes = Some(Seq(\"title,comments\", \"ingredients\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "searchableAttributes higher priority": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      searchableAttributes = Some(Seq(\"title\", \"ingredients\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "customRanking retweets": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      customRanking = Some(Seq(\"desc(retweets)\", \"desc(likes)\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "customRanking boosted": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      customRanking = Some(Seq(\"desc(boosted)\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "customRanking pageviews": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      customRanking = Some(Seq(\"desc(pageviews)\", \"desc(comments)\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "customRanking applying search parameters for a specific query": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      customRanking = Some(Seq(\"desc(nb_airline_liaisons)\")),\n      attributesForFaceting = Some(Seq(\"city, country\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "customRanking rounded pageviews": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      customRanking = Some(Seq(\"desc(rounded_pageviews)\", \"desc(comments)\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "customRanking price": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      customRanking = Some(Seq(\"desc(price)\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "ranking exhaustive (price)": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      ranking =\n        Some(Seq(\"desc(price)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "ranking exhaustive (is_popular)": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      ranking = Some(\n        Seq(\"desc(is_popular)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "ranking standard replica": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      ranking = Some(Seq(\"desc(post_date_timestamp)\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "ranking virtual replica": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      customRanking = Some(Seq(\"desc(post_date_timestamp)\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "customRanking and ranking sort alphabetically": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      customRanking = Some(Seq(\"asc(textual_attribute)\")),\n      ranking = Some(Seq(\"custom\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "relevancyStrictness": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      customRanking = Some(Seq(\"asc(textual_attribute)\")),\n      relevancyStrictness = Some(0)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "create replica index": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      replicas = Some(Seq(\"products_price_desc\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "create replica index articles": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      replicas = Some(Seq(\"articles_date_desc\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "create virtual replica index": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      replicas = Some(Seq(\"virtual(products_price_desc)\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "unlink replica index": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      replicas = Some(Seq(\"\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "forwardToReplicas": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      searchableAttributes = Some(Seq(\"name\", \"description\"))\n    ),\n    forwardToReplicas = Some(true)\n  ),\n  Duration(100, \"sec\")\n)",
      "maxValuesPerFacet": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      maxValuesPerFacet = Some(1000)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "maxFacetHits": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      maxFacetHits = Some(100)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "attributesForFaceting complex": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesForFaceting = Some(Seq(\"actor\", \"filterOnly(category)\", \"searchable(publisher)\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "ranking closest dates": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      ranking = Some(\n        Seq(\"asc(date_timestamp)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\")\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "searchableAttributes item variation": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      searchableAttributes = Some(Seq(\"design\", \"type\", \"color\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "searchableAttributes around location": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      searchableAttributes = Some(Seq(\"name\", \"country\", \"city\", \"iata_code\")),\n      customRanking = Some(Seq(\"desc(links_count)\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "attributesToHighlight": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesToHighlight = Some(Seq(\"author\", \"title\", \"content\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "attributesToHighlightStar": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesToHighlight = Some(Seq(\"*\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "everything": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      advancedSyntax = Some(true),\n      advancedSyntaxFeatures = Some(Seq(AdvancedSyntaxFeatures.withName(\"exactPhrase\"))),\n      allowCompressionOfIntegerArray = Some(true),\n      allowTyposOnNumericTokens = Some(true),\n      alternativesAsExact = Some(Seq(AlternativesAsExact.withName(\"singleWordSynonym\"))),\n      attributeCriteriaComputedByMinProximity = Some(true),\n      attributeForDistinct = Some(\"test\"),\n      attributesForFaceting = Some(Seq(\"algolia\")),\n      attributesToHighlight = Some(Seq(\"algolia\")),\n      attributesToRetrieve = Some(Seq(\"algolia\")),\n      attributesToSnippet = Some(Seq(\"algolia\")),\n      attributesToTransliterate = Some(Seq(\"algolia\")),\n      camelCaseAttributes = Some(Seq(\"algolia\")),\n      customNormalization = Some(Map(\"algolia\" -> Map(\"aloglia\" -> \"aglolia\"))),\n      customRanking = Some(Seq(\"algolia\")),\n      decompoundQuery = Some(false),\n      decompoundedAttributes = Some(JObject(List(JField(\"algolia\", JString(\"aloglia\"))))),\n      disableExactOnAttributes = Some(Seq(\"algolia\")),\n      disablePrefixOnAttributes = Some(Seq(\"algolia\")),\n      disableTypoToleranceOnAttributes = Some(Seq(\"algolia\")),\n      disableTypoToleranceOnWords = Some(Seq(\"algolia\")),\n      distinct = Some(Distinct(3)),\n      enablePersonalization = Some(true),\n      enableReRanking = Some(false),\n      enableRules = Some(true),\n      exactOnSingleWordQuery = Some(ExactOnSingleWordQuery.withName(\"attribute\")),\n      highlightPreTag = Some(\"<span>\"),\n      highlightPostTag = Some(\"</span>\"),\n      hitsPerPage = Some(10),\n      ignorePlurals = Some(IgnorePlurals(false)),\n      indexLanguages = Some(Seq(SupportedLanguage.withName(\"fr\"))),\n      keepDiacriticsOnCharacters = Some(\"abc\"),\n      maxFacetHits = Some(20),\n      maxValuesPerFacet = Some(30),\n      minProximity = Some(6),\n      minWordSizefor1Typo = Some(5),\n      minWordSizefor2Typos = Some(11),\n      mode = Some(Mode.withName(\"neuralSearch\")),\n      numericAttributesForFiltering = Some(Seq(\"algolia\")),\n      optionalWords = Some(OptionalWords(Seq(\"myspace\"))),\n      paginationLimitedTo = Some(0),\n      queryLanguages = Some(Seq(SupportedLanguage.withName(\"fr\"))),\n      queryType = Some(QueryType.withName(\"prefixLast\")),\n      ranking = Some(Seq(\"geo\")),\n      reRankingApplyFilter = Some(ReRankingApplyFilter(\"mySearch:filters\")),\n      relevancyStrictness = Some(10),\n      removeStopWords = Some(RemoveStopWords(false)),\n      removeWordsIfNoResults = Some(RemoveWordsIfNoResults.withName(\"lastWords\")),\n      renderingContent = Some(\n        RenderingContent(\n          facetOrdering = Some(\n            FacetOrdering(\n              facets = Some(\n                Facets(\n                  order = Some(Seq(\"a\", \"b\"))\n                )\n              ),\n              values = Some(\n                Map(\n                  \"a\" -> Value(\n                    order = Some(Seq(\"b\")),\n                    sortRemainingBy = Some(SortRemainingBy.withName(\"count\"))\n                  )\n                )\n              )\n            )\n          )\n        )\n      ),\n      replaceSynonymsInHighlight = Some(true),\n      replicas = Some(Seq(\"\")),\n      responseFields = Some(Seq(\"algolia\")),\n      restrictHighlightAndSnippetArrays = Some(true),\n      searchableAttributes = Some(Seq(\"foo\")),\n      semanticSearch = Some(\n        SemanticSearch(\n          eventSources = Some(Seq(\"foo\"))\n        )\n      ),\n      separatorsToIndex = Some(\"bar\"),\n      snippetEllipsisText = Some(\"---\"),\n      sortFacetValuesBy = Some(\"date\"),\n      typoTolerance = Some(TypoTolerance(false)),\n      unretrievableAttributes = Some(Seq(\"foo\")),\n      userData = Some(JObject(List(JField(\"user\", JString(\"data\")))))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "searchableAttributesWithCustomRankingsAndAttributesForFaceting": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      searchableAttributes = Some(Seq(\"brand\", \"name\", \"categories\", \"unordered(description)\")),\n      customRanking = Some(Seq(\"desc(popularity)\")),\n      attributesForFaceting = Some(Seq(\"searchable(brand)\", \"type\", \"categories\", \"price\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "searchableAttributesOrdering": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      searchableAttributes = Some(Seq(\"unordered(title)\", \"cast\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "searchableAttributesProductReferenceSuffixes": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      searchableAttributes = Some(Seq(\"name\", \"product_reference\", \"product_reference_suffixes\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "queryLanguageAndIgnorePlurals": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      queryLanguages = Some(Seq(SupportedLanguage.withName(\"en\"))),\n      ignorePlurals = Some(IgnorePlurals(true))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "searchableAttributesInMovies": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      searchableAttributes = Some(Seq(\"title_eng\", \"title_fr\", \"title_es\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "disablePrefixOnAttributes": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      disablePrefixOnAttributes = Some(Seq(\"serial_number\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "disableTypoToleranceOnAttributes": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      disableTypoToleranceOnAttributes = Some(Seq(\"serial_number\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "searchableAttributesSimpleExample": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      searchableAttributes = Some(Seq(\"serial_number\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "searchableAttributesSimpleExampleAlt": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      searchableAttributes = Some(Seq(\"serial_number\", \"serial_number_suffixes\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_searchable_attributes": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesForFaceting = Some(\n        Seq(\n          \"author\",\n          \"filterOnly(isbn)\",\n          \"searchable(edition)\",\n          \"afterDistinct(category)\",\n          \"afterDistinct(searchable(publisher))\"\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "unretrievable_attributes": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      unretrievableAttributes = Some(Seq(\"total_number_of_sales\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_retrievable_attributes": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesToRetrieve = Some(Seq(\"author\", \"title\", \"content\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_all_attributes_as_retrievable": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesToRetrieve = Some(Seq(\"*\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "specify_attributes_not_to_retrieve": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesToRetrieve = Some(Seq(\"*\", \"-SKU\", \"-internal_desc\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "neural_search": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      mode = Some(Mode.withName(\"neuralSearch\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "keyword_search": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      mode = Some(Mode.withName(\"keywordSearch\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_ranking": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      ranking = Some(Seq(\"typo\", \"geo\", \"words\", \"filters\", \"attribute\", \"proximity\", \"exact\", \"custom\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_ranking_by_attribute_asc": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      ranking =\n        Some(Seq(\"asc(price)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_ranking_by_attribute_desc": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      ranking =\n        Some(Seq(\"desc(price)\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\", \"custom\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "restrict_searchable_attributes": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      customRanking = Some(Seq(\"desc(popularity)\", \"asc(price)\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_relevancy": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      relevancyStrictness = Some(90)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_replicas": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      replicas = Some(Seq(\"name_of_replica_index1\", \"name_of_replica_index2\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_max_values_per_facet": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      maxValuesPerFacet = Some(100)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_sort_facet_values_by": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      sortFacetValuesBy = Some(\"alpha\")\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_attributes_to_snippet": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesToSnippet = Some(Seq(\"content:80\", \"description\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_all_attributes_to_snippet": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributesToSnippet = Some(Seq(\"*:80\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_highlight_pre_tag": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      highlightPreTag = Some(\"<em>\")\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_highlight_post_tag": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      highlightPostTag = Some(\"</em>\")\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_snippet_ellipsis_text": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      snippetEllipsisText = Some(\"…\")\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enable_restrict_highlight_and_snippet_arrays_by_default": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      restrictHighlightAndSnippetArrays = Some(true)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_hits_per_page": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      hitsPerPage = Some(20)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_pagination_limit": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      paginationLimitedTo = Some(1000)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_min_word_size_for_one_typo": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      minWordSizefor1Typo = Some(4)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_min_word_size_for_two_typos": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      minWordSizefor2Typos = Some(4)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_typo_tolerance_mode": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      typoTolerance = Some(TypoTolerance(true))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "disable_typos_on_numeric_tokens_by_default": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      allowTyposOnNumericTokens = Some(false)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "disable_typo_tolerance_for_words": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      disableTypoToleranceOnWords = Some(Seq(\"wheel\", \"1X2BCD\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_separators_to_index": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      separatorsToIndex = Some(\"+#\")\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_languages_using_querylanguages": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      queryLanguages = Some(Seq(SupportedLanguage.withName(\"es\"))),\n      removeStopWords = Some(RemoveStopWords(true)),\n      ignorePlurals = Some(IgnorePlurals(true))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_attributes_to_transliterate": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      indexLanguages = Some(Seq(SupportedLanguage.withName(\"ja\"))),\n      attributesToTransliterate = Some(Seq(\"name\", \"description\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_camel_case_attributes": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      camelCaseAttributes = Some(Seq(\"description\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_decompounded_attributes": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      decompoundedAttributes = Some(JObject(List(JField(\"de\", JArray(List(JString(\"name\")))))))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_decompounded_multiple_attributes": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      decompoundedAttributes = Some(\n        JObject(\n          List(\n            JField(\"de\", JArray(List(JString(\"name_de\"), JString(\"description_de\")))),\n            JField(\"fi\", JArray(List(JString(\"name_fi\"), JString(\"description_fi\"))))\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_keep_diacritics_on_characters": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      keepDiacriticsOnCharacters = Some(\"øé\")\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_custom_normalization": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      customNormalization = Some(Map(\"default\" -> Map(\"ä\" -> \"ae\")))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_indexlanguages": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      indexLanguages = Some(Seq(SupportedLanguage.withName(\"ja\")))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enable_decompound_query_by_default": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      decompoundQuery = Some(true)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enable_rules_syntax_by_default": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      enableRules = Some(true)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enable_personalization_settings": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      enablePersonalization = Some(true)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_query_type": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      queryType = Some(QueryType.withName(\"prefixLast\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_remove_words_if_no_result": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      removeWordsIfNoResults = Some(RemoveWordsIfNoResults.withName(\"none\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enable_advanced_syntax_by_default": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      advancedSyntax = Some(true)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_optional_words": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      optionalWords = Some(OptionalWords(Seq(\"blue\", \"iphone case\")))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "disabling_prefix_search_for_some_attributes_by_default": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      disablePrefixOnAttributes = Some(Seq(\"sku\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "disabling_exact_for_some_attributes_by_default": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      disableExactOnAttributes = Some(Seq(\"description\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_exact_single_word_query": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      exactOnSingleWordQuery = Some(ExactOnSingleWordQuery.withName(\"attribute\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_aternative_as_exact": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      alternativesAsExact =\n        Some(Seq(AlternativesAsExact.withName(\"ignorePlurals\"), AlternativesAsExact.withName(\"singleWordSynonym\")))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_numeric_attributes_for_filtering": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      numericAttributesForFiltering = Some(Seq(\"quantity\", \"popularity\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "enable_compression_of_integer_array": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      allowCompressionOfIntegerArray = Some(true)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_attributes_for_distinct": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributeForDistinct = Some(\"url\")\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_distinct": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      distinct = Some(Distinct(1)),\n      attributeForDistinct = Some(\"url\")\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_replace_synonyms_in_highlights": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      replaceSynonymsInHighlight = Some(false)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_min_proximity": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      minProximity = Some(1)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_default_field": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      responseFields = Some(Seq(\"hits\", \"hitsPerPage\", \"nbPages\", \"page\"))\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_max_facet_hits": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      maxFacetHits = Some(10)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_attribute_criteria_computed_by_min_proximity": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      attributeCriteriaComputedByMinProximity = Some(true)\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_user_data": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      userData = Some(\n        JObject(List(JField(\"extraData\", JString(\"This is the custom data that you want to store in your index\"))))\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "set_rendering_content": "val response = Await.result(\n  client.setSettings(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    indexSettings = IndexSettings(\n      renderingContent = Some(\n        RenderingContent(\n          facetOrdering = Some(\n            FacetOrdering(\n              facets = Some(\n                Facets(\n                  order = Some(Seq(\"size\", \"brand\"))\n                )\n              ),\n              values = Some(\n                Map(\n                  \"brand\" -> Value(\n                    order = Some(Seq(\"uniqlo\")),\n                    hide = Some(Seq(\"muji\")),\n                    sortRemainingBy = Some(SortRemainingBy.withName(\"count\"))\n                  ),\n                  \"size\" -> Value(\n                    order = Some(Seq(\"S\", \"M\", \"L\")),\n                    sortRemainingBy = Some(SortRemainingBy.withName(\"hidden\"))\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "updateApiKey": {
      "default": "val response = Await.result(\n  client.updateApiKey(\n    key = \"ALGOLIA_API_KEY\",\n    apiKey = ApiKey(\n      acl = Seq(Acl.withName(\"search\"), Acl.withName(\"addObject\")),\n      validity = Some(300),\n      maxQueriesPerIPPerHour = Some(100),\n      maxHitsPerQuery = Some(20)\n    )\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "val response = Await.result(\n  client.waitForApiKey(\n    key = \"api-key-add-operation-test-scala\",\n    operation = ApiKeyOperation.withName(\"add\")\n  ),\n  Duration(100, \"sec\")\n)",
      "wait for api key - update": "val response = Await.result(\n  client.waitForApiKey(\n    key = \"api-key-update-operation-test-scala\",\n    operation = ApiKeyOperation.withName(\"update\"),\n    apiKey = Some(\n      ApiKey(\n        description = Some(\"my updated api key\"),\n        acl = Seq(Acl.withName(\"search\"), Acl.withName(\"addObject\"), Acl.withName(\"deleteObject\")),\n        indexes = Some(Seq(\"Movies\", \"Books\")),\n        referers = Some(Seq(\"*google.com\", \"*algolia.com\")),\n        validity = Some(305),\n        maxQueriesPerIPPerHour = Some(95),\n        maxHitsPerQuery = Some(20)\n      )\n    )\n  ),\n  Duration(100, \"sec\")\n)",
      "wait for api key - delete": "val response = Await.result(\n  client.waitForApiKey(\n    key = \"api-key-delete-operation-test-scala\",\n    operation = ApiKeyOperation.withName(\"delete\")\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "waitForAppTask": {
      "default": "val response = Await.result(\n  client.waitForAppTask(\n    taskID = 123L\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "waitForTask": {
      "default": "val response = Await.result(\n  client.waitForTask(\n    indexName = \"<YOUR_INDEX_NAME>\",\n    taskID = 123L\n  ),\n  Duration(100, \"sec\")\n)"
    },
    "init": {
      "default": "val client = SearchClient(appId = \"ALGOLIA_APPLICATION_ID\", apiKey = \"ALGOLIA_API_KEY\")"
    }
  },
  "swift": {
    "import": {
      "default": "import Search"
    },
    "addApiKey": {
      "minimal": "let response = try await client.addApiKey(apiKey: ApiKey(\n    acl: [Acl.search, Acl.addObject],\n    description: \"my new api key\"\n))",
      "all": "let response = try await client.addApiKey(apiKey: ApiKey(\n    acl: [Acl.search, Acl.addObject],\n    description: \"my new api key\",\n    maxHitsPerQuery: 20,\n    maxQueriesPerIPPerHour: 100,\n    validity: 300\n))"
    },
    "addOrUpdateObject": {
      "default": "let response = try await client.addOrUpdateObject(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"uniqueID\",\n    body: [\"key\": \"value\"]\n)"
    },
    "appendSource": {
      "default": "let response = try await client.appendSource(source: SearchSource(\n    source: \"theSource\",\n    description: \"theDescription\"\n))"
    },
    "assignUserId": {
      "simple": "let response = try await client.assignUserId(\n    xAlgoliaUserID: \"user42\",\n    assignUserIdParams: AssignUserIdParams(cluster: \"d4242-eu\")\n)",
      "it should not encode the userID": "let response = try await client.assignUserId(\n    xAlgoliaUserID: \"user id with spaces\",\n    assignUserIdParams: AssignUserIdParams(cluster: \"cluster with spaces\")\n)"
    },
    "batch": {
      "addObject": "let response = try await client.batch(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    batchWriteParams: SearchBatchWriteParams(requests: [\n        SearchBatchRequest(action: SearchAction.addObject, body: [\"key\": \"bar\", \"foo\": \"1\"]),\n        SearchBatchRequest(action: SearchAction.addObject, body: [\"key\": \"baz\", \"foo\": \"2\"]),\n    ])\n)",
      "clear": "let response = try await client.batch(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    batchWriteParams: SearchBatchWriteParams(requests: [SearchBatchRequest(\n        action: SearchAction.clear,\n        body: [\"key\": \"value\"]\n    )])\n)",
      "delete": "let response = try await client.batch(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    batchWriteParams: SearchBatchWriteParams(requests: [SearchBatchRequest(\n        action: SearchAction.delete,\n        body: [\"key\": \"value\"]\n    )])\n)",
      "deleteObject": "let response = try await client.batch(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    batchWriteParams: SearchBatchWriteParams(requests: [SearchBatchRequest(\n        action: SearchAction.deleteObject,\n        body: [\"key\": \"value\"]\n    )])\n)",
      "partialUpdateObject": "let response = try await client.batch(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    batchWriteParams: SearchBatchWriteParams(requests: [SearchBatchRequest(\n        action: SearchAction.partialUpdateObject,\n        body: [\"key\": \"value\"]\n    )])\n)",
      "partialUpdateObjectNoCreate": "let response = try await client.batch(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    batchWriteParams: SearchBatchWriteParams(requests: [SearchBatchRequest(\n        action: SearchAction.partialUpdateObjectNoCreate,\n        body: [\"key\": \"value\"]\n    )])\n)",
      "updateObject": "let response = try await client.batch(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    batchWriteParams: SearchBatchWriteParams(requests: [SearchBatchRequest(\n        action: SearchAction.updateObject,\n        body: [\"key\": \"value\"]\n    )])\n)"
    },
    "batchAssignUserIds": {
      "default": "let response = try await client.batchAssignUserIds(\n    xAlgoliaUserID: \"userID\",\n    batchAssignUserIdsParams: BatchAssignUserIdsParams(cluster: \"theCluster\", users: [\"user1\", \"user2\"])\n)"
    },
    "batchDictionaryEntries": {
      "replace": "let response = try await client.batchDictionaryEntries(\n    dictionaryName: DictionaryType.plurals,\n    batchDictionaryEntriesParams: BatchDictionaryEntriesParams(\n        clearExistingDictionaryEntries: true,\n        requests: [BatchDictionaryEntriesRequest(\n            action: DictionaryAction.addEntry,\n            body: DictionaryEntry(\n                objectID: \"1\",\n                language: SearchSupportedLanguage.en,\n                word: \"fancy\",\n                words: [\"believe\", \"algolia\"],\n                decomposition: [\"trust\", \"algolia\"],\n                state: DictionaryEntryState.enabled\n            )\n        )]\n    )\n)",
      "delete": "let response = try await client.batchDictionaryEntries(\n    dictionaryName: DictionaryType.plurals,\n    batchDictionaryEntriesParams: BatchDictionaryEntriesParams(\n        clearExistingDictionaryEntries: true,\n        requests: [BatchDictionaryEntriesRequest(\n            action: DictionaryAction.deleteEntry,\n            body: DictionaryEntry(objectID: \"1\")\n        )]\n    )\n)",
      "append": "let response = try await client.batchDictionaryEntries(\n    dictionaryName: DictionaryType.stopwords,\n    batchDictionaryEntriesParams: BatchDictionaryEntriesParams(requests: [BatchDictionaryEntriesRequest(\n        action: DictionaryAction.addEntry,\n        body: DictionaryEntry(from: [\n            \"objectID\": AnyCodable(\"1\"),\n            \"language\": AnyCodable(SearchSupportedLanguage.en),\n            \"additional\": AnyCodable(\"try me\"),\n        ])\n    )])\n)"
    },
    "browse": {
      "browse with minimal parameters": "let response: BrowseResponse<Hit> = try await client.browse(indexName: \"<YOUR_INDEX_NAME>\")",
      "browse with search parameters": "let response: BrowseResponse<Hit> = try await client.browse(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    browseParams: BrowseParams.browseParamsObject(BrowseParamsObject(\n        query: \"myQuery\",\n        facetFilters: SearchFacetFilters.arrayOfSearchFacetFilters([SearchFacetFilters.string(\"tags:algolia\")])\n    ))\n)",
      "browse allow a cursor in parameters": "let response: BrowseResponse<Hit> = try await client.browse(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    browseParams: BrowseParams.browseParamsObject(BrowseParamsObject(cursor: \"test\"))\n)"
    },
    "clearObjects": {
      "default": "let response = try await client.clearObjects(indexName: \"<YOUR_INDEX_NAME>\")"
    },
    "clearRules": {
      "default": "let response = try await client.clearRules(indexName: \"<YOUR_INDEX_NAME>\")"
    },
    "clearSynonyms": {
      "default": "let response = try await client.clearSynonyms(indexName: \"<YOUR_INDEX_NAME>\")"
    },
    "customDelete": {
      "allow del method for a custom path with minimal parameters": "let response = try await client.customDelete(path: \"test/minimal\")",
      "allow del method for a custom path with all parameters": "let response = try await client.customDelete(path: \"test/all\", parameters: [\"query\": AnyCodable(\"parameters\")])"
    },
    "customGet": {
      "allow get method for a custom path with minimal parameters": "let response = try await client.customGet(path: \"test/minimal\")",
      "allow get method for a custom path with all parameters": "let response = try await client.customGet(\n    path: \"test/all\",\n    parameters: [\"query\": AnyCodable(\"parameters with space\")]\n)",
      "requestOptions should be escaped too": "let response = try await client.customGet(\n    path: \"test/all\",\n    parameters: [\"query\": AnyCodable(\"to be overriden\")],\n    requestOptions: RequestOptions(\n        headers: [\"x-header-1\": \"spaces are left alone\"],\n\n        queryParameters: [\"query\": \"parameters with space\", \"and an array\": [\"array\", \"with spaces\"]]\n    )\n)"
    },
    "customPost": {
      "allow post method for a custom path with minimal parameters": "let response = try await client.customPost(path: \"test/minimal\")",
      "allow post method for a custom path with all parameters": "let response = try await client.customPost(\n    path: \"test/all\",\n    parameters: [\"query\": AnyCodable(\"parameters\")],\n    body: [\"body\": \"parameters\"]\n)",
      "requestOptions can override default query parameters": "let response = try await client.customPost(\n    path: \"test/requestOptions\",\n    parameters: [\"query\": AnyCodable(\"parameters\")],\n    body: [\"facet\": \"filters\"],\n    requestOptions: RequestOptions(\n        queryParameters: [\"query\": \"myQueryParameter\"]\n    )\n)",
      "requestOptions merges query parameters with default ones": "let response = try await client.customPost(\n    path: \"test/requestOptions\",\n    parameters: [\"query\": AnyCodable(\"parameters\")],\n    body: [\"facet\": \"filters\"],\n    requestOptions: RequestOptions(\n        queryParameters: [\"query2\": \"myQueryParameter\"]\n    )\n)",
      "requestOptions can override default headers": "let response = try await client.customPost(\n    path: \"test/requestOptions\",\n    parameters: [\"query\": AnyCodable(\"parameters\")],\n    body: [\"facet\": \"filters\"],\n    requestOptions: RequestOptions(\n        headers: [\"x-algolia-api-key\": \"ALGOLIA_API_KEY\"]\n    )\n)",
      "requestOptions merges headers with default ones": "let response = try await client.customPost(\n    path: \"test/requestOptions\",\n    parameters: [\"query\": AnyCodable(\"parameters\")],\n    body: [\"facet\": \"filters\"],\n    requestOptions: RequestOptions(\n        headers: [\"x-algolia-api-key\": \"ALGOLIA_API_KEY\"]\n    )\n)",
      "requestOptions queryParameters accepts booleans": "let response = try await client.customPost(\n    path: \"test/requestOptions\",\n    parameters: [\"query\": AnyCodable(\"parameters\")],\n    body: [\"facet\": \"filters\"],\n    requestOptions: RequestOptions(\n        queryParameters: [\"isItWorking\": true]\n    )\n)",
      "requestOptions queryParameters accepts integers": "let response = try await client.customPost(\n    path: \"test/requestOptions\",\n    parameters: [\"query\": AnyCodable(\"parameters\")],\n    body: [\"facet\": \"filters\"],\n    requestOptions: RequestOptions(\n        queryParameters: [\"myParam\": 2]\n    )\n)",
      "requestOptions queryParameters accepts list of string": "let response = try await client.customPost(\n    path: \"test/requestOptions\",\n    parameters: [\"query\": AnyCodable(\"parameters\")],\n    body: [\"facet\": \"filters\"],\n    requestOptions: RequestOptions(\n        queryParameters: [\"myParam\": [\"b and c\", \"d\"]]\n    )\n)",
      "requestOptions queryParameters accepts list of booleans": "let response = try await client.customPost(\n    path: \"test/requestOptions\",\n    parameters: [\"query\": AnyCodable(\"parameters\")],\n    body: [\"facet\": \"filters\"],\n    requestOptions: RequestOptions(\n        queryParameters: [\"myParam\": [true, true, false]]\n    )\n)",
      "requestOptions queryParameters accepts list of integers": "let response = try await client.customPost(\n    path: \"test/requestOptions\",\n    parameters: [\"query\": AnyCodable(\"parameters\")],\n    body: [\"facet\": \"filters\"],\n    requestOptions: RequestOptions(\n        queryParameters: [\"myParam\": [1, 2]]\n    )\n)"
    },
    "customPut": {
      "allow put method for a custom path with minimal parameters": "let response = try await client.customPut(path: \"test/minimal\")",
      "allow put method for a custom path with all parameters": "let response = try await client.customPut(\n    path: \"test/all\",\n    parameters: [\"query\": AnyCodable(\"parameters\")],\n    body: [\"body\": \"parameters\"]\n)"
    },
    "deleteApiKey": {
      "default": "let response = try await client.deleteApiKey(key: \"myTestApiKey\")"
    },
    "deleteBy": {
      "default": "let response = try await client.deleteBy(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    deleteByParams: DeleteByParams(filters: \"brand:brandName\")\n)"
    },
    "deleteIndex": {
      "default": "let response = try await client.deleteIndex(indexName: \"<YOUR_INDEX_NAME>\")"
    },
    "deleteObject": {
      "default": "let response = try await client.deleteObject(indexName: \"<YOUR_INDEX_NAME>\", objectID: \"uniqueID\")"
    },
    "deleteObjects": {
      "default": "let response = try await client.deleteObjects(indexName: \"<YOUR_INDEX_NAME>\", objectIDs: [\"1\", \"2\"])"
    },
    "deleteRule": {
      "delete rule simple case": "let response = try await client.deleteRule(indexName: \"<YOUR_INDEX_NAME>\", objectID: \"id1\")",
      "delete rule with simple characters to encode in objectID": "let response = try await client.deleteRule(indexName: \"<YOUR_INDEX_NAME>\", objectID: \"test/with/slash\")"
    },
    "deleteSource": {
      "default": "let response = try await client.deleteSource(source: \"theSource\")"
    },
    "deleteSynonym": {
      "default": "let response = try await client.deleteSynonym(indexName: \"<YOUR_INDEX_NAME>\", objectID: \"id1\")"
    },
    "generateSecuredApiKey": {
      "api key basic": "let response = try client.generateSecuredApiKey(\n    parentApiKey: \"2640659426d5107b6e47d75db9cbaef8\",\n    restrictions: SecuredApiKeyRestrictions(validUntil: Int64(2_524_604_400), restrictIndices: [\"Movies\"])\n)",
      "with searchParams": "let response = try client.generateSecuredApiKey(\n    parentApiKey: \"2640659426d5107b6e47d75db9cbaef8\",\n    restrictions: SecuredApiKeyRestrictions(\n        searchParams: SearchSearchParamsObject(\n            query: \"batman\",\n            aroundRadius: SearchAroundRadius.searchAroundRadiusAll(SearchAroundRadiusAll.all),\n            hitsPerPage: 10,\n            typoTolerance: SearchTypoTolerance.searchTypoToleranceEnum(SearchTypoToleranceEnum.strict),\n            mode: SearchMode.neuralSearch,\n            optionalWords: SearchOptionalWords.arrayOfString([\"one\", \"two\"])\n        ),\n        filters: \"category:Book OR category:Ebook AND _tags:published\",\n        validUntil: Int64(2_524_604_400),\n        restrictIndices: [\"Movies\", \"cts_e2e_settings\"],\n        restrictSources: \"192.168.1.0/24\",\n        userToken: \"user123\"\n    )\n)",
      "with filters": "let response = try client.generateSecuredApiKey(\n    parentApiKey: \"2640659426d5107b6e47d75db9cbaef8\",\n    restrictions: SecuredApiKeyRestrictions(\n        filters: \"user:user42 AND user:public AND (visible_by:John OR visible_by:group/Finance)\"\n    )\n)",
      "with visible_by filter": "let response = try client.generateSecuredApiKey(\n    parentApiKey: \"2640659426d5107b6e47d75db9cbaef8\",\n    restrictions: SecuredApiKeyRestrictions(filters: \"visible_by:group/Finance\")\n)",
      "with userID": "let response = try client.generateSecuredApiKey(\n    parentApiKey: \"2640659426d5107b6e47d75db9cbaef8\",\n    restrictions: SecuredApiKeyRestrictions(userToken: \"user42\")\n)",
      "mcm with filters": "let response = try client.generateSecuredApiKey(\n    parentApiKey: \"YourSearchOnlyApiKey\",\n    restrictions: SecuredApiKeyRestrictions(filters: \"user:user42 AND user:public\")\n)",
      "mcm with user token": "let response = try client.generateSecuredApiKey(\n    parentApiKey: \"YourSearchOnlyApiKey\",\n    restrictions: SecuredApiKeyRestrictions(userToken: \"user42\")\n)"
    },
    "getApiKey": {
      "default": "let response = try await client.getApiKey(key: \"myTestApiKey\")"
    },
    "getAppTask": {
      "default": "let response = try await client.getAppTask(taskID: Int64(123))"
    },
    "getDictionaryLanguages": {
      "default": "let response = try await client.getDictionaryLanguages()"
    },
    "getDictionarySettings": {
      "default": "let response = try await client.getDictionarySettings()"
    },
    "getLogs": {
      "getLogs with minimal parameters": "let response = try await client.getLogs()",
      "getLogs with parameters": "let response = try await client.getLogs(\n    offset: 5,\n    length: 10,\n    indexName: \"<YOUR_INDEX_NAME>\",\n    type: LogType.all\n)"
    },
    "getObject": {
      "getObject": "let response = try await client.getObject(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"uniqueID\",\n    attributesToRetrieve: [\"attr1\", \"attr2\"]\n)",
      "search with a real object": "let response = try await client.getObject(indexName: \"<YOUR_INDEX_NAME>\", objectID: \"Batman and Robin\")"
    },
    "getObjects": {
      "by ID": "let response: GetObjectsResponse<Hit> = try await client\n    .getObjects(getObjectsParams: GetObjectsParams(requests: [GetObjectsRequest(\n        objectID: \"uniqueID\",\n        indexName: \"<YOUR_INDEX_NAME>\"\n    )]))",
      "multiple IDs": "let response: GetObjectsResponse<Hit> = try await client\n    .getObjects(getObjectsParams: GetObjectsParams(requests: [\n        GetObjectsRequest(objectID: \"uniqueID1\", indexName: \"<YOUR_INDEX_NAME>\"),\n        GetObjectsRequest(objectID: \"uniqueID2\", indexName: \"<YOUR_INDEX_NAME>\"),\n    ]))",
      "with attributesToRetrieve": "let response: GetObjectsResponse<Hit> = try await client\n    .getObjects(getObjectsParams: GetObjectsParams(requests: [GetObjectsRequest(\n        attributesToRetrieve: [\"attr1\", \"attr2\"],\n        objectID: \"uniqueID\",\n        indexName: \"<YOUR_INDEX_NAME>\"\n    )]))"
    },
    "getRule": {
      "default": "let response = try await client.getRule(indexName: \"<YOUR_INDEX_NAME>\", objectID: \"qr-1725004648916\")"
    },
    "getSettings": {
      "default": "let response = try await client.getSettings(indexName: \"<YOUR_INDEX_NAME>\")"
    },
    "getSources": {
      "default": "let response = try await client.getSources()"
    },
    "getSynonym": {
      "default": "let response = try await client.getSynonym(indexName: \"<YOUR_INDEX_NAME>\", objectID: \"id1\")"
    },
    "getTask": {
      "default": "let response = try await client.getTask(indexName: \"<YOUR_INDEX_NAME>\", taskID: Int64(123))"
    },
    "getTopUserIds": {
      "default": "let response = try await client.getTopUserIds()"
    },
    "getUserId": {
      "default": "let response = try await client.getUserId(userID: \"uniqueID\")"
    },
    "hasPendingMappings": {
      "hasPendingMappings with minimal parameters": "let response = try await client.hasPendingMappings()",
      "hasPendingMappings with parameters": "let response = try await client.hasPendingMappings(getClusters: true)"
    },
    "indexExists": {
      "indexExists": "let response = try await client.indexExists(indexName: \"<YOUR_INDEX_NAME>\")",
      "indexNotExists": "let response = try await client.indexExists(indexName: \"<YOUR_INDEX_NAME>\")",
      "indexExistsWithError": "let response = try await client.indexExists(indexName: \"<YOUR_INDEX_NAME>\")"
    },
    "listApiKeys": {
      "default": "let response = try await client.listApiKeys()"
    },
    "listClusters": {
      "default": "let response = try await client.listClusters()"
    },
    "listIndices": {
      "listIndices with minimal parameters": "let response = try await client.listIndices()",
      "listIndices with parameters": "let response = try await client.listIndices(page: 8, hitsPerPage: 3)"
    },
    "listUserIds": {
      "listUserIds with minimal parameters": "let response = try await client.listUserIds()",
      "listUserIds with parameters": "let response = try await client.listUserIds(page: 8, hitsPerPage: 100)"
    },
    "multipleBatch": {
      "default": "let response = try await client.multipleBatch(batchParams: BatchParams(requests: [MultipleBatchRequest(\n    action: SearchAction.addObject,\n    body: [\"key\": \"value\"],\n    indexName: \"<YOUR_INDEX_NAME>\"\n)]))"
    },
    "operationIndex": {
      "scopes": "let response = try await client.operationIndex(\n    indexName: \"<SOURCE_INDEX_NAME>\",\n    operationIndexParams: OperationIndexParams(\n        operation: OperationType.move,\n        destination: \"<DESTINATION_INDEX_NAME>\",\n        scope: [ScopeType.rules, ScopeType.settings]\n    )\n)",
      "copy": "let response = try await client.operationIndex(\n    indexName: \"<SOURCE_INDEX_NAME>\",\n    operationIndexParams: OperationIndexParams(\n        operation: OperationType.copy,\n        destination: \"<DESTINATION_INDEX_NAME>\"\n    )\n)",
      "move": "let response = try await client.operationIndex(\n    indexName: \"<SOURCE_INDEX_NAME>\",\n    operationIndexParams: OperationIndexParams(\n        operation: OperationType.move,\n        destination: \"<DESTINATION_INDEX_NAME>\"\n    )\n)"
    },
    "partialUpdateObject": {
      "Partial update with a new value for a string attribute": "let response = try await client.partialUpdateObject(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"uniqueID\",\n    attributesToUpdate: [\"attributeId\": \"new value\"]\n)",
      "Partial update with a new value for an integer attribute": "let response = try await client.partialUpdateObject(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"uniqueID\",\n    attributesToUpdate: [\"attributeId\": 1]\n)",
      "Partial update with a new value for a boolean attribute": "let response = try await client.partialUpdateObject(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"uniqueID\",\n    attributesToUpdate: [\"attributeId\": true]\n)",
      "Partial update with a new value for an array attribute": "let response = try await client.partialUpdateObject(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"uniqueID\",\n    attributesToUpdate: [\"attributeId\": [\"one\", \"two\", \"three\"]]\n)",
      "Partial update with a new value for an object attribute": "let response = try await client.partialUpdateObject(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"uniqueID\",\n    attributesToUpdate: [\"attributeId\": [\"nested\": \"value\"]]\n)",
      "with visible_by filter": "let response = try await client.partialUpdateObject(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"uniqueID\",\n    attributesToUpdate: [\"visible_by\": [\"Angela\", \"group/Finance\", \"group/Shareholders\"]]\n)",
      "add men pant": "let response = try await client.partialUpdateObject(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"productId\",\n    attributesToUpdate: [\"categoryPageId\": [\"_operation\": \"Add\", \"value\": \"men-clothing-pants\"]]\n)",
      "remove men pant": "let response = try await client.partialUpdateObject(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"productId\",\n    attributesToUpdate: [\"categoryPageId\": [\"_operation\": \"Remove\", \"value\": \"men-clothing-pants\"]]\n)"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "let response = try await client.partialUpdateObjects(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objects: [[\"objectID\": \"1\", \"name\": \"Adam\"], [\"objectID\": \"2\", \"name\": \"Benoit\"]],\n    createIfNotExists: true\n)",
      "call partialUpdateObjects with createIfNotExists=false": "let response = try await client.partialUpdateObjects(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objects: [[\"objectID\": \"3\", \"name\": \"Cyril\"], [\"objectID\": \"4\", \"name\": \"David\"]],\n    createIfNotExists: false\n)"
    },
    "removeUserId": {
      "default": "let response = try await client.removeUserId(userID: \"uniqueID\")"
    },
    "replaceAllObjects": {
      "call replaceAllObjects without error": "let response = try await client.replaceAllObjects(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objects: [\n        [\"objectID\": \"1\", \"name\": \"Adam\"],\n        [\"objectID\": \"2\", \"name\": \"Benoit\"],\n        [\"objectID\": \"3\", \"name\": \"Cyril\"],\n        [\"objectID\": \"4\", \"name\": \"David\"],\n        [\"objectID\": \"5\", \"name\": \"Eva\"],\n        [\"objectID\": \"6\", \"name\": \"Fiona\"],\n        [\"objectID\": \"7\", \"name\": \"Gael\"],\n        [\"objectID\": \"8\", \"name\": \"Hugo\"],\n        [\"objectID\": \"9\", \"name\": \"Igor\"],\n        [\"objectID\": \"10\", \"name\": \"Julia\"],\n    ],\n    batchSize: 3\n)",
      "call replaceAllObjects with partial scopes": "let response = try await client.replaceAllObjects(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objects: [[\"objectID\": \"1\", \"name\": \"Adam\"], [\"objectID\": \"2\", \"name\": \"Benoit\"]],\n    batchSize: 77,\n    scopes: [ScopeType.settings, ScopeType.synonyms]\n)",
      "replaceAllObjects should cleanup on failure": "let response = try await client.replaceAllObjects(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objects: [\n        [\"objectID\": \"fine\", \"body\": \"small obj\"],\n        [\"objectID\": \"toolarge\", \"body\": \"something bigger than 10KB\"],\n    ]\n)"
    },
    "replaceSources": {
      "default": "let response = try await client.replaceSources(source: [SearchSource(\n    source: \"theSource\",\n    description: \"theDescription\"\n)])"
    },
    "restoreApiKey": {
      "default": "let response = try await client.restoreApiKey(key: \"ALGOLIA_API_KEY\")"
    },
    "saveObject": {
      "default": "let response = try await client.saveObject(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    body: [\n        \"name\": \"Black T-shirt\",\n        \"color\": \"#000000||black\",\n        \"availableIn\": \"https://source.unsplash.com/100x100/?paris||Paris\",\n        \"objectID\": \"myID\",\n    ]\n)"
    },
    "saveObjects": {
      "call saveObjects without error": "let response = try await client.saveObjects(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objects: [[\"objectID\": \"1\", \"name\": \"Adam\"], [\"objectID\": \"2\", \"name\": \"Benoit\"]]\n)",
      "saveObjects should report errors": "let response = try await client.saveObjects(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objects: [[\"objectID\": \"1\", \"name\": \"Adam\"], [\"objectID\": \"2\", \"name\": \"Benoit\"]]\n)",
      "saveObjectsPlaylist": "let response = try await client.saveObjects(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objects: [[\n        \"objectID\": \"1\",\n        \"visibility\": \"public\",\n        \"name\": \"Hot 100 Billboard Charts\",\n        \"playlistId\": \"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\",\n        \"createdAt\": \"1500240452\",\n    ]]\n)",
      "saveObjectsPublicUser": "let response = try await client.saveObjects(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objects: [[\n        \"objectID\": \"1\",\n        \"visibility\": \"public\",\n        \"name\": \"Hot 100 Billboard Charts\",\n        \"playlistId\": \"d3e8e8f3-0a4f-4b7d-9b6b-7e8f4e8e3a0f\",\n        \"createdAt\": \"1500240452\",\n    ]],\n    waitForTasks: false,\n    batchSize: 1000,\n    requestOptions: RequestOptions(\n        headers: [\"X-Algolia-User-ID\": \"*\"]\n    )\n)"
    },
    "saveRule": {
      "saveRule with minimal parameters": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"id1\",\n    rule: Rule(\n        objectID: \"id1\",\n        conditions: [SearchCondition(pattern: \"apple\", anchoring: SearchAnchoring.contains)],\n        consequence: SearchConsequence(params: SearchConsequenceParams(filters: \"brand:xiaomi\"))\n    )\n)",
      "saveRule with all parameters": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"id1\",\n    rule: Rule(\n        objectID: \"id1\",\n        conditions: [SearchCondition(\n            pattern: \"apple\",\n            anchoring: SearchAnchoring.contains,\n            alternatives: false,\n            context: \"search\"\n        )],\n        consequence: SearchConsequence(\n            params: SearchConsequenceParams(\n                filters: \"brand:apple\",\n                query: SearchConsequenceQuery\n                    .searchConsequenceQueryObject(SearchConsequenceQueryObject(\n                        remove: [\"algolia\"],\n                        edits: [\n                            SearchEdit(type: SearchEditType.remove, delete: \"abc\", insert: \"cde\"),\n                            SearchEdit(type: SearchEditType.replace, delete: \"abc\", insert: \"cde\"),\n                        ]\n                    ))\n            ),\n            promote: [\n                SearchPromote.searchPromoteObjectID(SearchPromoteObjectID(objectID: \"abc\", position: 3)),\n                SearchPromote.searchPromoteObjectIDs(SearchPromoteObjectIDs(\n                    objectIDs: [\"abc\", \"def\"],\n                    position: 1\n                )),\n            ],\n            filterPromotes: false,\n            hide: [SearchConsequenceHide(objectID: \"321\")],\n            userData: [\"algolia\": \"aloglia\"]\n        ),\n        description: \"test\",\n        enabled: true,\n        validity: [SearchTimeRange(from: Int64(1_656_670_273), until: Int64(1_656_670_277))]\n    ),\n    forwardToReplicas: true\n)",
      "b2b catalog": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"article-rule\",\n    rule: Rule(\n        objectID: \"article-rule\",\n        conditions: [SearchCondition(pattern: \"article\", anchoring: SearchAnchoring.startsWith)],\n        consequence: SearchConsequence(params: SearchConsequenceParams(\n            restrictSearchableAttributes: [\"title\", \"book_id\"],\n            query: SearchConsequenceQuery\n                .searchConsequenceQueryObject(SearchConsequenceQueryObject(edits: [SearchEdit(\n                    type: SearchEditType.remove,\n                    delete: \"article\"\n                )]))\n        ))\n    )\n)",
      "merchandising and promoting": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"director-rule\",\n    rule: Rule(\n        objectID: \"director-rule\",\n        conditions: [SearchCondition(\n            pattern: \"{facet:director} director\",\n            anchoring: SearchAnchoring.contains\n        )],\n        consequence: SearchConsequence(params: SearchConsequenceParams(\n            restrictSearchableAttributes: [\"title\", \"book_id\"],\n            query: SearchConsequenceQuery\n                .searchConsequenceQueryObject(SearchConsequenceQueryObject(edits: [SearchEdit(\n                    type: SearchEditType.remove,\n                    delete: \"director\"\n                )])),\n            automaticFacetFilters: SearchAutomaticFacetFilters\n                .arrayOfSearchAutomaticFacetFilter([SearchAutomaticFacetFilter(facet: \"director\")])\n        ))\n    )\n)",
      "harry potter": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"harry-potter-rule\",\n    rule: Rule(\n        objectID: \"harry-potter-rule\",\n        conditions: [SearchCondition(pattern: \"harry potter\", anchoring: SearchAnchoring.contains)],\n        consequence: SearchConsequence(userData: [\"promo_content\": \"20% OFF on all Harry Potter books!\"])\n    )\n)",
      "merchandising empty query": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"clearance-category-filter\",\n    rule: Rule(\n        objectID: \"clearance-category-filter\",\n        conditions: [SearchCondition(pattern: \"\", anchoring: SearchAnchoring.`is`, context: \"landing\")],\n        consequence: SearchConsequence(params: SearchConsequenceParams(\n            optionalFilters: SearchOptionalFilters\n                .string(\"clearance:true\")\n        ))\n    )\n)",
      "redirect": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"redirect-help-rule\",\n    rule: Rule(\n        objectID: \"redirect-help-rule\",\n        conditions: [SearchCondition(pattern: \"help\", anchoring: SearchAnchoring.contains)],\n        consequence: SearchConsequence(userData: [\"redirect\": \"https://www.algolia.com/support\"])\n    )\n)",
      "promote some results over others": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"tomato-fruit\",\n    rule: Rule(\n        objectID: \"tomato-fruit\",\n        conditions: [SearchCondition(pattern: \"tomato\", anchoring: SearchAnchoring.contains)],\n        consequence: SearchConsequence(params: SearchConsequenceParams(\n            optionalFilters: SearchOptionalFilters\n                .string(\"food_group:fruit\")\n        ))\n    )\n)",
      "promote several hits": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"Promote-Apple-Newest\",\n    rule: Rule(\n        objectID: \"Promote-Apple-Newest\",\n        conditions: [SearchCondition(pattern: \"apple\", anchoring: SearchAnchoring.`is`)],\n        consequence: SearchConsequence(promote: [SearchPromote.searchPromoteObjectIDs(SearchPromoteObjectIDs(\n            objectIDs: [\"iPhone-12345\", \"watch-123\"],\n            position: 0\n        ))])\n    )\n)",
      "promote newest release": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"Promote-iPhone-X\",\n    rule: Rule(\n        objectID: \"Promote-iPhone-X\",\n        conditions: [SearchCondition(pattern: \"iPhone\", anchoring: SearchAnchoring.contains)],\n        consequence: SearchConsequence(promote: [SearchPromote.searchPromoteObjectID(SearchPromoteObjectID(\n            objectID: \"iPhone-12345\",\n            position: 0\n        ))])\n    )\n)",
      "promote single item": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"promote-harry-potter-box-set\",\n    rule: Rule(\n        objectID: \"promote-harry-potter-box-set\",\n        conditions: [SearchCondition(pattern: \"Harry Potter\", anchoring: SearchAnchoring.contains)],\n        consequence: SearchConsequence(promote: [SearchPromote.searchPromoteObjectID(SearchPromoteObjectID(\n            objectID: \"HP-12345\",\n            position: 0\n        ))])\n    )\n)",
      "limit search results": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"article-rule\",\n    rule: Rule(\n        objectID: \"article-rule\",\n        conditions: [SearchCondition(pattern: \"article\", anchoring: SearchAnchoring.startsWith)],\n        consequence: SearchConsequence(params: SearchConsequenceParams(\n            restrictSearchableAttributes: [\"title\", \"book_id\"],\n            query: SearchConsequenceQuery\n                .searchConsequenceQueryObject(SearchConsequenceQueryObject(edits: [SearchEdit(\n                    type: SearchEditType.remove,\n                    delete: \"article\"\n                )]))\n        ))\n    )\n)",
      "query match": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"tagged-brand-rule\",\n    rule: Rule(\n        objectID: \"tagged-brand-rule\",\n        conditions: [SearchCondition(\n            pattern: \"brand: {facet:brand}\",\n            anchoring: SearchAnchoring.contains,\n            alternatives: false\n        )],\n        consequence: SearchConsequence(params: SearchConsequenceParams(\n            query: SearchConsequenceQuery.searchConsequenceQueryObject(SearchConsequenceQueryObject(remove: [\n                \"brand:\",\n                \"{facet:brand}\",\n            ])),\n            automaticFacetFilters: SearchAutomaticFacetFilters\n                .arrayOfSearchAutomaticFacetFilter([SearchAutomaticFacetFilter(facet: \"brand\")])\n        )),\n        description: \"filter on brand: {brand}\"\n    )\n)",
      "dynamic filtering": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"color-facets\",\n    rule: Rule(\n        objectID: \"color-facets\",\n        conditions: [SearchCondition(pattern: \"{facet:color}\")],\n        consequence: SearchConsequence(\n            params: SearchConsequenceParams(\n                automaticFacetFilters: SearchAutomaticFacetFilters\n                    .arrayOfSearchAutomaticFacetFilter([SearchAutomaticFacetFilter(facet: \"color\")])\n            )\n        )\n    )\n)",
      "hide hits": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"hide-12345\",\n    rule: Rule(\n        objectID: \"hide-12345\",\n        conditions: [SearchCondition(pattern: \"cheap\", anchoring: SearchAnchoring.contains)],\n        consequence: SearchConsequence(hide: [SearchConsequenceHide(objectID: \"to-hide-12345\")])\n    )\n)",
      "one rule per facet": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"red-color\",\n    rule: Rule(\n        objectID: \"red-color\",\n        conditions: [SearchCondition(pattern: \"red\", anchoring: SearchAnchoring.contains)],\n        consequence: SearchConsequence(params: SearchConsequenceParams(\n            filters: \"color:red\",\n            query: SearchConsequenceQuery\n                .searchConsequenceQueryObject(SearchConsequenceQueryObject(remove: [\"red\"]))\n        ))\n    )\n)",
      "numerical filters": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"cheap\",\n    rule: Rule(\n        objectID: \"cheap\",\n        conditions: [SearchCondition(pattern: \"cheap\", anchoring: SearchAnchoring.contains)],\n        consequence: SearchConsequence(params: SearchConsequenceParams(\n            filters: \"price < 10\",\n            query: SearchConsequenceQuery\n                .searchConsequenceQueryObject(SearchConsequenceQueryObject(remove: [\"cheap\"]))\n        ))\n    )\n)",
      "negative filters": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"gluten-free-rule\",\n    rule: Rule(\n        objectID: \"gluten-free-rule\",\n        conditions: [SearchCondition(pattern: \"gluten-free\", anchoring: SearchAnchoring.contains)],\n        consequence: SearchConsequence(params: SearchConsequenceParams(\n            filters: \"NOT allergens:gluten\",\n            query: SearchConsequenceQuery\n                .searchConsequenceQueryObject(SearchConsequenceQueryObject(edits: [SearchEdit(\n                    type: SearchEditType.remove,\n                    delete: \"gluten-free\"\n                )]))\n        ))\n    )\n)",
      "positive filters": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"diet-rule\",\n    rule: Rule(\n        objectID: \"diet-rule\",\n        conditions: [SearchCondition(pattern: \"diet\", anchoring: SearchAnchoring.contains)],\n        consequence: SearchConsequence(params: SearchConsequenceParams(\n            filters: \"'low-carb' OR 'low-fat'\",\n            query: SearchConsequenceQuery\n                .searchConsequenceQueryObject(SearchConsequenceQueryObject(edits: [SearchEdit(\n                    type: SearchEditType.remove,\n                    delete: \"diet\"\n                )]))\n        ))\n    )\n)",
      "conditionless": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"diet-rule\",\n    rule: Rule(\n        objectID: \"diet-rule\",\n        consequence: SearchConsequence(params: SearchConsequenceParams(\n            filters: \"'low-carb' OR 'low-fat'\",\n            query: SearchConsequenceQuery\n                .searchConsequenceQueryObject(SearchConsequenceQueryObject(edits: [SearchEdit(\n                    type: SearchEditType.remove,\n                    delete: \"diet\"\n                )]))\n        ))\n    )\n)",
      "contextual": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"a-rule-id\",\n    rule: Rule(\n        objectID: \"a-rule-id\",\n        conditions: [SearchCondition(context: \"mobile\")],\n        consequence: SearchConsequence(params: SearchConsequenceParams(filters: \"release_date >= 1577836800\"))\n    )\n)",
      "saveRule always active rule": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"a-rule-id\",\n    rule: Rule(\n        objectID: \"a-rule-id\",\n        consequence: SearchConsequence(params: SearchConsequenceParams(\n            aroundRadius: SearchAroundRadius\n                .int(1000)\n        )),\n        validity: [SearchTimeRange(from: Int64(1_577_836_800), until: Int64(1_577_836_800))]\n    )\n)"
    },
    "saveRules": {
      "saveRules with minimal parameters": "let response = try await client.saveRules(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    rules: [\n        Rule(\n            objectID: \"a-rule-id\",\n            conditions: [SearchCondition(pattern: \"smartphone\", anchoring: SearchAnchoring.contains)],\n            consequence: SearchConsequence(params: SearchConsequenceParams(filters: \"brand:apple\"))\n        ),\n        Rule(\n            objectID: \"a-second-rule-id\",\n            conditions: [SearchCondition(pattern: \"apple\", anchoring: SearchAnchoring.contains)],\n            consequence: SearchConsequence(params: SearchConsequenceParams(filters: \"brand:samsung\"))\n        ),\n    ],\n    forwardToReplicas: false,\n    clearExistingRules: true\n)",
      "saveRules with all parameters": "let response = try await client.saveRules(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    rules: [Rule(\n        objectID: \"id1\",\n        conditions: [SearchCondition(\n            pattern: \"apple\",\n            anchoring: SearchAnchoring.contains,\n            alternatives: false,\n            context: \"search\"\n        )],\n        consequence: SearchConsequence(\n            params: SearchConsequenceParams(\n                filters: \"brand:apple\",\n                query: SearchConsequenceQuery\n                    .searchConsequenceQueryObject(SearchConsequenceQueryObject(\n                        remove: [\"algolia\"],\n                        edits: [\n                            SearchEdit(type: SearchEditType.remove, delete: \"abc\", insert: \"cde\"),\n                            SearchEdit(type: SearchEditType.replace, delete: \"abc\", insert: \"cde\"),\n                        ]\n                    ))\n            ),\n            promote: [\n                SearchPromote.searchPromoteObjectID(SearchPromoteObjectID(objectID: \"abc\", position: 3)),\n                SearchPromote.searchPromoteObjectIDs(SearchPromoteObjectIDs(\n                    objectIDs: [\"abc\", \"def\"],\n                    position: 1\n                )),\n            ],\n            filterPromotes: false,\n            hide: [SearchConsequenceHide(objectID: \"321\")],\n            userData: [\"algolia\": \"aloglia\"]\n        ),\n        description: \"test\",\n        enabled: true,\n        validity: [SearchTimeRange(from: Int64(1_656_670_273), until: Int64(1_656_670_277))]\n    )],\n    forwardToReplicas: true,\n    clearExistingRules: true\n)",
      "dynamic filtering": "let response = try await client.saveRules(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    rules: [\n        Rule(\n            objectID: \"toaster\",\n            conditions: [SearchCondition(pattern: \"toaster\", anchoring: SearchAnchoring.contains)],\n            consequence: SearchConsequence(params: SearchConsequenceParams(\n                filters: \"product_type:toaster\",\n                query: SearchConsequenceQuery\n                    .searchConsequenceQueryObject(SearchConsequenceQueryObject(remove: [\"toaster\"]))\n            ))\n        ),\n        Rule(\n            objectID: \"cheap\",\n            conditions: [SearchCondition(pattern: \"cheap\", anchoring: SearchAnchoring.contains)],\n            consequence: SearchConsequence(params: SearchConsequenceParams(\n                filters: \"price < 15\",\n                query: SearchConsequenceQuery\n                    .searchConsequenceQueryObject(SearchConsequenceQueryObject(remove: [\"cheap\"]))\n            ))\n        ),\n    ]\n)",
      "enhance search results": "let response = try await client.saveRules(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    rules: [\n        Rule(\n            objectID: \"country\",\n            conditions: [SearchCondition(pattern: \"{facet:country}\", anchoring: SearchAnchoring.contains)],\n            consequence: SearchConsequence(params: SearchConsequenceParams(aroundLatLngViaIP: false))\n        ),\n        Rule(\n            objectID: \"city\",\n            conditions: [SearchCondition(pattern: \"{facet:city}\", anchoring: SearchAnchoring.contains)],\n            consequence: SearchConsequence(params: SearchConsequenceParams(aroundLatLngViaIP: false))\n        ),\n    ]\n)"
    },
    "saveSynonym": {
      "default": "let response = try await client.saveSynonym(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"id1\",\n    synonymHit: SynonymHit(objectID: \"id1\", type: SynonymType.synonym, synonyms: [\"car\", \"vehicule\", \"auto\"]),\n    forwardToReplicas: true\n)"
    },
    "saveSynonyms": {
      "default": "let response = try await client.saveSynonyms(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    synonymHit: [\n        SynonymHit(objectID: \"id1\", type: SynonymType.synonym, synonyms: [\"car\", \"vehicule\", \"auto\"]),\n        SynonymHit(\n            objectID: \"id2\",\n            type: SynonymType.onewaysynonym,\n            synonyms: [\"ephone\", \"aphone\", \"yphone\"],\n            input: \"iphone\"\n        ),\n    ],\n    forwardToReplicas: true,\n    replaceExistingSynonyms: true\n)"
    },
    "search": {
      "withHitsPerPage": "let response: SearchResponses<Hit> = try await client\n    .search(searchMethodParams: SearchMethodParams(requests: [SearchQuery.searchForHits(SearchForHits(\n        query: \"<YOUR_QUERY>\",\n        hitsPerPage: 50,\n        indexName: \"<YOUR_INDEX_NAME>\"\n    ))]))",
      "filterOnly": "let response: SearchResponses<Hit> = try await client\n    .search(searchMethodParams: SearchMethodParams(requests: [SearchQuery.searchForHits(SearchForHits(\n        query: \"<YOUR_QUERY>\",\n        filters: \"actor:Scarlett Johansson\",\n        indexName: \"<YOUR_INDEX_NAME>\"\n    ))]))",
      "filterOr": "let response: SearchResponses<Hit> = try await client\n    .search(searchMethodParams: SearchMethodParams(requests: [SearchQuery.searchForHits(SearchForHits(\n        query: \"<YOUR_QUERY>\",\n        filters: \"actor:Tom Cruise OR actor:Scarlett Johansson\",\n        indexName: \"<YOUR_INDEX_NAME>\"\n    ))]))",
      "filterNot": "let response: SearchResponses<Hit> = try await client\n    .search(searchMethodParams: SearchMethodParams(requests: [SearchQuery.searchForHits(SearchForHits(\n        query: \"<YOUR_QUERY>\",\n        filters: \"NOT actor:Nicolas Cage\",\n        indexName: \"<YOUR_INDEX_NAME>\"\n    ))]))",
      "search for a single hits request with minimal parameters": "let response: SearchResponses<Hit> = try await client\n    .search(searchMethodParams: SearchMethodParams(requests: [\n        SearchQuery\n            .searchForHits(SearchForHits(indexName: \"<YOUR_INDEX_NAME>\")),\n    ]))",
      "search with highlight and snippet results": "let response: SearchResponses<Hit> = try await client\n    .search(searchMethodParams: SearchMethodParams(requests: [SearchQuery.searchForHits(SearchForHits(\n        query: \"vim\",\n        attributesToRetrieve: [\"*\"],\n        attributesToHighlight: [\"*\"],\n        attributesToSnippet: [\"*:20\"],\n        indexName: \"<YOUR_INDEX_NAME>\"\n    ))]))",
      "retrieveFacets": "let response: SearchResponses<Hit> = try await client\n    .search(searchMethodParams: SearchMethodParams(requests: [SearchQuery.searchForHits(SearchForHits(\n        query: \"<YOUR_QUERY>\",\n        facets: [\"author\", \"genre\"],\n        indexName: \"<YOUR_INDEX_NAME>\"\n    ))]))",
      "retrieveFacetsWildcard": "let response: SearchResponses<Hit> = try await client\n    .search(searchMethodParams: SearchMethodParams(requests: [SearchQuery.searchForHits(SearchForHits(\n        query: \"<YOUR_QUERY>\",\n        facets: [\"*\"],\n        indexName: \"<YOUR_INDEX_NAME>\"\n    ))]))",
      "search for a single facet request with minimal parameters": "let response: SearchResponses<Hit> = try await client.search(searchMethodParams: SearchMethodParams(\n    requests: [SearchQuery.searchForFacets(SearchForFacets(\n        facet: \"editor\",\n        indexName: \"<YOUR_INDEX_NAME>\",\n        type: SearchTypeFacet.facet\n    ))],\n    strategy: SearchStrategy.stopIfEnoughMatches\n))",
      "search for a single hits request with all parameters": "let response: SearchResponses<Hit> = try await client\n    .search(searchMethodParams: SearchMethodParams(requests: [SearchQuery.searchForHits(SearchForHits(\n        query: \"myQuery\",\n        hitsPerPage: 50,\n        indexName: \"<YOUR_INDEX_NAME>\",\n        type: SearchTypeDefault.`default`\n    ))]))",
      "search for a single facet request with all parameters": "let response: SearchResponses<Hit> = try await client.search(searchMethodParams: SearchMethodParams(\n    requests: [SearchQuery.searchForFacets(SearchForFacets(\n        query: \"theQuery\",\n        facet: \"theFacet\",\n        indexName: \"<YOUR_INDEX_NAME>\",\n        facetQuery: \"theFacetQuery\",\n        maxFacetHits: 50,\n        type: SearchTypeFacet.facet\n    ))],\n    strategy: SearchStrategy.stopIfEnoughMatches\n))",
      "search for multiple mixed requests in multiple indices with minimal parameters": "let response: SearchResponses<Hit> = try await client.search(searchMethodParams: SearchMethodParams(\n    requests: [\n        SearchQuery.searchForHits(SearchForHits(indexName: \"<YOUR_INDEX_NAME>\")),\n        SearchQuery\n            .searchForFacets(SearchForFacets(\n                facet: \"theFacet\",\n                indexName: \"<YOUR_INDEX_NAME>\",\n                type: SearchTypeFacet.facet\n            )),\n        SearchQuery\n            .searchForHits(SearchForHits(indexName: \"<YOUR_INDEX_NAME>\", type: SearchTypeDefault.`default`)),\n    ],\n    strategy: SearchStrategy.stopIfEnoughMatches\n))",
      "search for multiple mixed requests in multiple indices with all parameters": "let response: SearchResponses<Hit> = try await client.search(searchMethodParams: SearchMethodParams(\n    requests: [SearchQuery.searchForFacets(SearchForFacets(\n        query: \"theQuery\",\n        facet: \"theFacet\",\n        indexName: \"<YOUR_INDEX_NAME>\",\n        facetQuery: \"theFacetQuery\",\n        maxFacetHits: 50,\n        type: SearchTypeFacet.facet\n    )), SearchQuery.searchForHits(SearchForHits(\n        query: \"myQuery\",\n        hitsPerPage: 50,\n        indexName: \"<YOUR_INDEX_NAME>\",\n        type: SearchTypeDefault.`default`\n    ))],\n    strategy: SearchStrategy.stopIfEnoughMatches\n))",
      "search filters accept all of the possible shapes": "let response: SearchResponses<Hit> = try await client.search(searchMethodParams: SearchMethodParams(requests: [\n    SearchQuery.searchForHits(SearchForHits(\n        facetFilters: SearchFacetFilters.string(\"mySearch:filters\"),\n        optionalFilters: SearchOptionalFilters.string(\"mySearch:filters\"),\n        numericFilters: SearchNumericFilters.string(\"mySearch:filters\"),\n        tagFilters: SearchTagFilters.string(\"mySearch:filters\"),\n        reRankingApplyFilter: SearchReRankingApplyFilter.string(\"mySearch:filters\"),\n        indexName: \"<YOUR_INDEX_NAME>\"\n    )),\n    SearchQuery.searchForHits(SearchForHits(\n        facetFilters: SearchFacetFilters.arrayOfSearchFacetFilters([\n            SearchFacetFilters.string(\"mySearch:filters\"),\n            SearchFacetFilters.arrayOfSearchFacetFilters([\n                SearchFacetFilters.string(\"mySearch:filters\"),\n                SearchFacetFilters.arrayOfSearchFacetFilters([SearchFacetFilters.string(\"mySearch:filters\")]),\n            ]),\n        ]),\n        optionalFilters: SearchOptionalFilters.arrayOfSearchOptionalFilters([\n            SearchOptionalFilters.string(\"mySearch:filters\"),\n            SearchOptionalFilters\n                .arrayOfSearchOptionalFilters([SearchOptionalFilters.string(\"mySearch:filters\")]),\n        ]),\n        numericFilters: SearchNumericFilters.arrayOfSearchNumericFilters([\n            SearchNumericFilters.string(\"mySearch:filters\"),\n            SearchNumericFilters.arrayOfSearchNumericFilters([SearchNumericFilters.string(\"mySearch:filters\")]),\n        ]),\n        tagFilters: SearchTagFilters.arrayOfSearchTagFilters([\n            SearchTagFilters.string(\"mySearch:filters\"),\n            SearchTagFilters.arrayOfSearchTagFilters([SearchTagFilters.string(\"mySearch:filters\")]),\n        ]),\n        reRankingApplyFilter: SearchReRankingApplyFilter.arrayOfSearchReRankingApplyFilter([\n            SearchReRankingApplyFilter.string(\"mySearch:filters\"),\n            SearchReRankingApplyFilter\n                .arrayOfSearchReRankingApplyFilter([SearchReRankingApplyFilter.string(\"mySearch:filters\")]),\n        ]),\n        indexName: \"<YOUR_INDEX_NAME>\"\n    )),\n]))",
      "search filters end to end": "let response: SearchResponses<Hit> = try await client.search(searchMethodParams: SearchMethodParams(requests: [\n    SearchQuery.searchForHits(SearchForHits(\n        filters: \"editor:'visual studio' OR editor:neovim\",\n        indexName: \"<YOUR_INDEX_NAME>\"\n    )),\n    SearchQuery.searchForHits(SearchForHits(\n        facetFilters: SearchFacetFilters.arrayOfSearchFacetFilters([\n            SearchFacetFilters.string(\"editor:'visual studio'\"),\n            SearchFacetFilters.string(\"editor:neovim\"),\n        ]),\n        indexName: \"<YOUR_INDEX_NAME>\"\n    )),\n    SearchQuery.searchForHits(SearchForHits(\n        facetFilters: SearchFacetFilters.arrayOfSearchFacetFilters([\n            SearchFacetFilters.string(\"editor:'visual studio'\"),\n            SearchFacetFilters.arrayOfSearchFacetFilters([SearchFacetFilters.string(\"editor:neovim\")]),\n        ]),\n        indexName: \"<YOUR_INDEX_NAME>\"\n    )),\n    SearchQuery.searchForHits(SearchForHits(\n        facetFilters: SearchFacetFilters.arrayOfSearchFacetFilters([\n            SearchFacetFilters.string(\"editor:'visual studio'\"),\n            SearchFacetFilters.arrayOfSearchFacetFilters([\n                SearchFacetFilters.string(\"editor:neovim\"),\n                SearchFacetFilters.arrayOfSearchFacetFilters([SearchFacetFilters.string(\"editor:goland\")]),\n            ]),\n        ]),\n        indexName: \"<YOUR_INDEX_NAME>\"\n    )),\n]))",
      "search with all search parameters": "let response: SearchResponses<Hit> = try await client\n    .search(searchMethodParams: SearchMethodParams(requests: [SearchQuery.searchForHits(SearchForHits(\n        query: \"\",\n        similarQuery: \"\",\n        filters: \"\",\n        facetFilters: SearchFacetFilters.arrayOfSearchFacetFilters([SearchFacetFilters.string(\"\")]),\n        optionalFilters: SearchOptionalFilters.arrayOfSearchOptionalFilters([SearchOptionalFilters.string(\"\")]),\n        numericFilters: SearchNumericFilters.arrayOfSearchNumericFilters([SearchNumericFilters.string(\"\")]),\n        tagFilters: SearchTagFilters.arrayOfSearchTagFilters([SearchTagFilters.string(\"\")]),\n        sumOrFiltersScores: true,\n        restrictSearchableAttributes: [\"\"],\n        facets: [\"\"],\n        facetingAfterDistinct: true,\n        page: 0,\n        offset: 0,\n        length: 1,\n        aroundLatLng: \"\",\n        aroundLatLngViaIP: true,\n        aroundRadius: SearchAroundRadius.searchAroundRadiusAll(SearchAroundRadiusAll.all),\n        aroundPrecision: SearchAroundPrecision.int(0),\n        minimumAroundRadius: 1,\n        insideBoundingBox: SearchInsideBoundingBox.arrayOfArrayOfDouble([\n            [47.3165, 4.9665, 47.3424, 5.0201],\n            [40.9234, 2.1185, 38.643, 1.9916],\n        ]),\n        insidePolygon: [\n            [47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9],\n            [40.9234, 2.1185, 38.643, 1.9916, 39.2587, 2.0104],\n        ],\n        naturalLanguages: [SearchSupportedLanguage.fr],\n        ruleContexts: [\"\"],\n        personalizationImpact: 0,\n        userToken: \"\",\n        getRankingInfo: true,\n        synonyms: true,\n        clickAnalytics: true,\n        analytics: true,\n        analyticsTags: [\"\"],\n        percentileComputation: true,\n        enableABTest: true,\n        attributesToRetrieve: [\"\"],\n        ranking: [\"\"],\n        relevancyStrictness: 0,\n        attributesToHighlight: [\"\"],\n        attributesToSnippet: [\"\"],\n        highlightPreTag: \"\",\n        highlightPostTag: \"\",\n        snippetEllipsisText: \"\",\n        restrictHighlightAndSnippetArrays: true,\n        hitsPerPage: 1,\n        minWordSizefor1Typo: 0,\n        minWordSizefor2Typos: 0,\n        typoTolerance: SearchTypoTolerance.searchTypoToleranceEnum(SearchTypoToleranceEnum.min),\n        allowTyposOnNumericTokens: true,\n        disableTypoToleranceOnAttributes: [\"\"],\n        ignorePlurals: SearchIgnorePlurals.bool(false),\n        removeStopWords: SearchRemoveStopWords.bool(true),\n        queryLanguages: [SearchSupportedLanguage.fr],\n        decompoundQuery: true,\n        enableRules: true,\n        enablePersonalization: true,\n        queryType: SearchQueryType.prefixAll,\n        removeWordsIfNoResults: SearchRemoveWordsIfNoResults.allOptional,\n        advancedSyntax: true,\n        optionalWords: SearchOptionalWords.arrayOfString([\"\"]),\n        disableExactOnAttributes: [\"\"],\n        exactOnSingleWordQuery: SearchExactOnSingleWordQuery.attribute,\n        alternativesAsExact: [SearchAlternativesAsExact.multiWordsSynonym],\n        advancedSyntaxFeatures: [SearchAdvancedSyntaxFeatures.exactPhrase],\n        distinct: SearchDistinct.int(0),\n        replaceSynonymsInHighlight: true,\n        minProximity: 1,\n        responseFields: [\"\"],\n        maxValuesPerFacet: 0,\n        sortFacetValuesBy: \"\",\n        attributeCriteriaComputedByMinProximity: true,\n        renderingContent: SearchRenderingContent(facetOrdering: SearchFacetOrdering(\n            facets: SearchFacets(order: [\"a\", \"b\"]),\n            values: [\"a\": SearchValue(order: [\"b\"], sortRemainingBy: SearchSortRemainingBy.count)]\n        )),\n        enableReRanking: true,\n        reRankingApplyFilter: SearchReRankingApplyFilter\n            .arrayOfSearchReRankingApplyFilter([SearchReRankingApplyFilter.string(\"\")]),\n        indexName: \"<YOUR_INDEX_NAME>\",\n        type: SearchTypeDefault.`default`\n    ))]))"
    },
    "searchDictionaryEntries": {
      "get searchDictionaryEntries results with minimal parameters": "let response = try await client.searchDictionaryEntries(\n    dictionaryName: DictionaryType.stopwords,\n    searchDictionaryEntriesParams: SearchDictionaryEntriesParams(query: \"about\")\n)",
      "get searchDictionaryEntries results with all parameters": "let response = try await client.searchDictionaryEntries(\n    dictionaryName: DictionaryType.compounds,\n    searchDictionaryEntriesParams: SearchDictionaryEntriesParams(\n        query: \"foo\",\n        page: 4,\n        hitsPerPage: 2,\n        language: SearchSupportedLanguage.fr\n    )\n)"
    },
    "searchForFacetValues": {
      "get searchForFacetValues results with minimal parameters": "let response = try await client.searchForFacetValues(indexName: \"<YOUR_INDEX_NAME>\", facetName: \"facetName\")",
      "get searchForFacetValues results with all parameters": "let response = try await client.searchForFacetValues(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    facetName: \"facetName\",\n    searchForFacetValuesRequest: SearchForFacetValuesRequest(\n        params: \"query=foo&facetFilters=['bar']\",\n        facetQuery: \"foo\",\n        maxFacetHits: 42\n    )\n)",
      "facetName and facetQuery": "let response = try await client.searchForFacetValues(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    facetName: \"author\",\n    searchForFacetValuesRequest: SearchForFacetValuesRequest(facetQuery: \"stephen\")\n)"
    },
    "searchRules": {
      "default": "let response = try await client.searchRules(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchRulesParams: SearchRulesParams(query: \"zorro\")\n)"
    },
    "searchSingleIndex": {
      "search with minimal parameters": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(indexName: \"<YOUR_INDEX_NAME>\")",
      "search with special characters in indexName": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(indexName: \"<YOUR_INDEX_NAME>\")",
      "search with searchParams": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"myQuery\",\n        facetFilters: SearchFacetFilters.arrayOfSearchFacetFilters([SearchFacetFilters.string(\"tags:algolia\")])\n    ))\n)",
      "single search retrieve snippets": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"batman mask of the phantasm\",\n        attributesToRetrieve: [\"*\"],\n        attributesToSnippet: [\"*:20\"]\n    ))\n)",
      "query": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(query: \"phone\"))\n)",
      "filters": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams\n        .searchSearchParamsObject(SearchSearchParamsObject(filters: \"country:US AND price.gross < 2.0\"))\n)",
      "filters for stores": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"ben\",\n        filters: \"categories:politics AND store:Gibert Joseph Saint-Michel\"\n    ))\n)",
      "filters boolean": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams\n        .searchSearchParamsObject(SearchSearchParamsObject(filters: \"is_available:true\"))\n)",
      "distinct": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams\n        .searchSearchParamsObject(SearchSearchParamsObject(distinct: SearchDistinct.bool(true)))\n)",
      "filtersNumeric": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(filters: \"price < 10\"))\n)",
      "filtersTimestamp": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams\n        .searchSearchParamsObject(\n            SearchSearchParamsObject(filters: \"NOT date_timestamp:1514764800 TO 1546300799\")\n        )\n)",
      "filtersSumOrFiltersScoresFalse": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        filters: \"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\",\n        sumOrFiltersScores: false\n    ))\n)",
      "filtersSumOrFiltersScoresTrue": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        filters: \"(company:Google<score=3> OR company:Amazon<score=2> OR company:Facebook<score=1>)\",\n        sumOrFiltersScores: true\n    ))\n)",
      "filtersStephenKing": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams\n        .searchSearchParamsObject(SearchSearchParamsObject(filters: \"author:\\\"Stephen King\\\"\"))\n)",
      "filtersNotTags": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"harry\",\n        filters: \"_tags:non-fiction\"\n    ))\n)",
      "facetFiltersList": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams\n        .searchSearchParamsObject(SearchSearchParamsObject(\n            facetFilters: SearchFacetFilters\n                .arrayOfSearchFacetFilters([\n                    SearchFacetFilters.string(\"publisher:Penguin\"),\n                    SearchFacetFilters.arrayOfSearchFacetFilters([\n                        SearchFacetFilters.string(\"author:Stephen King\"),\n                        SearchFacetFilters.string(\"genre:Horror\"),\n                    ]),\n                ])\n        ))\n)",
      "facetFiltersBook": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        facetFilters: SearchFacetFilters.arrayOfSearchFacetFilters([SearchFacetFilters.string(\"category:Book\")])\n    ))\n)",
      "facetFiltersAND": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        facetFilters: SearchFacetFilters.arrayOfSearchFacetFilters([\n            SearchFacetFilters.string(\"category:Book\"),\n            SearchFacetFilters.string(\"author:John Doe\"),\n        ])\n    ))\n)",
      "facetFiltersOR": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        facetFilters: SearchFacetFilters\n            .arrayOfSearchFacetFilters([SearchFacetFilters.arrayOfSearchFacetFilters([\n                SearchFacetFilters.string(\"category:Book\"),\n                SearchFacetFilters.string(\"author:John Doe\"),\n            ])])\n    ))\n)",
      "facetFiltersCombined": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        facetFilters: SearchFacetFilters.arrayOfSearchFacetFilters([\n            SearchFacetFilters.string(\"author:John Doe\"),\n            SearchFacetFilters.arrayOfSearchFacetFilters([\n                SearchFacetFilters.string(\"category:Book\"),\n                SearchFacetFilters.string(\"category:Movie\"),\n            ]),\n        ])\n    ))\n)",
      "facetFiltersNeg": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams\n        .searchSearchParamsObject(SearchSearchParamsObject(\n            facetFilters: SearchFacetFilters\n                .string(\"category:-Ebook\")\n        ))\n)",
      "filtersAndFacetFilters": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        filters: \"(author:\\\"Stephen King\\\" OR genre:\\\"Horror\\\")\",\n        facetFilters: SearchFacetFilters\n            .arrayOfSearchFacetFilters([SearchFacetFilters.string(\"publisher:Penguin\")])\n    ))\n)",
      "facet author genre": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(facets: [\n        \"author\",\n        \"genre\",\n    ]))\n)",
      "facet wildcard": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(facets: [\"*\"]))\n)",
      "maxValuesPerFacet": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(maxValuesPerFacet: 1000))\n)",
      "aroundLatLng": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams\n        .searchSearchParamsObject(SearchSearchParamsObject(aroundLatLng: \"40.71, -74.01\"))\n)",
      "aroundLatLngViaIP": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(aroundLatLngViaIP: true))\n)",
      "aroundRadius": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        aroundLatLng: \"40.71, -74.01\",\n        aroundRadius: SearchAroundRadius.int(1_000_000)\n    ))\n)",
      "insideBoundingBox": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams\n        .searchSearchParamsObject(SearchSearchParamsObject(\n            insideBoundingBox: SearchInsideBoundingBox\n                .arrayOfArrayOfDouble([[\n                    49.067996905313834,\n                    65.73828125,\n                    25.905859247243498,\n                    128.8046875,\n                ]])\n        ))\n)",
      "insidePolygon": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(insidePolygon: [[\n        42.01,\n        -124.31,\n        48.835509470063045,\n        -124.40453125000005,\n        45.01082951668149,\n        -65.95726562500005,\n        31.247243545293433,\n        -81.06578125000004,\n        25.924152577235226,\n        -97.68234374999997,\n        32.300311895879545,\n        -117.54828125,\n    ]]))\n)",
      "optionalFilters": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams\n        .searchSearchParamsObject(SearchSearchParamsObject(\n            optionalFilters: SearchOptionalFilters\n                .arrayOfSearchOptionalFilters([SearchOptionalFilters.string(\"can_deliver_quickly:true\")])\n        ))\n)",
      "optionalFiltersMany": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams\n        .searchSearchParamsObject(SearchSearchParamsObject(\n            optionalFilters: SearchOptionalFilters\n                .arrayOfSearchOptionalFilters([\n                    SearchOptionalFilters.string(\"brand:Apple<score=3>\"),\n                    SearchOptionalFilters.string(\"brand:Samsung<score=2>\"),\n                    SearchOptionalFilters.string(\"brand:-Huawei\"),\n                ])\n        ))\n)",
      "optionalFiltersSimple": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams\n        .searchSearchParamsObject(SearchSearchParamsObject(\n            optionalFilters: SearchOptionalFilters\n                .arrayOfSearchOptionalFilters([\n                    SearchOptionalFilters.string(\"brand:Apple<score=2>\"),\n                    SearchOptionalFilters.string(\"type:tablet\"),\n                ])\n        ))\n)",
      "restrictSearchableAttributes": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams\n        .searchSearchParamsObject(SearchSearchParamsObject(restrictSearchableAttributes: [\"title_fr\"]))\n)",
      "getRankingInfo": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(getRankingInfo: true))\n)",
      "clickAnalytics": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(clickAnalytics: true))\n)",
      "clickAnalyticsUserToken": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        userToken: \"user-1\",\n        clickAnalytics: true\n    ))\n)",
      "enablePersonalization": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        userToken: \"user-1\",\n        enablePersonalization: true\n    ))\n)",
      "userToken": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(userToken: \"user-1\"))\n)",
      "userToken1234": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        userToken: \"user-1234\"\n    ))\n)",
      "analyticsTag": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams\n        .searchSearchParamsObject(SearchSearchParamsObject(analyticsTags: [\"YOUR_ANALYTICS_TAG\"]))\n)",
      "facetFiltersUsers": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams\n        .searchSearchParamsObject(SearchSearchParamsObject(\n            facetFilters: SearchFacetFilters\n                .arrayOfSearchFacetFilters([\n                    SearchFacetFilters.string(\"user:user42\"),\n                    SearchFacetFilters.string(\"user:public\"),\n                ])\n        ))\n)",
      "buildTheQuery": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        filters: \"categoryPageId: Men's Clothing\",\n        analyticsTags: [\"mens-clothing\"],\n        hitsPerPage: 50\n    ))\n)",
      "attributesToHighlightOverride": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        attributesToHighlight: [\"title\", \"content\"]\n    ))\n)",
      "disableTypoToleranceOnAttributes": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        disableTypoToleranceOnAttributes: [\"serial_number\"]\n    ))\n)",
      "search_a_query": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"\",\n        similarQuery: \"Comedy Drama Crime McDormand Macy Buscemi Stormare Presnell Coen\",\n        filters: \"year:1991 TO 2001\"\n    ))\n)",
      "search_everything": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(query: \"\"))\n)",
      "api_filtering_range_example": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"books\",\n        filters: \"price:10 TO 20\"\n    ))\n)",
      "override_retrievable_attributes": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        attributesToRetrieve: [\"title\", \"content\"]\n    ))\n)",
      "restrict_searchable_attributes": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        restrictSearchableAttributes: [\"title\", \"author\"]\n    ))\n)",
      "override_default_relevancy": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        relevancyStrictness: 70\n    ))\n)",
      "apply_filters": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        sumOrFiltersScores: true\n    ))\n)",
      "apply_all_filters": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        filters: \"available = 1 AND (category:Book OR NOT category:Ebook) AND _tags:published AND publication_date:1441745506 TO 1441755506 AND inStock > 0 AND author:\\\"John Doe\\\"\"\n    ))\n)",
      "escape_spaces": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        filters: \"category:\\\"Books and Comics\\\"\"\n    ))\n)",
      "escape_keywords": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        filters: \"keyword:\\\"OR\\\"\"\n    ))\n)",
      "escape_single_quotes": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        filters: \"content:\\\"It's a wonderful day\\\"\"\n    ))\n)",
      "escape_double_quotes": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        filters: \"content:\\\"She said \\\"Hello World\\\"\"\n    ))\n)",
      "apply_negative_filters": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        optionalFilters: SearchOptionalFilters.arrayOfSearchOptionalFilters([\n            SearchOptionalFilters.string(\"category:Book\"),\n            SearchOptionalFilters.string(\"author:-John Doe\"),\n        ])\n    ))\n)",
      "apply_negative_filters_restaurants": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        optionalFilters: SearchOptionalFilters\n            .arrayOfSearchOptionalFilters([SearchOptionalFilters.string(\"restaurant:-Bert's Inn\")])\n    ))\n)",
      "apply_numeric_filters": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        numericFilters: SearchNumericFilters.arrayOfSearchNumericFilters([\n            SearchNumericFilters.string(\"price < 1000\"),\n            SearchNumericFilters.arrayOfSearchNumericFilters([\n                SearchNumericFilters.string(\"inStock = 1\"),\n                SearchNumericFilters.string(\"deliveryDate < 1441755506\"),\n            ]),\n        ])\n    ))\n)",
      "apply_tag_filters": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        tagFilters: SearchTagFilters.arrayOfSearchTagFilters([\n            SearchTagFilters.string(\"SciFi\"),\n            SearchTagFilters.arrayOfSearchTagFilters([\n                SearchTagFilters.string(\"Book\"),\n                SearchTagFilters.string(\"Movie\"),\n            ]),\n        ])\n    ))\n)",
      "facets_all": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        facets: [\"*\"]\n    ))\n)",
      "retrieve_only_some_facets": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        facets: [\"category\", \"author\"]\n    ))\n)",
      "override_default_max_values_per_facet": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        maxValuesPerFacet: 20\n    ))\n)",
      "enable_faceting_after_distinct": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        facetingAfterDistinct: true\n    ))\n)",
      "sort_facet_values_alphabetically": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        sortFacetValuesBy: \"count\"\n    ))\n)",
      "override_attributes_to_snippet": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        attributesToSnippet: [\"title\", \"content:80\"]\n    ))\n)",
      "override_default_highlight_pre_tag": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        highlightPreTag: \"<strong>\"\n    ))\n)",
      "override_default_highlight_post_tag": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        highlightPostTag: \"</strong>\"\n    ))\n)",
      "override_default_snippet_ellipsis_text": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        snippetEllipsisText: \"\"\n    ))\n)",
      "enable_restrict_highlight_and_snippet_arrays": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        restrictHighlightAndSnippetArrays: false\n    ))\n)",
      "access_page": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(query: \"query\", page: 0))\n)",
      "override_default_hits_per_page": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        hitsPerPage: 10\n    ))\n)",
      "get_nth_hit": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        offset: 4\n    ))\n)",
      "get_n_results": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        length: 4\n    ))\n)",
      "override_default_min_word_size_for_one_typo": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        minWordSizefor1Typo: 2\n    ))\n)",
      "override_default_min_word_size_for_two_typos": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        minWordSizefor2Typos: 2\n    ))\n)",
      "override_default_typo_tolerance_mode": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        typoTolerance: SearchTypoTolerance.bool(false)\n    ))\n)",
      "disable_typos_on_numeric_tokens_at_search_time": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        allowTyposOnNumericTokens: false\n    ))\n)",
      "search_around_a_position": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        aroundLatLng: \"40.71, -74.01\"\n    ))\n)",
      "search_around_server_ip": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        aroundLatLngViaIP: true\n    )),\n    requestOptions: RequestOptions(\n        headers: [\n            \"x-forwarded-for\": \"94.228.178.246 // should be replaced with the actual IP you would like to search around\",\n        ]\n    )\n)",
      "set_around_radius": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        aroundRadius: SearchAroundRadius.int(1000)\n    ))\n)",
      "disable_automatic_radius": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        aroundRadius: SearchAroundRadius.searchAroundRadiusAll(SearchAroundRadiusAll.all)\n    ))\n)",
      "set_geo_search_precision": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        aroundPrecision: SearchAroundPrecision.int(100)\n    ))\n)",
      "set_geo_search_precision_non_linear": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        aroundPrecision: SearchAroundPrecision.arrayOfSearchRange([\n            SearchRange(from: 0, value: 25),\n            SearchRange(from: 2000, value: 1000),\n        ])\n    ))\n)",
      "set_minimum_geo_search_radius": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        minimumAroundRadius: 1000\n    ))\n)",
      "search_inside_rectangular_area": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        insideBoundingBox: SearchInsideBoundingBox.arrayOfArrayOfDouble([[\n            46.650828100116044,\n            7.123046875,\n            45.17210966999772,\n            1.009765625,\n        ]])\n    ))\n)",
      "search_inside_multiple_rectangular_areas": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        insideBoundingBox: SearchInsideBoundingBox.arrayOfArrayOfDouble([\n            [46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625],\n            [49.62625916704081, 4.6181640625, 47.715070300900194, 0.482421875],\n        ])\n    ))\n)",
      "search_inside_polygon_area": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        insidePolygon: [[\n            46.650828100116044,\n            7.123046875,\n            45.17210966999772,\n            1.009765625,\n            49.62625916704081,\n            4.6181640625,\n        ]]\n    ))\n)",
      "search_inside_multiple_polygon_areas": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        insidePolygon: [\n            [46.650828100116044, 7.123046875, 45.17210966999772, 1.009765625, 49.62625916704081, 4.6181640625],\n            [\n                49.62625916704081,\n                4.6181640625,\n                47.715070300900194,\n                0.482421875,\n                45.17210966999772,\n                1.009765625,\n                50.62626704081,\n                4.6181640625,\n            ],\n        ]\n    ))\n)",
      "set_querylanguages_override": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        removeStopWords: SearchRemoveStopWords.arrayOfSearchSupportedLanguage([\n            SearchSupportedLanguage.ca,\n            SearchSupportedLanguage.es,\n        ])\n    ))\n)",
      "set_querylanguages_with_japanese_query": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        queryLanguages: [SearchSupportedLanguage.ja, SearchSupportedLanguage.en]\n    ))\n)",
      "set_natural_languages": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"\",\n        naturalLanguages: [SearchSupportedLanguage.fr]\n    ))\n)",
      "override_natural_languages_with_query": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"\",\n        naturalLanguages: [SearchSupportedLanguage.fr],\n        removeWordsIfNoResults: SearchRemoveWordsIfNoResults.firstWords\n    ))\n)",
      "enable_decompound_query_search_time": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        decompoundQuery: true\n    ))\n)",
      "enable_rules_search_time": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        enableRules: true\n    ))\n)",
      "set_rule_contexts": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        ruleContexts: [\"front_end\", \"website2\"]\n    ))\n)",
      "enable_personalization": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        enablePersonalization: true\n    ))\n)",
      "enable_personalization_with_user_token": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        userToken: \"123456\",\n        enablePersonalization: true\n    ))\n)",
      "personalization_impact": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        personalizationImpact: 20\n    ))\n)",
      "set_user_token": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        userToken: \"123456\"\n    ))\n)",
      "set_user_token_with_personalization": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        userToken: \"123456\",\n        enablePersonalization: true\n    ))\n)",
      "override_default_query_type": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        queryType: SearchQueryType.prefixAll\n    ))\n)",
      "override_default_remove_words_if_no_results": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        removeWordsIfNoResults: SearchRemoveWordsIfNoResults.lastWords\n    ))\n)",
      "enable_advanced_syntax_search_time": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        advancedSyntax: true\n    ))\n)",
      "overide_default_optional_words": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        optionalWords: SearchOptionalWords.arrayOfString([\"toyota\", \"2020 2021\"])\n    ))\n)",
      "disabling_exact_for_some_attributes_search_time": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        disableExactOnAttributes: [\"description\"]\n    ))\n)",
      "override_default_exact_single_word_query": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        exactOnSingleWordQuery: SearchExactOnSingleWordQuery.`none`\n    ))\n)",
      "override_default_aternative_as_exact": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        alternativesAsExact: [SearchAlternativesAsExact.multiWordsSynonym]\n    ))\n)",
      "enable_advanced_syntax_exact_phrase": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        advancedSyntax: true,\n        advancedSyntaxFeatures: [SearchAdvancedSyntaxFeatures.exactPhrase]\n    ))\n)",
      "enable_advanced_syntax_exclude_words": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        advancedSyntax: true,\n        advancedSyntaxFeatures: [SearchAdvancedSyntaxFeatures.excludeWords]\n    ))\n)",
      "override_distinct": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        distinct: SearchDistinct.int(0)\n    ))\n)",
      "get_ranking_info": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        getRankingInfo: true\n    ))\n)",
      "disable_click_analytics": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        clickAnalytics: false\n    ))\n)",
      "enable_click_analytics": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        clickAnalytics: true\n    ))\n)",
      "disable_analytics": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        analytics: false\n    ))\n)",
      "add_analytics_tags": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        analyticsTags: [\"front_end\", \"website2\"]\n    ))\n)",
      "disable_synonyms": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        synonyms: false\n    ))\n)",
      "override_replace_synonyms_in_highlights": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        replaceSynonymsInHighlight: true\n    ))\n)",
      "override_min_proximity": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        minProximity: 2\n    ))\n)",
      "override_default_field": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        responseFields: [\"hits\", \"facets\"]\n    ))\n)",
      "override_percentile_computation": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        percentileComputation: false\n    ))\n)",
      "set_ab_test": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        enableABTest: false\n    ))\n)",
      "set_enable_re_ranking": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(\n        query: \"query\",\n        enableReRanking: false\n    ))\n)",
      "with algolia user id": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(query: \"query\")),\n    requestOptions: RequestOptions(\n        headers: [\"X-Algolia-User-ID\": \"user1234\"]\n    )\n)",
      "mcm with algolia user id": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchParams: SearchSearchParams.searchSearchParamsObject(SearchSearchParamsObject(query: \"peace\")),\n    requestOptions: RequestOptions(\n        headers: [\"X-Algolia-User-ID\": \"user42\"]\n    )\n)"
    },
    "searchSynonyms": {
      "searchSynonyms with minimal parameters": "let response = try await client.searchSynonyms(indexName: \"<YOUR_INDEX_NAME>\")",
      "searchSynonyms with all parameters": "let response = try await client.searchSynonyms(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchSynonymsParams: SearchSynonymsParams(\n        query: \"myQuery\",\n        type: SynonymType.altcorrection1,\n        page: 10,\n        hitsPerPage: 10\n    )\n)"
    },
    "searchUserIds": {
      "default": "let response = try await client.searchUserIds(searchUserIdsParams: SearchUserIdsParams(\n    query: \"test\",\n    clusterName: \"theClusterName\",\n    page: 5,\n    hitsPerPage: 10\n))"
    },
    "setClientApiKey": {
      "default": "try client.setClientApiKey(apiKey: \"updated-api-key\")"
    },
    "setDictionarySettings": {
      "get setDictionarySettings results with minimal parameters": "let response = try await client\n    .setDictionarySettings(\n        dictionarySettingsParams: DictionarySettingsParams(disableStandardEntries: StandardEntries(plurals: [\n            \"fr\": false,\n            \"en\": false,\n            \"ru\": true,\n        ]))\n    )",
      "get setDictionarySettings results with all parameters": "let response = try await client\n    .setDictionarySettings(\n        dictionarySettingsParams: DictionarySettingsParams(disableStandardEntries: StandardEntries(\n            plurals: [\"fr\": false, \"en\": false, \"ru\": true],\n            stopwords: [\"fr\": false],\n            compounds: [\"ru\": true]\n        ))\n    )"
    },
    "setSettings": {
      "minimal parameters": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(paginationLimitedTo: 10),\n    forwardToReplicas: true\n)",
      "boolean typoTolerance": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(typoTolerance: SearchTypoTolerance.bool(true)),\n    forwardToReplicas: true\n)",
      "enum typoTolerance": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(\n        typoTolerance: SearchTypoTolerance\n            .searchTypoToleranceEnum(SearchTypoToleranceEnum.min)\n    ),\n    forwardToReplicas: true\n)",
      "ignorePlurals": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(ignorePlurals: SearchIgnorePlurals.bool(true)),\n    forwardToReplicas: true\n)",
      "list of string ignorePlurals": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(\n        ignorePlurals: SearchIgnorePlurals\n            .arrayOfSearchSupportedLanguage([SearchSupportedLanguage.fr])\n    ),\n    forwardToReplicas: true\n)",
      "removeStopWords boolean": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(removeStopWords: SearchRemoveStopWords.bool(true)),\n    forwardToReplicas: true\n)",
      "removeStopWords list of string": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(\n        removeStopWords: SearchRemoveStopWords\n            .arrayOfSearchSupportedLanguage([SearchSupportedLanguage.fr])\n    ),\n    forwardToReplicas: true\n)",
      "boolean distinct": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(distinct: SearchDistinct.bool(true)),\n    forwardToReplicas: true\n)",
      "integer distinct": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(distinct: SearchDistinct.int(1)),\n    forwardToReplicas: true\n)",
      "distinct company": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributeForDistinct: \"company\", distinct: SearchDistinct.bool(true))\n)",
      "distinct design": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributeForDistinct: \"design\", distinct: SearchDistinct.bool(true))\n)",
      "distinct true": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(distinct: SearchDistinct.bool(true))\n)",
      "distinct section": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributeForDistinct: \"section\", distinct: SearchDistinct.bool(true))\n)",
      "attributesForFaceting allergens": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesForFaceting: [\"allergens\"])\n)",
      "attributesForFaceting availableIn": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesForFaceting: [\"color\", \"availableIn\"])\n)",
      "api_attributes_for_faceting": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesForFaceting: [\"genre\", \"author\"])\n)",
      "api_attributes_for_faceting_searchable": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesForFaceting: [\"genre\", \"searchable(author)\"])\n)",
      "api_attributes_for_filter_only": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesForFaceting: [\"filterOnly(genre)\", \"author\"])\n)",
      "attributesForFaceting categoryPageId": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesForFaceting: [\"searchable(categoryPageId)\"])\n)",
      "unretrievableAttributes": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(unretrievableAttributes: [\"visible_by\"])\n)",
      "attributesForFaceting user restricted data": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesForFaceting: [\"filterOnly(visible_by)\"])\n)",
      "attributesForFaceting optional filters": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesForFaceting: [\"can_deliver_quickly\", \"restaurant\"])\n)",
      "attributesForFaceting redirect index": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesForFaceting: [\"query_terms\"])\n)",
      "attributesForFaceting multiple consequences": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesForFaceting: [\"director\"])\n)",
      "attributesForFaceting in-depth optional filters": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesForFaceting: [\"filterOnly(brand)\"])\n)",
      "mode neuralSearch": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(mode: SearchMode.neuralSearch)\n)",
      "mode keywordSearch": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(mode: SearchMode.keywordSearch)\n)",
      "searchableAttributes same priority": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(searchableAttributes: [\"title,comments\", \"ingredients\"])\n)",
      "searchableAttributes higher priority": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(searchableAttributes: [\"title\", \"ingredients\"])\n)",
      "customRanking retweets": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(customRanking: [\"desc(retweets)\", \"desc(likes)\"])\n)",
      "customRanking boosted": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(customRanking: [\"desc(boosted)\"])\n)",
      "customRanking pageviews": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(customRanking: [\"desc(pageviews)\", \"desc(comments)\"])\n)",
      "customRanking applying search parameters for a specific query": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(\n        attributesForFaceting: [\"city, country\"],\n        customRanking: [\"desc(nb_airline_liaisons)\"]\n    )\n)",
      "customRanking rounded pageviews": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(customRanking: [\"desc(rounded_pageviews)\", \"desc(comments)\"])\n)",
      "customRanking price": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(customRanking: [\"desc(price)\"])\n)",
      "ranking exhaustive (price)": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(ranking: [\n        \"desc(price)\",\n        \"typo\",\n        \"geo\",\n        \"words\",\n        \"filters\",\n        \"proximity\",\n        \"attribute\",\n        \"exact\",\n        \"custom\",\n    ])\n)",
      "ranking exhaustive (is_popular)": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(ranking: [\n        \"desc(is_popular)\",\n        \"typo\",\n        \"geo\",\n        \"words\",\n        \"filters\",\n        \"proximity\",\n        \"attribute\",\n        \"exact\",\n        \"custom\",\n    ])\n)",
      "ranking standard replica": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(ranking: [\"desc(post_date_timestamp)\"])\n)",
      "ranking virtual replica": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(customRanking: [\"desc(post_date_timestamp)\"])\n)",
      "customRanking and ranking sort alphabetically": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(\n        customRanking: [\"asc(textual_attribute)\"],\n        ranking: [\"custom\", \"typo\", \"geo\", \"words\", \"filters\", \"proximity\", \"attribute\", \"exact\"]\n    )\n)",
      "relevancyStrictness": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(customRanking: [\"asc(textual_attribute)\"], relevancyStrictness: 0)\n)",
      "create replica index": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(replicas: [\"products_price_desc\"])\n)",
      "create replica index articles": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(replicas: [\"articles_date_desc\"])\n)",
      "create virtual replica index": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(replicas: [\"virtual(products_price_desc)\"])\n)",
      "unlink replica index": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(replicas: [\"\"])\n)",
      "forwardToReplicas": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(searchableAttributes: [\"name\", \"description\"]),\n    forwardToReplicas: true\n)",
      "maxValuesPerFacet": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(maxValuesPerFacet: 1000)\n)",
      "maxFacetHits": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(maxFacetHits: 100)\n)",
      "attributesForFaceting complex": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesForFaceting: [\n        \"actor\",\n        \"filterOnly(category)\",\n        \"searchable(publisher)\",\n    ])\n)",
      "ranking closest dates": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(ranking: [\n        \"asc(date_timestamp)\",\n        \"typo\",\n        \"geo\",\n        \"words\",\n        \"filters\",\n        \"proximity\",\n        \"attribute\",\n        \"exact\",\n        \"custom\",\n    ])\n)",
      "searchableAttributes item variation": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(searchableAttributes: [\"design\", \"type\", \"color\"])\n)",
      "searchableAttributes around location": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(\n        searchableAttributes: [\"name\", \"country\", \"city\", \"iata_code\"],\n        customRanking: [\"desc(links_count)\"]\n    )\n)",
      "attributesToHighlight": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesToHighlight: [\"author\", \"title\", \"content\"])\n)",
      "attributesToHighlightStar": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesToHighlight: [\"*\"])\n)",
      "everything": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(\n        attributesForFaceting: [\"algolia\"],\n        replicas: [\"\"],\n        paginationLimitedTo: 0,\n        unretrievableAttributes: [\"foo\"],\n        disableTypoToleranceOnWords: [\"algolia\"],\n        attributesToTransliterate: [\"algolia\"],\n        camelCaseAttributes: [\"algolia\"],\n        decompoundedAttributes: [\"algolia\": \"aloglia\"],\n        indexLanguages: [SearchSupportedLanguage.fr],\n        disablePrefixOnAttributes: [\"algolia\"],\n        allowCompressionOfIntegerArray: true,\n        numericAttributesForFiltering: [\"algolia\"],\n        separatorsToIndex: \"bar\",\n        searchableAttributes: [\"foo\"],\n        userData: [\"user\": \"data\"],\n        customNormalization: [\"algolia\": [\"aloglia\": \"aglolia\"]],\n        attributeForDistinct: \"test\",\n        maxFacetHits: 20,\n        keepDiacriticsOnCharacters: \"abc\",\n        customRanking: [\"algolia\"],\n        attributesToRetrieve: [\"algolia\"],\n        ranking: [\"geo\"],\n        relevancyStrictness: 10,\n        attributesToHighlight: [\"algolia\"],\n        attributesToSnippet: [\"algolia\"],\n        highlightPreTag: \"<span>\",\n        highlightPostTag: \"</span>\",\n        snippetEllipsisText: \"---\",\n        restrictHighlightAndSnippetArrays: true,\n        hitsPerPage: 10,\n        minWordSizefor1Typo: 5,\n        minWordSizefor2Typos: 11,\n        typoTolerance: SearchTypoTolerance.bool(false),\n        allowTyposOnNumericTokens: true,\n        disableTypoToleranceOnAttributes: [\"algolia\"],\n        ignorePlurals: SearchIgnorePlurals.bool(false),\n        removeStopWords: SearchRemoveStopWords.bool(false),\n        queryLanguages: [SearchSupportedLanguage.fr],\n        decompoundQuery: false,\n        enableRules: true,\n        enablePersonalization: true,\n        queryType: SearchQueryType.prefixLast,\n        removeWordsIfNoResults: SearchRemoveWordsIfNoResults.lastWords,\n        mode: SearchMode.neuralSearch,\n        semanticSearch: SearchSemanticSearch(eventSources: [\"foo\"]),\n        advancedSyntax: true,\n        optionalWords: SearchOptionalWords.arrayOfString([\"myspace\"]),\n        disableExactOnAttributes: [\"algolia\"],\n        exactOnSingleWordQuery: SearchExactOnSingleWordQuery.attribute,\n        alternativesAsExact: [SearchAlternativesAsExact.singleWordSynonym],\n        advancedSyntaxFeatures: [SearchAdvancedSyntaxFeatures.exactPhrase],\n        distinct: SearchDistinct.int(3),\n        replaceSynonymsInHighlight: true,\n        minProximity: 6,\n        responseFields: [\"algolia\"],\n        maxValuesPerFacet: 30,\n        sortFacetValuesBy: \"date\",\n        attributeCriteriaComputedByMinProximity: true,\n        renderingContent: SearchRenderingContent(facetOrdering: SearchFacetOrdering(\n            facets: SearchFacets(order: [\"a\", \"b\"]),\n            values: [\"a\": SearchValue(order: [\"b\"], sortRemainingBy: SearchSortRemainingBy.count)]\n        )),\n        enableReRanking: false,\n        reRankingApplyFilter: SearchReRankingApplyFilter.string(\"mySearch:filters\")\n    )\n)",
      "searchableAttributesWithCustomRankingsAndAttributesForFaceting": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(\n        attributesForFaceting: [\"searchable(brand)\", \"type\", \"categories\", \"price\"],\n        searchableAttributes: [\"brand\", \"name\", \"categories\", \"unordered(description)\"],\n        customRanking: [\"desc(popularity)\"]\n    )\n)",
      "searchableAttributesOrdering": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(searchableAttributes: [\"unordered(title)\", \"cast\"])\n)",
      "searchableAttributesProductReferenceSuffixes": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(searchableAttributes: [\n        \"name\",\n        \"product_reference\",\n        \"product_reference_suffixes\",\n    ])\n)",
      "queryLanguageAndIgnorePlurals": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(\n        ignorePlurals: SearchIgnorePlurals.bool(true),\n        queryLanguages: [SearchSupportedLanguage.en]\n    )\n)",
      "searchableAttributesInMovies": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(searchableAttributes: [\"title_eng\", \"title_fr\", \"title_es\"])\n)",
      "disablePrefixOnAttributes": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(disablePrefixOnAttributes: [\"serial_number\"])\n)",
      "disableTypoToleranceOnAttributes": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(disableTypoToleranceOnAttributes: [\"serial_number\"])\n)",
      "searchableAttributesSimpleExample": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(searchableAttributes: [\"serial_number\"])\n)",
      "searchableAttributesSimpleExampleAlt": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(searchableAttributes: [\"serial_number\", \"serial_number_suffixes\"])\n)",
      "set_searchable_attributes": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesForFaceting: [\n        \"author\",\n        \"filterOnly(isbn)\",\n        \"searchable(edition)\",\n        \"afterDistinct(category)\",\n        \"afterDistinct(searchable(publisher))\",\n    ])\n)",
      "unretrievable_attributes": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(unretrievableAttributes: [\"total_number_of_sales\"])\n)",
      "set_retrievable_attributes": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesToRetrieve: [\"author\", \"title\", \"content\"])\n)",
      "set_all_attributes_as_retrievable": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesToRetrieve: [\"*\"])\n)",
      "specify_attributes_not_to_retrieve": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesToRetrieve: [\"*\", \"-SKU\", \"-internal_desc\"])\n)",
      "neural_search": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(mode: SearchMode.neuralSearch)\n)",
      "keyword_search": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(mode: SearchMode.keywordSearch)\n)",
      "set_default_ranking": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(ranking: [\n        \"typo\",\n        \"geo\",\n        \"words\",\n        \"filters\",\n        \"attribute\",\n        \"proximity\",\n        \"exact\",\n        \"custom\",\n    ])\n)",
      "set_ranking_by_attribute_asc": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(ranking: [\n        \"asc(price)\",\n        \"typo\",\n        \"geo\",\n        \"words\",\n        \"filters\",\n        \"proximity\",\n        \"attribute\",\n        \"exact\",\n        \"custom\",\n    ])\n)",
      "set_ranking_by_attribute_desc": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(ranking: [\n        \"desc(price)\",\n        \"typo\",\n        \"geo\",\n        \"words\",\n        \"filters\",\n        \"proximity\",\n        \"attribute\",\n        \"exact\",\n        \"custom\",\n    ])\n)",
      "restrict_searchable_attributes": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(customRanking: [\"desc(popularity)\", \"asc(price)\"])\n)",
      "set_default_relevancy": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(relevancyStrictness: 90)\n)",
      "set_replicas": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(replicas: [\"name_of_replica_index1\", \"name_of_replica_index2\"])\n)",
      "set_default_max_values_per_facet": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(maxValuesPerFacet: 100)\n)",
      "set_default_sort_facet_values_by": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(sortFacetValuesBy: \"alpha\")\n)",
      "set_attributes_to_snippet": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesToSnippet: [\"content:80\", \"description\"])\n)",
      "set_all_attributes_to_snippet": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesToSnippet: [\"*:80\"])\n)",
      "set_default_highlight_pre_tag": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(highlightPreTag: \"<em>\")\n)",
      "set_default_highlight_post_tag": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(highlightPostTag: \"</em>\")\n)",
      "set_default_snippet_ellipsis_text": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(snippetEllipsisText: \"…\")\n)",
      "enable_restrict_highlight_and_snippet_arrays_by_default": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(restrictHighlightAndSnippetArrays: true)\n)",
      "set_default_hits_per_page": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(hitsPerPage: 20)\n)",
      "set_pagination_limit": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(paginationLimitedTo: 1000)\n)",
      "set_default_min_word_size_for_one_typo": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(minWordSizefor1Typo: 4)\n)",
      "set_default_min_word_size_for_two_typos": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(minWordSizefor2Typos: 4)\n)",
      "set_default_typo_tolerance_mode": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(typoTolerance: SearchTypoTolerance.bool(true))\n)",
      "disable_typos_on_numeric_tokens_by_default": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(allowTyposOnNumericTokens: false)\n)",
      "disable_typo_tolerance_for_words": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(disableTypoToleranceOnWords: [\"wheel\", \"1X2BCD\"])\n)",
      "set_separators_to_index": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(separatorsToIndex: \"+#\")\n)",
      "set_languages_using_querylanguages": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(\n        ignorePlurals: SearchIgnorePlurals.bool(true),\n        removeStopWords: SearchRemoveStopWords.bool(true),\n        queryLanguages: [SearchSupportedLanguage.es]\n    )\n)",
      "set_attributes_to_transliterate": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(\n        attributesToTransliterate: [\"name\", \"description\"],\n        indexLanguages: [SearchSupportedLanguage.ja]\n    )\n)",
      "set_camel_case_attributes": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(camelCaseAttributes: [\"description\"])\n)",
      "set_decompounded_attributes": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(decompoundedAttributes: [\"de\": [\"name\"]])\n)",
      "set_decompounded_multiple_attributes": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(decompoundedAttributes: [\n        \"de\": [\"name_de\", \"description_de\"],\n        \"fi\": [\"name_fi\", \"description_fi\"],\n    ])\n)",
      "set_keep_diacritics_on_characters": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(keepDiacriticsOnCharacters: \"øé\")\n)",
      "set_custom_normalization": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(customNormalization: [\"default\": [\"ä\": \"ae\"]])\n)",
      "set_indexlanguages": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(indexLanguages: [SearchSupportedLanguage.ja])\n)",
      "enable_decompound_query_by_default": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(decompoundQuery: true)\n)",
      "enable_rules_syntax_by_default": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(enableRules: true)\n)",
      "enable_personalization_settings": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(enablePersonalization: true)\n)",
      "set_default_query_type": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(queryType: SearchQueryType.prefixLast)\n)",
      "set_default_remove_words_if_no_result": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(removeWordsIfNoResults: SearchRemoveWordsIfNoResults.`none`)\n)",
      "enable_advanced_syntax_by_default": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(advancedSyntax: true)\n)",
      "set_default_optional_words": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(optionalWords: SearchOptionalWords.arrayOfString([\"blue\", \"iphone case\"]))\n)",
      "disabling_prefix_search_for_some_attributes_by_default": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(disablePrefixOnAttributes: [\"sku\"])\n)",
      "disabling_exact_for_some_attributes_by_default": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(disableExactOnAttributes: [\"description\"])\n)",
      "set_default_exact_single_word_query": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(exactOnSingleWordQuery: SearchExactOnSingleWordQuery.attribute)\n)",
      "set_default_aternative_as_exact": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(alternativesAsExact: [\n        SearchAlternativesAsExact.ignorePlurals,\n        SearchAlternativesAsExact.singleWordSynonym,\n    ])\n)",
      "set_numeric_attributes_for_filtering": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(numericAttributesForFiltering: [\"quantity\", \"popularity\"])\n)",
      "enable_compression_of_integer_array": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(allowCompressionOfIntegerArray: true)\n)",
      "set_attributes_for_distinct": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributeForDistinct: \"url\")\n)",
      "set_distinct": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributeForDistinct: \"url\", distinct: SearchDistinct.int(1))\n)",
      "set_replace_synonyms_in_highlights": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(replaceSynonymsInHighlight: false)\n)",
      "set_min_proximity": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(minProximity: 1)\n)",
      "set_default_field": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(responseFields: [\"hits\", \"hitsPerPage\", \"nbPages\", \"page\"])\n)",
      "set_max_facet_hits": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(maxFacetHits: 10)\n)",
      "set_attribute_criteria_computed_by_min_proximity": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributeCriteriaComputedByMinProximity: true)\n)",
      "set_user_data": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(\n        userData: [\"extraData\": \"This is the custom data that you want to store in your index\"]\n    )\n)",
      "set_rendering_content": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(renderingContent: SearchRenderingContent(facetOrdering: SearchFacetOrdering(\n        facets: SearchFacets(order: [\"size\", \"brand\"]),\n        values: [\n            \"brand\": SearchValue(order: [\"uniqlo\"], sortRemainingBy: SearchSortRemainingBy.count,\n                                 hide: [\"muji\"]),\n            \"size\": SearchValue(order: [\"S\", \"M\", \"L\"], sortRemainingBy: SearchSortRemainingBy.hidden),\n        ]\n    )))\n)"
    },
    "updateApiKey": {
      "default": "let response = try await client.updateApiKey(\n    key: \"ALGOLIA_API_KEY\",\n    apiKey: ApiKey(\n        acl: [Acl.search, Acl.addObject],\n        maxHitsPerQuery: 20,\n        maxQueriesPerIPPerHour: 100,\n        validity: 300\n    )\n)"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "let response = try await client.waitForApiKey(\n    key: \"api-key-add-operation-test-swift\",\n    operation: ApiKeyOperation.add\n)",
      "wait for api key - update": "let response = try await client.waitForApiKey(\n    key: \"api-key-update-operation-test-swift\",\n    operation: ApiKeyOperation.update,\n    apiKey: ApiKey(\n        acl: [Acl.search, Acl.addObject, Acl.deleteObject],\n        description: \"my updated api key\",\n        indexes: [\"Movies\", \"Books\"],\n        maxHitsPerQuery: 20,\n        maxQueriesPerIPPerHour: 95,\n        referers: [\"*google.com\", \"*algolia.com\"],\n        validity: 305\n    )\n)",
      "wait for api key - delete": "let response = try await client.waitForApiKey(\n    key: \"api-key-delete-operation-test-swift\",\n    operation: ApiKeyOperation.delete\n)"
    },
    "waitForAppTask": {
      "default": "let response = try await client.waitForAppTask(taskID: Int64(123))"
    },
    "waitForTask": {
      "default": "let response = try await client.waitForTask(indexName: \"<YOUR_INDEX_NAME>\", taskID: Int64(123))"
    },
    "init": {
      "default": "let client = try SearchClient(appID: \"ALGOLIA_APPLICATION_ID\", apiKey: \"ALGOLIA_API_KEY\")"
    }
  }
}