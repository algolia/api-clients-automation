{
  "csharp": {
    "import": {
      "default": "using Algolia.Search.Clients;\nusing Algolia.Search.Models.Search;"
    },
    "addApiKey": {
      "default": "var response = await client.AddApiKeyAsync(\n  new ApiKey\n  {\n    Acl = new List<Acl> { Enum.Parse<Acl>(\"Search\"), Enum.Parse<Acl>(\"AddObject\") },\n    Description = \"my new api key\",\n    Validity = 300,\n    MaxQueriesPerIPPerHour = 100,\n    MaxHitsPerQuery = 20,\n  }\n);"
    },
    "addOrUpdateObject": {
      "default": "var response = await client.AddOrUpdateObjectAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new Dictionary<string, string> { { \"key\", \"value\" } }\n);"
    },
    "appendSource": {
      "default": "var response = await client.AppendSourceAsync(\n  new Source { VarSource = \"theSource\", Description = \"theDescription\" }\n);"
    },
    "assignUserId": {
      "default": "var response = await client.AssignUserIdAsync(\n  \"userID\",\n  new AssignUserIdParams { Cluster = \"theCluster\" }\n);"
    },
    "batch": {
      "addObject": "var response = await client.BatchAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams\n  {\n    Requests = new List<BatchRequest>\n    {\n      new BatchRequest\n      {\n        Action = Enum.Parse<Action>(\"AddObject\"),\n        Body = new Dictionary<string, string> { { \"key\", \"bar\" }, { \"foo\", \"1\" } },\n      },\n      new BatchRequest\n      {\n        Action = Enum.Parse<Action>(\"AddObject\"),\n        Body = new Dictionary<string, string> { { \"key\", \"baz\" }, { \"foo\", \"2\" } },\n      },\n    },\n  }\n);",
      "clear": "var response = await client.BatchAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams\n  {\n    Requests = new List<BatchRequest>\n    {\n      new BatchRequest\n      {\n        Action = Enum.Parse<Action>(\"Clear\"),\n        Body = new Dictionary<string, string> { { \"key\", \"value\" } },\n      },\n    },\n  }\n);",
      "delete": "var response = await client.BatchAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams\n  {\n    Requests = new List<BatchRequest>\n    {\n      new BatchRequest\n      {\n        Action = Enum.Parse<Action>(\"Delete\"),\n        Body = new Dictionary<string, string> { { \"key\", \"value\" } },\n      },\n    },\n  }\n);",
      "deleteObject": "var response = await client.BatchAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams\n  {\n    Requests = new List<BatchRequest>\n    {\n      new BatchRequest\n      {\n        Action = Enum.Parse<Action>(\"DeleteObject\"),\n        Body = new Dictionary<string, string> { { \"key\", \"value\" } },\n      },\n    },\n  }\n);",
      "partialUpdateObject": "var response = await client.BatchAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams\n  {\n    Requests = new List<BatchRequest>\n    {\n      new BatchRequest\n      {\n        Action = Enum.Parse<Action>(\"PartialUpdateObject\"),\n        Body = new Dictionary<string, string> { { \"key\", \"value\" } },\n      },\n    },\n  }\n);",
      "partialUpdateObjectNoCreate": "var response = await client.BatchAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams\n  {\n    Requests = new List<BatchRequest>\n    {\n      new BatchRequest\n      {\n        Action = Enum.Parse<Action>(\"PartialUpdateObjectNoCreate\"),\n        Body = new Dictionary<string, string> { { \"key\", \"value\" } },\n      },\n    },\n  }\n);",
      "updateObject": "var response = await client.BatchAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams\n  {\n    Requests = new List<BatchRequest>\n    {\n      new BatchRequest\n      {\n        Action = Enum.Parse<Action>(\"UpdateObject\"),\n        Body = new Dictionary<string, string> { { \"key\", \"value\" } },\n      },\n    },\n  }\n);"
    },
    "batchAssignUserIds": {
      "default": "var response = await client.BatchAssignUserIdsAsync(\n  \"userID\",\n  new BatchAssignUserIdsParams\n  {\n    Cluster = \"theCluster\",\n    Users = new List<string> { \"user1\", \"user2\" },\n  }\n);"
    },
    "batchDictionaryEntries": {
      "replace": "var response = await client.BatchDictionaryEntriesAsync(\n  Enum.Parse<DictionaryType>(\"Plurals\"),\n  new BatchDictionaryEntriesParams\n  {\n    ClearExistingDictionaryEntries = true,\n    Requests = new List<BatchDictionaryEntriesRequest>\n    {\n      new BatchDictionaryEntriesRequest\n      {\n        Action = Enum.Parse<DictionaryAction>(\"AddEntry\"),\n        Body = new DictionaryEntry\n        {\n          ObjectID = \"1\",\n          Language = Enum.Parse<SupportedLanguage>(\"En\"),\n          Word = \"fancy\",\n          Words = new List<string> { \"believe\", \"algolia\" },\n          Decomposition = new List<string> { \"trust\", \"algolia\" },\n          State = Enum.Parse<DictionaryEntryState>(\"Enabled\"),\n        },\n      },\n    },\n  }\n);",
      "delete": "var response = await client.BatchDictionaryEntriesAsync(\n  Enum.Parse<DictionaryType>(\"Plurals\"),\n  new BatchDictionaryEntriesParams\n  {\n    ClearExistingDictionaryEntries = true,\n    Requests = new List<BatchDictionaryEntriesRequest>\n    {\n      new BatchDictionaryEntriesRequest\n      {\n        Action = Enum.Parse<DictionaryAction>(\"DeleteEntry\"),\n        Body = new DictionaryEntry { ObjectID = \"1\" },\n      },\n    },\n  }\n);",
      "append": "var response = await client.BatchDictionaryEntriesAsync(\n  Enum.Parse<DictionaryType>(\"Stopwords\"),\n  new BatchDictionaryEntriesParams\n  {\n    Requests = new List<BatchDictionaryEntriesRequest>\n    {\n      new BatchDictionaryEntriesRequest\n      {\n        Action = Enum.Parse<DictionaryAction>(\"AddEntry\"),\n        Body = new DictionaryEntry\n        {\n          ObjectID = \"1\",\n          Language = Enum.Parse<SupportedLanguage>(\"En\"),\n          AdditionalProperties = new Dictionary<string, object> { { \"additional\", \"try me\" } },\n        },\n      },\n    },\n  }\n);"
    },
    "browse": {
      "default": "var response = await client.BrowseAsync<Hit>(\"<YOUR_INDEX_NAME>\");"
    },
    "clearObjects": {
      "default": "var response = await client.ClearObjectsAsync(\"<YOUR_INDEX_NAME>\");"
    },
    "clearRules": {
      "default": "var response = await client.ClearRulesAsync(\"<YOUR_INDEX_NAME>\");"
    },
    "clearSynonyms": {
      "default": "var response = await client.ClearSynonymsAsync(\"<YOUR_INDEX_NAME>\");"
    },
    "customDelete": {
      "default": "var response = await client.CustomDeleteAsync(\"test/minimal\");"
    },
    "customGet": {
      "default": "var response = await client.CustomGetAsync(\"test/minimal\");"
    },
    "customPost": {
      "default": "var response = await client.CustomPostAsync(\"test/minimal\");"
    },
    "customPut": {
      "default": "var response = await client.CustomPutAsync(\"test/minimal\");"
    },
    "deleteApiKey": {
      "default": "var response = await client.DeleteApiKeyAsync(\"myTestApiKey\");"
    },
    "deleteBy": {
      "default": "var response = await client.DeleteByAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new DeleteByParams { Filters = \"brand:brandName\" }\n);"
    },
    "deleteIndex": {
      "default": "var response = await client.DeleteIndexAsync(\"<YOUR_INDEX_NAME>\");"
    },
    "deleteObject": {
      "default": "var response = await client.DeleteObjectAsync(\"<YOUR_INDEX_NAME>\", \"uniqueID\");"
    },
    "deleteObjects": {
      "default": "var response = await client.DeleteObjectsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<string> { \"1\", \"2\" }\n);"
    },
    "deleteRule": {
      "default": "var response = await client.DeleteRuleAsync(\"<YOUR_INDEX_NAME>\", \"id1\");"
    },
    "deleteSource": {
      "default": "var response = await client.DeleteSourceAsync(\"theSource\");"
    },
    "deleteSynonym": {
      "default": "var response = await client.DeleteSynonymAsync(\"<YOUR_INDEX_NAME>\", \"id1\");"
    },
    "generateSecuredApiKey": {
      "generate secured api key basic": "var response = client.GenerateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  new SecuredApiKeyRestrictions\n  {\n    ValidUntil = 2524604400L,\n    RestrictIndices = new List<string> { \"Movies\" },\n  }\n);",
      "generate secured api key with searchParams": "var response = client.GenerateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  new SecuredApiKeyRestrictions\n  {\n    ValidUntil = 2524604400L,\n    RestrictIndices = new List<string> { \"Movies\", \"cts_e2e_settings\" },\n    RestrictSources = \"192.168.1.0/24\",\n    Filters = \"category:Book OR category:Ebook AND _tags:published\",\n    UserToken = \"user123\",\n    SearchParams = new SearchParamsObject\n    {\n      Query = \"batman\",\n      TypoTolerance = new TypoTolerance(Enum.Parse<TypoToleranceEnum>(\"Strict\")),\n      AroundRadius = new AroundRadius(Enum.Parse<AroundRadiusAll>(\"All\")),\n      Mode = Enum.Parse<Mode>(\"NeuralSearch\"),\n      HitsPerPage = 10,\n      OptionalWords = new List<string> { \"one\", \"two\" },\n    },\n  }\n);"
    },
    "getApiKey": {
      "default": "var response = await client.GetApiKeyAsync(\"myTestApiKey\");"
    },
    "getAppTask": {
      "default": "var response = await client.GetAppTaskAsync(123L);"
    },
    "getDictionaryLanguages": {
      "default": "var response = await client.GetDictionaryLanguagesAsync();"
    },
    "getDictionarySettings": {
      "default": "var response = await client.GetDictionarySettingsAsync();"
    },
    "getLogs": {
      "default": "var response = await client.GetLogsAsync();"
    },
    "getObject": {
      "default": "var response = await client.GetObjectAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new List<string> { \"attr1\", \"attr2\" }\n);"
    },
    "getObjects": {
      "default": "var response = await client.GetObjectsAsync<Hit>(\n  new GetObjectsParams\n  {\n    Requests = new List<GetObjectsRequest>\n    {\n      new GetObjectsRequest\n      {\n        AttributesToRetrieve = new List<string> { \"attr1\", \"attr2\" },\n        ObjectID = \"uniqueID\",\n        IndexName = \"<YOUR_INDEX_NAME>\",\n      },\n    },\n  }\n);"
    },
    "getRule": {
      "default": "var response = await client.GetRuleAsync(\"<YOUR_INDEX_NAME>\", \"qr-1725004648916\");"
    },
    "getSettings": {
      "default": "var response = await client.GetSettingsAsync(\"<YOUR_INDEX_NAME>\");"
    },
    "getSources": {
      "default": "var response = await client.GetSourcesAsync();"
    },
    "getSynonym": {
      "default": "var response = await client.GetSynonymAsync(\"<YOUR_INDEX_NAME>\", \"id1\");"
    },
    "getTask": {
      "default": "var response = await client.GetTaskAsync(\"<YOUR_INDEX_NAME>\", 123L);"
    },
    "getTopUserIds": {
      "default": "var response = await client.GetTopUserIdsAsync();"
    },
    "getUserId": {
      "default": "var response = await client.GetUserIdAsync(\"uniqueID\");"
    },
    "hasPendingMappings": {
      "default": "var response = await client.HasPendingMappingsAsync();"
    },
    "indexExists": {
      "indexExists": "var response = await client.IndexExistsAsync(\"<YOUR_INDEX_NAME>\");",
      "indexNotExists": "var response = await client.IndexExistsAsync(\"<YOUR_INDEX_NAME>\");",
      "indexExistsWithError": "var response = await client.IndexExistsAsync(\"<YOUR_INDEX_NAME>\");"
    },
    "listApiKeys": {
      "default": "var response = await client.ListApiKeysAsync();"
    },
    "listClusters": {
      "default": "var response = await client.ListClustersAsync();"
    },
    "listIndices": {
      "default": "var response = await client.ListIndicesAsync();"
    },
    "listUserIds": {
      "default": "var response = await client.ListUserIdsAsync();"
    },
    "multipleBatch": {
      "default": "var response = await client.MultipleBatchAsync(\n  new BatchParams\n  {\n    Requests = new List<MultipleBatchRequest>\n    {\n      new MultipleBatchRequest\n      {\n        Action = Enum.Parse<Action>(\"AddObject\"),\n        Body = new Dictionary<string, string> { { \"key\", \"value\" } },\n        IndexName = \"<YOUR_INDEX_NAME>\",\n      },\n    },\n  }\n);"
    },
    "operationIndex": {
      "scopes": "var response = await client.OperationIndexAsync(\n  \"<SOURCE_INDEX_NAME>\",\n  new OperationIndexParams\n  {\n    Operation = Enum.Parse<OperationType>(\"Move\"),\n    Destination = \"<DESTINATION_INDEX_NAME>\",\n    Scope = new List<ScopeType>\n    {\n      Enum.Parse<ScopeType>(\"Rules\"),\n      Enum.Parse<ScopeType>(\"Settings\"),\n    },\n  }\n);",
      "copy": "var response = await client.OperationIndexAsync(\n  \"<SOURCE_INDEX_NAME>\",\n  new OperationIndexParams\n  {\n    Operation = Enum.Parse<OperationType>(\"Copy\"),\n    Destination = \"<DESTINATION_INDEX_NAME>\",\n  }\n);",
      "move": "var response = await client.OperationIndexAsync(\n  \"<SOURCE_INDEX_NAME>\",\n  new OperationIndexParams\n  {\n    Operation = Enum.Parse<OperationType>(\"Move\"),\n    Destination = \"<DESTINATION_INDEX_NAME>\",\n  }\n);"
    },
    "partialUpdateObject": {
      "default": "var response = await client.PartialUpdateObjectAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new Dictionary<string, string> { { \"attributeId\", \"new value\" } }\n);"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "var response = await client.PartialUpdateObjectsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Object>\n  {\n    new Dictionary<string, string> { { \"objectID\", \"1\" }, { \"name\", \"Adam\" } },\n    new Dictionary<string, string> { { \"objectID\", \"2\" }, { \"name\", \"Benoit\" } },\n  },\n  true\n);",
      "call partialUpdateObjects with createIfNotExists=false": "var response = await client.PartialUpdateObjectsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Object>\n  {\n    new Dictionary<string, string> { { \"objectID\", \"3\" }, { \"name\", \"Cyril\" } },\n    new Dictionary<string, string> { { \"objectID\", \"4\" }, { \"name\", \"David\" } },\n  },\n  false\n);"
    },
    "removeUserId": {
      "default": "var response = await client.RemoveUserIdAsync(\"uniqueID\");"
    },
    "replaceAllObjects": {
      "default": "var response = await client.ReplaceAllObjectsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Object>\n  {\n    new Dictionary<string, string> { { \"objectID\", \"1\" }, { \"name\", \"Adam\" } },\n    new Dictionary<string, string> { { \"objectID\", \"2\" }, { \"name\", \"Benoit\" } },\n    new Dictionary<string, string> { { \"objectID\", \"3\" }, { \"name\", \"Cyril\" } },\n    new Dictionary<string, string> { { \"objectID\", \"4\" }, { \"name\", \"David\" } },\n    new Dictionary<string, string> { { \"objectID\", \"5\" }, { \"name\", \"Eva\" } },\n    new Dictionary<string, string> { { \"objectID\", \"6\" }, { \"name\", \"Fiona\" } },\n    new Dictionary<string, string> { { \"objectID\", \"7\" }, { \"name\", \"Gael\" } },\n    new Dictionary<string, string> { { \"objectID\", \"8\" }, { \"name\", \"Hugo\" } },\n    new Dictionary<string, string> { { \"objectID\", \"9\" }, { \"name\", \"Igor\" } },\n    new Dictionary<string, string> { { \"objectID\", \"10\" }, { \"name\", \"Julia\" } },\n  },\n  3\n);"
    },
    "replaceSources": {
      "default": "var response = await client.ReplaceSourcesAsync(\n  new List<Source>\n  {\n    new Source { VarSource = \"theSource\", Description = \"theDescription\" },\n  }\n);"
    },
    "restoreApiKey": {
      "default": "var response = await client.RestoreApiKeyAsync(\"ALGOLIA_API_KEY\");"
    },
    "saveObject": {
      "default": "var response = await client.SaveObjectAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new Dictionary<string, string> { { \"objectID\", \"id\" }, { \"test\", \"val\" } }\n);"
    },
    "saveObjects": {
      "call saveObjects without error": "var response = await client.SaveObjectsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Object>\n  {\n    new Dictionary<string, string> { { \"objectID\", \"1\" }, { \"name\", \"Adam\" } },\n    new Dictionary<string, string> { { \"objectID\", \"2\" }, { \"name\", \"Benoit\" } },\n  }\n);",
      "saveObjects should report errors": "var response = await client.SaveObjectsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Object>\n  {\n    new Dictionary<string, string> { { \"objectID\", \"1\" }, { \"name\", \"Adam\" } },\n    new Dictionary<string, string> { { \"objectID\", \"2\" }, { \"name\", \"Benoit\" } },\n  }\n);"
    },
    "saveRule": {
      "default": "var response = await client.SaveRuleAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"id1\",\n  new Rule\n  {\n    ObjectID = \"id1\",\n    Conditions = new List<Condition>\n    {\n      new Condition { Pattern = \"apple\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n    },\n  }\n);"
    },
    "saveRules": {
      "default": "var response = await client.SaveRulesAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<Rule>\n  {\n    new Rule\n    {\n      ObjectID = \"a-rule-id\",\n      Conditions = new List<Condition>\n      {\n        new Condition { Pattern = \"smartphone\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n      },\n    },\n    new Rule\n    {\n      ObjectID = \"a-second-rule-id\",\n      Conditions = new List<Condition>\n      {\n        new Condition { Pattern = \"apple\", Anchoring = Enum.Parse<Anchoring>(\"Contains\") },\n      },\n    },\n  },\n  false,\n  true\n);"
    },
    "saveSynonym": {
      "default": "var response = await client.SaveSynonymAsync(\n  \"<YOUR_INDEX_NAME>\",\n  \"id1\",\n  new SynonymHit\n  {\n    ObjectID = \"id1\",\n    Type = Enum.Parse<SynonymType>(\"Synonym\"),\n    Synonyms = new List<string> { \"car\", \"vehicule\", \"auto\" },\n  },\n  true\n);"
    },
    "saveSynonyms": {
      "default": "var response = await client.SaveSynonymsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new List<SynonymHit>\n  {\n    new SynonymHit\n    {\n      ObjectID = \"id1\",\n      Type = Enum.Parse<SynonymType>(\"Synonym\"),\n      Synonyms = new List<string> { \"car\", \"vehicule\", \"auto\" },\n    },\n    new SynonymHit\n    {\n      ObjectID = \"id2\",\n      Type = Enum.Parse<SynonymType>(\"Onewaysynonym\"),\n      Input = \"iphone\",\n      Synonyms = new List<string> { \"ephone\", \"aphone\", \"yphone\" },\n    },\n  },\n  true,\n  true\n);"
    },
    "search": {
      "withHitsPerPage": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Query = \"<YOUR_QUERY>\",\n          HitsPerPage = 50,\n        }\n      ),\n    },\n  }\n);",
      "filterOnly": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Query = \"<YOUR_QUERY>\",\n          Filters = \"actor:Scarlett Johansson\",\n        }\n      ),\n    },\n  }\n);",
      "filterOr": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Query = \"<YOUR_QUERY>\",\n          Filters = \"actor:Tom Cruise OR actor:Scarlett Johansson\",\n        }\n      ),\n    },\n  }\n);",
      "filterNot": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Query = \"<YOUR_QUERY>\",\n          Filters = \"NOT actor:Nicolas Cage\",\n        }\n      ),\n    },\n  }\n);",
      "retrieveFacets": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Query = \"<YOUR_QUERY>\",\n          Facets = new List<string> { \"author\", \"genre\" },\n        }\n      ),\n    },\n  }\n);",
      "retrieveFacetsWildcard": "var response = await client.SearchAsync<Hit>(\n  new SearchMethodParams\n  {\n    Requests = new List<SearchQuery>\n    {\n      new SearchQuery(\n        new SearchForHits\n        {\n          IndexName = \"<YOUR_INDEX_NAME>\",\n          Query = \"<YOUR_QUERY>\",\n          Facets = new List<string> { \"*\" },\n        }\n      ),\n    },\n  }\n);"
    },
    "searchDictionaryEntries": {
      "default": "var response = await client.SearchDictionaryEntriesAsync(\n  Enum.Parse<DictionaryType>(\"Stopwords\"),\n  new SearchDictionaryEntriesParams { Query = \"about\" }\n);"
    },
    "searchForFacetValues": {
      "default": "var response = await client.SearchForFacetValuesAsync(\"<YOUR_INDEX_NAME>\", \"facetName\");"
    },
    "searchRules": {
      "default": "var response = await client.SearchRulesAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new SearchRulesParams { Query = \"zorro\" }\n);"
    },
    "searchSingleIndex": {
      "default": "var response = await client.SearchSingleIndexAsync<Hit>(\"<YOUR_INDEX_NAME>\");"
    },
    "searchSynonyms": {
      "default": "var response = await client.SearchSynonymsAsync(\"<YOUR_INDEX_NAME>\");"
    },
    "searchUserIds": {
      "default": "var response = await client.SearchUserIdsAsync(\n  new SearchUserIdsParams\n  {\n    Query = \"test\",\n    ClusterName = \"theClusterName\",\n    Page = 5,\n    HitsPerPage = 10,\n  }\n);"
    },
    "setClientApiKey": {
      "default": "client.SetClientApiKey(\"updated-api-key\");"
    },
    "setDictionarySettings": {
      "default": "var response = await client.SetDictionarySettingsAsync(\n  new DictionarySettingsParams\n  {\n    DisableStandardEntries = new StandardEntries\n    {\n      Plurals = new Dictionary<string, Boolean>\n      {\n        { \"fr\", false },\n        { \"en\", false },\n        { \"ru\", true },\n      },\n    },\n  }\n);"
    },
    "setSettings": {
      "default": "var response = await client.SetSettingsAsync(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings\n  {\n    AttributesForFaceting = new List<string>\n    {\n      \"actor\",\n      \"filterOnly(category)\",\n      \"searchable(publisher)\",\n    },\n  }\n);"
    },
    "updateApiKey": {
      "default": "var response = await client.UpdateApiKeyAsync(\n  \"ALGOLIA_API_KEY\",\n  new ApiKey\n  {\n    Acl = new List<Acl> { Enum.Parse<Acl>(\"Search\"), Enum.Parse<Acl>(\"AddObject\") },\n    Validity = 300,\n    MaxQueriesPerIPPerHour = 100,\n    MaxHitsPerQuery = 20,\n  }\n);"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "var response = await client.WaitForApiKeyAsync(\n  \"api-key-add-operation-test-csharp\",\n  Enum.Parse<ApiKeyOperation>(\"Add\")\n);",
      "wait for api key - update": "var response = await client.WaitForApiKeyAsync(\n  \"api-key-update-operation-test-csharp\",\n  Enum.Parse<ApiKeyOperation>(\"Update\"),\n  new ApiKey\n  {\n    Description = \"my updated api key\",\n    Acl = new List<Acl>\n    {\n      Enum.Parse<Acl>(\"Search\"),\n      Enum.Parse<Acl>(\"AddObject\"),\n      Enum.Parse<Acl>(\"DeleteObject\"),\n    },\n    Indexes = new List<string> { \"Movies\", \"Books\" },\n    Referers = new List<string> { \"*google.com\", \"*algolia.com\" },\n    Validity = 305,\n    MaxQueriesPerIPPerHour = 95,\n    MaxHitsPerQuery = 20,\n  }\n);",
      "wait for api key - delete": "var response = await client.WaitForApiKeyAsync(\n  \"api-key-delete-operation-test-csharp\",\n  Enum.Parse<ApiKeyOperation>(\"Delete\")\n);"
    },
    "waitForAppTask": {
      "default": "var response = await client.WaitForAppTaskAsync(123L);"
    },
    "waitForTask": {
      "default": "var response = await client.WaitForTaskAsync(\"<YOUR_INDEX_NAME>\", 123L);"
    },
    "init": {
      "default": "var client = new SearchClient(new SearchConfig(\"ALGOLIA_APPLICATION_ID\", \"ALGOLIA_API_KEY\"));"
    }
  },
  "dart": {
    "import": {
      "default": "import 'package:algolia_client_search/algolia_client_search.dart';"
    },
    "addApiKey": {
      "default": "final response = await client.addApiKey(\n  apiKey: ApiKey(\n    acl: [\n      Acl.fromJson(\"search\"),\n      Acl.fromJson(\"addObject\"),\n    ],\n    description: \"my new api key\",\n    validity: 300,\n    maxQueriesPerIPPerHour: 100,\n    maxHitsPerQuery: 20,\n  ),\n);"
    },
    "addOrUpdateObject": {
      "default": "final response = await client.addOrUpdateObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"uniqueID\",\n  body: {\n    'key': \"value\",\n  },\n);"
    },
    "appendSource": {
      "default": "final response = await client.appendSource(\n  source: Source(\n    source: \"theSource\",\n    description: \"theDescription\",\n  ),\n);"
    },
    "assignUserId": {
      "default": "final response = await client.assignUserId(\n  xAlgoliaUserID: \"userID\",\n  assignUserIdParams: AssignUserIdParams(\n    cluster: \"theCluster\",\n  ),\n);"
    },
    "batch": {
      "addObject": "final response = await client.batch(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  batchWriteParams: BatchWriteParams(\n    requests: [\n      BatchRequest(\n        action: Action.fromJson(\"addObject\"),\n        body: {\n          'key': \"bar\",\n          'foo': \"1\",\n        },\n      ),\n      BatchRequest(\n        action: Action.fromJson(\"addObject\"),\n        body: {\n          'key': \"baz\",\n          'foo': \"2\",\n        },\n      ),\n    ],\n  ),\n);",
      "clear": "final response = await client.batch(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  batchWriteParams: BatchWriteParams(\n    requests: [\n      BatchRequest(\n        action: Action.fromJson(\"clear\"),\n        body: {\n          'key': \"value\",\n        },\n      ),\n    ],\n  ),\n);",
      "delete": "final response = await client.batch(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  batchWriteParams: BatchWriteParams(\n    requests: [\n      BatchRequest(\n        action: Action.fromJson(\"delete\"),\n        body: {\n          'key': \"value\",\n        },\n      ),\n    ],\n  ),\n);",
      "deleteObject": "final response = await client.batch(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  batchWriteParams: BatchWriteParams(\n    requests: [\n      BatchRequest(\n        action: Action.fromJson(\"deleteObject\"),\n        body: {\n          'key': \"value\",\n        },\n      ),\n    ],\n  ),\n);",
      "partialUpdateObject": "final response = await client.batch(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  batchWriteParams: BatchWriteParams(\n    requests: [\n      BatchRequest(\n        action: Action.fromJson(\"partialUpdateObject\"),\n        body: {\n          'key': \"value\",\n        },\n      ),\n    ],\n  ),\n);",
      "partialUpdateObjectNoCreate": "final response = await client.batch(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  batchWriteParams: BatchWriteParams(\n    requests: [\n      BatchRequest(\n        action: Action.fromJson(\"partialUpdateObjectNoCreate\"),\n        body: {\n          'key': \"value\",\n        },\n      ),\n    ],\n  ),\n);",
      "updateObject": "final response = await client.batch(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  batchWriteParams: BatchWriteParams(\n    requests: [\n      BatchRequest(\n        action: Action.fromJson(\"updateObject\"),\n        body: {\n          'key': \"value\",\n        },\n      ),\n    ],\n  ),\n);"
    },
    "batchAssignUserIds": {
      "default": "final response = await client.batchAssignUserIds(\n  xAlgoliaUserID: \"userID\",\n  batchAssignUserIdsParams: BatchAssignUserIdsParams(\n    cluster: \"theCluster\",\n    users: [\n      \"user1\",\n      \"user2\",\n    ],\n  ),\n);"
    },
    "batchDictionaryEntries": {
      "replace": "final response = await client.batchDictionaryEntries(\n  dictionaryName: DictionaryType.fromJson(\"plurals\"),\n  batchDictionaryEntriesParams: BatchDictionaryEntriesParams(\n    clearExistingDictionaryEntries: true,\n    requests: [\n      BatchDictionaryEntriesRequest(\n        action: DictionaryAction.fromJson(\"addEntry\"),\n        body: DictionaryEntry(\n          objectID: \"1\",\n          language: SupportedLanguage.fromJson(\"en\"),\n          word: \"fancy\",\n          words: [\n            \"believe\",\n            \"algolia\",\n          ],\n          decomposition: [\n            \"trust\",\n            \"algolia\",\n          ],\n          state: DictionaryEntryState.fromJson(\"enabled\"),\n        ),\n      ),\n    ],\n  ),\n);",
      "delete": "final response = await client.batchDictionaryEntries(\n  dictionaryName: DictionaryType.fromJson(\"plurals\"),\n  batchDictionaryEntriesParams: BatchDictionaryEntriesParams(\n    clearExistingDictionaryEntries: true,\n    requests: [\n      BatchDictionaryEntriesRequest(\n        action: DictionaryAction.fromJson(\"deleteEntry\"),\n        body: DictionaryEntry(\n          objectID: \"1\",\n        ),\n      ),\n    ],\n  ),\n);",
      "append": "final response = await client.batchDictionaryEntries(\n  dictionaryName: DictionaryType.fromJson(\"stopwords\"),\n  batchDictionaryEntriesParams: BatchDictionaryEntriesParams(\n    requests: [\n      BatchDictionaryEntriesRequest(\n        action: DictionaryAction.fromJson(\"addEntry\"),\n        body: DictionaryEntry(\n          objectID: \"1\",\n          language: SupportedLanguage.fromJson(\"en\"),\n          additionalProperties: {'additional': 'try me'},\n        ),\n      ),\n    ],\n  ),\n);"
    },
    "browse": {
      "default": "final response = await client.browse(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);"
    },
    "clearObjects": {
      "default": "final response = await client.clearObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);"
    },
    "clearRules": {
      "default": "final response = await client.clearRules(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);"
    },
    "clearSynonyms": {
      "default": "final response = await client.clearSynonyms(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);"
    },
    "customDelete": {
      "default": "final response = await client.customDelete(\n  path: \"test/minimal\",\n);"
    },
    "customGet": {
      "default": "final response = await client.customGet(\n  path: \"test/minimal\",\n);"
    },
    "customPost": {
      "default": "final response = await client.customPost(\n  path: \"test/minimal\",\n);"
    },
    "customPut": {
      "default": "final response = await client.customPut(\n  path: \"test/minimal\",\n);"
    },
    "deleteApiKey": {
      "default": "final response = await client.deleteApiKey(\n  key: \"myTestApiKey\",\n);"
    },
    "deleteBy": {
      "default": "final response = await client.deleteBy(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  deleteByParams: DeleteByParams(\n    filters: \"brand:brandName\",\n  ),\n);"
    },
    "deleteIndex": {
      "default": "final response = await client.deleteIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);"
    },
    "deleteObject": {
      "default": "final response = await client.deleteObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"uniqueID\",\n);"
    },
    "deleteObjects": {
      "default": "final response = await client.deleteObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectIDs: [\n    \"1\",\n    \"2\",\n  ],\n);"
    },
    "deleteRule": {
      "default": "final response = await client.deleteRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"id1\",\n);"
    },
    "deleteSource": {
      "default": "final response = await client.deleteSource(\n  source: \"theSource\",\n);"
    },
    "deleteSynonym": {
      "default": "final response = await client.deleteSynonym(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"id1\",\n);"
    },
    "generateSecuredApiKey": {
      "generate secured api key basic": "final response = client.generateSecuredApiKey(\n  parentApiKey: \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions: SecuredApiKeyRestrictions(\n    validUntil: 2524604400,\n    restrictIndices: [\n      \"Movies\",\n    ],\n  ),\n);",
      "generate secured api key with searchParams": "final response = client.generateSecuredApiKey(\n  parentApiKey: \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions: SecuredApiKeyRestrictions(\n    validUntil: 2524604400,\n    restrictIndices: [\n      \"Movies\",\n      \"cts_e2e_settings\",\n    ],\n    restrictSources: \"192.168.1.0/24\",\n    filters: \"category:Book OR category:Ebook AND _tags:published\",\n    userToken: \"user123\",\n    searchParams: SearchParamsObject(\n      query: \"batman\",\n      typoTolerance: TypoToleranceEnum.fromJson(\"strict\"),\n      aroundRadius: AroundRadiusAll.fromJson(\"all\"),\n      mode: Mode.fromJson(\"neuralSearch\"),\n      hitsPerPage: 10,\n      optionalWords: [\n        \"one\",\n        \"two\",\n      ],\n    ),\n  ),\n);"
    },
    "getApiKey": {
      "default": "final response = await client.getApiKey(\n  key: \"myTestApiKey\",\n);"
    },
    "getAppTask": {
      "default": "final response = await client.getAppTask(\n  taskID: 123,\n);"
    },
    "getDictionaryLanguages": {
      "default": "final response = await client.getDictionaryLanguages();"
    },
    "getDictionarySettings": {
      "default": "final response = await client.getDictionarySettings();"
    },
    "getLogs": {
      "default": "final response = await client.getLogs();"
    },
    "getObject": {
      "default": "final response = await client.getObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"uniqueID\",\n  attributesToRetrieve: [\n    \"attr1\",\n    \"attr2\",\n  ],\n);"
    },
    "getObjects": {
      "default": "final response = await client.getObjects(\n  getObjectsParams: GetObjectsParams(\n    requests: [\n      GetObjectsRequest(\n        attributesToRetrieve: [\n          \"attr1\",\n          \"attr2\",\n        ],\n        objectID: \"uniqueID\",\n        indexName: \"<YOUR_INDEX_NAME>\",\n      ),\n    ],\n  ),\n);"
    },
    "getRule": {
      "default": "final response = await client.getRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"qr-1725004648916\",\n);"
    },
    "getSettings": {
      "default": "final response = await client.getSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);"
    },
    "getSources": {
      "default": "final response = await client.getSources();"
    },
    "getSynonym": {
      "default": "final response = await client.getSynonym(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"id1\",\n);"
    },
    "getTask": {
      "default": "final response = await client.getTask(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  taskID: 123,\n);"
    },
    "getTopUserIds": {
      "default": "final response = await client.getTopUserIds();"
    },
    "getUserId": {
      "default": "final response = await client.getUserId(\n  userID: \"uniqueID\",\n);"
    },
    "hasPendingMappings": {
      "default": "final response = await client.hasPendingMappings();"
    },
    "indexExists": {
      "indexExists": "final response = await client.indexExists(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);",
      "indexNotExists": "final response = await client.indexExists(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);",
      "indexExistsWithError": "final response = await client.indexExists(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);"
    },
    "listApiKeys": {
      "default": "final response = await client.listApiKeys();"
    },
    "listClusters": {
      "default": "final response = await client.listClusters();"
    },
    "listIndices": {
      "default": "final response = await client.listIndices();"
    },
    "listUserIds": {
      "default": "final response = await client.listUserIds();"
    },
    "multipleBatch": {
      "default": "final response = await client.multipleBatch(\n  batchParams: BatchParams(\n    requests: [\n      MultipleBatchRequest(\n        action: Action.fromJson(\"addObject\"),\n        body: {\n          'key': \"value\",\n        },\n        indexName: \"<YOUR_INDEX_NAME>\",\n      ),\n    ],\n  ),\n);"
    },
    "operationIndex": {
      "scopes": "final response = await client.operationIndex(\n  indexName: \"<SOURCE_INDEX_NAME>\",\n  operationIndexParams: OperationIndexParams(\n    operation: OperationType.fromJson(\"move\"),\n    destination: \"<DESTINATION_INDEX_NAME>\",\n    scope: [\n      ScopeType.fromJson(\"rules\"),\n      ScopeType.fromJson(\"settings\"),\n    ],\n  ),\n);",
      "copy": "final response = await client.operationIndex(\n  indexName: \"<SOURCE_INDEX_NAME>\",\n  operationIndexParams: OperationIndexParams(\n    operation: OperationType.fromJson(\"copy\"),\n    destination: \"<DESTINATION_INDEX_NAME>\",\n  ),\n);",
      "move": "final response = await client.operationIndex(\n  indexName: \"<SOURCE_INDEX_NAME>\",\n  operationIndexParams: OperationIndexParams(\n    operation: OperationType.fromJson(\"move\"),\n    destination: \"<DESTINATION_INDEX_NAME>\",\n  ),\n);"
    },
    "partialUpdateObject": {
      "default": "final response = await client.partialUpdateObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"uniqueID\",\n  attributesToUpdate: {\n    'attributeId': \"new value\",\n  },\n);"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "final response = await client.partialUpdateObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objects: [\n    {\n      'objectID': \"1\",\n      'name': \"Adam\",\n    },\n    {\n      'objectID': \"2\",\n      'name': \"Benoit\",\n    },\n  ],\n  createIfNotExists: true,\n);",
      "call partialUpdateObjects with createIfNotExists=false": "final response = await client.partialUpdateObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objects: [\n    {\n      'objectID': \"3\",\n      'name': \"Cyril\",\n    },\n    {\n      'objectID': \"4\",\n      'name': \"David\",\n    },\n  ],\n  createIfNotExists: false,\n);"
    },
    "removeUserId": {
      "default": "final response = await client.removeUserId(\n  userID: \"uniqueID\",\n);"
    },
    "replaceAllObjects": {
      "default": "final response = await client.replaceAllObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objects: [\n    {\n      'objectID': \"1\",\n      'name': \"Adam\",\n    },\n    {\n      'objectID': \"2\",\n      'name': \"Benoit\",\n    },\n    {\n      'objectID': \"3\",\n      'name': \"Cyril\",\n    },\n    {\n      'objectID': \"4\",\n      'name': \"David\",\n    },\n    {\n      'objectID': \"5\",\n      'name': \"Eva\",\n    },\n    {\n      'objectID': \"6\",\n      'name': \"Fiona\",\n    },\n    {\n      'objectID': \"7\",\n      'name': \"Gael\",\n    },\n    {\n      'objectID': \"8\",\n      'name': \"Hugo\",\n    },\n    {\n      'objectID': \"9\",\n      'name': \"Igor\",\n    },\n    {\n      'objectID': \"10\",\n      'name': \"Julia\",\n    },\n  ],\n  batchSize: 3,\n);"
    },
    "replaceSources": {
      "default": "final response = await client.replaceSources(\n  source: [\n    Source(\n      source: \"theSource\",\n      description: \"theDescription\",\n    ),\n  ],\n);"
    },
    "restoreApiKey": {
      "default": "final response = await client.restoreApiKey(\n  key: \"ALGOLIA_API_KEY\",\n);"
    },
    "saveObject": {
      "default": "final response = await client.saveObject(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  body: {\n    'objectID': \"id\",\n    'test': \"val\",\n  },\n);"
    },
    "saveObjects": {
      "call saveObjects without error": "final response = await client.saveObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objects: [\n    {\n      'objectID': \"1\",\n      'name': \"Adam\",\n    },\n    {\n      'objectID': \"2\",\n      'name': \"Benoit\",\n    },\n  ],\n);",
      "saveObjects should report errors": "final response = await client.saveObjects(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objects: [\n    {\n      'objectID': \"1\",\n      'name': \"Adam\",\n    },\n    {\n      'objectID': \"2\",\n      'name': \"Benoit\",\n    },\n  ],\n);"
    },
    "saveRule": {
      "default": "final response = await client.saveRule(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"id1\",\n  rule: Rule(\n    objectID: \"id1\",\n    conditions: [\n      Condition(\n        pattern: \"apple\",\n        anchoring: Anchoring.fromJson(\"contains\"),\n      ),\n    ],\n  ),\n);"
    },
    "saveRules": {
      "default": "final response = await client.saveRules(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  rules: [\n    Rule(\n      objectID: \"a-rule-id\",\n      conditions: [\n        Condition(\n          pattern: \"smartphone\",\n          anchoring: Anchoring.fromJson(\"contains\"),\n        ),\n      ],\n    ),\n    Rule(\n      objectID: \"a-second-rule-id\",\n      conditions: [\n        Condition(\n          pattern: \"apple\",\n          anchoring: Anchoring.fromJson(\"contains\"),\n        ),\n      ],\n    ),\n  ],\n  forwardToReplicas: false,\n  clearExistingRules: true,\n);"
    },
    "saveSynonym": {
      "default": "final response = await client.saveSynonym(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  objectID: \"id1\",\n  synonymHit: SynonymHit(\n    objectID: \"id1\",\n    type: SynonymType.fromJson(\"synonym\"),\n    synonyms: [\n      \"car\",\n      \"vehicule\",\n      \"auto\",\n    ],\n  ),\n  forwardToReplicas: true,\n);"
    },
    "saveSynonyms": {
      "default": "final response = await client.saveSynonyms(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  synonymHit: [\n    SynonymHit(\n      objectID: \"id1\",\n      type: SynonymType.fromJson(\"synonym\"),\n      synonyms: [\n        \"car\",\n        \"vehicule\",\n        \"auto\",\n      ],\n    ),\n    SynonymHit(\n      objectID: \"id2\",\n      type: SynonymType.fromJson(\"onewaysynonym\"),\n      input: \"iphone\",\n      synonyms: [\n        \"ephone\",\n        \"aphone\",\n        \"yphone\",\n      ],\n    ),\n  ],\n  forwardToReplicas: true,\n  replaceExistingSynonyms: true,\n);"
    },
    "search": {
      "withHitsPerPage": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        hitsPerPage: 50,\n      ),\n    ],\n  ),\n);",
      "filterOnly": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        filters: \"actor:Scarlett Johansson\",\n      ),\n    ],\n  ),\n);",
      "filterOr": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        filters: \"actor:Tom Cruise OR actor:Scarlett Johansson\",\n      ),\n    ],\n  ),\n);",
      "filterNot": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        filters: \"NOT actor:Nicolas Cage\",\n      ),\n    ],\n  ),\n);",
      "retrieveFacets": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        facets: [\n          \"author\",\n          \"genre\",\n        ],\n      ),\n    ],\n  ),\n);",
      "retrieveFacetsWildcard": "final response = await client.search(\n  searchMethodParams: SearchMethodParams(\n    requests: [\n      SearchForHits(\n        indexName: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        facets: [\n          \"*\",\n        ],\n      ),\n    ],\n  ),\n);"
    },
    "searchDictionaryEntries": {
      "default": "final response = await client.searchDictionaryEntries(\n  dictionaryName: DictionaryType.fromJson(\"stopwords\"),\n  searchDictionaryEntriesParams: SearchDictionaryEntriesParams(\n    query: \"about\",\n  ),\n);"
    },
    "searchForFacetValues": {
      "default": "final response = await client.searchForFacetValues(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  facetName: \"facetName\",\n);"
    },
    "searchRules": {
      "default": "final response = await client.searchRules(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  searchRulesParams: SearchRulesParams(\n    query: \"zorro\",\n  ),\n);"
    },
    "searchSingleIndex": {
      "default": "final response = await client.searchSingleIndex(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);"
    },
    "searchSynonyms": {
      "default": "final response = await client.searchSynonyms(\n  indexName: \"<YOUR_INDEX_NAME>\",\n);"
    },
    "searchUserIds": {
      "default": "final response = await client.searchUserIds(\n  searchUserIdsParams: SearchUserIdsParams(\n    query: \"test\",\n    clusterName: \"theClusterName\",\n    page: 5,\n    hitsPerPage: 10,\n  ),\n);"
    },
    "setClientApiKey": {
      "default": "client.setClientApiKey(\n  apiKey: \"updated-api-key\",\n);"
    },
    "setDictionarySettings": {
      "default": "final response = await client.setDictionarySettings(\n  dictionarySettingsParams: DictionarySettingsParams(\n    disableStandardEntries: StandardEntries(\n      plurals: {\n        'fr': false,\n        'en': false,\n        'ru': true,\n      },\n    ),\n  ),\n);"
    },
    "setSettings": {
      "default": "final response = await client.setSettings(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  indexSettings: IndexSettings(\n    attributesForFaceting: [\n      \"actor\",\n      \"filterOnly(category)\",\n      \"searchable(publisher)\",\n    ],\n  ),\n);"
    },
    "updateApiKey": {
      "default": "final response = await client.updateApiKey(\n  key: \"ALGOLIA_API_KEY\",\n  apiKey: ApiKey(\n    acl: [\n      Acl.fromJson(\"search\"),\n      Acl.fromJson(\"addObject\"),\n    ],\n    validity: 300,\n    maxQueriesPerIPPerHour: 100,\n    maxHitsPerQuery: 20,\n  ),\n);"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "final response = await client.waitForApiKey(\n  key: \"api-key-add-operation-test-dart\",\n  operation: ApiKeyOperation.fromJson(\"add\"),\n);",
      "wait for api key - update": "final response = await client.waitForApiKey(\n  key: \"api-key-update-operation-test-dart\",\n  operation: ApiKeyOperation.fromJson(\"update\"),\n  apiKey: ApiKey(\n    description: \"my updated api key\",\n    acl: [\n      Acl.fromJson(\"search\"),\n      Acl.fromJson(\"addObject\"),\n      Acl.fromJson(\"deleteObject\"),\n    ],\n    indexes: [\n      \"Movies\",\n      \"Books\",\n    ],\n    referers: [\n      \"*google.com\",\n      \"*algolia.com\",\n    ],\n    validity: 305,\n    maxQueriesPerIPPerHour: 95,\n    maxHitsPerQuery: 20,\n  ),\n);",
      "wait for api key - delete": "final response = await client.waitForApiKey(\n  key: \"api-key-delete-operation-test-dart\",\n  operation: ApiKeyOperation.fromJson(\"delete\"),\n);"
    },
    "waitForAppTask": {
      "default": "final response = await client.waitForAppTask(\n  taskID: 123,\n);"
    },
    "waitForTask": {
      "default": "final response = await client.waitForTask(\n  indexName: \"<YOUR_INDEX_NAME>\",\n  taskID: 123,\n);"
    },
    "init": {
      "default": "final client =\n    SearchClient(appId: 'ALGOLIA_APPLICATION_ID', apiKey: 'ALGOLIA_API_KEY');"
    }
  },
  "go": {
    "import": {
      "default": "import \"github.com/algolia/algoliasearch-client-go/v4/algolia/search\""
    },
    "addApiKey": {
      "default": "response, err := client.AddApiKey(client.NewApiAddApiKeyRequest(\n\n  search.NewEmptyApiKey().SetAcl(\n    []search.Acl{search.Acl(\"search\"), search.Acl(\"addObject\")}).SetDescription(\"my new api key\").SetValidity(300).SetMaxQueriesPerIPPerHour(100).SetMaxHitsPerQuery(20),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "addOrUpdateObject": {
      "default": "response, err := client.AddOrUpdateObject(client.NewApiAddOrUpdateObjectRequest(\n  \"<YOUR_INDEX_NAME>\", \"uniqueID\", map[string]any{\"key\": \"value\"},\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "appendSource": {
      "default": "response, err := client.AppendSource(client.NewApiAppendSourceRequest(\n\n  search.NewEmptySource().SetSource(\"theSource\").SetDescription(\"theDescription\"),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "assignUserId": {
      "default": "response, err := client.AssignUserId(client.NewApiAssignUserIdRequest(\n  \"userID\",\n  search.NewEmptyAssignUserIdParams().SetCluster(\"theCluster\"),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "batch": {
      "addObject": "response, err := client.Batch(client.NewApiBatchRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyBatchWriteParams().SetRequests(\n    []search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action(\"addObject\")).SetBody(map[string]any{\"key\": \"bar\", \"foo\": \"1\"}), *search.NewEmptyBatchRequest().SetAction(search.Action(\"addObject\")).SetBody(map[string]any{\"key\": \"baz\", \"foo\": \"2\"})}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "clear": "response, err := client.Batch(client.NewApiBatchRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyBatchWriteParams().SetRequests(\n    []search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action(\"clear\")).SetBody(map[string]any{\"key\": \"value\"})}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "delete": "response, err := client.Batch(client.NewApiBatchRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyBatchWriteParams().SetRequests(\n    []search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action(\"delete\")).SetBody(map[string]any{\"key\": \"value\"})}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "deleteObject": "response, err := client.Batch(client.NewApiBatchRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyBatchWriteParams().SetRequests(\n    []search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action(\"deleteObject\")).SetBody(map[string]any{\"key\": \"value\"})}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "partialUpdateObject": "response, err := client.Batch(client.NewApiBatchRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyBatchWriteParams().SetRequests(\n    []search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action(\"partialUpdateObject\")).SetBody(map[string]any{\"key\": \"value\"})}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "partialUpdateObjectNoCreate": "response, err := client.Batch(client.NewApiBatchRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyBatchWriteParams().SetRequests(\n    []search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action(\"partialUpdateObjectNoCreate\")).SetBody(map[string]any{\"key\": \"value\"})}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "updateObject": "response, err := client.Batch(client.NewApiBatchRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyBatchWriteParams().SetRequests(\n    []search.BatchRequest{*search.NewEmptyBatchRequest().SetAction(search.Action(\"updateObject\")).SetBody(map[string]any{\"key\": \"value\"})}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "batchAssignUserIds": {
      "default": "response, err := client.BatchAssignUserIds(client.NewApiBatchAssignUserIdsRequest(\n  \"userID\",\n  search.NewEmptyBatchAssignUserIdsParams().SetCluster(\"theCluster\").SetUsers(\n    []string{\"user1\", \"user2\"}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "batchDictionaryEntries": {
      "replace": "response, err := client.BatchDictionaryEntries(client.NewApiBatchDictionaryEntriesRequest(\n  search.DictionaryType(\"plurals\"),\n  search.NewEmptyBatchDictionaryEntriesParams().SetClearExistingDictionaryEntries(true).SetRequests(\n    []search.BatchDictionaryEntriesRequest{*search.NewEmptyBatchDictionaryEntriesRequest().SetAction(search.DictionaryAction(\"addEntry\")).SetBody(\n      search.NewEmptyDictionaryEntry().SetObjectID(\"1\").SetLanguage(search.SupportedLanguage(\"en\")).SetWord(\"fancy\").SetWords(\n        []string{\"believe\", \"algolia\"}).SetDecomposition(\n        []string{\"trust\", \"algolia\"}).SetState(search.DictionaryEntryState(\"enabled\")))}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "delete": "response, err := client.BatchDictionaryEntries(client.NewApiBatchDictionaryEntriesRequest(\n  search.DictionaryType(\"plurals\"),\n  search.NewEmptyBatchDictionaryEntriesParams().SetClearExistingDictionaryEntries(true).SetRequests(\n    []search.BatchDictionaryEntriesRequest{*search.NewEmptyBatchDictionaryEntriesRequest().SetAction(search.DictionaryAction(\"deleteEntry\")).SetBody(\n      search.NewEmptyDictionaryEntry().SetObjectID(\"1\"))}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "append": "response, err := client.BatchDictionaryEntries(client.NewApiBatchDictionaryEntriesRequest(\n  search.DictionaryType(\"stopwords\"),\n  search.NewEmptyBatchDictionaryEntriesParams().SetRequests(\n    []search.BatchDictionaryEntriesRequest{*search.NewEmptyBatchDictionaryEntriesRequest().SetAction(search.DictionaryAction(\"addEntry\")).SetBody(\n      search.NewEmptyDictionaryEntry().SetObjectID(\"1\").SetLanguage(search.SupportedLanguage(\"en\")).SetAdditionalProperty(\"additional\", \"try me\"))}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "browse": {
      "default": "response, err := client.Browse(client.NewApiBrowseRequest(\n  \"<YOUR_INDEX_NAME>\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "clearObjects": {
      "default": "response, err := client.ClearObjects(client.NewApiClearObjectsRequest(\n  \"<YOUR_INDEX_NAME>\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "clearRules": {
      "default": "response, err := client.ClearRules(client.NewApiClearRulesRequest(\n  \"<YOUR_INDEX_NAME>\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "clearSynonyms": {
      "default": "response, err := client.ClearSynonyms(client.NewApiClearSynonymsRequest(\n  \"<YOUR_INDEX_NAME>\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "customDelete": {
      "default": "response, err := client.CustomDelete(client.NewApiCustomDeleteRequest(\n  \"test/minimal\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "customGet": {
      "default": "response, err := client.CustomGet(client.NewApiCustomGetRequest(\n  \"test/minimal\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "customPost": {
      "default": "response, err := client.CustomPost(client.NewApiCustomPostRequest(\n  \"test/minimal\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "customPut": {
      "default": "response, err := client.CustomPut(client.NewApiCustomPutRequest(\n  \"test/minimal\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "deleteApiKey": {
      "default": "response, err := client.DeleteApiKey(client.NewApiDeleteApiKeyRequest(\n  \"myTestApiKey\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "deleteBy": {
      "default": "response, err := client.DeleteBy(client.NewApiDeleteByRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyDeleteByParams().SetFilters(\"brand:brandName\"),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "deleteIndex": {
      "default": "response, err := client.DeleteIndex(client.NewApiDeleteIndexRequest(\n  \"<YOUR_INDEX_NAME>\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "deleteObject": {
      "default": "response, err := client.DeleteObject(client.NewApiDeleteObjectRequest(\n  \"<YOUR_INDEX_NAME>\", \"uniqueID\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "deleteObjects": {
      "default": "response, err := client.DeleteObjects(\n  \"<YOUR_INDEX_NAME>\",\n  []string{\"1\", \"2\"},\n)\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "deleteRule": {
      "default": "response, err := client.DeleteRule(client.NewApiDeleteRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"id1\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "deleteSource": {
      "default": "response, err := client.DeleteSource(client.NewApiDeleteSourceRequest(\n  \"theSource\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "deleteSynonym": {
      "default": "response, err := client.DeleteSynonym(client.NewApiDeleteSynonymRequest(\n  \"<YOUR_INDEX_NAME>\", \"id1\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "generateSecuredApiKey": {
      "generate secured api key basic": "response, err := client.GenerateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  search.NewEmptySecuredApiKeyRestrictions().SetValidUntil(2524604400).SetRestrictIndices(\n    []string{\"Movies\"}),\n)\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "generate secured api key with searchParams": "response, err := client.GenerateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  search.NewEmptySecuredApiKeyRestrictions().SetValidUntil(2524604400).SetRestrictIndices(\n    []string{\"Movies\", \"cts_e2e_settings\"}).SetRestrictSources(\"192.168.1.0/24\").SetFilters(\"category:Book OR category:Ebook AND _tags:published\").SetUserToken(\"user123\").SetSearchParams(\n    search.NewEmptySearchParamsObject().SetQuery(\"batman\").SetTypoTolerance(search.TypoToleranceEnumAsTypoTolerance(search.TypoToleranceEnum(\"strict\"))).SetAroundRadius(search.AroundRadiusAllAsAroundRadius(search.AroundRadiusAll(\"all\"))).SetMode(search.Mode(\"neuralSearch\")).SetHitsPerPage(10).SetOptionalWords(\n      []string{\"one\", \"two\"})),\n)\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getApiKey": {
      "default": "response, err := client.GetApiKey(client.NewApiGetApiKeyRequest(\n  \"myTestApiKey\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getAppTask": {
      "default": "response, err := client.GetAppTask(client.NewApiGetAppTaskRequest(\n  123,\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getDictionaryLanguages": {
      "default": "response, err := client.GetDictionaryLanguages()\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getDictionarySettings": {
      "default": "response, err := client.GetDictionarySettings()\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getLogs": {
      "default": "response, err := client.GetLogs(client.NewApiGetLogsRequest())\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getObject": {
      "default": "response, err := client.GetObject(client.NewApiGetObjectRequest(\n  \"<YOUR_INDEX_NAME>\", \"uniqueID\",\n).WithAttributesToRetrieve(\n  []string{\"attr1\", \"attr2\"}))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getObjects": {
      "default": "response, err := client.GetObjects(client.NewApiGetObjectsRequest(\n\n  search.NewEmptyGetObjectsParams().SetRequests(\n    []search.GetObjectsRequest{*search.NewEmptyGetObjectsRequest().SetAttributesToRetrieve(\n      []string{\"attr1\", \"attr2\"}).SetObjectID(\"uniqueID\").SetIndexName(\"<YOUR_INDEX_NAME>\")}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getRule": {
      "default": "response, err := client.GetRule(client.NewApiGetRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"qr-1725004648916\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getSettings": {
      "default": "response, err := client.GetSettings(client.NewApiGetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getSources": {
      "default": "response, err := client.GetSources()\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getSynonym": {
      "default": "response, err := client.GetSynonym(client.NewApiGetSynonymRequest(\n  \"<YOUR_INDEX_NAME>\", \"id1\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getTask": {
      "default": "response, err := client.GetTask(client.NewApiGetTaskRequest(\n  \"<YOUR_INDEX_NAME>\", 123,\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getTopUserIds": {
      "default": "response, err := client.GetTopUserIds()\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "getUserId": {
      "default": "response, err := client.GetUserId(client.NewApiGetUserIdRequest(\n  \"uniqueID\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "hasPendingMappings": {
      "default": "response, err := client.HasPendingMappings(client.NewApiHasPendingMappingsRequest())\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "indexExists": {
      "indexExists": "response, err := client.IndexExists(\n  \"<YOUR_INDEX_NAME>\",\n)\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "indexNotExists": "response, err := client.IndexExists(\n  \"<YOUR_INDEX_NAME>\",\n)\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "indexExistsWithError": "response, err := client.IndexExists(\n  \"<YOUR_INDEX_NAME>\",\n)\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "listApiKeys": {
      "default": "response, err := client.ListApiKeys()\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "listClusters": {
      "default": "response, err := client.ListClusters()\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "listIndices": {
      "default": "response, err := client.ListIndices(client.NewApiListIndicesRequest())\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "listUserIds": {
      "default": "response, err := client.ListUserIds(client.NewApiListUserIdsRequest())\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "multipleBatch": {
      "default": "response, err := client.MultipleBatch(client.NewApiMultipleBatchRequest(\n\n  search.NewEmptyBatchParams().SetRequests(\n    []search.MultipleBatchRequest{*search.NewEmptyMultipleBatchRequest().SetAction(search.Action(\"addObject\")).SetBody(map[string]any{\"key\": \"value\"}).SetIndexName(\"<YOUR_INDEX_NAME>\")}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "operationIndex": {
      "scopes": "response, err := client.OperationIndex(client.NewApiOperationIndexRequest(\n  \"<SOURCE_INDEX_NAME>\",\n  search.NewEmptyOperationIndexParams().SetOperation(search.OperationType(\"move\")).SetDestination(\"<DESTINATION_INDEX_NAME>\").SetScope(\n    []search.ScopeType{search.ScopeType(\"rules\"), search.ScopeType(\"settings\")}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "copy": "response, err := client.OperationIndex(client.NewApiOperationIndexRequest(\n  \"<SOURCE_INDEX_NAME>\",\n  search.NewEmptyOperationIndexParams().SetOperation(search.OperationType(\"copy\")).SetDestination(\"<DESTINATION_INDEX_NAME>\"),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "move": "response, err := client.OperationIndex(client.NewApiOperationIndexRequest(\n  \"<SOURCE_INDEX_NAME>\",\n  search.NewEmptyOperationIndexParams().SetOperation(search.OperationType(\"move\")).SetDestination(\"<DESTINATION_INDEX_NAME>\"),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "partialUpdateObject": {
      "default": "response, err := client.PartialUpdateObject(client.NewApiPartialUpdateObjectRequest(\n  \"<YOUR_INDEX_NAME>\", \"uniqueID\", map[string]any{\"attributeId\": \"new value\"},\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "response, err := client.PartialUpdateObjects(\n  \"<YOUR_INDEX_NAME>\",\n  []map[string]any{map[string]any{\"objectID\": \"1\", \"name\": \"Adam\"}, map[string]any{\"objectID\": \"2\", \"name\": \"Benoit\"}},\n  search.WithCreateIfNotExists(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "call partialUpdateObjects with createIfNotExists=false": "response, err := client.PartialUpdateObjects(\n  \"<YOUR_INDEX_NAME>\",\n  []map[string]any{map[string]any{\"objectID\": \"3\", \"name\": \"Cyril\"}, map[string]any{\"objectID\": \"4\", \"name\": \"David\"}},\n  search.WithCreateIfNotExists(false))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "removeUserId": {
      "default": "response, err := client.RemoveUserId(client.NewApiRemoveUserIdRequest(\n  \"uniqueID\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "replaceAllObjects": {
      "default": "response, err := client.ReplaceAllObjects(\n  \"<YOUR_INDEX_NAME>\",\n  []map[string]any{map[string]any{\"objectID\": \"1\", \"name\": \"Adam\"}, map[string]any{\"objectID\": \"2\", \"name\": \"Benoit\"}, map[string]any{\"objectID\": \"3\", \"name\": \"Cyril\"}, map[string]any{\"objectID\": \"4\", \"name\": \"David\"}, map[string]any{\"objectID\": \"5\", \"name\": \"Eva\"}, map[string]any{\"objectID\": \"6\", \"name\": \"Fiona\"}, map[string]any{\"objectID\": \"7\", \"name\": \"Gael\"}, map[string]any{\"objectID\": \"8\", \"name\": \"Hugo\"}, map[string]any{\"objectID\": \"9\", \"name\": \"Igor\"}, map[string]any{\"objectID\": \"10\", \"name\": \"Julia\"}},\n  search.WithBatchSize(3))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "replaceSources": {
      "default": "response, err := client.ReplaceSources(client.NewApiReplaceSourcesRequest(\n\n  []search.Source{*search.NewEmptySource().SetSource(\"theSource\").SetDescription(\"theDescription\")},\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "restoreApiKey": {
      "default": "response, err := client.RestoreApiKey(client.NewApiRestoreApiKeyRequest(\n  \"ALGOLIA_API_KEY\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "saveObject": {
      "default": "response, err := client.SaveObject(client.NewApiSaveObjectRequest(\n  \"<YOUR_INDEX_NAME>\", map[string]any{\"objectID\": \"id\", \"test\": \"val\"},\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "saveObjects": {
      "call saveObjects without error": "response, err := client.SaveObjects(\n  \"<YOUR_INDEX_NAME>\",\n  []map[string]any{map[string]any{\"objectID\": \"1\", \"name\": \"Adam\"}, map[string]any{\"objectID\": \"2\", \"name\": \"Benoit\"}},\n)\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "saveObjects should report errors": "response, err := client.SaveObjects(\n  \"<YOUR_INDEX_NAME>\",\n  []map[string]any{map[string]any{\"objectID\": \"1\", \"name\": \"Adam\"}, map[string]any{\"objectID\": \"2\", \"name\": \"Benoit\"}},\n)\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "saveRule": {
      "default": "response, err := client.SaveRule(client.NewApiSaveRuleRequest(\n  \"<YOUR_INDEX_NAME>\", \"id1\",\n  search.NewEmptyRule().SetObjectID(\"id1\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"apple\").SetAnchoring(search.Anchoring(\"contains\"))}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "saveRules": {
      "default": "response, err := client.SaveRules(client.NewApiSaveRulesRequest(\n  \"<YOUR_INDEX_NAME>\",\n  []search.Rule{*search.NewEmptyRule().SetObjectID(\"a-rule-id\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"smartphone\").SetAnchoring(search.Anchoring(\"contains\"))}), *search.NewEmptyRule().SetObjectID(\"a-second-rule-id\").SetConditions(\n    []search.Condition{*search.NewEmptyCondition().SetPattern(\"apple\").SetAnchoring(search.Anchoring(\"contains\"))})},\n).WithForwardToReplicas(false).WithClearExistingRules(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "saveSynonym": {
      "default": "response, err := client.SaveSynonym(client.NewApiSaveSynonymRequest(\n  \"<YOUR_INDEX_NAME>\", \"id1\",\n  search.NewEmptySynonymHit().SetObjectID(\"id1\").SetType(search.SynonymType(\"synonym\")).SetSynonyms(\n    []string{\"car\", \"vehicule\", \"auto\"}),\n).WithForwardToReplicas(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "saveSynonyms": {
      "default": "response, err := client.SaveSynonyms(client.NewApiSaveSynonymsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  []search.SynonymHit{*search.NewEmptySynonymHit().SetObjectID(\"id1\").SetType(search.SynonymType(\"synonym\")).SetSynonyms(\n    []string{\"car\", \"vehicule\", \"auto\"}), *search.NewEmptySynonymHit().SetObjectID(\"id2\").SetType(search.SynonymType(\"onewaysynonym\")).SetInput(\"iphone\").SetSynonyms(\n    []string{\"ephone\", \"aphone\", \"yphone\"})},\n).WithForwardToReplicas(true).WithReplaceExistingSynonyms(true))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "search": {
      "withHitsPerPage": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetQuery(\"<YOUR_QUERY>\").SetHitsPerPage(50))}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "filterOnly": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetQuery(\"<YOUR_QUERY>\").SetFilters(\"actor:Scarlett Johansson\"))}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "filterOr": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetQuery(\"<YOUR_QUERY>\").SetFilters(\"actor:Tom Cruise OR actor:Scarlett Johansson\"))}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "filterNot": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetQuery(\"<YOUR_QUERY>\").SetFilters(\"NOT actor:Nicolas Cage\"))}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "retrieveFacets": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetQuery(\"<YOUR_QUERY>\").SetFacets(\n        []string{\"author\", \"genre\"}))}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "retrieveFacetsWildcard": "response, err := client.Search(client.NewApiSearchRequest(\n\n  search.NewEmptySearchMethodParams().SetRequests(\n    []search.SearchQuery{*search.SearchForHitsAsSearchQuery(\n      search.NewEmptySearchForHits().SetIndexName(\"<YOUR_INDEX_NAME>\").SetQuery(\"<YOUR_QUERY>\").SetFacets(\n        []string{\"*\"}))}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "searchDictionaryEntries": {
      "default": "response, err := client.SearchDictionaryEntries(client.NewApiSearchDictionaryEntriesRequest(\n  search.DictionaryType(\"stopwords\"),\n  search.NewEmptySearchDictionaryEntriesParams().SetQuery(\"about\"),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "searchForFacetValues": {
      "default": "response, err := client.SearchForFacetValues(client.NewApiSearchForFacetValuesRequest(\n  \"<YOUR_INDEX_NAME>\", \"facetName\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "searchRules": {
      "default": "response, err := client.SearchRules(client.NewApiSearchRulesRequest(\n  \"<YOUR_INDEX_NAME>\",\n).WithSearchRulesParams(\n  search.NewEmptySearchRulesParams().SetQuery(\"zorro\")))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "searchSingleIndex": {
      "default": "response, err := client.SearchSingleIndex(client.NewApiSearchSingleIndexRequest(\n  \"<YOUR_INDEX_NAME>\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "searchSynonyms": {
      "default": "response, err := client.SearchSynonyms(client.NewApiSearchSynonymsRequest(\n  \"<YOUR_INDEX_NAME>\",\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "searchUserIds": {
      "default": "response, err := client.SearchUserIds(client.NewApiSearchUserIdsRequest(\n\n  search.NewEmptySearchUserIdsParams().SetQuery(\"test\").SetClusterName(\"theClusterName\").SetPage(5).SetHitsPerPage(10),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "setClientApiKey": {
      "default": "err = client.SetClientApiKey(\n  \"updated-api-key\",\n)\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "setDictionarySettings": {
      "default": "response, err := client.SetDictionarySettings(client.NewApiSetDictionarySettingsRequest(\n\n  search.NewEmptyDictionarySettingsParams().SetDisableStandardEntries(\n    search.NewEmptyStandardEntries().SetPlurals(map[string]bool{\"fr\": false, \"en\": false, \"ru\": true})),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "setSettings": {
      "default": "response, err := client.SetSettings(client.NewApiSetSettingsRequest(\n  \"<YOUR_INDEX_NAME>\",\n  search.NewEmptyIndexSettings().SetAttributesForFaceting(\n    []string{\"actor\", \"filterOnly(category)\", \"searchable(publisher)\"}),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "updateApiKey": {
      "default": "response, err := client.UpdateApiKey(client.NewApiUpdateApiKeyRequest(\n  \"ALGOLIA_API_KEY\",\n  search.NewEmptyApiKey().SetAcl(\n    []search.Acl{search.Acl(\"search\"), search.Acl(\"addObject\")}).SetValidity(300).SetMaxQueriesPerIPPerHour(100).SetMaxHitsPerQuery(20),\n))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "response, err := client.WaitForApiKey(\n  \"api-key-add-operation-test-go\", search.ApiKeyOperation(\"add\"),\n)\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "wait for api key - update": "response, err := client.WaitForApiKey(\n  \"api-key-update-operation-test-go\", search.ApiKeyOperation(\"update\"),\n  search.WithApiKey(\n    search.NewEmptyApiKey().SetDescription(\"my updated api key\").SetAcl(\n      []search.Acl{search.Acl(\"search\"), search.Acl(\"addObject\"), search.Acl(\"deleteObject\")}).SetIndexes(\n      []string{\"Movies\", \"Books\"}).SetReferers(\n      []string{\"*google.com\", \"*algolia.com\"}).SetValidity(305).SetMaxQueriesPerIPPerHour(95).SetMaxHitsPerQuery(20)))\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}",
      "wait for api key - delete": "response, err := client.WaitForApiKey(\n  \"api-key-delete-operation-test-go\", search.ApiKeyOperation(\"delete\"),\n)\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "waitForAppTask": {
      "default": "response, err := client.WaitForAppTask(\n  123,\n)\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "waitForTask": {
      "default": "response, err := client.WaitForTask(\n  \"<YOUR_INDEX_NAME>\", 123,\n)\nif err != nil {\n  // handle the eventual error\n  panic(err)\n}"
    },
    "init": {
      "default": "client, err := search.NewClient(\"ALGOLIA_APPLICATION_ID\", \"ALGOLIA_API_KEY\")\nif err != nil {\n  // The client can fail to initialize if you pass an invalid parameter.\n  panic(err)\n}"
    }
  },
  "java": {
    "import": {
      "default": "import com.algolia.api.SearchClient;\nimport com.algolia.model.search.*;"
    },
    "addApiKey": {
      "default": "client.addApiKey(\n  new ApiKey()\n    .setAcl(Arrays.asList(Acl.SEARCH, Acl.ADD_OBJECT))\n    .setDescription(\"my new api key\")\n    .setValidity(300)\n    .setMaxQueriesPerIPPerHour(100)\n    .setMaxHitsPerQuery(20)\n);"
    },
    "addOrUpdateObject": {
      "default": "client.addOrUpdateObject(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new HashMap() {\n    {\n      put(\"key\", \"value\");\n    }\n  }\n);"
    },
    "appendSource": {
      "default": "client.appendSource(new Source().setSource(\"theSource\").setDescription(\"theDescription\"));"
    },
    "assignUserId": {
      "default": "client.assignUserId(\"userID\", new AssignUserIdParams().setCluster(\"theCluster\"));"
    },
    "batch": {
      "addObject": "client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams()\n    .setRequests(\n      Arrays.asList(\n        new BatchRequest()\n          .setAction(Action.ADD_OBJECT)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"bar\");\n                put(\"foo\", \"1\");\n              }\n            }\n          ),\n        new BatchRequest()\n          .setAction(Action.ADD_OBJECT)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"baz\");\n                put(\"foo\", \"2\");\n              }\n            }\n          )\n      )\n    )\n);",
      "clear": "client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams()\n    .setRequests(\n      Arrays.asList(\n        new BatchRequest()\n          .setAction(Action.CLEAR)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"value\");\n              }\n            }\n          )\n      )\n    )\n);",
      "delete": "client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams()\n    .setRequests(\n      Arrays.asList(\n        new BatchRequest()\n          .setAction(Action.DELETE)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"value\");\n              }\n            }\n          )\n      )\n    )\n);",
      "deleteObject": "client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams()\n    .setRequests(\n      Arrays.asList(\n        new BatchRequest()\n          .setAction(Action.DELETE_OBJECT)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"value\");\n              }\n            }\n          )\n      )\n    )\n);",
      "partialUpdateObject": "client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams()\n    .setRequests(\n      Arrays.asList(\n        new BatchRequest()\n          .setAction(Action.PARTIAL_UPDATE_OBJECT)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"value\");\n              }\n            }\n          )\n      )\n    )\n);",
      "partialUpdateObjectNoCreate": "client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams()\n    .setRequests(\n      Arrays.asList(\n        new BatchRequest()\n          .setAction(Action.PARTIAL_UPDATE_OBJECT_NO_CREATE)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"value\");\n              }\n            }\n          )\n      )\n    )\n);",
      "updateObject": "client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  new BatchWriteParams()\n    .setRequests(\n      Arrays.asList(\n        new BatchRequest()\n          .setAction(Action.UPDATE_OBJECT)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"value\");\n              }\n            }\n          )\n      )\n    )\n);"
    },
    "batchAssignUserIds": {
      "default": "client.batchAssignUserIds(\"userID\", new BatchAssignUserIdsParams().setCluster(\"theCluster\").setUsers(Arrays.asList(\"user1\", \"user2\")));"
    },
    "batchDictionaryEntries": {
      "replace": "client.batchDictionaryEntries(\n  DictionaryType.PLURALS,\n  new BatchDictionaryEntriesParams()\n    .setClearExistingDictionaryEntries(true)\n    .setRequests(\n      Arrays.asList(\n        new BatchDictionaryEntriesRequest()\n          .setAction(DictionaryAction.ADD_ENTRY)\n          .setBody(\n            new DictionaryEntry()\n              .setObjectID(\"1\")\n              .setLanguage(SupportedLanguage.EN)\n              .setWord(\"fancy\")\n              .setWords(Arrays.asList(\"believe\", \"algolia\"))\n              .setDecomposition(Arrays.asList(\"trust\", \"algolia\"))\n              .setState(DictionaryEntryState.ENABLED)\n          )\n      )\n    )\n);",
      "delete": "client.batchDictionaryEntries(\n  DictionaryType.PLURALS,\n  new BatchDictionaryEntriesParams()\n    .setClearExistingDictionaryEntries(true)\n    .setRequests(\n      Arrays.asList(\n        new BatchDictionaryEntriesRequest().setAction(DictionaryAction.DELETE_ENTRY).setBody(new DictionaryEntry().setObjectID(\"1\"))\n      )\n    )\n);",
      "append": "client.batchDictionaryEntries(\n  DictionaryType.STOPWORDS,\n  new BatchDictionaryEntriesParams()\n    .setRequests(\n      Arrays.asList(\n        new BatchDictionaryEntriesRequest()\n          .setAction(DictionaryAction.ADD_ENTRY)\n          .setBody(\n            new DictionaryEntry().setObjectID(\"1\").setLanguage(SupportedLanguage.EN).setAdditionalProperty(\"additional\", \"try me\")\n          )\n      )\n    )\n);"
    },
    "browse": {
      "default": "client.browse(\"<YOUR_INDEX_NAME>\", Hit.class);"
    },
    "clearObjects": {
      "default": "client.clearObjects(\"<YOUR_INDEX_NAME>\");"
    },
    "clearRules": {
      "default": "client.clearRules(\"<YOUR_INDEX_NAME>\");"
    },
    "clearSynonyms": {
      "default": "client.clearSynonyms(\"<YOUR_INDEX_NAME>\");"
    },
    "customDelete": {
      "default": "client.customDelete(\"test/minimal\");"
    },
    "customGet": {
      "default": "client.customGet(\"test/minimal\");"
    },
    "customPost": {
      "default": "client.customPost(\"test/minimal\");"
    },
    "customPut": {
      "default": "client.customPut(\"test/minimal\");"
    },
    "deleteApiKey": {
      "default": "client.deleteApiKey(\"myTestApiKey\");"
    },
    "deleteBy": {
      "default": "client.deleteBy(\"<YOUR_INDEX_NAME>\", new DeleteByParams().setFilters(\"brand:brandName\"));"
    },
    "deleteIndex": {
      "default": "client.deleteIndex(\"<YOUR_INDEX_NAME>\");"
    },
    "deleteObject": {
      "default": "client.deleteObject(\"<YOUR_INDEX_NAME>\", \"uniqueID\");"
    },
    "deleteObjects": {
      "default": "client.deleteObjects(\"<YOUR_INDEX_NAME>\", Arrays.asList(\"1\", \"2\"));"
    },
    "deleteRule": {
      "default": "client.deleteRule(\"<YOUR_INDEX_NAME>\", \"id1\");"
    },
    "deleteSource": {
      "default": "client.deleteSource(\"theSource\");"
    },
    "deleteSynonym": {
      "default": "client.deleteSynonym(\"<YOUR_INDEX_NAME>\", \"id1\");"
    },
    "generateSecuredApiKey": {
      "generate secured api key basic": "client.generateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  new SecuredApiKeyRestrictions().setValidUntil(2524604400L).setRestrictIndices(Arrays.asList(\"Movies\"))\n);",
      "generate secured api key with searchParams": "client.generateSecuredApiKey(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  new SecuredApiKeyRestrictions()\n    .setValidUntil(2524604400L)\n    .setRestrictIndices(Arrays.asList(\"Movies\", \"cts_e2e_settings\"))\n    .setRestrictSources(\"192.168.1.0/24\")\n    .setFilters(\"category:Book OR category:Ebook AND _tags:published\")\n    .setUserToken(\"user123\")\n    .setSearchParams(\n      new SearchParamsObject()\n        .setQuery(\"batman\")\n        .setTypoTolerance(TypoToleranceEnum.STRICT)\n        .setAroundRadius(AroundRadiusAll.ALL)\n        .setMode(Mode.NEURAL_SEARCH)\n        .setHitsPerPage(10)\n        .setOptionalWords(Arrays.asList(\"one\", \"two\"))\n    )\n);"
    },
    "getApiKey": {
      "default": "client.getApiKey(\"myTestApiKey\");"
    },
    "getAppTask": {
      "default": "client.getAppTask(123L);"
    },
    "getDictionaryLanguages": {
      "default": "client.getDictionaryLanguages();"
    },
    "getDictionarySettings": {
      "default": "client.getDictionarySettings();"
    },
    "getLogs": {
      "default": "client.getLogs();"
    },
    "getObject": {
      "default": "client.getObject(\"<YOUR_INDEX_NAME>\", \"uniqueID\", Arrays.asList(\"attr1\", \"attr2\"));"
    },
    "getObjects": {
      "default": "client.getObjects(\n  new GetObjectsParams()\n    .setRequests(\n      Arrays.asList(\n        new GetObjectsRequest()\n          .setAttributesToRetrieve(Arrays.asList(\"attr1\", \"attr2\"))\n          .setObjectID(\"uniqueID\")\n          .setIndexName(\"<YOUR_INDEX_NAME>\")\n      )\n    ),\n  Hit.class\n);"
    },
    "getRule": {
      "default": "client.getRule(\"<YOUR_INDEX_NAME>\", \"qr-1725004648916\");"
    },
    "getSettings": {
      "default": "client.getSettings(\"<YOUR_INDEX_NAME>\");"
    },
    "getSources": {
      "default": "client.getSources();"
    },
    "getSynonym": {
      "default": "client.getSynonym(\"<YOUR_INDEX_NAME>\", \"id1\");"
    },
    "getTask": {
      "default": "client.getTask(\"<YOUR_INDEX_NAME>\", 123L);"
    },
    "getTopUserIds": {
      "default": "client.getTopUserIds();"
    },
    "getUserId": {
      "default": "client.getUserId(\"uniqueID\");"
    },
    "hasPendingMappings": {
      "default": "client.hasPendingMappings();"
    },
    "indexExists": {
      "indexExists": "client.indexExists(\"<YOUR_INDEX_NAME>\");",
      "indexNotExists": "client.indexExists(\"<YOUR_INDEX_NAME>\");",
      "indexExistsWithError": "client.indexExists(\"<YOUR_INDEX_NAME>\");"
    },
    "listApiKeys": {
      "default": "client.listApiKeys();"
    },
    "listClusters": {
      "default": "client.listClusters();"
    },
    "listIndices": {
      "default": "client.listIndices();"
    },
    "listUserIds": {
      "default": "client.listUserIds();"
    },
    "multipleBatch": {
      "default": "client.multipleBatch(\n  new BatchParams()\n    .setRequests(\n      Arrays.asList(\n        new MultipleBatchRequest()\n          .setAction(Action.ADD_OBJECT)\n          .setBody(\n            new HashMap() {\n              {\n                put(\"key\", \"value\");\n              }\n            }\n          )\n          .setIndexName(\"<YOUR_INDEX_NAME>\")\n      )\n    )\n);"
    },
    "operationIndex": {
      "scopes": "client.operationIndex(\n  \"<SOURCE_INDEX_NAME>\",\n  new OperationIndexParams()\n    .setOperation(OperationType.MOVE)\n    .setDestination(\"<DESTINATION_INDEX_NAME>\")\n    .setScope(Arrays.asList(ScopeType.RULES, ScopeType.SETTINGS))\n);",
      "copy": "client.operationIndex(\n  \"<SOURCE_INDEX_NAME>\",\n  new OperationIndexParams().setOperation(OperationType.COPY).setDestination(\"<DESTINATION_INDEX_NAME>\")\n);",
      "move": "client.operationIndex(\n  \"<SOURCE_INDEX_NAME>\",\n  new OperationIndexParams().setOperation(OperationType.MOVE).setDestination(\"<DESTINATION_INDEX_NAME>\")\n);"
    },
    "partialUpdateObject": {
      "default": "client.partialUpdateObject(\n  \"<YOUR_INDEX_NAME>\",\n  \"uniqueID\",\n  new HashMap() {\n    {\n      put(\"attributeId\", \"new value\");\n    }\n  }\n);"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "client.partialUpdateObjects(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new HashMap() {\n      {\n        put(\"objectID\", \"1\");\n        put(\"name\", \"Adam\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"2\");\n        put(\"name\", \"Benoit\");\n      }\n    }\n  ),\n  true\n);",
      "call partialUpdateObjects with createIfNotExists=false": "client.partialUpdateObjects(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new HashMap() {\n      {\n        put(\"objectID\", \"3\");\n        put(\"name\", \"Cyril\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"4\");\n        put(\"name\", \"David\");\n      }\n    }\n  ),\n  false\n);"
    },
    "removeUserId": {
      "default": "client.removeUserId(\"uniqueID\");"
    },
    "replaceAllObjects": {
      "default": "client.replaceAllObjects(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new HashMap() {\n      {\n        put(\"objectID\", \"1\");\n        put(\"name\", \"Adam\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"2\");\n        put(\"name\", \"Benoit\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"3\");\n        put(\"name\", \"Cyril\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"4\");\n        put(\"name\", \"David\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"5\");\n        put(\"name\", \"Eva\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"6\");\n        put(\"name\", \"Fiona\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"7\");\n        put(\"name\", \"Gael\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"8\");\n        put(\"name\", \"Hugo\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"9\");\n        put(\"name\", \"Igor\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"10\");\n        put(\"name\", \"Julia\");\n      }\n    }\n  ),\n  3\n);"
    },
    "replaceSources": {
      "default": "client.replaceSources(Arrays.asList(new Source().setSource(\"theSource\").setDescription(\"theDescription\")));"
    },
    "restoreApiKey": {
      "default": "client.restoreApiKey(\"ALGOLIA_API_KEY\");"
    },
    "saveObject": {
      "default": "client.saveObject(\n  \"<YOUR_INDEX_NAME>\",\n  new HashMap() {\n    {\n      put(\"objectID\", \"id\");\n      put(\"test\", \"val\");\n    }\n  }\n);"
    },
    "saveObjects": {
      "call saveObjects without error": "client.saveObjects(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new HashMap() {\n      {\n        put(\"objectID\", \"1\");\n        put(\"name\", \"Adam\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"2\");\n        put(\"name\", \"Benoit\");\n      }\n    }\n  )\n);",
      "saveObjects should report errors": "client.saveObjects(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new HashMap() {\n      {\n        put(\"objectID\", \"1\");\n        put(\"name\", \"Adam\");\n      }\n    },\n    new HashMap() {\n      {\n        put(\"objectID\", \"2\");\n        put(\"name\", \"Benoit\");\n      }\n    }\n  )\n);"
    },
    "saveRule": {
      "default": "client.saveRule(\n  \"<YOUR_INDEX_NAME>\",\n  \"id1\",\n  new Rule().setObjectID(\"id1\").setConditions(Arrays.asList(new Condition().setPattern(\"apple\").setAnchoring(Anchoring.CONTAINS)))\n);"
    },
    "saveRules": {
      "default": "client.saveRules(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new Rule()\n      .setObjectID(\"a-rule-id\")\n      .setConditions(Arrays.asList(new Condition().setPattern(\"smartphone\").setAnchoring(Anchoring.CONTAINS))),\n    new Rule()\n      .setObjectID(\"a-second-rule-id\")\n      .setConditions(Arrays.asList(new Condition().setPattern(\"apple\").setAnchoring(Anchoring.CONTAINS)))\n  ),\n  false,\n  true\n);"
    },
    "saveSynonym": {
      "default": "client.saveSynonym(\n  \"<YOUR_INDEX_NAME>\",\n  \"id1\",\n  new SynonymHit().setObjectID(\"id1\").setType(SynonymType.SYNONYM).setSynonyms(Arrays.asList(\"car\", \"vehicule\", \"auto\")),\n  true\n);"
    },
    "saveSynonyms": {
      "default": "client.saveSynonyms(\n  \"<YOUR_INDEX_NAME>\",\n  Arrays.asList(\n    new SynonymHit().setObjectID(\"id1\").setType(SynonymType.SYNONYM).setSynonyms(Arrays.asList(\"car\", \"vehicule\", \"auto\")),\n    new SynonymHit()\n      .setObjectID(\"id2\")\n      .setType(SynonymType.ONEWAYSYNONYM)\n      .setInput(\"iphone\")\n      .setSynonyms(Arrays.asList(\"ephone\", \"aphone\", \"yphone\"))\n  ),\n  true,\n  true\n);"
    },
    "search": {
      "withHitsPerPage": "client.search(\n  new SearchMethodParams()\n    .setRequests(Arrays.asList(new SearchForHits().setIndexName(\"<YOUR_INDEX_NAME>\").setQuery(\"<YOUR_QUERY>\").setHitsPerPage(50))),\n  Hit.class\n);",
      "filterOnly": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(\n        new SearchForHits().setIndexName(\"<YOUR_INDEX_NAME>\").setQuery(\"<YOUR_QUERY>\").setFilters(\"actor:Scarlett Johansson\")\n      )\n    ),\n  Hit.class\n);",
      "filterOr": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(\n        new SearchForHits()\n          .setIndexName(\"<YOUR_INDEX_NAME>\")\n          .setQuery(\"<YOUR_QUERY>\")\n          .setFilters(\"actor:Tom Cruise OR actor:Scarlett Johansson\")\n      )\n    ),\n  Hit.class\n);",
      "filterNot": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(new SearchForHits().setIndexName(\"<YOUR_INDEX_NAME>\").setQuery(\"<YOUR_QUERY>\").setFilters(\"NOT actor:Nicolas Cage\"))\n    ),\n  Hit.class\n);",
      "retrieveFacets": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(\n        new SearchForHits().setIndexName(\"<YOUR_INDEX_NAME>\").setQuery(\"<YOUR_QUERY>\").setFacets(Arrays.asList(\"author\", \"genre\"))\n      )\n    ),\n  Hit.class\n);",
      "retrieveFacetsWildcard": "client.search(\n  new SearchMethodParams()\n    .setRequests(\n      Arrays.asList(new SearchForHits().setIndexName(\"<YOUR_INDEX_NAME>\").setQuery(\"<YOUR_QUERY>\").setFacets(Arrays.asList(\"*\")))\n    ),\n  Hit.class\n);"
    },
    "searchDictionaryEntries": {
      "default": "client.searchDictionaryEntries(DictionaryType.STOPWORDS, new SearchDictionaryEntriesParams().setQuery(\"about\"));"
    },
    "searchForFacetValues": {
      "default": "client.searchForFacetValues(\"<YOUR_INDEX_NAME>\", \"facetName\");"
    },
    "searchRules": {
      "default": "client.searchRules(\"<YOUR_INDEX_NAME>\", new SearchRulesParams().setQuery(\"zorro\"));"
    },
    "searchSingleIndex": {
      "default": "client.searchSingleIndex(\"<YOUR_INDEX_NAME>\", Hit.class);"
    },
    "searchSynonyms": {
      "default": "client.searchSynonyms(\"<YOUR_INDEX_NAME>\");"
    },
    "searchUserIds": {
      "default": "client.searchUserIds(new SearchUserIdsParams().setQuery(\"test\").setClusterName(\"theClusterName\").setPage(5).setHitsPerPage(10));"
    },
    "setClientApiKey": {
      "default": "client.setClientApiKey(\"updated-api-key\");"
    },
    "setDictionarySettings": {
      "default": "client.setDictionarySettings(\n  new DictionarySettingsParams()\n    .setDisableStandardEntries(\n      new StandardEntries()\n        .setPlurals(\n          new HashMap() {\n            {\n              put(\"fr\", false);\n              put(\"en\", false);\n              put(\"ru\", true);\n            }\n          }\n        )\n    )\n);"
    },
    "setSettings": {
      "default": "client.setSettings(\n  \"<YOUR_INDEX_NAME>\",\n  new IndexSettings().setAttributesForFaceting(Arrays.asList(\"actor\", \"filterOnly(category)\", \"searchable(publisher)\"))\n);"
    },
    "updateApiKey": {
      "default": "client.updateApiKey(\n  \"ALGOLIA_API_KEY\",\n  new ApiKey().setAcl(Arrays.asList(Acl.SEARCH, Acl.ADD_OBJECT)).setValidity(300).setMaxQueriesPerIPPerHour(100).setMaxHitsPerQuery(20)\n);"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "client.waitForApiKey(\"api-key-add-operation-test-java\", ApiKeyOperation.ADD);",
      "wait for api key - update": "client.waitForApiKey(\n  \"api-key-update-operation-test-java\",\n  ApiKeyOperation.UPDATE,\n  new ApiKey()\n    .setDescription(\"my updated api key\")\n    .setAcl(Arrays.asList(Acl.SEARCH, Acl.ADD_OBJECT, Acl.DELETE_OBJECT))\n    .setIndexes(Arrays.asList(\"Movies\", \"Books\"))\n    .setReferers(Arrays.asList(\"*google.com\", \"*algolia.com\"))\n    .setValidity(305)\n    .setMaxQueriesPerIPPerHour(95)\n    .setMaxHitsPerQuery(20)\n);",
      "wait for api key - delete": "client.waitForApiKey(\"api-key-delete-operation-test-java\", ApiKeyOperation.DELETE);"
    },
    "waitForAppTask": {
      "default": "client.waitForAppTask(123L);"
    },
    "waitForTask": {
      "default": "client.waitForTask(\"<YOUR_INDEX_NAME>\", 123L);"
    },
    "init": {
      "default": "SearchClient client = new SearchClient(\"ALGOLIA_APPLICATION_ID\", \"ALGOLIA_API_KEY\");"
    }
  },
  "javascript": {
    "import": {
      "default": "import { searchClient } from '@algolia/client-search';"
    },
    "addApiKey": {
      "default": "const response = await client.addApiKey({\n  acl: ['search', 'addObject'],\n  description: 'my new api key',\n  validity: 300,\n  maxQueriesPerIPPerHour: 100,\n  maxHitsPerQuery: 20,\n});"
    },
    "addOrUpdateObject": {
      "default": "const response = await client.addOrUpdateObject({\n  indexName: 'indexName',\n  objectID: 'uniqueID',\n  body: { key: 'value' },\n});"
    },
    "appendSource": {
      "default": "const response = await client.appendSource({ source: 'theSource', description: 'theDescription' });"
    },
    "assignUserId": {
      "default": "const response = await client.assignUserId({\n  xAlgoliaUserID: 'userID',\n  assignUserIdParams: { cluster: 'theCluster' },\n});"
    },
    "batch": {
      "addObject": "const response = await client.batch({\n  indexName: '<YOUR_INDEX_NAME>',\n  batchWriteParams: {\n    requests: [\n      { action: 'addObject', body: { key: 'bar', foo: '1' } },\n      { action: 'addObject', body: { key: 'baz', foo: '2' } },\n    ],\n  },\n});",
      "clear": "const response = await client.batch({\n  indexName: '<YOUR_INDEX_NAME>',\n  batchWriteParams: { requests: [{ action: 'clear', body: { key: 'value' } }] },\n});",
      "delete": "const response = await client.batch({\n  indexName: '<YOUR_INDEX_NAME>',\n  batchWriteParams: { requests: [{ action: 'delete', body: { key: 'value' } }] },\n});",
      "deleteObject": "const response = await client.batch({\n  indexName: '<YOUR_INDEX_NAME>',\n  batchWriteParams: { requests: [{ action: 'deleteObject', body: { key: 'value' } }] },\n});",
      "partialUpdateObject": "const response = await client.batch({\n  indexName: '<YOUR_INDEX_NAME>',\n  batchWriteParams: { requests: [{ action: 'partialUpdateObject', body: { key: 'value' } }] },\n});",
      "partialUpdateObjectNoCreate": "const response = await client.batch({\n  indexName: '<YOUR_INDEX_NAME>',\n  batchWriteParams: { requests: [{ action: 'partialUpdateObjectNoCreate', body: { key: 'value' } }] },\n});",
      "updateObject": "const response = await client.batch({\n  indexName: '<YOUR_INDEX_NAME>',\n  batchWriteParams: { requests: [{ action: 'updateObject', body: { key: 'value' } }] },\n});"
    },
    "batchAssignUserIds": {
      "default": "const response = await client.batchAssignUserIds({\n  xAlgoliaUserID: 'userID',\n  batchAssignUserIdsParams: { cluster: 'theCluster', users: ['user1', 'user2'] },\n});"
    },
    "batchDictionaryEntries": {
      "replace": "const response = await client.batchDictionaryEntries({\n  dictionaryName: 'plurals',\n  batchDictionaryEntriesParams: {\n    clearExistingDictionaryEntries: true,\n    requests: [\n      {\n        action: 'addEntry',\n        body: {\n          objectID: '1',\n          language: 'en',\n          word: 'fancy',\n          words: ['believe', 'algolia'],\n          decomposition: ['trust', 'algolia'],\n          state: 'enabled',\n        },\n      },\n    ],\n  },\n});",
      "delete": "const response = await client.batchDictionaryEntries({\n  dictionaryName: 'plurals',\n  batchDictionaryEntriesParams: {\n    clearExistingDictionaryEntries: true,\n    requests: [{ action: 'deleteEntry', body: { objectID: '1' } }],\n  },\n});",
      "append": "const response = await client.batchDictionaryEntries({\n  dictionaryName: 'stopwords',\n  batchDictionaryEntriesParams: {\n    requests: [{ action: 'addEntry', body: { objectID: '1', language: 'en', additional: 'try me' } }],\n  },\n});"
    },
    "browse": {
      "default": "const response = await client.browse({ indexName: 'cts_e2e_browse' });"
    },
    "clearObjects": {
      "default": "const response = await client.clearObjects({ indexName: 'theIndexName' });"
    },
    "clearRules": {
      "default": "const response = await client.clearRules({ indexName: 'indexName' });"
    },
    "clearSynonyms": {
      "default": "const response = await client.clearSynonyms({ indexName: 'indexName' });"
    },
    "customDelete": {
      "default": "const response = await client.customDelete({ path: 'test/minimal' });"
    },
    "customGet": {
      "default": "const response = await client.customGet({ path: 'test/minimal' });"
    },
    "customPost": {
      "default": "const response = await client.customPost({ path: 'test/minimal' });"
    },
    "customPut": {
      "default": "const response = await client.customPut({ path: 'test/minimal' });"
    },
    "deleteApiKey": {
      "default": "const response = await client.deleteApiKey({ key: 'myTestApiKey' });"
    },
    "deleteBy": {
      "default": "const response = await client.deleteBy({ indexName: 'theIndexName', deleteByParams: { filters: 'brand:brandName' } });"
    },
    "deleteIndex": {
      "default": "const response = await client.deleteIndex({ indexName: 'theIndexName' });"
    },
    "deleteObject": {
      "default": "const response = await client.deleteObject({ indexName: '<YOUR_INDEX_NAME>', objectID: 'uniqueID' });"
    },
    "deleteObjects": {
      "default": "const response = await client.deleteObjects({ indexName: 'cts_e2e_deleteObjects_javascript', objectIDs: ['1', '2'] });"
    },
    "deleteRule": {
      "default": "const response = await client.deleteRule({ indexName: 'indexName', objectID: 'id1' });"
    },
    "deleteSource": {
      "default": "const response = await client.deleteSource({ source: 'theSource' });"
    },
    "deleteSynonym": {
      "default": "const response = await client.deleteSynonym({ indexName: 'indexName', objectID: 'id1' });"
    },
    "generateSecuredApiKey": {
      "generate secured api key basic": "const response = client.generateSecuredApiKey({\n  parentApiKey: '2640659426d5107b6e47d75db9cbaef8',\n  restrictions: { validUntil: 2524604400, restrictIndices: ['Movies'] },\n});",
      "generate secured api key with searchParams": "const response = client.generateSecuredApiKey({\n  parentApiKey: '2640659426d5107b6e47d75db9cbaef8',\n  restrictions: {\n    validUntil: 2524604400,\n    restrictIndices: ['Movies', 'cts_e2e_settings'],\n    restrictSources: '192.168.1.0/24',\n    filters: 'category:Book OR category:Ebook AND _tags:published',\n    userToken: 'user123',\n    searchParams: {\n      query: 'batman',\n      typoTolerance: 'strict',\n      aroundRadius: 'all',\n      mode: 'neuralSearch',\n      hitsPerPage: 10,\n      optionalWords: ['one', 'two'],\n    },\n  },\n});"
    },
    "getApiKey": {
      "default": "const response = await client.getApiKey({ key: 'myTestApiKey' });"
    },
    "getAppTask": {
      "default": "const response = await client.getAppTask({ taskID: 123 });"
    },
    "getDictionaryLanguages": {
      "default": "const response = await client.getDictionaryLanguages();"
    },
    "getDictionarySettings": {
      "default": "const response = await client.getDictionarySettings();"
    },
    "getLogs": {
      "default": "const response = await client.getLogs();"
    },
    "getObject": {
      "default": "const response = await client.getObject({\n  indexName: 'theIndexName',\n  objectID: 'uniqueID',\n  attributesToRetrieve: ['attr1', 'attr2'],\n});"
    },
    "getObjects": {
      "default": "const response = await client.getObjects({\n  requests: [{ attributesToRetrieve: ['attr1', 'attr2'], objectID: 'uniqueID', indexName: 'theIndexName' }],\n});"
    },
    "getRule": {
      "default": "const response = await client.getRule({ indexName: 'cts_e2e_browse', objectID: 'qr-1725004648916' });"
    },
    "getSettings": {
      "default": "const response = await client.getSettings({ indexName: 'cts_e2e_settings' });"
    },
    "getSources": {
      "default": "const response = await client.getSources();"
    },
    "getSynonym": {
      "default": "const response = await client.getSynonym({ indexName: 'indexName', objectID: 'id1' });"
    },
    "getTask": {
      "default": "const response = await client.getTask({ indexName: 'theIndexName', taskID: 123 });"
    },
    "getTopUserIds": {
      "default": "const response = await client.getTopUserIds();"
    },
    "getUserId": {
      "default": "const response = await client.getUserId({ userID: 'uniqueID' });"
    },
    "hasPendingMappings": {
      "default": "const response = await client.hasPendingMappings();"
    },
    "indexExists": {
      "indexExists": "const response = await client.indexExists({ indexName: 'indexExistsYES' });",
      "indexNotExists": "const response = await client.indexExists({ indexName: 'indexExistsNO' });",
      "indexExistsWithError": "const response = await client.indexExists({ indexName: 'indexExistsERROR' });"
    },
    "listApiKeys": {
      "default": "const response = await client.listApiKeys();"
    },
    "listClusters": {
      "default": "const response = await client.listClusters();"
    },
    "listIndices": {
      "default": "const response = await client.listIndices();"
    },
    "listUserIds": {
      "default": "const response = await client.listUserIds();"
    },
    "multipleBatch": {
      "default": "const response = await client.multipleBatch({\n  requests: [{ action: 'addObject', body: { key: 'value' }, indexName: 'theIndexName' }],\n});"
    },
    "operationIndex": {
      "scopes": "const response = await client.operationIndex({\n  indexName: '<SOURCE_INDEX_NAME>',\n  operationIndexParams: { operation: 'move', destination: '<DESTINATION_INDEX_NAME>', scope: ['rules', 'settings'] },\n});",
      "copy": "const response = await client.operationIndex({\n  indexName: '<SOURCE_INDEX_NAME>',\n  operationIndexParams: { operation: 'copy', destination: '<DESTINATION_INDEX_NAME>' },\n});",
      "move": "const response = await client.operationIndex({\n  indexName: '<SOURCE_INDEX_NAME>',\n  operationIndexParams: { operation: 'move', destination: '<DESTINATION_INDEX_NAME>' },\n});"
    },
    "partialUpdateObject": {
      "default": "const response = await client.partialUpdateObject({\n  indexName: 'theIndexName',\n  objectID: 'uniqueID',\n  attributesToUpdate: { attributeId: 'new value' },\n});"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "const response = await client.partialUpdateObjects({\n  indexName: 'cts_e2e_partialUpdateObjects_javascript',\n  objects: [\n    { objectID: '1', name: 'Adam' },\n    { objectID: '2', name: 'Benoit' },\n  ],\n  createIfNotExists: true,\n});",
      "call partialUpdateObjects with createIfNotExists=false": "const response = await client.partialUpdateObjects({\n  indexName: 'cts_e2e_partialUpdateObjects_javascript',\n  objects: [\n    { objectID: '3', name: 'Cyril' },\n    { objectID: '4', name: 'David' },\n  ],\n  createIfNotExists: false,\n});"
    },
    "removeUserId": {
      "default": "const response = await client.removeUserId({ userID: 'uniqueID' });"
    },
    "replaceAllObjects": {
      "default": "const response = await client.replaceAllObjects({\n  indexName: 'cts_e2e_replace_all_objects_javascript',\n  objects: [\n    { objectID: '1', name: 'Adam' },\n    { objectID: '2', name: 'Benoit' },\n    { objectID: '3', name: 'Cyril' },\n    { objectID: '4', name: 'David' },\n    { objectID: '5', name: 'Eva' },\n    { objectID: '6', name: 'Fiona' },\n    { objectID: '7', name: 'Gael' },\n    { objectID: '8', name: 'Hugo' },\n    { objectID: '9', name: 'Igor' },\n    { objectID: '10', name: 'Julia' },\n  ],\n  batchSize: 3,\n});"
    },
    "replaceSources": {
      "default": "const response = await client.replaceSources({ source: [{ source: 'theSource', description: 'theDescription' }] });"
    },
    "restoreApiKey": {
      "default": "const response = await client.restoreApiKey({ key: 'ALGOLIA_API_KEY' });"
    },
    "saveObject": {
      "default": "const response = await client.saveObject({ indexName: '<YOUR_INDEX_NAME>', body: { objectID: 'id', test: 'val' } });"
    },
    "saveObjects": {
      "call saveObjects without error": "const response = await client.saveObjects({\n  indexName: 'cts_e2e_saveObjects_javascript',\n  objects: [\n    { objectID: '1', name: 'Adam' },\n    { objectID: '2', name: 'Benoit' },\n  ],\n});",
      "saveObjects should report errors": "const response = await client.saveObjects({\n  indexName: 'cts_e2e_saveObjects_javascript',\n  objects: [\n    { objectID: '1', name: 'Adam' },\n    { objectID: '2', name: 'Benoit' },\n  ],\n});"
    },
    "saveRule": {
      "default": "const response = await client.saveRule({\n  indexName: 'indexName',\n  objectID: 'id1',\n  rule: { objectID: 'id1', conditions: [{ pattern: 'apple', anchoring: 'contains' }] },\n});"
    },
    "saveRules": {
      "default": "const response = await client.saveRules({\n  indexName: '<YOUR_INDEX_NAME>',\n  rules: [\n    { objectID: 'a-rule-id', conditions: [{ pattern: 'smartphone', anchoring: 'contains' }] },\n    { objectID: 'a-second-rule-id', conditions: [{ pattern: 'apple', anchoring: 'contains' }] },\n  ],\n  forwardToReplicas: false,\n  clearExistingRules: true,\n});"
    },
    "saveSynonym": {
      "default": "const response = await client.saveSynonym({\n  indexName: 'indexName',\n  objectID: 'id1',\n  synonymHit: { objectID: 'id1', type: 'synonym', synonyms: ['car', 'vehicule', 'auto'] },\n  forwardToReplicas: true,\n});"
    },
    "saveSynonyms": {
      "default": "const response = await client.saveSynonyms({\n  indexName: '<YOUR_INDEX_NAME>',\n  synonymHit: [\n    { objectID: 'id1', type: 'synonym', synonyms: ['car', 'vehicule', 'auto'] },\n    { objectID: 'id2', type: 'onewaysynonym', input: 'iphone', synonyms: ['ephone', 'aphone', 'yphone'] },\n  ],\n  forwardToReplicas: true,\n  replaceExistingSynonyms: true,\n});"
    },
    "search": {
      "withHitsPerPage": "const response = await client.search({\n  requests: [{ indexName: '<YOUR_INDEX_NAME>', query: '<YOUR_QUERY>', hitsPerPage: 50 }],\n});",
      "filterOnly": "const response = await client.search({\n  requests: [{ indexName: '<YOUR_INDEX_NAME>', query: '<YOUR_QUERY>', filters: 'actor:Scarlett Johansson' }],\n});",
      "filterOr": "const response = await client.search({\n  requests: [\n    {\n      indexName: '<YOUR_INDEX_NAME>',\n      query: '<YOUR_QUERY>',\n      filters: 'actor:Tom Cruise OR actor:Scarlett Johansson',\n    },\n  ],\n});",
      "filterNot": "const response = await client.search({\n  requests: [{ indexName: '<YOUR_INDEX_NAME>', query: '<YOUR_QUERY>', filters: 'NOT actor:Nicolas Cage' }],\n});",
      "retrieveFacets": "const response = await client.search({\n  requests: [{ indexName: '<YOUR_INDEX_NAME>', query: '<YOUR_QUERY>', facets: ['author', 'genre'] }],\n});",
      "retrieveFacetsWildcard": "const response = await client.search({\n  requests: [{ indexName: '<YOUR_INDEX_NAME>', query: '<YOUR_QUERY>', facets: ['*'] }],\n});"
    },
    "searchDictionaryEntries": {
      "default": "const response = await client.searchDictionaryEntries({\n  dictionaryName: 'stopwords',\n  searchDictionaryEntriesParams: { query: 'about' },\n});"
    },
    "searchForFacetValues": {
      "default": "const response = await client.searchForFacetValues({ indexName: 'indexName', facetName: 'facetName' });"
    },
    "searchRules": {
      "default": "const response = await client.searchRules({ indexName: 'cts_e2e_browse', searchRulesParams: { query: 'zorro' } });"
    },
    "searchSingleIndex": {
      "default": "const response = await client.searchSingleIndex({ indexName: 'indexName' });"
    },
    "searchSynonyms": {
      "default": "const response = await client.searchSynonyms({ indexName: 'indexName' });"
    },
    "searchUserIds": {
      "default": "const response = await client.searchUserIds({\n  query: 'test',\n  clusterName: 'theClusterName',\n  page: 5,\n  hitsPerPage: 10,\n});"
    },
    "setClientApiKey": {
      "default": "client.setClientApiKey({ apiKey: 'updated-api-key' });"
    },
    "setDictionarySettings": {
      "default": "const response = await client.setDictionarySettings({\n  disableStandardEntries: { plurals: { fr: false, en: false, ru: true } },\n});"
    },
    "setSettings": {
      "default": "const response = await client.setSettings({\n  indexName: '<YOUR_INDEX_NAME>',\n  indexSettings: { attributesForFaceting: ['actor', 'filterOnly(category)', 'searchable(publisher)'] },\n});"
    },
    "updateApiKey": {
      "default": "const response = await client.updateApiKey({\n  key: 'ALGOLIA_API_KEY',\n  apiKey: { acl: ['search', 'addObject'], validity: 300, maxQueriesPerIPPerHour: 100, maxHitsPerQuery: 20 },\n});"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "const response = await client.waitForApiKey({ key: 'api-key-add-operation-test-javascript', operation: 'add' });",
      "wait for api key - update": "const response = await client.waitForApiKey({\n  key: 'api-key-update-operation-test-javascript',\n  operation: 'update',\n  apiKey: {\n    description: 'my updated api key',\n    acl: ['search', 'addObject', 'deleteObject'],\n    indexes: ['Movies', 'Books'],\n    referers: ['*google.com', '*algolia.com'],\n    validity: 305,\n    maxQueriesPerIPPerHour: 95,\n    maxHitsPerQuery: 20,\n  },\n});",
      "wait for api key - delete": "const response = await client.waitForApiKey({ key: 'api-key-delete-operation-test-javascript', operation: 'delete' });"
    },
    "waitForAppTask": {
      "default": "const response = await client.waitForAppTask({ taskID: 123 });"
    },
    "waitForTask": {
      "default": "const response = await client.waitForTask({ indexName: 'wait-task-javascript', taskID: 123 });"
    },
    "init": {
      "default": "//\nconst client = searchClient('ALGOLIA_APPLICATION_ID', 'ALGOLIA_API_KEY');"
    }
  },
  "kotlin": {
    "import": {
      "default": "import com.algolia.client.api.SearchClient\nimport com.algolia.client.extensions.*"
    },
    "addApiKey": {
      "default": "var response = client.addApiKey(\n  apiKey = ApiKey(\n    acl = listOf(Acl.entries.first { it.value == \"search\" }, Acl.entries.first { it.value == \"addObject\" }),\n    description = \"my new api key\",\n    validity = 300,\n    maxQueriesPerIPPerHour = 100,\n    maxHitsPerQuery = 20,\n  ),\n)"
    },
    "addOrUpdateObject": {
      "default": "var response = client.addOrUpdateObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\",\n  body = buildJsonObject {\n    put(\n      \"key\",\n      JsonPrimitive(\"value\"),\n    )\n  },\n)"
    },
    "appendSource": {
      "default": "var response = client.appendSource(\n  source = Source(\n    source = \"theSource\",\n    description = \"theDescription\",\n  ),\n)"
    },
    "assignUserId": {
      "default": "var response = client.assignUserId(\n  xAlgoliaUserID = \"userID\",\n  assignUserIdParams = AssignUserIdParams(\n    cluster = \"theCluster\",\n  ),\n)"
    },
    "batch": {
      "addObject": "var response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = listOf(\n      BatchRequest(\n        action = Action.entries.first { it.value == \"addObject\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"bar\"),\n          )\n          put(\n            \"foo\",\n            JsonPrimitive(\"1\"),\n          )\n        },\n      ),\n      BatchRequest(\n        action = Action.entries.first { it.value == \"addObject\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"baz\"),\n          )\n          put(\n            \"foo\",\n            JsonPrimitive(\"2\"),\n          )\n        },\n      ),\n    ),\n  ),\n)",
      "clear": "var response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = listOf(\n      BatchRequest(\n        action = Action.entries.first { it.value == \"clear\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"value\"),\n          )\n        },\n      ),\n    ),\n  ),\n)",
      "delete": "var response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = listOf(\n      BatchRequest(\n        action = Action.entries.first { it.value == \"delete\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"value\"),\n          )\n        },\n      ),\n    ),\n  ),\n)",
      "deleteObject": "var response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = listOf(\n      BatchRequest(\n        action = Action.entries.first { it.value == \"deleteObject\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"value\"),\n          )\n        },\n      ),\n    ),\n  ),\n)",
      "partialUpdateObject": "var response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = listOf(\n      BatchRequest(\n        action = Action.entries.first { it.value == \"partialUpdateObject\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"value\"),\n          )\n        },\n      ),\n    ),\n  ),\n)",
      "partialUpdateObjectNoCreate": "var response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = listOf(\n      BatchRequest(\n        action = Action.entries.first { it.value == \"partialUpdateObjectNoCreate\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"value\"),\n          )\n        },\n      ),\n    ),\n  ),\n)",
      "updateObject": "var response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = listOf(\n      BatchRequest(\n        action = Action.entries.first { it.value == \"updateObject\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"value\"),\n          )\n        },\n      ),\n    ),\n  ),\n)"
    },
    "batchAssignUserIds": {
      "default": "var response = client.batchAssignUserIds(\n  xAlgoliaUserID = \"userID\",\n  batchAssignUserIdsParams = BatchAssignUserIdsParams(\n    cluster = \"theCluster\",\n    users = listOf(\"user1\", \"user2\"),\n  ),\n)"
    },
    "batchDictionaryEntries": {
      "replace": "var response = client.batchDictionaryEntries(\n  dictionaryName = DictionaryType.entries.first { it.value == \"plurals\" },\n  batchDictionaryEntriesParams = BatchDictionaryEntriesParams(\n    clearExistingDictionaryEntries = true,\n    requests = listOf(\n      BatchDictionaryEntriesRequest(\n        action = DictionaryAction.entries.first { it.value == \"addEntry\" },\n        body = DictionaryEntry(\n          objectID = \"1\",\n          language = SupportedLanguage.entries.first { it.value == \"en\" },\n          word = \"fancy\",\n          words = listOf(\"believe\", \"algolia\"),\n          decomposition = listOf(\"trust\", \"algolia\"),\n          state = DictionaryEntryState.entries.first { it.value == \"enabled\" },\n        ),\n      ),\n    ),\n  ),\n)",
      "delete": "var response = client.batchDictionaryEntries(\n  dictionaryName = DictionaryType.entries.first { it.value == \"plurals\" },\n  batchDictionaryEntriesParams = BatchDictionaryEntriesParams(\n    clearExistingDictionaryEntries = true,\n    requests = listOf(\n      BatchDictionaryEntriesRequest(\n        action = DictionaryAction.entries.first { it.value == \"deleteEntry\" },\n        body = DictionaryEntry(\n          objectID = \"1\",\n        ),\n      ),\n    ),\n  ),\n)",
      "append": "var response = client.batchDictionaryEntries(\n  dictionaryName = DictionaryType.entries.first { it.value == \"stopwords\" },\n  batchDictionaryEntriesParams = BatchDictionaryEntriesParams(\n    requests = listOf(\n      BatchDictionaryEntriesRequest(\n        action = DictionaryAction.entries.first { it.value == \"addEntry\" },\n        body = DictionaryEntry(\n          objectID = \"1\",\n          language = SupportedLanguage.entries.first { it.value == \"en\" },\n          additionalProperties = mapOf(\n            \"additional\" to JsonPrimitive(\"try me\"),\n          ),\n        ),\n      ),\n    ),\n  ),\n)"
    },
    "browse": {
      "default": "var response = client.browse(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)"
    },
    "clearObjects": {
      "default": "var response = client.clearObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)"
    },
    "clearRules": {
      "default": "var response = client.clearRules(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)"
    },
    "clearSynonyms": {
      "default": "var response = client.clearSynonyms(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)"
    },
    "customDelete": {
      "default": "var response = client.customDelete(\n  path = \"test/minimal\",\n)"
    },
    "customGet": {
      "default": "var response = client.customGet(\n  path = \"test/minimal\",\n)"
    },
    "customPost": {
      "default": "var response = client.customPost(\n  path = \"test/minimal\",\n)"
    },
    "customPut": {
      "default": "var response = client.customPut(\n  path = \"test/minimal\",\n)"
    },
    "deleteApiKey": {
      "default": "var response = client.deleteApiKey(\n  key = \"myTestApiKey\",\n)"
    },
    "deleteBy": {
      "default": "var response = client.deleteBy(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  deleteByParams = DeleteByParams(\n    filters = \"brand:brandName\",\n  ),\n)"
    },
    "deleteIndex": {
      "default": "var response = client.deleteIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)"
    },
    "deleteObject": {
      "default": "var response = client.deleteObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\",\n)"
    },
    "deleteObjects": {
      "default": "var response = client.deleteObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectIDs = listOf(\"1\", \"2\"),\n)"
    },
    "deleteRule": {
      "default": "var response = client.deleteRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"id1\",\n)"
    },
    "deleteSource": {
      "default": "var response = client.deleteSource(\n  source = \"theSource\",\n)"
    },
    "deleteSynonym": {
      "default": "var response = client.deleteSynonym(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"id1\",\n)"
    },
    "generateSecuredApiKey": {
      "generate secured api key basic": "var response = client.generateSecuredApiKey(\n  parentApiKey = \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions = SecuredApiKeyRestrictions(\n    validUntil = 2524604400L,\n    restrictIndices = listOf(\"Movies\"),\n  ),\n)",
      "generate secured api key with searchParams": "var response = client.generateSecuredApiKey(\n  parentApiKey = \"2640659426d5107b6e47d75db9cbaef8\",\n  restrictions = SecuredApiKeyRestrictions(\n    validUntil = 2524604400L,\n    restrictIndices = listOf(\"Movies\", \"cts_e2e_settings\"),\n    restrictSources = \"192.168.1.0/24\",\n    filters = \"category:Book OR category:Ebook AND _tags:published\",\n    userToken = \"user123\",\n    searchParams = SearchParamsObject(\n      query = \"batman\",\n      typoTolerance = TypoToleranceEnum.entries.first { it.value == \"strict\" },\n      aroundRadius = AroundRadiusAll.entries.first { it.value == \"all\" },\n      mode = Mode.entries.first { it.value == \"neuralSearch\" },\n      hitsPerPage = 10,\n      optionalWords = listOf(\"one\", \"two\"),\n    ),\n  ),\n)"
    },
    "getApiKey": {
      "default": "var response = client.getApiKey(\n  key = \"myTestApiKey\",\n)"
    },
    "getAppTask": {
      "default": "var response = client.getAppTask(\n  taskID = 123L,\n)"
    },
    "getDictionaryLanguages": {
      "default": "var response = client.getDictionaryLanguages()"
    },
    "getDictionarySettings": {
      "default": "var response = client.getDictionarySettings()"
    },
    "getLogs": {
      "default": "var response = client.getLogs()"
    },
    "getObject": {
      "default": "var response = client.getObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\",\n  attributesToRetrieve = listOf(\"attr1\", \"attr2\"),\n)"
    },
    "getObjects": {
      "default": "var response = client.getObjects(\n  getObjectsParams = GetObjectsParams(\n    requests = listOf(\n      GetObjectsRequest(\n        attributesToRetrieve = listOf(\"attr1\", \"attr2\"),\n        objectID = \"uniqueID\",\n        indexName = \"<YOUR_INDEX_NAME>\",\n      ),\n    ),\n  ),\n)"
    },
    "getRule": {
      "default": "var response = client.getRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"qr-1725004648916\",\n)"
    },
    "getSettings": {
      "default": "var response = client.getSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)"
    },
    "getSources": {
      "default": "var response = client.getSources()"
    },
    "getSynonym": {
      "default": "var response = client.getSynonym(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"id1\",\n)"
    },
    "getTask": {
      "default": "var response = client.getTask(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  taskID = 123L,\n)"
    },
    "getTopUserIds": {
      "default": "var response = client.getTopUserIds()"
    },
    "getUserId": {
      "default": "var response = client.getUserId(\n  userID = \"uniqueID\",\n)"
    },
    "hasPendingMappings": {
      "default": "var response = client.hasPendingMappings()"
    },
    "indexExists": {
      "indexExists": "var response = client.indexExists(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)",
      "indexNotExists": "var response = client.indexExists(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)",
      "indexExistsWithError": "var response = client.indexExists(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)"
    },
    "listApiKeys": {
      "default": "var response = client.listApiKeys()"
    },
    "listClusters": {
      "default": "var response = client.listClusters()"
    },
    "listIndices": {
      "default": "var response = client.listIndices()"
    },
    "listUserIds": {
      "default": "var response = client.listUserIds()"
    },
    "multipleBatch": {
      "default": "var response = client.multipleBatch(\n  batchParams = BatchParams(\n    requests = listOf(\n      MultipleBatchRequest(\n        action = Action.entries.first { it.value == \"addObject\" },\n        body = buildJsonObject {\n          put(\n            \"key\",\n            JsonPrimitive(\"value\"),\n          )\n        },\n        indexName = \"<YOUR_INDEX_NAME>\",\n      ),\n    ),\n  ),\n)"
    },
    "operationIndex": {
      "scopes": "var response = client.operationIndex(\n  indexName = \"<SOURCE_INDEX_NAME>\",\n  operationIndexParams = OperationIndexParams(\n    operation = OperationType.entries.first { it.value == \"move\" },\n    destination = \"<DESTINATION_INDEX_NAME>\",\n    scope = listOf(ScopeType.entries.first { it.value == \"rules\" }, ScopeType.entries.first { it.value == \"settings\" }),\n  ),\n)",
      "copy": "var response = client.operationIndex(\n  indexName = \"<SOURCE_INDEX_NAME>\",\n  operationIndexParams = OperationIndexParams(\n    operation = OperationType.entries.first { it.value == \"copy\" },\n    destination = \"<DESTINATION_INDEX_NAME>\",\n  ),\n)",
      "move": "var response = client.operationIndex(\n  indexName = \"<SOURCE_INDEX_NAME>\",\n  operationIndexParams = OperationIndexParams(\n    operation = OperationType.entries.first { it.value == \"move\" },\n    destination = \"<DESTINATION_INDEX_NAME>\",\n  ),\n)"
    },
    "partialUpdateObject": {
      "default": "var response = client.partialUpdateObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\",\n  attributesToUpdate = buildJsonObject {\n    put(\n      \"attributeId\",\n      JsonPrimitive(\"new value\"),\n    )\n  },\n)"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "var response = client.partialUpdateObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objects = listOf(\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"1\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Adam\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"2\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Benoit\"),\n      )\n    },\n  ),\n  createIfNotExists = true,\n)",
      "call partialUpdateObjects with createIfNotExists=false": "var response = client.partialUpdateObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objects = listOf(\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"3\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Cyril\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"4\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"David\"),\n      )\n    },\n  ),\n  createIfNotExists = false,\n)"
    },
    "removeUserId": {
      "default": "var response = client.removeUserId(\n  userID = \"uniqueID\",\n)"
    },
    "replaceAllObjects": {
      "default": "var response = client.replaceAllObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objects = listOf(\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"1\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Adam\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"2\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Benoit\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"3\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Cyril\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"4\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"David\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"5\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Eva\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"6\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Fiona\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"7\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Gael\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"8\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Hugo\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"9\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Igor\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"10\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Julia\"),\n      )\n    },\n  ),\n  batchSize = 3,\n)"
    },
    "replaceSources": {
      "default": "var response = client.replaceSources(\n  source = listOf(\n    Source(\n      source = \"theSource\",\n      description = \"theDescription\",\n    ),\n  ),\n)"
    },
    "restoreApiKey": {
      "default": "var response = client.restoreApiKey(\n  key = \"ALGOLIA_API_KEY\",\n)"
    },
    "saveObject": {
      "default": "var response = client.saveObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  body = buildJsonObject {\n    put(\n      \"objectID\",\n      JsonPrimitive(\"id\"),\n    )\n    put(\n      \"test\",\n      JsonPrimitive(\"val\"),\n    )\n  },\n)"
    },
    "saveObjects": {
      "call saveObjects without error": "var response = client.saveObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objects = listOf(\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"1\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Adam\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"2\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Benoit\"),\n      )\n    },\n  ),\n)",
      "saveObjects should report errors": "var response = client.saveObjects(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objects = listOf(\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"1\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Adam\"),\n      )\n    },\n    buildJsonObject {\n      put(\n        \"objectID\",\n        JsonPrimitive(\"2\"),\n      )\n      put(\n        \"name\",\n        JsonPrimitive(\"Benoit\"),\n      )\n    },\n  ),\n)"
    },
    "saveRule": {
      "default": "var response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"id1\",\n  rule = Rule(\n    objectID = \"id1\",\n    conditions = listOf(\n      Condition(\n        pattern = \"apple\",\n        anchoring = Anchoring.entries.first { it.value == \"contains\" },\n      ),\n    ),\n  ),\n)"
    },
    "saveRules": {
      "default": "var response = client.saveRules(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  rules = listOf(\n    Rule(\n      objectID = \"a-rule-id\",\n      conditions = listOf(\n        Condition(\n          pattern = \"smartphone\",\n          anchoring = Anchoring.entries.first { it.value == \"contains\" },\n        ),\n      ),\n    ),\n    Rule(\n      objectID = \"a-second-rule-id\",\n      conditions = listOf(\n        Condition(\n          pattern = \"apple\",\n          anchoring = Anchoring.entries.first { it.value == \"contains\" },\n        ),\n      ),\n    ),\n  ),\n  forwardToReplicas = false,\n  clearExistingRules = true,\n)"
    },
    "saveSynonym": {
      "default": "var response = client.saveSynonym(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"id1\",\n  synonymHit = SynonymHit(\n    objectID = \"id1\",\n    type = SynonymType.entries.first { it.value == \"synonym\" },\n    synonyms = listOf(\"car\", \"vehicule\", \"auto\"),\n  ),\n  forwardToReplicas = true,\n)"
    },
    "saveSynonyms": {
      "default": "var response = client.saveSynonyms(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  synonymHit = listOf(\n    SynonymHit(\n      objectID = \"id1\",\n      type = SynonymType.entries.first { it.value == \"synonym\" },\n      synonyms = listOf(\"car\", \"vehicule\", \"auto\"),\n    ),\n    SynonymHit(\n      objectID = \"id2\",\n      type = SynonymType.entries.first { it.value == \"onewaysynonym\" },\n      input = \"iphone\",\n      synonyms = listOf(\"ephone\", \"aphone\", \"yphone\"),\n    ),\n  ),\n  forwardToReplicas = true,\n  replaceExistingSynonyms = true,\n)"
    },
    "search": {
      "withHitsPerPage": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = \"<YOUR_QUERY>\",\n        hitsPerPage = 50,\n      ),\n    ),\n  ),\n)",
      "filterOnly": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = \"<YOUR_QUERY>\",\n        filters = \"actor:Scarlett Johansson\",\n      ),\n    ),\n  ),\n)",
      "filterOr": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = \"<YOUR_QUERY>\",\n        filters = \"actor:Tom Cruise OR actor:Scarlett Johansson\",\n      ),\n    ),\n  ),\n)",
      "filterNot": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = \"<YOUR_QUERY>\",\n        filters = \"NOT actor:Nicolas Cage\",\n      ),\n    ),\n  ),\n)",
      "retrieveFacets": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = \"<YOUR_QUERY>\",\n        facets = listOf(\"author\", \"genre\"),\n      ),\n    ),\n  ),\n)",
      "retrieveFacetsWildcard": "var response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = listOf(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = \"<YOUR_QUERY>\",\n        facets = listOf(\"*\"),\n      ),\n    ),\n  ),\n)"
    },
    "searchDictionaryEntries": {
      "default": "var response = client.searchDictionaryEntries(\n  dictionaryName = DictionaryType.entries.first { it.value == \"stopwords\" },\n  searchDictionaryEntriesParams = SearchDictionaryEntriesParams(\n    query = \"about\",\n  ),\n)"
    },
    "searchForFacetValues": {
      "default": "var response = client.searchForFacetValues(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  facetName = \"facetName\",\n)"
    },
    "searchRules": {
      "default": "var response = client.searchRules(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchRulesParams = SearchRulesParams(\n    query = \"zorro\",\n  ),\n)"
    },
    "searchSingleIndex": {
      "default": "var response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)"
    },
    "searchSynonyms": {
      "default": "var response = client.searchSynonyms(\n  indexName = \"<YOUR_INDEX_NAME>\",\n)"
    },
    "searchUserIds": {
      "default": "var response = client.searchUserIds(\n  searchUserIdsParams = SearchUserIdsParams(\n    query = \"test\",\n    clusterName = \"theClusterName\",\n    page = 5,\n    hitsPerPage = 10,\n  ),\n)"
    },
    "setClientApiKey": {
      "default": "client.setClientApiKey(\n  apiKey = \"updated-api-key\",\n)"
    },
    "setDictionarySettings": {
      "default": "var response = client.setDictionarySettings(\n  dictionarySettingsParams = DictionarySettingsParams(\n    disableStandardEntries = StandardEntries(\n      plurals = mapOf(\"fr\" to false, \"en\" to false, \"ru\" to true),\n    ),\n  ),\n)"
    },
    "setSettings": {
      "default": "var response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesForFaceting = listOf(\"actor\", \"filterOnly(category)\", \"searchable(publisher)\"),\n  ),\n)"
    },
    "updateApiKey": {
      "default": "var response = client.updateApiKey(\n  key = \"ALGOLIA_API_KEY\",\n  apiKey = ApiKey(\n    acl = listOf(Acl.entries.first { it.value == \"search\" }, Acl.entries.first { it.value == \"addObject\" }),\n    validity = 300,\n    maxQueriesPerIPPerHour = 100,\n    maxHitsPerQuery = 20,\n  ),\n)"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "var response = client.waitForApiKey(\n  key = \"api-key-add-operation-test-kotlin\",\n  operation = ApiKeyOperation.entries.first { it.value == \"add\" },\n)",
      "wait for api key - update": "var response = client.waitForApiKey(\n  key = \"api-key-update-operation-test-kotlin\",\n  operation = ApiKeyOperation.entries.first { it.value == \"update\" },\n  apiKey = ApiKey(\n    description = \"my updated api key\",\n    acl = listOf(Acl.entries.first { it.value == \"search\" }, Acl.entries.first { it.value == \"addObject\" }, Acl.entries.first { it.value == \"deleteObject\" }),\n    indexes = listOf(\"Movies\", \"Books\"),\n    referers = listOf(\"*google.com\", \"*algolia.com\"),\n    validity = 305,\n    maxQueriesPerIPPerHour = 95,\n    maxHitsPerQuery = 20,\n  ),\n)",
      "wait for api key - delete": "var response = client.waitForApiKey(\n  key = \"api-key-delete-operation-test-kotlin\",\n  operation = ApiKeyOperation.entries.first { it.value == \"delete\" },\n)"
    },
    "waitForAppTask": {
      "default": "var response = client.waitForAppTask(\n  taskID = 123L,\n)"
    },
    "waitForTask": {
      "default": "var response = client.waitForTask(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  taskID = 123L,\n)"
    },
    "init": {
      "default": "val client = SearchClient(appId = \"ALGOLIA_APPLICATION_ID\", apiKey = \"ALGOLIA_API_KEY\")"
    }
  },
  "php": {
    "import": {
      "default": "use Algolia\\AlgoliaSearch\\Api\\SearchClient;"
    },
    "addApiKey": {
      "default": "$response = $client->addApiKey(\n    ['acl' => [\n        'search',\n\n        'addObject',\n    ],\n        'description' => 'my new api key',\n        'validity' => 300,\n        'maxQueriesPerIPPerHour' => 100,\n        'maxHitsPerQuery' => 20,\n    ],\n);"
    },
    "addOrUpdateObject": {
      "default": "$response = $client->addOrUpdateObject(\n    '<YOUR_INDEX_NAME>',\n    'uniqueID',\n    ['key' => 'value',\n    ],\n);"
    },
    "appendSource": {
      "default": "$response = $client->appendSource(\n    ['source' => 'theSource',\n        'description' => 'theDescription',\n    ],\n);"
    },
    "assignUserId": {
      "default": "$response = $client->assignUserId(\n    'userID',\n    ['cluster' => 'theCluster',\n    ],\n);"
    },
    "batch": {
      "addObject": "$response = $client->batch(\n    '<YOUR_INDEX_NAME>',\n    ['requests' => [\n        ['action' => 'addObject',\n            'body' => ['key' => 'bar',\n                'foo' => '1',\n            ],\n        ],\n\n        ['action' => 'addObject',\n            'body' => ['key' => 'baz',\n                'foo' => '2',\n            ],\n        ],\n    ],\n    ],\n);",
      "clear": "$response = $client->batch(\n    '<YOUR_INDEX_NAME>',\n    ['requests' => [\n        ['action' => 'clear',\n            'body' => ['key' => 'value',\n            ],\n        ],\n    ],\n    ],\n);",
      "delete": "$response = $client->batch(\n    '<YOUR_INDEX_NAME>',\n    ['requests' => [\n        ['action' => 'delete',\n            'body' => ['key' => 'value',\n            ],\n        ],\n    ],\n    ],\n);",
      "deleteObject": "$response = $client->batch(\n    '<YOUR_INDEX_NAME>',\n    ['requests' => [\n        ['action' => 'deleteObject',\n            'body' => ['key' => 'value',\n            ],\n        ],\n    ],\n    ],\n);",
      "partialUpdateObject": "$response = $client->batch(\n    '<YOUR_INDEX_NAME>',\n    ['requests' => [\n        ['action' => 'partialUpdateObject',\n            'body' => ['key' => 'value',\n            ],\n        ],\n    ],\n    ],\n);",
      "partialUpdateObjectNoCreate": "$response = $client->batch(\n    '<YOUR_INDEX_NAME>',\n    ['requests' => [\n        ['action' => 'partialUpdateObjectNoCreate',\n            'body' => ['key' => 'value',\n            ],\n        ],\n    ],\n    ],\n);",
      "updateObject": "$response = $client->batch(\n    '<YOUR_INDEX_NAME>',\n    ['requests' => [\n        ['action' => 'updateObject',\n            'body' => ['key' => 'value',\n            ],\n        ],\n    ],\n    ],\n);"
    },
    "batchAssignUserIds": {
      "default": "$response = $client->batchAssignUserIds(\n    'userID',\n    ['cluster' => 'theCluster',\n        'users' => [\n            'user1',\n\n            'user2',\n        ],\n    ],\n);"
    },
    "batchDictionaryEntries": {
      "replace": "$response = $client->batchDictionaryEntries(\n    'plurals',\n    ['clearExistingDictionaryEntries' => true,\n        'requests' => [\n            ['action' => 'addEntry',\n                'body' => ['objectID' => '1',\n                    'language' => 'en',\n                    'word' => 'fancy',\n                    'words' => [\n                        'believe',\n\n                        'algolia',\n                    ],\n                    'decomposition' => [\n                        'trust',\n\n                        'algolia',\n                    ],\n                    'state' => 'enabled',\n                ],\n            ],\n        ],\n    ],\n);",
      "delete": "$response = $client->batchDictionaryEntries(\n    'plurals',\n    ['clearExistingDictionaryEntries' => true,\n        'requests' => [\n            ['action' => 'deleteEntry',\n                'body' => ['objectID' => '1',\n                ],\n            ],\n        ],\n    ],\n);",
      "append": "$response = $client->batchDictionaryEntries(\n    'stopwords',\n    ['requests' => [\n        ['action' => 'addEntry',\n            'body' => ['objectID' => '1',\n                'language' => 'en',\n                'additional' => 'try me',\n            ],\n        ],\n    ],\n    ],\n);"
    },
    "browse": {
      "default": "$response = $client->browse(\n    '<YOUR_INDEX_NAME>',\n);"
    },
    "clearObjects": {
      "default": "$response = $client->clearObjects(\n    '<YOUR_INDEX_NAME>',\n);"
    },
    "clearRules": {
      "default": "$response = $client->clearRules(\n    '<YOUR_INDEX_NAME>',\n);"
    },
    "clearSynonyms": {
      "default": "$response = $client->clearSynonyms(\n    '<YOUR_INDEX_NAME>',\n);"
    },
    "customDelete": {
      "default": "$response = $client->customDelete(\n    'test/minimal',\n);"
    },
    "customGet": {
      "default": "$response = $client->customGet(\n    'test/minimal',\n);"
    },
    "customPost": {
      "default": "$response = $client->customPost(\n    'test/minimal',\n);"
    },
    "customPut": {
      "default": "$response = $client->customPut(\n    'test/minimal',\n);"
    },
    "deleteApiKey": {
      "default": "$response = $client->deleteApiKey(\n    'myTestApiKey',\n);"
    },
    "deleteBy": {
      "default": "$response = $client->deleteBy(\n    '<YOUR_INDEX_NAME>',\n    ['filters' => 'brand:brandName',\n    ],\n);"
    },
    "deleteIndex": {
      "default": "$response = $client->deleteIndex(\n    '<YOUR_INDEX_NAME>',\n);"
    },
    "deleteObject": {
      "default": "$response = $client->deleteObject(\n    '<YOUR_INDEX_NAME>',\n    'uniqueID',\n);"
    },
    "deleteObjects": {
      "default": "$response = $client->deleteObjects(\n    '<YOUR_INDEX_NAME>',\n    [\n        '1',\n\n        '2',\n    ],\n);"
    },
    "deleteRule": {
      "default": "$response = $client->deleteRule(\n    '<YOUR_INDEX_NAME>',\n    'id1',\n);"
    },
    "deleteSource": {
      "default": "$response = $client->deleteSource(\n    'theSource',\n);"
    },
    "deleteSynonym": {
      "default": "$response = $client->deleteSynonym(\n    '<YOUR_INDEX_NAME>',\n    'id1',\n);"
    },
    "generateSecuredApiKey": {
      "generate secured api key basic": "$response = $client->generateSecuredApiKey(\n    '2640659426d5107b6e47d75db9cbaef8',\n    ['validUntil' => 2524604400,\n        'restrictIndices' => [\n            'Movies',\n        ],\n    ],\n);",
      "generate secured api key with searchParams": "$response = $client->generateSecuredApiKey(\n    '2640659426d5107b6e47d75db9cbaef8',\n    ['validUntil' => 2524604400,\n        'restrictIndices' => [\n            'Movies',\n\n            'cts_e2e_settings',\n        ],\n        'restrictSources' => '192.168.1.0/24',\n        'filters' => 'category:Book OR category:Ebook AND _tags:published',\n        'userToken' => 'user123',\n        'searchParams' => ['query' => 'batman',\n            'typoTolerance' => 'strict',\n            'aroundRadius' => 'all',\n            'mode' => 'neuralSearch',\n            'hitsPerPage' => 10,\n            'optionalWords' => [\n                'one',\n\n                'two',\n            ],\n        ],\n    ],\n);"
    },
    "getApiKey": {
      "default": "$response = $client->getApiKey(\n    'myTestApiKey',\n);"
    },
    "getAppTask": {
      "default": "$response = $client->getAppTask(\n    123,\n);"
    },
    "getDictionaryLanguages": {
      "default": "$response = $client->getDictionaryLanguages();"
    },
    "getDictionarySettings": {
      "default": "$response = $client->getDictionarySettings();"
    },
    "getLogs": {
      "default": "$response = $client->getLogs();"
    },
    "getObject": {
      "default": "$response = $client->getObject(\n    '<YOUR_INDEX_NAME>',\n    'uniqueID',\n    [\n        'attr1',\n\n        'attr2',\n    ],\n);"
    },
    "getObjects": {
      "default": "$response = $client->getObjects(\n    ['requests' => [\n        ['attributesToRetrieve' => [\n            'attr1',\n\n            'attr2',\n        ],\n            'objectID' => 'uniqueID',\n            'indexName' => '<YOUR_INDEX_NAME>',\n        ],\n    ],\n    ],\n);"
    },
    "getRule": {
      "default": "$response = $client->getRule(\n    '<YOUR_INDEX_NAME>',\n    'qr-1725004648916',\n);"
    },
    "getSettings": {
      "default": "$response = $client->getSettings(\n    '<YOUR_INDEX_NAME>',\n);"
    },
    "getSources": {
      "default": "$response = $client->getSources();"
    },
    "getSynonym": {
      "default": "$response = $client->getSynonym(\n    '<YOUR_INDEX_NAME>',\n    'id1',\n);"
    },
    "getTask": {
      "default": "$response = $client->getTask(\n    '<YOUR_INDEX_NAME>',\n    123,\n);"
    },
    "getTopUserIds": {
      "default": "$response = $client->getTopUserIds();"
    },
    "getUserId": {
      "default": "$response = $client->getUserId(\n    'uniqueID',\n);"
    },
    "hasPendingMappings": {
      "default": "$response = $client->hasPendingMappings();"
    },
    "indexExists": {
      "indexExists": "$response = $client->indexExists(\n    '<YOUR_INDEX_NAME>',\n);",
      "indexNotExists": "$response = $client->indexExists(\n    '<YOUR_INDEX_NAME>',\n);",
      "indexExistsWithError": "$response = $client->indexExists(\n    '<YOUR_INDEX_NAME>',\n);"
    },
    "listApiKeys": {
      "default": "$response = $client->listApiKeys();"
    },
    "listClusters": {
      "default": "$response = $client->listClusters();"
    },
    "listIndices": {
      "default": "$response = $client->listIndices();"
    },
    "listUserIds": {
      "default": "$response = $client->listUserIds();"
    },
    "multipleBatch": {
      "default": "$response = $client->multipleBatch(\n    ['requests' => [\n        ['action' => 'addObject',\n            'body' => ['key' => 'value',\n            ],\n            'indexName' => '<YOUR_INDEX_NAME>',\n        ],\n    ],\n    ],\n);"
    },
    "operationIndex": {
      "scopes": "$response = $client->operationIndex(\n    '<SOURCE_INDEX_NAME>',\n    ['operation' => 'move',\n        'destination' => '<DESTINATION_INDEX_NAME>',\n        'scope' => [\n            'rules',\n\n            'settings',\n        ],\n    ],\n);",
      "copy": "$response = $client->operationIndex(\n    '<SOURCE_INDEX_NAME>',\n    ['operation' => 'copy',\n        'destination' => '<DESTINATION_INDEX_NAME>',\n    ],\n);",
      "move": "$response = $client->operationIndex(\n    '<SOURCE_INDEX_NAME>',\n    ['operation' => 'move',\n        'destination' => '<DESTINATION_INDEX_NAME>',\n    ],\n);"
    },
    "partialUpdateObject": {
      "default": "$response = $client->partialUpdateObject(\n    '<YOUR_INDEX_NAME>',\n    'uniqueID',\n    ['attributeId' => 'new value',\n    ],\n);"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "$response = $client->partialUpdateObjects(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => '1',\n            'name' => 'Adam',\n        ],\n\n        ['objectID' => '2',\n            'name' => 'Benoit',\n        ],\n    ],\n    true,\n);",
      "call partialUpdateObjects with createIfNotExists=false": "$response = $client->partialUpdateObjects(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => '3',\n            'name' => 'Cyril',\n        ],\n\n        ['objectID' => '4',\n            'name' => 'David',\n        ],\n    ],\n    false,\n);"
    },
    "removeUserId": {
      "default": "$response = $client->removeUserId(\n    'uniqueID',\n);"
    },
    "replaceAllObjects": {
      "default": "$response = $client->replaceAllObjects(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => '1',\n            'name' => 'Adam',\n        ],\n\n        ['objectID' => '2',\n            'name' => 'Benoit',\n        ],\n\n        ['objectID' => '3',\n            'name' => 'Cyril',\n        ],\n\n        ['objectID' => '4',\n            'name' => 'David',\n        ],\n\n        ['objectID' => '5',\n            'name' => 'Eva',\n        ],\n\n        ['objectID' => '6',\n            'name' => 'Fiona',\n        ],\n\n        ['objectID' => '7',\n            'name' => 'Gael',\n        ],\n\n        ['objectID' => '8',\n            'name' => 'Hugo',\n        ],\n\n        ['objectID' => '9',\n            'name' => 'Igor',\n        ],\n\n        ['objectID' => '10',\n            'name' => 'Julia',\n        ],\n    ],\n    3,\n);"
    },
    "replaceSources": {
      "default": "$response = $client->replaceSources(\n    [\n        ['source' => 'theSource',\n            'description' => 'theDescription',\n        ],\n    ],\n);"
    },
    "restoreApiKey": {
      "default": "$response = $client->restoreApiKey(\n    'ALGOLIA_API_KEY',\n);"
    },
    "saveObject": {
      "default": "$response = $client->saveObject(\n    '<YOUR_INDEX_NAME>',\n    ['objectID' => 'id',\n        'test' => 'val',\n    ],\n);"
    },
    "saveObjects": {
      "call saveObjects without error": "$response = $client->saveObjects(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => '1',\n            'name' => 'Adam',\n        ],\n\n        ['objectID' => '2',\n            'name' => 'Benoit',\n        ],\n    ],\n);",
      "saveObjects should report errors": "$response = $client->saveObjects(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => '1',\n            'name' => 'Adam',\n        ],\n\n        ['objectID' => '2',\n            'name' => 'Benoit',\n        ],\n    ],\n);"
    },
    "saveRule": {
      "default": "$response = $client->saveRule(\n    '<YOUR_INDEX_NAME>',\n    'id1',\n    ['objectID' => 'id1',\n        'conditions' => [\n            ['pattern' => 'apple',\n                'anchoring' => 'contains',\n            ],\n        ],\n    ],\n);"
    },
    "saveRules": {
      "default": "$response = $client->saveRules(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => 'a-rule-id',\n            'conditions' => [\n                ['pattern' => 'smartphone',\n                    'anchoring' => 'contains',\n                ],\n            ],\n        ],\n\n        ['objectID' => 'a-second-rule-id',\n            'conditions' => [\n                ['pattern' => 'apple',\n                    'anchoring' => 'contains',\n                ],\n            ],\n        ],\n    ],\n    false,\n    true,\n);"
    },
    "saveSynonym": {
      "default": "$response = $client->saveSynonym(\n    '<YOUR_INDEX_NAME>',\n    'id1',\n    ['objectID' => 'id1',\n        'type' => 'synonym',\n        'synonyms' => [\n            'car',\n\n            'vehicule',\n\n            'auto',\n        ],\n    ],\n    true,\n);"
    },
    "saveSynonyms": {
      "default": "$response = $client->saveSynonyms(\n    '<YOUR_INDEX_NAME>',\n    [\n        ['objectID' => 'id1',\n            'type' => 'synonym',\n            'synonyms' => [\n                'car',\n\n                'vehicule',\n\n                'auto',\n            ],\n        ],\n\n        ['objectID' => 'id2',\n            'type' => 'onewaysynonym',\n            'input' => 'iphone',\n            'synonyms' => [\n                'ephone',\n\n                'aphone',\n\n                'yphone',\n            ],\n        ],\n    ],\n    true,\n    true,\n);"
    },
    "search": {
      "withHitsPerPage": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'query' => '<YOUR_QUERY>',\n            'hitsPerPage' => 50,\n        ],\n    ],\n    ],\n);",
      "filterOnly": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'query' => '<YOUR_QUERY>',\n            'filters' => 'actor:Scarlett Johansson',\n        ],\n    ],\n    ],\n);",
      "filterOr": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'query' => '<YOUR_QUERY>',\n            'filters' => 'actor:Tom Cruise OR actor:Scarlett Johansson',\n        ],\n    ],\n    ],\n);",
      "filterNot": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'query' => '<YOUR_QUERY>',\n            'filters' => 'NOT actor:Nicolas Cage',\n        ],\n    ],\n    ],\n);",
      "retrieveFacets": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'query' => '<YOUR_QUERY>',\n            'facets' => [\n                'author',\n\n                'genre',\n            ],\n        ],\n    ],\n    ],\n);",
      "retrieveFacetsWildcard": "$response = $client->search(\n    ['requests' => [\n        ['indexName' => '<YOUR_INDEX_NAME>',\n            'query' => '<YOUR_QUERY>',\n            'facets' => [\n                '*',\n            ],\n        ],\n    ],\n    ],\n);"
    },
    "searchDictionaryEntries": {
      "default": "$response = $client->searchDictionaryEntries(\n    'stopwords',\n    ['query' => 'about',\n    ],\n);"
    },
    "searchForFacetValues": {
      "default": "$response = $client->searchForFacetValues(\n    '<YOUR_INDEX_NAME>',\n    'facetName',\n);"
    },
    "searchRules": {
      "default": "$response = $client->searchRules(\n    '<YOUR_INDEX_NAME>',\n    ['query' => 'zorro',\n    ],\n);"
    },
    "searchSingleIndex": {
      "default": "$response = $client->searchSingleIndex(\n    '<YOUR_INDEX_NAME>',\n);"
    },
    "searchSynonyms": {
      "default": "$response = $client->searchSynonyms(\n    '<YOUR_INDEX_NAME>',\n);"
    },
    "searchUserIds": {
      "default": "$response = $client->searchUserIds(\n    ['query' => 'test',\n        'clusterName' => 'theClusterName',\n        'page' => 5,\n        'hitsPerPage' => 10,\n    ],\n);"
    },
    "setClientApiKey": {
      "default": "$client->setClientApiKey(\n    'updated-api-key',\n);"
    },
    "setDictionarySettings": {
      "default": "$response = $client->setDictionarySettings(\n    ['disableStandardEntries' => ['plurals' => ['fr' => false,\n        'en' => false,\n        'ru' => true,\n    ],\n    ],\n    ],\n);"
    },
    "setSettings": {
      "default": "$response = $client->setSettings(\n    '<YOUR_INDEX_NAME>',\n    ['attributesForFaceting' => [\n        'actor',\n\n        'filterOnly(category)',\n\n        'searchable(publisher)',\n    ],\n    ],\n);"
    },
    "updateApiKey": {
      "default": "$response = $client->updateApiKey(\n    'ALGOLIA_API_KEY',\n    ['acl' => [\n        'search',\n\n        'addObject',\n    ],\n        'validity' => 300,\n        'maxQueriesPerIPPerHour' => 100,\n        'maxHitsPerQuery' => 20,\n    ],\n);"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "$response = $client->waitForApiKey(\n    'api-key-add-operation-test-php',\n    'add',\n);",
      "wait for api key - update": "$response = $client->waitForApiKey(\n    'api-key-update-operation-test-php',\n    'update',\n    ['description' => 'my updated api key',\n        'acl' => [\n            'search',\n\n            'addObject',\n\n            'deleteObject',\n        ],\n        'indexes' => [\n            'Movies',\n\n            'Books',\n        ],\n        'referers' => [\n            '*google.com',\n\n            '*algolia.com',\n        ],\n        'validity' => 305,\n        'maxQueriesPerIPPerHour' => 95,\n        'maxHitsPerQuery' => 20,\n    ],\n);",
      "wait for api key - delete": "$response = $client->waitForApiKey(\n    'api-key-delete-operation-test-php',\n    'delete',\n);"
    },
    "waitForAppTask": {
      "default": "$response = $client->waitForAppTask(\n    123,\n);"
    },
    "waitForTask": {
      "default": "$response = $client->waitForTask(\n    '<YOUR_INDEX_NAME>',\n    123,\n);"
    },
    "init": {
      "default": "$client = SearchClient::create('ALGOLIA_APPLICATION_ID', 'ALGOLIA_API_KEY');"
    }
  },
  "python": {
    "import": {
      "default": "from algoliasearch.search.client import SearchClientSync"
    },
    "addApiKey": {
      "default": "response = client.add_api_key(\n    api_key={\n        \"acl\": [\n            \"search\",\n            \"addObject\",\n        ],\n        \"description\": \"my new api key\",\n        \"validity\": 300,\n        \"maxQueriesPerIPPerHour\": 100,\n        \"maxHitsPerQuery\": 20,\n    },\n)"
    },
    "addOrUpdateObject": {
      "default": "response = client.add_or_update_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"uniqueID\",\n    body={\n        \"key\": \"value\",\n    },\n)"
    },
    "appendSource": {
      "default": "response = client.append_source(\n    source={\n        \"source\": \"theSource\",\n        \"description\": \"theDescription\",\n    },\n)"
    },
    "assignUserId": {
      "default": "response = client.assign_user_id(\n    x_algolia_user_id=\"userID\",\n    assign_user_id_params={\n        \"cluster\": \"theCluster\",\n    },\n)"
    },
    "batch": {
      "addObject": "response = client.batch(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    batch_write_params={\n        \"requests\": [\n            {\n                \"action\": \"addObject\",\n                \"body\": {\n                    \"key\": \"bar\",\n                    \"foo\": \"1\",\n                },\n            },\n            {\n                \"action\": \"addObject\",\n                \"body\": {\n                    \"key\": \"baz\",\n                    \"foo\": \"2\",\n                },\n            },\n        ],\n    },\n)",
      "clear": "response = client.batch(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    batch_write_params={\n        \"requests\": [\n            {\n                \"action\": \"clear\",\n                \"body\": {\n                    \"key\": \"value\",\n                },\n            },\n        ],\n    },\n)",
      "delete": "response = client.batch(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    batch_write_params={\n        \"requests\": [\n            {\n                \"action\": \"delete\",\n                \"body\": {\n                    \"key\": \"value\",\n                },\n            },\n        ],\n    },\n)",
      "deleteObject": "response = client.batch(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    batch_write_params={\n        \"requests\": [\n            {\n                \"action\": \"deleteObject\",\n                \"body\": {\n                    \"key\": \"value\",\n                },\n            },\n        ],\n    },\n)",
      "partialUpdateObject": "response = client.batch(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    batch_write_params={\n        \"requests\": [\n            {\n                \"action\": \"partialUpdateObject\",\n                \"body\": {\n                    \"key\": \"value\",\n                },\n            },\n        ],\n    },\n)",
      "partialUpdateObjectNoCreate": "response = client.batch(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    batch_write_params={\n        \"requests\": [\n            {\n                \"action\": \"partialUpdateObjectNoCreate\",\n                \"body\": {\n                    \"key\": \"value\",\n                },\n            },\n        ],\n    },\n)",
      "updateObject": "response = client.batch(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    batch_write_params={\n        \"requests\": [\n            {\n                \"action\": \"updateObject\",\n                \"body\": {\n                    \"key\": \"value\",\n                },\n            },\n        ],\n    },\n)"
    },
    "batchAssignUserIds": {
      "default": "response = client.batch_assign_user_ids(\n    x_algolia_user_id=\"userID\",\n    batch_assign_user_ids_params={\n        \"cluster\": \"theCluster\",\n        \"users\": [\n            \"user1\",\n            \"user2\",\n        ],\n    },\n)"
    },
    "batchDictionaryEntries": {
      "replace": "response = client.batch_dictionary_entries(\n    dictionary_name=\"plurals\",\n    batch_dictionary_entries_params={\n        \"clearExistingDictionaryEntries\": True,\n        \"requests\": [\n            {\n                \"action\": \"addEntry\",\n                \"body\": {\n                    \"objectID\": \"1\",\n                    \"language\": \"en\",\n                    \"word\": \"fancy\",\n                    \"words\": [\n                        \"believe\",\n                        \"algolia\",\n                    ],\n                    \"decomposition\": [\n                        \"trust\",\n                        \"algolia\",\n                    ],\n                    \"state\": \"enabled\",\n                },\n            },\n        ],\n    },\n)",
      "delete": "response = client.batch_dictionary_entries(\n    dictionary_name=\"plurals\",\n    batch_dictionary_entries_params={\n        \"clearExistingDictionaryEntries\": True,\n        \"requests\": [\n            {\n                \"action\": \"deleteEntry\",\n                \"body\": {\n                    \"objectID\": \"1\",\n                },\n            },\n        ],\n    },\n)",
      "append": "response = client.batch_dictionary_entries(\n    dictionary_name=\"stopwords\",\n    batch_dictionary_entries_params={\n        \"requests\": [\n            {\n                \"action\": \"addEntry\",\n                \"body\": {\n                    \"objectID\": \"1\",\n                    \"language\": \"en\",\n                    \"additional\": \"try me\",\n                },\n            },\n        ],\n    },\n)"
    },
    "browse": {
      "default": "response = client.browse(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)"
    },
    "clearObjects": {
      "default": "response = client.clear_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)"
    },
    "clearRules": {
      "default": "response = client.clear_rules(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)"
    },
    "clearSynonyms": {
      "default": "response = client.clear_synonyms(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)"
    },
    "customDelete": {
      "default": "response = client.custom_delete(\n    path=\"test/minimal\",\n)"
    },
    "customGet": {
      "default": "response = client.custom_get(\n    path=\"test/minimal\",\n)"
    },
    "customPost": {
      "default": "response = client.custom_post(\n    path=\"test/minimal\",\n)"
    },
    "customPut": {
      "default": "response = client.custom_put(\n    path=\"test/minimal\",\n)"
    },
    "deleteApiKey": {
      "default": "response = client.delete_api_key(\n    key=\"myTestApiKey\",\n)"
    },
    "deleteBy": {
      "default": "response = client.delete_by(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    delete_by_params={\n        \"filters\": \"brand:brandName\",\n    },\n)"
    },
    "deleteIndex": {
      "default": "response = client.delete_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)"
    },
    "deleteObject": {
      "default": "response = client.delete_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"uniqueID\",\n)"
    },
    "deleteObjects": {
      "default": "response = client.delete_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_ids=[\n        \"1\",\n        \"2\",\n    ],\n)"
    },
    "deleteRule": {
      "default": "response = client.delete_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"id1\",\n)"
    },
    "deleteSource": {
      "default": "response = client.delete_source(\n    source=\"theSource\",\n)"
    },
    "deleteSynonym": {
      "default": "response = client.delete_synonym(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"id1\",\n)"
    },
    "generateSecuredApiKey": {
      "generate secured api key basic": "response = client.generate_secured_api_key(\n    parent_api_key=\"2640659426d5107b6e47d75db9cbaef8\",\n    restrictions={\n        \"validUntil\": 2524604400,\n        \"restrictIndices\": [\n            \"Movies\",\n        ],\n    },\n)",
      "generate secured api key with searchParams": "response = client.generate_secured_api_key(\n    parent_api_key=\"2640659426d5107b6e47d75db9cbaef8\",\n    restrictions={\n        \"validUntil\": 2524604400,\n        \"restrictIndices\": [\n            \"Movies\",\n            \"cts_e2e_settings\",\n        ],\n        \"restrictSources\": \"192.168.1.0/24\",\n        \"filters\": \"category:Book OR category:Ebook AND _tags:published\",\n        \"userToken\": \"user123\",\n        \"searchParams\": {\n            \"query\": \"batman\",\n            \"typoTolerance\": \"strict\",\n            \"aroundRadius\": \"all\",\n            \"mode\": \"neuralSearch\",\n            \"hitsPerPage\": 10,\n            \"optionalWords\": [\n                \"one\",\n                \"two\",\n            ],\n        },\n    },\n)"
    },
    "getApiKey": {
      "default": "response = client.get_api_key(\n    key=\"myTestApiKey\",\n)"
    },
    "getAppTask": {
      "default": "response = client.get_app_task(\n    task_id=123,\n)"
    },
    "getDictionaryLanguages": {
      "default": "response = client.get_dictionary_languages()"
    },
    "getDictionarySettings": {
      "default": "response = client.get_dictionary_settings()"
    },
    "getLogs": {
      "default": "response = client.get_logs()"
    },
    "getObject": {
      "default": "response = client.get_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"uniqueID\",\n    attributes_to_retrieve=[\n        \"attr1\",\n        \"attr2\",\n    ],\n)"
    },
    "getObjects": {
      "default": "response = client.get_objects(\n    get_objects_params={\n        \"requests\": [\n            {\n                \"attributesToRetrieve\": [\n                    \"attr1\",\n                    \"attr2\",\n                ],\n                \"objectID\": \"uniqueID\",\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n            },\n        ],\n    },\n)"
    },
    "getRule": {
      "default": "response = client.get_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"qr-1725004648916\",\n)"
    },
    "getSettings": {
      "default": "response = client.get_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)"
    },
    "getSources": {
      "default": "response = client.get_sources()"
    },
    "getSynonym": {
      "default": "response = client.get_synonym(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"id1\",\n)"
    },
    "getTask": {
      "default": "response = client.get_task(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    task_id=123,\n)"
    },
    "getTopUserIds": {
      "default": "response = client.get_top_user_ids()"
    },
    "getUserId": {
      "default": "response = client.get_user_id(\n    user_id=\"uniqueID\",\n)"
    },
    "hasPendingMappings": {
      "default": "response = client.has_pending_mappings()"
    },
    "indexExists": {
      "indexExists": "response = client.index_exists(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)",
      "indexNotExists": "response = client.index_exists(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)",
      "indexExistsWithError": "response = client.index_exists(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)"
    },
    "listApiKeys": {
      "default": "response = client.list_api_keys()"
    },
    "listClusters": {
      "default": "response = client.list_clusters()"
    },
    "listIndices": {
      "default": "response = client.list_indices()"
    },
    "listUserIds": {
      "default": "response = client.list_user_ids()"
    },
    "multipleBatch": {
      "default": "response = client.multiple_batch(\n    batch_params={\n        \"requests\": [\n            {\n                \"action\": \"addObject\",\n                \"body\": {\n                    \"key\": \"value\",\n                },\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n            },\n        ],\n    },\n)"
    },
    "operationIndex": {
      "scopes": "response = client.operation_index(\n    index_name=\"<SOURCE_INDEX_NAME>\",\n    operation_index_params={\n        \"operation\": \"move\",\n        \"destination\": \"<DESTINATION_INDEX_NAME>\",\n        \"scope\": [\n            \"rules\",\n            \"settings\",\n        ],\n    },\n)",
      "copy": "response = client.operation_index(\n    index_name=\"<SOURCE_INDEX_NAME>\",\n    operation_index_params={\n        \"operation\": \"copy\",\n        \"destination\": \"<DESTINATION_INDEX_NAME>\",\n    },\n)",
      "move": "response = client.operation_index(\n    index_name=\"<SOURCE_INDEX_NAME>\",\n    operation_index_params={\n        \"operation\": \"move\",\n        \"destination\": \"<DESTINATION_INDEX_NAME>\",\n    },\n)"
    },
    "partialUpdateObject": {
      "default": "response = client.partial_update_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"uniqueID\",\n    attributes_to_update={\n        \"attributeId\": \"new value\",\n    },\n)"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "response = client.partial_update_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    objects=[\n        {\n            \"objectID\": \"1\",\n            \"name\": \"Adam\",\n        },\n        {\n            \"objectID\": \"2\",\n            \"name\": \"Benoit\",\n        },\n    ],\n    create_if_not_exists=True,\n)",
      "call partialUpdateObjects with createIfNotExists=false": "response = client.partial_update_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    objects=[\n        {\n            \"objectID\": \"3\",\n            \"name\": \"Cyril\",\n        },\n        {\n            \"objectID\": \"4\",\n            \"name\": \"David\",\n        },\n    ],\n    create_if_not_exists=False,\n)"
    },
    "removeUserId": {
      "default": "response = client.remove_user_id(\n    user_id=\"uniqueID\",\n)"
    },
    "replaceAllObjects": {
      "default": "response = client.replace_all_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    objects=[\n        {\n            \"objectID\": \"1\",\n            \"name\": \"Adam\",\n        },\n        {\n            \"objectID\": \"2\",\n            \"name\": \"Benoit\",\n        },\n        {\n            \"objectID\": \"3\",\n            \"name\": \"Cyril\",\n        },\n        {\n            \"objectID\": \"4\",\n            \"name\": \"David\",\n        },\n        {\n            \"objectID\": \"5\",\n            \"name\": \"Eva\",\n        },\n        {\n            \"objectID\": \"6\",\n            \"name\": \"Fiona\",\n        },\n        {\n            \"objectID\": \"7\",\n            \"name\": \"Gael\",\n        },\n        {\n            \"objectID\": \"8\",\n            \"name\": \"Hugo\",\n        },\n        {\n            \"objectID\": \"9\",\n            \"name\": \"Igor\",\n        },\n        {\n            \"objectID\": \"10\",\n            \"name\": \"Julia\",\n        },\n    ],\n    batch_size=3,\n)"
    },
    "replaceSources": {
      "default": "response = client.replace_sources(\n    source=[\n        {\n            \"source\": \"theSource\",\n            \"description\": \"theDescription\",\n        },\n    ],\n)"
    },
    "restoreApiKey": {
      "default": "response = client.restore_api_key(\n    key=\"ALGOLIA_API_KEY\",\n)"
    },
    "saveObject": {
      "default": "response = client.save_object(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    body={\n        \"objectID\": \"id\",\n        \"test\": \"val\",\n    },\n)"
    },
    "saveObjects": {
      "call saveObjects without error": "response = client.save_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    objects=[\n        {\n            \"objectID\": \"1\",\n            \"name\": \"Adam\",\n        },\n        {\n            \"objectID\": \"2\",\n            \"name\": \"Benoit\",\n        },\n    ],\n)",
      "saveObjects should report errors": "response = client.save_objects(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    objects=[\n        {\n            \"objectID\": \"1\",\n            \"name\": \"Adam\",\n        },\n        {\n            \"objectID\": \"2\",\n            \"name\": \"Benoit\",\n        },\n    ],\n)"
    },
    "saveRule": {
      "default": "response = client.save_rule(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"id1\",\n    rule={\n        \"objectID\": \"id1\",\n        \"conditions\": [\n            {\n                \"pattern\": \"apple\",\n                \"anchoring\": \"contains\",\n            },\n        ],\n    },\n)"
    },
    "saveRules": {
      "default": "response = client.save_rules(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    rules=[\n        {\n            \"objectID\": \"a-rule-id\",\n            \"conditions\": [\n                {\n                    \"pattern\": \"smartphone\",\n                    \"anchoring\": \"contains\",\n                },\n            ],\n        },\n        {\n            \"objectID\": \"a-second-rule-id\",\n            \"conditions\": [\n                {\n                    \"pattern\": \"apple\",\n                    \"anchoring\": \"contains\",\n                },\n            ],\n        },\n    ],\n    forward_to_replicas=False,\n    clear_existing_rules=True,\n)"
    },
    "saveSynonym": {
      "default": "response = client.save_synonym(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    object_id=\"id1\",\n    synonym_hit={\n        \"objectID\": \"id1\",\n        \"type\": \"synonym\",\n        \"synonyms\": [\n            \"car\",\n            \"vehicule\",\n            \"auto\",\n        ],\n    },\n    forward_to_replicas=True,\n)"
    },
    "saveSynonyms": {
      "default": "response = client.save_synonyms(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    synonym_hit=[\n        {\n            \"objectID\": \"id1\",\n            \"type\": \"synonym\",\n            \"synonyms\": [\n                \"car\",\n                \"vehicule\",\n                \"auto\",\n            ],\n        },\n        {\n            \"objectID\": \"id2\",\n            \"type\": \"onewaysynonym\",\n            \"input\": \"iphone\",\n            \"synonyms\": [\n                \"ephone\",\n                \"aphone\",\n                \"yphone\",\n            ],\n        },\n    ],\n    forward_to_replicas=True,\n    replace_existing_synonyms=True,\n)"
    },
    "search": {
      "withHitsPerPage": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"query\": \"<YOUR_QUERY>\",\n                \"hitsPerPage\": 50,\n            },\n        ],\n    },\n)",
      "filterOnly": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"query\": \"<YOUR_QUERY>\",\n                \"filters\": \"actor:Scarlett Johansson\",\n            },\n        ],\n    },\n)",
      "filterOr": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"query\": \"<YOUR_QUERY>\",\n                \"filters\": \"actor:Tom Cruise OR actor:Scarlett Johansson\",\n            },\n        ],\n    },\n)",
      "filterNot": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"query\": \"<YOUR_QUERY>\",\n                \"filters\": \"NOT actor:Nicolas Cage\",\n            },\n        ],\n    },\n)",
      "retrieveFacets": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"query\": \"<YOUR_QUERY>\",\n                \"facets\": [\n                    \"author\",\n                    \"genre\",\n                ],\n            },\n        ],\n    },\n)",
      "retrieveFacetsWildcard": "response = client.search(\n    search_method_params={\n        \"requests\": [\n            {\n                \"indexName\": \"<YOUR_INDEX_NAME>\",\n                \"query\": \"<YOUR_QUERY>\",\n                \"facets\": [\n                    \"*\",\n                ],\n            },\n        ],\n    },\n)"
    },
    "searchDictionaryEntries": {
      "default": "response = client.search_dictionary_entries(\n    dictionary_name=\"stopwords\",\n    search_dictionary_entries_params={\n        \"query\": \"about\",\n    },\n)"
    },
    "searchForFacetValues": {
      "default": "response = client.search_for_facet_values(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    facet_name=\"facetName\",\n)"
    },
    "searchRules": {
      "default": "response = client.search_rules(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    search_rules_params={\n        \"query\": \"zorro\",\n    },\n)"
    },
    "searchSingleIndex": {
      "default": "response = client.search_single_index(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)"
    },
    "searchSynonyms": {
      "default": "response = client.search_synonyms(\n    index_name=\"<YOUR_INDEX_NAME>\",\n)"
    },
    "searchUserIds": {
      "default": "response = client.search_user_ids(\n    search_user_ids_params={\n        \"query\": \"test\",\n        \"clusterName\": \"theClusterName\",\n        \"page\": 5,\n        \"hitsPerPage\": 10,\n    },\n)"
    },
    "setClientApiKey": {
      "default": "client.set_client_api_key(\n    api_key=\"updated-api-key\",\n)"
    },
    "setDictionarySettings": {
      "default": "response = client.set_dictionary_settings(\n    dictionary_settings_params={\n        \"disableStandardEntries\": {\n            \"plurals\": {\n                \"fr\": False,\n                \"en\": False,\n                \"ru\": True,\n            },\n        },\n    },\n)"
    },
    "setSettings": {
      "default": "response = client.set_settings(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    index_settings={\n        \"attributesForFaceting\": [\n            \"actor\",\n            \"filterOnly(category)\",\n            \"searchable(publisher)\",\n        ],\n    },\n)"
    },
    "updateApiKey": {
      "default": "response = client.update_api_key(\n    key=\"ALGOLIA_API_KEY\",\n    api_key={\n        \"acl\": [\n            \"search\",\n            \"addObject\",\n        ],\n        \"validity\": 300,\n        \"maxQueriesPerIPPerHour\": 100,\n        \"maxHitsPerQuery\": 20,\n    },\n)"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "response = client.wait_for_api_key(\n    key=\"api-key-add-operation-test-python\",\n    operation=\"add\",\n)",
      "wait for api key - update": "response = client.wait_for_api_key(\n    key=\"api-key-update-operation-test-python\",\n    operation=\"update\",\n    api_key={\n        \"description\": \"my updated api key\",\n        \"acl\": [\n            \"search\",\n            \"addObject\",\n            \"deleteObject\",\n        ],\n        \"indexes\": [\n            \"Movies\",\n            \"Books\",\n        ],\n        \"referers\": [\n            \"*google.com\",\n            \"*algolia.com\",\n        ],\n        \"validity\": 305,\n        \"maxQueriesPerIPPerHour\": 95,\n        \"maxHitsPerQuery\": 20,\n    },\n)",
      "wait for api key - delete": "response = client.wait_for_api_key(\n    key=\"api-key-delete-operation-test-python\",\n    operation=\"delete\",\n)"
    },
    "waitForAppTask": {
      "default": "response = client.wait_for_app_task(\n    task_id=123,\n)"
    },
    "waitForTask": {
      "default": "response = client.wait_for_task(\n    index_name=\"<YOUR_INDEX_NAME>\",\n    task_id=123,\n)"
    },
    "init": {
      "default": "# In an asynchronous context, you can use SearchClient instead, which exposes the exact same methods.\nclient = SearchClientSync(\"ALGOLIA_APPLICATION_ID\", \"ALGOLIA_API_KEY\")"
    }
  },
  "ruby": {
    "import": {
      "default": "require \"algolia\""
    },
    "addApiKey": {
      "default": "response = client.add_api_key(\n  Algolia::Search::ApiKey.new(\n    acl: [\"search\", \"addObject\"],\n    description: \"my new api key\",\n    validity: 300,\n    max_queries_per_ip_per_hour: 100,\n    max_hits_per_query: 20\n  )\n)"
    },
    "addOrUpdateObject": {
      "default": "response = client.add_or_update_object(\"<YOUR_INDEX_NAME>\", \"uniqueID\", {key: \"value\"})"
    },
    "appendSource": {
      "default": "response = client.append_source(Algolia::Search::Source.new(source: \"theSource\", description: \"theDescription\"))"
    },
    "assignUserId": {
      "default": "response = client.assign_user_id(\"userID\", Algolia::Search::AssignUserIdParams.new(cluster: \"theCluster\"))"
    },
    "batch": {
      "addObject": "response = client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::BatchWriteParams.new(\n    requests: [\n      Algolia::Search::BatchRequest.new(action: \"addObject\", body: {key: \"bar\", foo: \"1\"}),\n      Algolia::Search::BatchRequest.new(action: \"addObject\", body: {key: \"baz\", foo: \"2\"})\n    ]\n  )\n)",
      "clear": "response = client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::BatchWriteParams.new(\n    requests: [Algolia::Search::BatchRequest.new(action: \"clear\", body: {key: \"value\"})]\n  )\n)",
      "delete": "response = client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::BatchWriteParams.new(\n    requests: [Algolia::Search::BatchRequest.new(action: \"delete\", body: {key: \"value\"})]\n  )\n)",
      "deleteObject": "response = client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::BatchWriteParams.new(\n    requests: [Algolia::Search::BatchRequest.new(action: \"deleteObject\", body: {key: \"value\"})]\n  )\n)",
      "partialUpdateObject": "response = client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::BatchWriteParams.new(\n    requests: [Algolia::Search::BatchRequest.new(action: \"partialUpdateObject\", body: {key: \"value\"})]\n  )\n)",
      "partialUpdateObjectNoCreate": "response = client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::BatchWriteParams.new(\n    requests: [Algolia::Search::BatchRequest.new(action: \"partialUpdateObjectNoCreate\", body: {key: \"value\"})]\n  )\n)",
      "updateObject": "response = client.batch(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::BatchWriteParams.new(\n    requests: [Algolia::Search::BatchRequest.new(action: \"updateObject\", body: {key: \"value\"})]\n  )\n)"
    },
    "batchAssignUserIds": {
      "default": "response = client.batch_assign_user_ids(\n  \"userID\",\n  Algolia::Search::BatchAssignUserIdsParams.new(cluster: \"theCluster\", users: [\"user1\", \"user2\"])\n)"
    },
    "batchDictionaryEntries": {
      "replace": "response = client.batch_dictionary_entries(\n  \"plurals\",\n  Algolia::Search::BatchDictionaryEntriesParams.new(\n    clear_existing_dictionary_entries: true,\n    requests: [\n      Algolia::Search::BatchDictionaryEntriesRequest.new(\n        action: \"addEntry\",\n        body: Algolia::Search::DictionaryEntry.new(\n          object_id: \"1\",\n          language: \"en\",\n          word: \"fancy\",\n          words: [\"believe\", \"algolia\"],\n          decomposition: [\"trust\", \"algolia\"],\n          state: \"enabled\"\n        )\n      )\n    ]\n  )\n)",
      "delete": "response = client.batch_dictionary_entries(\n  \"plurals\",\n  Algolia::Search::BatchDictionaryEntriesParams.new(\n    clear_existing_dictionary_entries: true,\n    requests: [\n      Algolia::Search::BatchDictionaryEntriesRequest.new(\n        action: \"deleteEntry\",\n        body: Algolia::Search::DictionaryEntry.new(object_id: \"1\")\n      )\n    ]\n  )\n)",
      "append": "response = client.batch_dictionary_entries(\n  \"stopwords\",\n  Algolia::Search::BatchDictionaryEntriesParams.new(\n    requests: [\n      Algolia::Search::BatchDictionaryEntriesRequest.new(\n        action: \"addEntry\",\n        body: Algolia::Search::DictionaryEntry.new(object_id: \"1\", language: \"en\", additional: \"try me\")\n      )\n    ]\n  )\n)"
    },
    "browse": {
      "default": "response = client.browse(\"<YOUR_INDEX_NAME>\")"
    },
    "clearObjects": {
      "default": "response = client.clear_objects(\"<YOUR_INDEX_NAME>\")"
    },
    "clearRules": {
      "default": "response = client.clear_rules(\"<YOUR_INDEX_NAME>\")"
    },
    "clearSynonyms": {
      "default": "response = client.clear_synonyms(\"<YOUR_INDEX_NAME>\")"
    },
    "customDelete": {
      "default": "response = client.custom_delete(\"test/minimal\")"
    },
    "customGet": {
      "default": "response = client.custom_get(\"test/minimal\")"
    },
    "customPost": {
      "default": "response = client.custom_post(\"test/minimal\")"
    },
    "customPut": {
      "default": "response = client.custom_put(\"test/minimal\")"
    },
    "deleteApiKey": {
      "default": "response = client.delete_api_key(\"myTestApiKey\")"
    },
    "deleteBy": {
      "default": "response = client.delete_by(\"<YOUR_INDEX_NAME>\", Algolia::Search::DeleteByParams.new(filters: \"brand:brandName\"))"
    },
    "deleteIndex": {
      "default": "response = client.delete_index(\"<YOUR_INDEX_NAME>\")"
    },
    "deleteObject": {
      "default": "response = client.delete_object(\"<YOUR_INDEX_NAME>\", \"uniqueID\")"
    },
    "deleteObjects": {
      "default": "response = client.delete_objects(\"<YOUR_INDEX_NAME>\", [\"1\", \"2\"])"
    },
    "deleteRule": {
      "default": "response = client.delete_rule(\"<YOUR_INDEX_NAME>\", \"id1\")"
    },
    "deleteSource": {
      "default": "response = client.delete_source(\"theSource\")"
    },
    "deleteSynonym": {
      "default": "response = client.delete_synonym(\"<YOUR_INDEX_NAME>\", \"id1\")"
    },
    "generateSecuredApiKey": {
      "generate secured api key basic": "response = client.generate_secured_api_key(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  Algolia::Search::SecuredApiKeyRestrictions.new(valid_until: 2524604400, restrict_indices: [\"Movies\"])\n)",
      "generate secured api key with searchParams": "response = client.generate_secured_api_key(\n  \"2640659426d5107b6e47d75db9cbaef8\",\n  Algolia::Search::SecuredApiKeyRestrictions.new(\n    valid_until: 2524604400,\n    restrict_indices: [\"Movies\", \"cts_e2e_settings\"],\n    restrict_sources: \"192.168.1.0/24\",\n    filters: \"category:Book OR category:Ebook AND _tags:published\",\n    user_token: \"user123\",\n    search_params: Algolia::Search::SearchParamsObject.new(\n      query: \"batman\",\n      typo_tolerance: \"strict\",\n      around_radius: \"all\",\n      mode: \"neuralSearch\",\n      hits_per_page: 10,\n      optional_words: [\"one\", \"two\"]\n    )\n  )\n)"
    },
    "getApiKey": {
      "default": "response = client.get_api_key(\"myTestApiKey\")"
    },
    "getAppTask": {
      "default": "response = client.get_app_task(123)"
    },
    "getDictionaryLanguages": {
      "default": "response = client.get_dictionary_languages"
    },
    "getDictionarySettings": {
      "default": "response = client.get_dictionary_settings"
    },
    "getLogs": {
      "default": "response = client.get_logs"
    },
    "getObject": {
      "default": "response = client.get_object(\"<YOUR_INDEX_NAME>\", \"uniqueID\", [\"attr1\", \"attr2\"])"
    },
    "getObjects": {
      "default": "response = client.get_objects(\n  Algolia::Search::GetObjectsParams.new(\n    requests: [\n      Algolia::Search::GetObjectsRequest.new(\n        attributes_to_retrieve: [\"attr1\", \"attr2\"],\n        object_id: \"uniqueID\",\n        index_name: \"<YOUR_INDEX_NAME>\"\n      )\n    ]\n  )\n)"
    },
    "getRule": {
      "default": "response = client.get_rule(\"<YOUR_INDEX_NAME>\", \"qr-1725004648916\")"
    },
    "getSettings": {
      "default": "response = client.get_settings(\"<YOUR_INDEX_NAME>\")"
    },
    "getSources": {
      "default": "response = client.get_sources"
    },
    "getSynonym": {
      "default": "response = client.get_synonym(\"<YOUR_INDEX_NAME>\", \"id1\")"
    },
    "getTask": {
      "default": "response = client.get_task(\"<YOUR_INDEX_NAME>\", 123)"
    },
    "getTopUserIds": {
      "default": "response = client.get_top_user_ids"
    },
    "getUserId": {
      "default": "response = client.get_user_id(\"uniqueID\")"
    },
    "hasPendingMappings": {
      "default": "response = client.has_pending_mappings"
    },
    "indexExists": {
      "indexExists": "response = client.index_exists(\"<YOUR_INDEX_NAME>\")",
      "indexNotExists": "response = client.index_exists(\"<YOUR_INDEX_NAME>\")",
      "indexExistsWithError": "response = client.index_exists(\"<YOUR_INDEX_NAME>\")"
    },
    "listApiKeys": {
      "default": "response = client.list_api_keys"
    },
    "listClusters": {
      "default": "response = client.list_clusters"
    },
    "listIndices": {
      "default": "response = client.list_indices"
    },
    "listUserIds": {
      "default": "response = client.list_user_ids"
    },
    "multipleBatch": {
      "default": "response = client.multiple_batch(\n  Algolia::Search::BatchParams.new(\n    requests: [\n      Algolia::Search::MultipleBatchRequest.new(\n        action: \"addObject\",\n        body: {key: \"value\"},\n        index_name: \"<YOUR_INDEX_NAME>\"\n      )\n    ]\n  )\n)"
    },
    "operationIndex": {
      "scopes": "response = client.operation_index(\n  \"<SOURCE_INDEX_NAME>\",\n  Algolia::Search::OperationIndexParams.new(\n    operation: \"move\",\n    destination: \"<DESTINATION_INDEX_NAME>\",\n    scope: [\"rules\", \"settings\"]\n  )\n)",
      "copy": "response = client.operation_index(\n  \"<SOURCE_INDEX_NAME>\",\n  Algolia::Search::OperationIndexParams.new(operation: \"copy\", destination: \"<DESTINATION_INDEX_NAME>\")\n)",
      "move": "response = client.operation_index(\n  \"<SOURCE_INDEX_NAME>\",\n  Algolia::Search::OperationIndexParams.new(operation: \"move\", destination: \"<DESTINATION_INDEX_NAME>\")\n)"
    },
    "partialUpdateObject": {
      "default": "response = client.partial_update_object(\"<YOUR_INDEX_NAME>\", \"uniqueID\", {attributeId: \"new value\"})"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "response = client.partial_update_objects(\n  \"<YOUR_INDEX_NAME>\",\n  [{objectID: \"1\", name: \"Adam\"}, {objectID: \"2\", name: \"Benoit\"}],\n  true\n)",
      "call partialUpdateObjects with createIfNotExists=false": "response = client.partial_update_objects(\n  \"<YOUR_INDEX_NAME>\",\n  [{objectID: \"3\", name: \"Cyril\"}, {objectID: \"4\", name: \"David\"}],\n  false\n)"
    },
    "removeUserId": {
      "default": "response = client.remove_user_id(\"uniqueID\")"
    },
    "replaceAllObjects": {
      "default": "response = client.replace_all_objects(\n  \"<YOUR_INDEX_NAME>\",\n  [\n    {objectID: \"1\", name: \"Adam\"},\n    {objectID: \"2\", name: \"Benoit\"},\n    {objectID: \"3\", name: \"Cyril\"},\n    {objectID: \"4\", name: \"David\"},\n    {objectID: \"5\", name: \"Eva\"},\n    {objectID: \"6\", name: \"Fiona\"},\n    {objectID: \"7\", name: \"Gael\"},\n    {objectID: \"8\", name: \"Hugo\"},\n    {objectID: \"9\", name: \"Igor\"},\n    {objectID: \"10\", name: \"Julia\"}\n  ],\n  3\n)"
    },
    "replaceSources": {
      "default": "response = client.replace_sources([Algolia::Search::Source.new(source: \"theSource\", description: \"theDescription\")])"
    },
    "restoreApiKey": {
      "default": "response = client.restore_api_key(\"ALGOLIA_API_KEY\")"
    },
    "saveObject": {
      "default": "response = client.save_object(\"<YOUR_INDEX_NAME>\", {objectID: \"id\", test: \"val\"})"
    },
    "saveObjects": {
      "call saveObjects without error": "response = client.save_objects(\n  \"<YOUR_INDEX_NAME>\",\n  [{objectID: \"1\", name: \"Adam\"}, {objectID: \"2\", name: \"Benoit\"}]\n)",
      "saveObjects should report errors": "response = client.save_objects(\n  \"<YOUR_INDEX_NAME>\",\n  [{objectID: \"1\", name: \"Adam\"}, {objectID: \"2\", name: \"Benoit\"}]\n)"
    },
    "saveRule": {
      "default": "response = client.save_rule(\n  \"<YOUR_INDEX_NAME>\",\n  \"id1\",\n  Algolia::Search::Rule.new(\n    object_id: \"id1\",\n    conditions: [Algolia::Search::Condition.new(pattern: \"apple\", anchoring: \"contains\")]\n  )\n)"
    },
    "saveRules": {
      "default": "response = client.save_rules(\n  \"<YOUR_INDEX_NAME>\",\n  [\n    Algolia::Search::Rule.new(\n      object_id: \"a-rule-id\",\n      conditions: [Algolia::Search::Condition.new(pattern: \"smartphone\", anchoring: \"contains\")]\n    ),\n    Algolia::Search::Rule.new(\n      object_id: \"a-second-rule-id\",\n      conditions: [Algolia::Search::Condition.new(pattern: \"apple\", anchoring: \"contains\")]\n    )\n  ],\n  false,\n  true\n)"
    },
    "saveSynonym": {
      "default": "response = client.save_synonym(\n  \"<YOUR_INDEX_NAME>\",\n  \"id1\",\n  Algolia::Search::SynonymHit.new(object_id: \"id1\", type: \"synonym\", synonyms: [\"car\", \"vehicule\", \"auto\"]),\n  true\n)"
    },
    "saveSynonyms": {
      "default": "response = client.save_synonyms(\n  \"<YOUR_INDEX_NAME>\",\n  [\n    Algolia::Search::SynonymHit.new(object_id: \"id1\", type: \"synonym\", synonyms: [\"car\", \"vehicule\", \"auto\"]),\n    Algolia::Search::SynonymHit.new(\n      object_id: \"id2\",\n      type: \"onewaysynonym\",\n      input: \"iphone\",\n      synonyms: [\"ephone\", \"aphone\", \"yphone\"]\n    )\n  ],\n  true,\n  true\n)"
    },
    "search": {
      "withHitsPerPage": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(index_name: \"<YOUR_INDEX_NAME>\", query: \"<YOUR_QUERY>\", hits_per_page: 50)\n    ]\n  )\n)",
      "filterOnly": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        filters: \"actor:Scarlett Johansson\"\n      )\n    ]\n  )\n)",
      "filterOr": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        filters: \"actor:Tom Cruise OR actor:Scarlett Johansson\"\n      )\n    ]\n  )\n)",
      "filterNot": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        filters: \"NOT actor:Nicolas Cage\"\n      )\n    ]\n  )\n)",
      "retrieveFacets": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(\n        index_name: \"<YOUR_INDEX_NAME>\",\n        query: \"<YOUR_QUERY>\",\n        facets: [\"author\", \"genre\"]\n      )\n    ]\n  )\n)",
      "retrieveFacetsWildcard": "response = client.search(\n  Algolia::Search::SearchMethodParams.new(\n    requests: [\n      Algolia::Search::SearchForHits.new(index_name: \"<YOUR_INDEX_NAME>\", query: \"<YOUR_QUERY>\", facets: [\"*\"])\n    ]\n  )\n)"
    },
    "searchDictionaryEntries": {
      "default": "response = client.search_dictionary_entries(\n  \"stopwords\",\n  Algolia::Search::SearchDictionaryEntriesParams.new(query: \"about\")\n)"
    },
    "searchForFacetValues": {
      "default": "response = client.search_for_facet_values(\"<YOUR_INDEX_NAME>\", \"facetName\")"
    },
    "searchRules": {
      "default": "response = client.search_rules(\"<YOUR_INDEX_NAME>\", Algolia::Search::SearchRulesParams.new(query: \"zorro\"))"
    },
    "searchSingleIndex": {
      "default": "response = client.search_single_index(\"<YOUR_INDEX_NAME>\")"
    },
    "searchSynonyms": {
      "default": "response = client.search_synonyms(\"<YOUR_INDEX_NAME>\")"
    },
    "searchUserIds": {
      "default": "response = client.search_user_ids(\n  Algolia::Search::SearchUserIdsParams.new(query: \"test\", cluster_name: \"theClusterName\", page: 5, hits_per_page: 10)\n)"
    },
    "setClientApiKey": {
      "default": "client.set_client_api_key(\"updated-api-key\")"
    },
    "setDictionarySettings": {
      "default": "response = client.set_dictionary_settings(\n  Algolia::Search::DictionarySettingsParams.new(\n    disable_standard_entries: Algolia::Search::StandardEntries.new(plurals: {fr: false, en: false, ru: true})\n  )\n)"
    },
    "setSettings": {
      "default": "response = client.set_settings(\n  \"<YOUR_INDEX_NAME>\",\n  Algolia::Search::IndexSettings.new(\n    attributes_for_faceting: [\"actor\", \"filterOnly(category)\", \"searchable(publisher)\"]\n  )\n)"
    },
    "updateApiKey": {
      "default": "response = client.update_api_key(\n  \"ALGOLIA_API_KEY\",\n  Algolia::Search::ApiKey.new(\n    acl: [\"search\", \"addObject\"],\n    validity: 300,\n    max_queries_per_ip_per_hour: 100,\n    max_hits_per_query: 20\n  )\n)"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "response = client.wait_for_api_key(\"api-key-add-operation-test-ruby\", \"add\")",
      "wait for api key - update": "response = client.wait_for_api_key(\n  \"api-key-update-operation-test-ruby\",\n  \"update\",\n  Algolia::Search::ApiKey.new(\n    description: \"my updated api key\",\n    acl: [\"search\", \"addObject\", \"deleteObject\"],\n    indexes: [\"Movies\", \"Books\"],\n    referers: [\"*google.com\", \"*algolia.com\"],\n    validity: 305,\n    max_queries_per_ip_per_hour: 95,\n    max_hits_per_query: 20\n  )\n)",
      "wait for api key - delete": "response = client.wait_for_api_key(\"api-key-delete-operation-test-ruby\", \"delete\")"
    },
    "waitForAppTask": {
      "default": "response = client.wait_for_app_task(123)"
    },
    "waitForTask": {
      "default": "response = client.wait_for_task(\"<YOUR_INDEX_NAME>\", 123)"
    },
    "init": {
      "default": "client = Algolia::SearchClient.create(\"ALGOLIA_APPLICATION_ID\", \"ALGOLIA_API_KEY\")"
    }
  },
  "scala": {
    "import": {
      "default": "import algoliasearch.api.SearchClient\nimport algoliasearch.extension.SearchClientExtensions"
    },
    "addApiKey": {
      "default": "val response = client.addApiKey(\n  apiKey = ApiKey(\n    acl = Seq(Acl.withName(\"search\"), Acl.withName(\"addObject\")),\n    description = Some(\"my new api key\"),\n    validity = Some(300),\n    maxQueriesPerIPPerHour = Some(100),\n    maxHitsPerQuery = Some(20)\n  )\n)"
    },
    "addOrUpdateObject": {
      "default": "val response = client.addOrUpdateObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\",\n  body = JObject(List(JField(\"key\", JString(\"value\"))))\n)"
    },
    "appendSource": {
      "default": "val response = client.appendSource(\n  source = Source(\n    source = \"theSource\",\n    description = Some(\"theDescription\")\n  )\n)"
    },
    "assignUserId": {
      "default": "val response = client.assignUserId(\n  xAlgoliaUserID = \"userID\",\n  assignUserIdParams = AssignUserIdParams(\n    cluster = \"theCluster\"\n  )\n)"
    },
    "batch": {
      "addObject": "val response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = Seq(\n      BatchRequest(\n        action = Action.withName(\"addObject\"),\n        body = JObject(List(JField(\"key\", JString(\"bar\")), JField(\"foo\", JString(\"1\"))))\n      ),\n      BatchRequest(\n        action = Action.withName(\"addObject\"),\n        body = JObject(List(JField(\"key\", JString(\"baz\")), JField(\"foo\", JString(\"2\"))))\n      )\n    )\n  )\n)",
      "clear": "val response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = Seq(\n      BatchRequest(\n        action = Action.withName(\"clear\"),\n        body = JObject(List(JField(\"key\", JString(\"value\"))))\n      )\n    )\n  )\n)",
      "delete": "val response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = Seq(\n      BatchRequest(\n        action = Action.withName(\"delete\"),\n        body = JObject(List(JField(\"key\", JString(\"value\"))))\n      )\n    )\n  )\n)",
      "deleteObject": "val response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = Seq(\n      BatchRequest(\n        action = Action.withName(\"deleteObject\"),\n        body = JObject(List(JField(\"key\", JString(\"value\"))))\n      )\n    )\n  )\n)",
      "partialUpdateObject": "val response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = Seq(\n      BatchRequest(\n        action = Action.withName(\"partialUpdateObject\"),\n        body = JObject(List(JField(\"key\", JString(\"value\"))))\n      )\n    )\n  )\n)",
      "partialUpdateObjectNoCreate": "val response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = Seq(\n      BatchRequest(\n        action = Action.withName(\"partialUpdateObjectNoCreate\"),\n        body = JObject(List(JField(\"key\", JString(\"value\"))))\n      )\n    )\n  )\n)",
      "updateObject": "val response = client.batch(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  batchWriteParams = BatchWriteParams(\n    requests = Seq(\n      BatchRequest(\n        action = Action.withName(\"updateObject\"),\n        body = JObject(List(JField(\"key\", JString(\"value\"))))\n      )\n    )\n  )\n)"
    },
    "batchAssignUserIds": {
      "default": "val response = client.batchAssignUserIds(\n  xAlgoliaUserID = \"userID\",\n  batchAssignUserIdsParams = BatchAssignUserIdsParams(\n    cluster = \"theCluster\",\n    users = Seq(\"user1\", \"user2\")\n  )\n)"
    },
    "batchDictionaryEntries": {
      "replace": "val response = client.batchDictionaryEntries(\n  dictionaryName = DictionaryType.withName(\"plurals\"),\n  batchDictionaryEntriesParams = BatchDictionaryEntriesParams(\n    clearExistingDictionaryEntries = Some(true),\n    requests = Seq(\n      BatchDictionaryEntriesRequest(\n        action = DictionaryAction.withName(\"addEntry\"),\n        body = DictionaryEntry(\n          objectID = \"1\",\n          language = Some(SupportedLanguage.withName(\"en\")),\n          word = Some(\"fancy\"),\n          words = Some(Seq(\"believe\", \"algolia\")),\n          decomposition = Some(Seq(\"trust\", \"algolia\")),\n          state = Some(DictionaryEntryState.withName(\"enabled\"))\n        )\n      )\n    )\n  )\n)",
      "delete": "val response = client.batchDictionaryEntries(\n  dictionaryName = DictionaryType.withName(\"plurals\"),\n  batchDictionaryEntriesParams = BatchDictionaryEntriesParams(\n    clearExistingDictionaryEntries = Some(true),\n    requests = Seq(\n      BatchDictionaryEntriesRequest(\n        action = DictionaryAction.withName(\"deleteEntry\"),\n        body = DictionaryEntry(\n          objectID = \"1\"\n        )\n      )\n    )\n  )\n)",
      "append": "val response = client.batchDictionaryEntries(\n  dictionaryName = DictionaryType.withName(\"stopwords\"),\n  batchDictionaryEntriesParams = BatchDictionaryEntriesParams(\n    requests = Seq(\n      BatchDictionaryEntriesRequest(\n        action = DictionaryAction.withName(\"addEntry\"),\n        body = DictionaryEntry(\n          objectID = \"1\",\n          language = Some(SupportedLanguage.withName(\"en\")),\n          additionalProperties = Some(List(JField(\"additional\", JString(\"try me\"))))\n        )\n      )\n    )\n  )\n)"
    },
    "browse": {
      "default": "val response = client.browse(\n  indexName = \"<YOUR_INDEX_NAME>\"\n)"
    },
    "clearObjects": {
      "default": "val response = client.clearObjects(\n  indexName = \"<YOUR_INDEX_NAME>\"\n)"
    },
    "clearRules": {
      "default": "val response = client.clearRules(\n  indexName = \"<YOUR_INDEX_NAME>\"\n)"
    },
    "clearSynonyms": {
      "default": "val response = client.clearSynonyms(\n  indexName = \"<YOUR_INDEX_NAME>\"\n)"
    },
    "customDelete": {
      "default": "val response = client.customDelete[JObject](\n  path = \"test/minimal\"\n)"
    },
    "customGet": {
      "default": "val response = client.customGet[JObject](\n  path = \"test/minimal\"\n)"
    },
    "customPost": {
      "default": "val response = client.customPost[JObject](\n  path = \"test/minimal\"\n)"
    },
    "customPut": {
      "default": "val response = client.customPut[JObject](\n  path = \"test/minimal\"\n)"
    },
    "deleteApiKey": {
      "default": "val response = client.deleteApiKey(\n  key = \"myTestApiKey\"\n)"
    },
    "deleteBy": {
      "default": "val response = client.deleteBy(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  deleteByParams = DeleteByParams(\n    filters = Some(\"brand:brandName\")\n  )\n)"
    },
    "deleteIndex": {
      "default": "val response = client.deleteIndex(\n  indexName = \"<YOUR_INDEX_NAME>\"\n)"
    },
    "deleteObject": {
      "default": "val response = client.deleteObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\"\n)"
    },
    "deleteRule": {
      "default": "val response = client.deleteRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"id1\"\n)"
    },
    "deleteSource": {
      "default": "val response = client.deleteSource(\n  source = \"theSource\"\n)"
    },
    "deleteSynonym": {
      "default": "val response = client.deleteSynonym(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"id1\"\n)"
    },
    "getApiKey": {
      "default": "val response = client.getApiKey(\n  key = \"myTestApiKey\"\n)"
    },
    "getAppTask": {
      "default": "val response = client.getAppTask(\n  taskID = 123L\n)"
    },
    "getDictionaryLanguages": {
      "default": "val response = client.getDictionaryLanguages(\n)"
    },
    "getDictionarySettings": {
      "default": "val response = client.getDictionarySettings(\n)"
    },
    "getLogs": {
      "default": "val response = client.getLogs(\n)"
    },
    "getObject": {
      "default": "val response = client.getObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\",\n  attributesToRetrieve = Some(Seq(\"attr1\", \"attr2\"))\n)"
    },
    "getObjects": {
      "default": "val response = client.getObjects(\n  getObjectsParams = GetObjectsParams(\n    requests = Seq(\n      GetObjectsRequest(\n        attributesToRetrieve = Some(Seq(\"attr1\", \"attr2\")),\n        objectID = \"uniqueID\",\n        indexName = \"<YOUR_INDEX_NAME>\"\n      )\n    )\n  )\n)"
    },
    "getRule": {
      "default": "val response = client.getRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"qr-1725004648916\"\n)"
    },
    "getSettings": {
      "default": "val response = client.getSettings(\n  indexName = \"<YOUR_INDEX_NAME>\"\n)"
    },
    "getSources": {
      "default": "val response = client.getSources(\n)"
    },
    "getSynonym": {
      "default": "val response = client.getSynonym(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"id1\"\n)"
    },
    "getTask": {
      "default": "val response = client.getTask(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  taskID = 123L\n)"
    },
    "getTopUserIds": {
      "default": "val response = client.getTopUserIds(\n)"
    },
    "getUserId": {
      "default": "val response = client.getUserId(\n  userID = \"uniqueID\"\n)"
    },
    "hasPendingMappings": {
      "default": "val response = client.hasPendingMappings(\n)"
    },
    "listApiKeys": {
      "default": "val response = client.listApiKeys(\n)"
    },
    "listClusters": {
      "default": "val response = client.listClusters(\n)"
    },
    "listIndices": {
      "default": "val response = client.listIndices(\n)"
    },
    "listUserIds": {
      "default": "val response = client.listUserIds(\n)"
    },
    "multipleBatch": {
      "default": "val response = client.multipleBatch(\n  batchParams = BatchParams(\n    requests = Seq(\n      MultipleBatchRequest(\n        action = Action.withName(\"addObject\"),\n        body = Some(JObject(List(JField(\"key\", JString(\"value\"))))),\n        indexName = \"<YOUR_INDEX_NAME>\"\n      )\n    )\n  )\n)"
    },
    "operationIndex": {
      "scopes": "val response = client.operationIndex(\n  indexName = \"<SOURCE_INDEX_NAME>\",\n  operationIndexParams = OperationIndexParams(\n    operation = OperationType.withName(\"move\"),\n    destination = \"<DESTINATION_INDEX_NAME>\",\n    scope = Some(Seq(ScopeType.withName(\"rules\"), ScopeType.withName(\"settings\")))\n  )\n)",
      "copy": "val response = client.operationIndex(\n  indexName = \"<SOURCE_INDEX_NAME>\",\n  operationIndexParams = OperationIndexParams(\n    operation = OperationType.withName(\"copy\"),\n    destination = \"<DESTINATION_INDEX_NAME>\"\n  )\n)",
      "move": "val response = client.operationIndex(\n  indexName = \"<SOURCE_INDEX_NAME>\",\n  operationIndexParams = OperationIndexParams(\n    operation = OperationType.withName(\"move\"),\n    destination = \"<DESTINATION_INDEX_NAME>\"\n  )\n)"
    },
    "partialUpdateObject": {
      "default": "val response = client.partialUpdateObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"uniqueID\",\n  attributesToUpdate = JObject(List(JField(\"attributeId\", JString(\"new value\"))))\n)"
    },
    "removeUserId": {
      "default": "val response = client.removeUserId(\n  userID = \"uniqueID\"\n)"
    },
    "replaceSources": {
      "default": "val response = client.replaceSources(\n  source = Seq(\n    Source(\n      source = \"theSource\",\n      description = Some(\"theDescription\")\n    )\n  )\n)"
    },
    "restoreApiKey": {
      "default": "val response = client.restoreApiKey(\n  key = \"ALGOLIA_API_KEY\"\n)"
    },
    "saveObject": {
      "default": "val response = client.saveObject(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  body = JObject(List(JField(\"objectID\", JString(\"id\")), JField(\"test\", JString(\"val\"))))\n)"
    },
    "saveRule": {
      "default": "val response = client.saveRule(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"id1\",\n  rule = Rule(\n    objectID = \"id1\",\n    conditions = Some(\n      Seq(\n        Condition(\n          pattern = Some(\"apple\"),\n          anchoring = Some(Anchoring.withName(\"contains\"))\n        )\n      )\n    )\n  )\n)"
    },
    "saveRules": {
      "default": "val response = client.saveRules(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  rules = Seq(\n    Rule(\n      objectID = \"a-rule-id\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"smartphone\"),\n            anchoring = Some(Anchoring.withName(\"contains\"))\n          )\n        )\n      )\n    ),\n    Rule(\n      objectID = \"a-second-rule-id\",\n      conditions = Some(\n        Seq(\n          Condition(\n            pattern = Some(\"apple\"),\n            anchoring = Some(Anchoring.withName(\"contains\"))\n          )\n        )\n      )\n    )\n  ),\n  forwardToReplicas = Some(false),\n  clearExistingRules = Some(true)\n)"
    },
    "saveSynonym": {
      "default": "val response = client.saveSynonym(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  objectID = \"id1\",\n  synonymHit = SynonymHit(\n    objectID = \"id1\",\n    `type` = SynonymType.withName(\"synonym\"),\n    synonyms = Some(Seq(\"car\", \"vehicule\", \"auto\"))\n  ),\n  forwardToReplicas = Some(true)\n)"
    },
    "saveSynonyms": {
      "default": "val response = client.saveSynonyms(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  synonymHit = Seq(\n    SynonymHit(\n      objectID = \"id1\",\n      `type` = SynonymType.withName(\"synonym\"),\n      synonyms = Some(Seq(\"car\", \"vehicule\", \"auto\"))\n    ),\n    SynonymHit(\n      objectID = \"id2\",\n      `type` = SynonymType.withName(\"onewaysynonym\"),\n      input = Some(\"iphone\"),\n      synonyms = Some(Seq(\"ephone\", \"aphone\", \"yphone\"))\n    )\n  ),\n  forwardToReplicas = Some(true),\n  replaceExistingSynonyms = Some(true)\n)"
    },
    "search": {
      "withHitsPerPage": "val response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = Seq(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = Some(\"<YOUR_QUERY>\"),\n        hitsPerPage = Some(50)\n      )\n    )\n  )\n)",
      "filterOnly": "val response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = Seq(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = Some(\"<YOUR_QUERY>\"),\n        filters = Some(\"actor:Scarlett Johansson\")\n      )\n    )\n  )\n)",
      "filterOr": "val response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = Seq(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = Some(\"<YOUR_QUERY>\"),\n        filters = Some(\"actor:Tom Cruise OR actor:Scarlett Johansson\")\n      )\n    )\n  )\n)",
      "filterNot": "val response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = Seq(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = Some(\"<YOUR_QUERY>\"),\n        filters = Some(\"NOT actor:Nicolas Cage\")\n      )\n    )\n  )\n)",
      "retrieveFacets": "val response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = Seq(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = Some(\"<YOUR_QUERY>\"),\n        facets = Some(Seq(\"author\", \"genre\"))\n      )\n    )\n  )\n)",
      "retrieveFacetsWildcard": "val response = client.search(\n  searchMethodParams = SearchMethodParams(\n    requests = Seq(\n      SearchForHits(\n        indexName = \"<YOUR_INDEX_NAME>\",\n        query = Some(\"<YOUR_QUERY>\"),\n        facets = Some(Seq(\"*\"))\n      )\n    )\n  )\n)"
    },
    "searchDictionaryEntries": {
      "default": "val response = client.searchDictionaryEntries(\n  dictionaryName = DictionaryType.withName(\"stopwords\"),\n  searchDictionaryEntriesParams = SearchDictionaryEntriesParams(\n    query = \"about\"\n  )\n)"
    },
    "searchForFacetValues": {
      "default": "val response = client.searchForFacetValues(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  facetName = \"facetName\"\n)"
    },
    "searchRules": {
      "default": "val response = client.searchRules(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  searchRulesParams = Some(\n    SearchRulesParams(\n      query = Some(\"zorro\")\n    )\n  )\n)"
    },
    "searchSingleIndex": {
      "default": "val response = client.searchSingleIndex(\n  indexName = \"<YOUR_INDEX_NAME>\"\n)"
    },
    "searchSynonyms": {
      "default": "val response = client.searchSynonyms(\n  indexName = \"<YOUR_INDEX_NAME>\"\n)"
    },
    "searchUserIds": {
      "default": "val response = client.searchUserIds(\n  searchUserIdsParams = SearchUserIdsParams(\n    query = \"test\",\n    clusterName = Some(\"theClusterName\"),\n    page = Some(5),\n    hitsPerPage = Some(10)\n  )\n)"
    },
    "setDictionarySettings": {
      "default": "val response = client.setDictionarySettings(\n  dictionarySettingsParams = DictionarySettingsParams(\n    disableStandardEntries = StandardEntries(\n      plurals = Some(Map(\"fr\" -> false, \"en\" -> false, \"ru\" -> true))\n    )\n  )\n)"
    },
    "setSettings": {
      "default": "val response = client.setSettings(\n  indexName = \"<YOUR_INDEX_NAME>\",\n  indexSettings = IndexSettings(\n    attributesForFaceting = Some(Seq(\"actor\", \"filterOnly(category)\", \"searchable(publisher)\"))\n  )\n)"
    },
    "updateApiKey": {
      "default": "val response = client.updateApiKey(\n  key = \"ALGOLIA_API_KEY\",\n  apiKey = ApiKey(\n    acl = Seq(Acl.withName(\"search\"), Acl.withName(\"addObject\")),\n    validity = Some(300),\n    maxQueriesPerIPPerHour = Some(100),\n    maxHitsPerQuery = Some(20)\n  )\n)"
    },
    "init": {
      "default": "val client = SearchClient(appId = \"ALGOLIA_APPLICATION_ID\", apiKey = \"ALGOLIA_API_KEY\")"
    }
  },
  "swift": {
    "import": {
      "default": "import Search"
    },
    "addApiKey": {
      "default": "let response = try await client.addApiKey(apiKey: ApiKey(\n    acl: [Acl.search, Acl.addObject],\n    description: \"my new api key\",\n    maxHitsPerQuery: 20,\n    maxQueriesPerIPPerHour: 100,\n    validity: 300\n))"
    },
    "addOrUpdateObject": {
      "default": "let response = try await client.addOrUpdateObject(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"uniqueID\",\n    body: [\"key\": \"value\"]\n)"
    },
    "appendSource": {
      "default": "let response = try await client.appendSource(source: SearchSource(\n    source: \"theSource\",\n    description: \"theDescription\"\n))"
    },
    "assignUserId": {
      "default": "let response = try await client.assignUserId(\n    xAlgoliaUserID: \"userID\",\n    assignUserIdParams: AssignUserIdParams(cluster: \"theCluster\")\n)"
    },
    "batch": {
      "addObject": "let response = try await client.batch(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    batchWriteParams: SearchBatchWriteParams(requests: [\n        SearchBatchRequest(action: SearchAction.addObject, body: [\"key\": \"bar\", \"foo\": \"1\"]),\n        SearchBatchRequest(action: SearchAction.addObject, body: [\"key\": \"baz\", \"foo\": \"2\"]),\n    ])\n)",
      "clear": "let response = try await client.batch(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    batchWriteParams: SearchBatchWriteParams(requests: [SearchBatchRequest(\n        action: SearchAction.clear,\n        body: [\"key\": \"value\"]\n    )])\n)",
      "delete": "let response = try await client.batch(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    batchWriteParams: SearchBatchWriteParams(requests: [SearchBatchRequest(\n        action: SearchAction.delete,\n        body: [\"key\": \"value\"]\n    )])\n)",
      "deleteObject": "let response = try await client.batch(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    batchWriteParams: SearchBatchWriteParams(requests: [SearchBatchRequest(\n        action: SearchAction.deleteObject,\n        body: [\"key\": \"value\"]\n    )])\n)",
      "partialUpdateObject": "let response = try await client.batch(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    batchWriteParams: SearchBatchWriteParams(requests: [SearchBatchRequest(\n        action: SearchAction.partialUpdateObject,\n        body: [\"key\": \"value\"]\n    )])\n)",
      "partialUpdateObjectNoCreate": "let response = try await client.batch(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    batchWriteParams: SearchBatchWriteParams(requests: [SearchBatchRequest(\n        action: SearchAction.partialUpdateObjectNoCreate,\n        body: [\"key\": \"value\"]\n    )])\n)",
      "updateObject": "let response = try await client.batch(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    batchWriteParams: SearchBatchWriteParams(requests: [SearchBatchRequest(\n        action: SearchAction.updateObject,\n        body: [\"key\": \"value\"]\n    )])\n)"
    },
    "batchAssignUserIds": {
      "default": "let response = try await client.batchAssignUserIds(\n    xAlgoliaUserID: \"userID\",\n    batchAssignUserIdsParams: BatchAssignUserIdsParams(cluster: \"theCluster\", users: [\"user1\", \"user2\"])\n)"
    },
    "batchDictionaryEntries": {
      "replace": "let response = try await client.batchDictionaryEntries(\n    dictionaryName: DictionaryType.plurals,\n    batchDictionaryEntriesParams: BatchDictionaryEntriesParams(\n        clearExistingDictionaryEntries: true,\n        requests: [BatchDictionaryEntriesRequest(\n            action: DictionaryAction.addEntry,\n            body: DictionaryEntry(\n                objectID: \"1\",\n                language: SearchSupportedLanguage.en,\n                word: \"fancy\",\n                words: [\"believe\", \"algolia\"],\n                decomposition: [\"trust\", \"algolia\"],\n                state: DictionaryEntryState.enabled\n            )\n        )]\n    )\n)",
      "delete": "let response = try await client.batchDictionaryEntries(\n    dictionaryName: DictionaryType.plurals,\n    batchDictionaryEntriesParams: BatchDictionaryEntriesParams(\n        clearExistingDictionaryEntries: true,\n        requests: [BatchDictionaryEntriesRequest(\n            action: DictionaryAction.deleteEntry,\n            body: DictionaryEntry(objectID: \"1\")\n        )]\n    )\n)",
      "append": "let response = try await client.batchDictionaryEntries(\n    dictionaryName: DictionaryType.stopwords,\n    batchDictionaryEntriesParams: BatchDictionaryEntriesParams(requests: [BatchDictionaryEntriesRequest(\n        action: DictionaryAction.addEntry,\n        body: DictionaryEntry(from: [\n            \"objectID\": AnyCodable(\"1\"),\n            \"language\": AnyCodable(SearchSupportedLanguage.en),\n            \"additional\": AnyCodable(\"try me\"),\n        ])\n    )])\n)"
    },
    "browse": {
      "default": "let response: BrowseResponse<Hit> = try await client.browse(indexName: \"<YOUR_INDEX_NAME>\")"
    },
    "clearObjects": {
      "default": "let response = try await client.clearObjects(indexName: \"<YOUR_INDEX_NAME>\")"
    },
    "clearRules": {
      "default": "let response = try await client.clearRules(indexName: \"<YOUR_INDEX_NAME>\")"
    },
    "clearSynonyms": {
      "default": "let response = try await client.clearSynonyms(indexName: \"<YOUR_INDEX_NAME>\")"
    },
    "customDelete": {
      "default": "let response = try await client.customDelete(path: \"test/minimal\")"
    },
    "customGet": {
      "default": "let response = try await client.customGet(path: \"test/minimal\")"
    },
    "customPost": {
      "default": "let response = try await client.customPost(path: \"test/minimal\")"
    },
    "customPut": {
      "default": "let response = try await client.customPut(path: \"test/minimal\")"
    },
    "deleteApiKey": {
      "default": "let response = try await client.deleteApiKey(key: \"myTestApiKey\")"
    },
    "deleteBy": {
      "default": "let response = try await client.deleteBy(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    deleteByParams: DeleteByParams(filters: \"brand:brandName\")\n)"
    },
    "deleteIndex": {
      "default": "let response = try await client.deleteIndex(indexName: \"<YOUR_INDEX_NAME>\")"
    },
    "deleteObject": {
      "default": "let response = try await client.deleteObject(indexName: \"<YOUR_INDEX_NAME>\", objectID: \"uniqueID\")"
    },
    "deleteObjects": {
      "default": "let response = try await client.deleteObjects(indexName: \"<YOUR_INDEX_NAME>\", objectIDs: [\"1\", \"2\"])"
    },
    "deleteRule": {
      "default": "let response = try await client.deleteRule(indexName: \"<YOUR_INDEX_NAME>\", objectID: \"id1\")"
    },
    "deleteSource": {
      "default": "let response = try await client.deleteSource(source: \"theSource\")"
    },
    "deleteSynonym": {
      "default": "let response = try await client.deleteSynonym(indexName: \"<YOUR_INDEX_NAME>\", objectID: \"id1\")"
    },
    "generateSecuredApiKey": {
      "generate secured api key basic": "let response = try client.generateSecuredApiKey(\n    parentApiKey: \"2640659426d5107b6e47d75db9cbaef8\",\n    restrictions: SecuredApiKeyRestrictions(validUntil: Int64(2_524_604_400), restrictIndices: [\"Movies\"])\n)",
      "generate secured api key with searchParams": "let response = try client.generateSecuredApiKey(\n    parentApiKey: \"2640659426d5107b6e47d75db9cbaef8\",\n    restrictions: SecuredApiKeyRestrictions(\n        searchParams: SearchSearchParamsObject(\n            query: \"batman\",\n            aroundRadius: SearchAroundRadius.searchAroundRadiusAll(SearchAroundRadiusAll.all),\n            hitsPerPage: 10,\n            typoTolerance: SearchTypoTolerance.searchTypoToleranceEnum(SearchTypoToleranceEnum.strict),\n            mode: SearchMode.neuralSearch,\n            optionalWords: [\"one\", \"two\"]\n        ),\n        filters: \"category:Book OR category:Ebook AND _tags:published\",\n        validUntil: Int64(2_524_604_400),\n        restrictIndices: [\"Movies\", \"cts_e2e_settings\"],\n        restrictSources: \"192.168.1.0/24\",\n        userToken: \"user123\"\n    )\n)"
    },
    "getApiKey": {
      "default": "let response = try await client.getApiKey(key: \"myTestApiKey\")"
    },
    "getAppTask": {
      "default": "let response = try await client.getAppTask(taskID: Int64(123))"
    },
    "getDictionaryLanguages": {
      "default": "let response = try await client.getDictionaryLanguages()"
    },
    "getDictionarySettings": {
      "default": "let response = try await client.getDictionarySettings()"
    },
    "getLogs": {
      "default": "let response = try await client.getLogs()"
    },
    "getObject": {
      "default": "let response = try await client.getObject(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"uniqueID\",\n    attributesToRetrieve: [\"attr1\", \"attr2\"]\n)"
    },
    "getObjects": {
      "default": "let response: GetObjectsResponse<Hit> = try await client\n    .getObjects(getObjectsParams: GetObjectsParams(requests: [GetObjectsRequest(\n        attributesToRetrieve: [\"attr1\", \"attr2\"],\n        objectID: \"uniqueID\",\n        indexName: \"<YOUR_INDEX_NAME>\"\n    )]))"
    },
    "getRule": {
      "default": "let response = try await client.getRule(indexName: \"<YOUR_INDEX_NAME>\", objectID: \"qr-1725004648916\")"
    },
    "getSettings": {
      "default": "let response = try await client.getSettings(indexName: \"<YOUR_INDEX_NAME>\")"
    },
    "getSources": {
      "default": "let response = try await client.getSources()"
    },
    "getSynonym": {
      "default": "let response = try await client.getSynonym(indexName: \"<YOUR_INDEX_NAME>\", objectID: \"id1\")"
    },
    "getTask": {
      "default": "let response = try await client.getTask(indexName: \"<YOUR_INDEX_NAME>\", taskID: Int64(123))"
    },
    "getTopUserIds": {
      "default": "let response = try await client.getTopUserIds()"
    },
    "getUserId": {
      "default": "let response = try await client.getUserId(userID: \"uniqueID\")"
    },
    "hasPendingMappings": {
      "default": "let response = try await client.hasPendingMappings()"
    },
    "indexExists": {
      "indexExists": "let response = try await client.indexExists(indexName: \"<YOUR_INDEX_NAME>\")",
      "indexNotExists": "let response = try await client.indexExists(indexName: \"<YOUR_INDEX_NAME>\")",
      "indexExistsWithError": "let response = try await client.indexExists(indexName: \"<YOUR_INDEX_NAME>\")"
    },
    "listApiKeys": {
      "default": "let response = try await client.listApiKeys()"
    },
    "listClusters": {
      "default": "let response = try await client.listClusters()"
    },
    "listIndices": {
      "default": "let response = try await client.listIndices()"
    },
    "listUserIds": {
      "default": "let response = try await client.listUserIds()"
    },
    "multipleBatch": {
      "default": "let response = try await client.multipleBatch(batchParams: BatchParams(requests: [MultipleBatchRequest(\n    action: SearchAction.addObject,\n    body: [\"key\": \"value\"],\n    indexName: \"<YOUR_INDEX_NAME>\"\n)]))"
    },
    "operationIndex": {
      "scopes": "let response = try await client.operationIndex(\n    indexName: \"<SOURCE_INDEX_NAME>\",\n    operationIndexParams: OperationIndexParams(\n        operation: OperationType.move,\n        destination: \"<DESTINATION_INDEX_NAME>\",\n        scope: [ScopeType.rules, ScopeType.settings]\n    )\n)",
      "copy": "let response = try await client.operationIndex(\n    indexName: \"<SOURCE_INDEX_NAME>\",\n    operationIndexParams: OperationIndexParams(\n        operation: OperationType.copy,\n        destination: \"<DESTINATION_INDEX_NAME>\"\n    )\n)",
      "move": "let response = try await client.operationIndex(\n    indexName: \"<SOURCE_INDEX_NAME>\",\n    operationIndexParams: OperationIndexParams(\n        operation: OperationType.move,\n        destination: \"<DESTINATION_INDEX_NAME>\"\n    )\n)"
    },
    "partialUpdateObject": {
      "default": "let response = try await client.partialUpdateObject(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"uniqueID\",\n    attributesToUpdate: [\"attributeId\": \"new value\"]\n)"
    },
    "partialUpdateObjects": {
      "call partialUpdateObjects with createIfNotExists=true": "let response = try await client.partialUpdateObjects(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objects: [[\"objectID\": \"1\", \"name\": \"Adam\"], [\"objectID\": \"2\", \"name\": \"Benoit\"]],\n    createIfNotExists: true\n)",
      "call partialUpdateObjects with createIfNotExists=false": "let response = try await client.partialUpdateObjects(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objects: [[\"objectID\": \"3\", \"name\": \"Cyril\"], [\"objectID\": \"4\", \"name\": \"David\"]],\n    createIfNotExists: false\n)"
    },
    "removeUserId": {
      "default": "let response = try await client.removeUserId(userID: \"uniqueID\")"
    },
    "replaceAllObjects": {
      "default": "let response = try await client.replaceAllObjects(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objects: [\n        [\"objectID\": \"1\", \"name\": \"Adam\"],\n        [\"objectID\": \"2\", \"name\": \"Benoit\"],\n        [\"objectID\": \"3\", \"name\": \"Cyril\"],\n        [\"objectID\": \"4\", \"name\": \"David\"],\n        [\"objectID\": \"5\", \"name\": \"Eva\"],\n        [\"objectID\": \"6\", \"name\": \"Fiona\"],\n        [\"objectID\": \"7\", \"name\": \"Gael\"],\n        [\"objectID\": \"8\", \"name\": \"Hugo\"],\n        [\"objectID\": \"9\", \"name\": \"Igor\"],\n        [\"objectID\": \"10\", \"name\": \"Julia\"],\n    ],\n    batchSize: 3\n)"
    },
    "replaceSources": {
      "default": "let response = try await client.replaceSources(source: [SearchSource(\n    source: \"theSource\",\n    description: \"theDescription\"\n)])"
    },
    "restoreApiKey": {
      "default": "let response = try await client.restoreApiKey(key: \"ALGOLIA_API_KEY\")"
    },
    "saveObject": {
      "default": "let response = try await client.saveObject(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    body: [\"objectID\": \"id\", \"test\": \"val\"]\n)"
    },
    "saveObjects": {
      "call saveObjects without error": "let response = try await client.saveObjects(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objects: [[\"objectID\": \"1\", \"name\": \"Adam\"], [\"objectID\": \"2\", \"name\": \"Benoit\"]]\n)",
      "saveObjects should report errors": "let response = try await client.saveObjects(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objects: [[\"objectID\": \"1\", \"name\": \"Adam\"], [\"objectID\": \"2\", \"name\": \"Benoit\"]]\n)"
    },
    "saveRule": {
      "default": "let response = try await client.saveRule(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"id1\",\n    rule: Rule(\n        objectID: \"id1\",\n        conditions: [SearchCondition(pattern: \"apple\", anchoring: SearchAnchoring.contains)]\n    )\n)"
    },
    "saveRules": {
      "default": "let response = try await client.saveRules(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    rules: [\n        Rule(\n            objectID: \"a-rule-id\",\n            conditions: [SearchCondition(pattern: \"smartphone\", anchoring: SearchAnchoring.contains)]\n        ),\n        Rule(\n            objectID: \"a-second-rule-id\",\n            conditions: [SearchCondition(pattern: \"apple\", anchoring: SearchAnchoring.contains)]\n        ),\n    ],\n    forwardToReplicas: false,\n    clearExistingRules: true\n)"
    },
    "saveSynonym": {
      "default": "let response = try await client.saveSynonym(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    objectID: \"id1\",\n    synonymHit: SynonymHit(objectID: \"id1\", type: SynonymType.synonym, synonyms: [\"car\", \"vehicule\", \"auto\"]),\n    forwardToReplicas: true\n)"
    },
    "saveSynonyms": {
      "default": "let response = try await client.saveSynonyms(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    synonymHit: [\n        SynonymHit(objectID: \"id1\", type: SynonymType.synonym, synonyms: [\"car\", \"vehicule\", \"auto\"]),\n        SynonymHit(\n            objectID: \"id2\",\n            type: SynonymType.onewaysynonym,\n            synonyms: [\"ephone\", \"aphone\", \"yphone\"],\n            input: \"iphone\"\n        ),\n    ],\n    forwardToReplicas: true,\n    replaceExistingSynonyms: true\n)"
    },
    "search": {
      "withHitsPerPage": "let response: SearchResponses<Hit> = try await client\n    .search(searchMethodParams: SearchMethodParams(requests: [SearchQuery.searchForHits(SearchForHits(\n        query: \"<YOUR_QUERY>\",\n        hitsPerPage: 50,\n        indexName: \"<YOUR_INDEX_NAME>\"\n    ))]))",
      "filterOnly": "let response: SearchResponses<Hit> = try await client\n    .search(searchMethodParams: SearchMethodParams(requests: [SearchQuery.searchForHits(SearchForHits(\n        query: \"<YOUR_QUERY>\",\n        filters: \"actor:Scarlett Johansson\",\n        indexName: \"<YOUR_INDEX_NAME>\"\n    ))]))",
      "filterOr": "let response: SearchResponses<Hit> = try await client\n    .search(searchMethodParams: SearchMethodParams(requests: [SearchQuery.searchForHits(SearchForHits(\n        query: \"<YOUR_QUERY>\",\n        filters: \"actor:Tom Cruise OR actor:Scarlett Johansson\",\n        indexName: \"<YOUR_INDEX_NAME>\"\n    ))]))",
      "filterNot": "let response: SearchResponses<Hit> = try await client\n    .search(searchMethodParams: SearchMethodParams(requests: [SearchQuery.searchForHits(SearchForHits(\n        query: \"<YOUR_QUERY>\",\n        filters: \"NOT actor:Nicolas Cage\",\n        indexName: \"<YOUR_INDEX_NAME>\"\n    ))]))",
      "retrieveFacets": "let response: SearchResponses<Hit> = try await client\n    .search(searchMethodParams: SearchMethodParams(requests: [SearchQuery.searchForHits(SearchForHits(\n        query: \"<YOUR_QUERY>\",\n        facets: [\"author\", \"genre\"],\n        indexName: \"<YOUR_INDEX_NAME>\"\n    ))]))",
      "retrieveFacetsWildcard": "let response: SearchResponses<Hit> = try await client\n    .search(searchMethodParams: SearchMethodParams(requests: [SearchQuery.searchForHits(SearchForHits(\n        query: \"<YOUR_QUERY>\",\n        facets: [\"*\"],\n        indexName: \"<YOUR_INDEX_NAME>\"\n    ))]))"
    },
    "searchDictionaryEntries": {
      "default": "let response = try await client.searchDictionaryEntries(\n    dictionaryName: DictionaryType.stopwords,\n    searchDictionaryEntriesParams: SearchDictionaryEntriesParams(query: \"about\")\n)"
    },
    "searchForFacetValues": {
      "default": "let response = try await client.searchForFacetValues(indexName: \"<YOUR_INDEX_NAME>\", facetName: \"facetName\")"
    },
    "searchRules": {
      "default": "let response = try await client.searchRules(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    searchRulesParams: SearchRulesParams(query: \"zorro\")\n)"
    },
    "searchSingleIndex": {
      "default": "let response: SearchResponse<Hit> = try await client.searchSingleIndex(indexName: \"<YOUR_INDEX_NAME>\")"
    },
    "searchSynonyms": {
      "default": "let response = try await client.searchSynonyms(indexName: \"<YOUR_INDEX_NAME>\")"
    },
    "searchUserIds": {
      "default": "let response = try await client.searchUserIds(searchUserIdsParams: SearchUserIdsParams(\n    query: \"test\",\n    clusterName: \"theClusterName\",\n    page: 5,\n    hitsPerPage: 10\n))"
    },
    "setClientApiKey": {
      "default": "try client.setClientApiKey(apiKey: \"updated-api-key\")"
    },
    "setDictionarySettings": {
      "default": "let response = try await client\n    .setDictionarySettings(\n        dictionarySettingsParams: DictionarySettingsParams(disableStandardEntries: StandardEntries(plurals: [\n            \"fr\": false,\n            \"en\": false,\n            \"ru\": true,\n        ]))\n    )"
    },
    "setSettings": {
      "default": "let response = try await client.setSettings(\n    indexName: \"<YOUR_INDEX_NAME>\",\n    indexSettings: IndexSettings(attributesForFaceting: [\n        \"actor\",\n        \"filterOnly(category)\",\n        \"searchable(publisher)\",\n    ])\n)"
    },
    "updateApiKey": {
      "default": "let response = try await client.updateApiKey(\n    key: \"ALGOLIA_API_KEY\",\n    apiKey: ApiKey(\n        acl: [Acl.search, Acl.addObject],\n        maxHitsPerQuery: 20,\n        maxQueriesPerIPPerHour: 100,\n        validity: 300\n    )\n)"
    },
    "waitForApiKey": {
      "wait for api key helper - add": "let response = try await client.waitForApiKey(\n    key: \"api-key-add-operation-test-swift\",\n    operation: ApiKeyOperation.add\n)",
      "wait for api key - update": "let response = try await client.waitForApiKey(\n    key: \"api-key-update-operation-test-swift\",\n    operation: ApiKeyOperation.update,\n    apiKey: ApiKey(\n        acl: [Acl.search, Acl.addObject, Acl.deleteObject],\n        description: \"my updated api key\",\n        indexes: [\"Movies\", \"Books\"],\n        maxHitsPerQuery: 20,\n        maxQueriesPerIPPerHour: 95,\n        referers: [\"*google.com\", \"*algolia.com\"],\n        validity: 305\n    )\n)",
      "wait for api key - delete": "let response = try await client.waitForApiKey(\n    key: \"api-key-delete-operation-test-swift\",\n    operation: ApiKeyOperation.delete\n)"
    },
    "waitForAppTask": {
      "default": "let response = try await client.waitForAppTask(taskID: Int64(123))"
    },
    "waitForTask": {
      "default": "let response = try await client.waitForTask(indexName: \"<YOUR_INDEX_NAME>\", taskID: Int64(123))"
    },
    "init": {
      "default": "let client = try SearchClient(appID: \"ALGOLIA_APPLICATION_ID\", apiKey: \"ALGOLIA_API_KEY\")"
    }
  }
}