{
  "csharp": {},
  "dart": {},
  "go": {},
  "java": {},
  "javascript": {
    "import": {
      "default": "import { compositionClient } from '@algolia/client-composition';"
    },
    "customDelete": {
      "allow del method for a custom path with minimal parameters": "const response = await client.customDelete({ path: 'test/minimal' });",
      "allow del method for a custom path with all parameters": "const response = await client.customDelete({ path: 'test/all', parameters: { query: 'parameters' } });"
    },
    "customGet": {
      "allow get method for a custom path with minimal parameters": "const response = await client.customGet({ path: 'test/minimal' });",
      "allow get method for a custom path with all parameters": "const response = await client.customGet({ path: 'test/all', parameters: { query: 'parameters with space' } });",
      "requestOptions should be escaped too": "const response = await client.customGet(\n  { path: 'test/all', parameters: { query: 'to be overriden' } },\n  {\n    queryParameters: { query: 'parameters with space', 'and an array': ['array', 'with spaces'] },\n    headers: { 'x-header-1': 'spaces are left alone' },\n  },\n);"
    },
    "customPost": {
      "allow post method for a custom path with minimal parameters": "const response = await client.customPost({ path: 'test/minimal' });",
      "allow post method for a custom path with all parameters": "const response = await client.customPost({\n  path: 'test/all',\n  parameters: { query: 'parameters' },\n  body: { body: 'parameters' },\n});",
      "requestOptions can override default query parameters": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    queryParameters: { query: 'myQueryParameter' },\n  },\n);",
      "requestOptions merges query parameters with default ones": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    queryParameters: { query2: 'myQueryParameter' },\n  },\n);",
      "requestOptions can override default headers": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    headers: { 'x-algolia-api-key': 'ALGOLIA_API_KEY' },\n  },\n);",
      "requestOptions merges headers with default ones": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    headers: { 'x-algolia-api-key': 'ALGOLIA_API_KEY' },\n  },\n);",
      "requestOptions queryParameters accepts booleans": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    queryParameters: { isItWorking: true },\n  },\n);",
      "requestOptions queryParameters accepts integers": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    queryParameters: { myParam: 2 },\n  },\n);",
      "requestOptions queryParameters accepts list of string": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    queryParameters: { myParam: ['b and c', 'd'] },\n  },\n);",
      "requestOptions queryParameters accepts list of booleans": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    queryParameters: { myParam: [true, true, false] },\n  },\n);",
      "requestOptions queryParameters accepts list of integers": "const response = await client.customPost(\n  { path: 'test/requestOptions', parameters: { query: 'parameters' }, body: { facet: 'filters' } },\n  {\n    queryParameters: { myParam: [1, 2] },\n  },\n);"
    },
    "customPut": {
      "allow put method for a custom path with minimal parameters": "const response = await client.customPut({ path: 'test/minimal' });",
      "allow put method for a custom path with all parameters": "const response = await client.customPut({\n  path: 'test/all',\n  parameters: { query: 'parameters' },\n  body: { body: 'parameters' },\n});"
    },
    "deleteComposition": {
      "default": "const response = await client.deleteComposition({ compositionID: '1234' });"
    },
    "deleteCompositionRule": {
      "default": "const response = await client.deleteCompositionRule({ compositionID: '1234', objectID: '5678' });"
    },
    "getComposition": {
      "default": "const response = await client.getComposition({ compositionID: 'foo' });"
    },
    "getRule": {
      "default": "const response = await client.getRule({ compositionID: 'foo', objectID: '123' });"
    },
    "getTask": {
      "default": "const response = await client.getTask({ compositionID: 'foo', taskID: 42 });"
    },
    "listCompositions": {
      "listCompositions": "const response = await client.listCompositions();"
    },
    "multipleBatch": {
      "multipleBatch": "const response = await client.multipleBatch({\n  requests: [\n    {\n      action: 'upsert',\n      body: {\n        objectID: 'my-metadata-compo',\n        name: 'my composition',\n        behavior: {\n          injection: {\n            main: { source: { search: { index: 'foo', params: { filters: 'brand:adidas' } } } },\n            injectedItems: [\n              {\n                key: 'injectedItem1',\n                source: { search: { index: 'foo', params: { filters: 'brand:adidas' } } },\n                position: 2,\n                length: 1,\n                metadata: {\n                  hits: {\n                    addItemKey: true,\n                    extra: {\n                      'my-string': 'string',\n                      'my-bool': true,\n                      'my-number': 42,\n                      'my-object': { 'sub-key': 'sub-value' },\n                      'my-array': [1, 2, 3],\n                      'my-empty-object': {},\n                    },\n                  },\n                },\n              },\n              {\n                key: 'externalItem',\n                source: { search: { index: 'foo', params: { filters: 'brand:puma' } } },\n                position: 5,\n                length: 5,\n                metadata: {\n                  hits: {\n                    addItemKey: true,\n                    extra: {\n                      'my-string': 'string',\n                      'my-bool': true,\n                      'my-number': 42,\n                      'my-object': { 'sub-key': 'sub-value' },\n                      'my-array': [1, 2, 3],\n                      'my-empty-object': {},\n                    },\n                  },\n                },\n              },\n            ],\n          },\n        },\n      },\n    },\n  ],\n});"
    },
    "putComposition": {
      "putComposition": "const response = await client.putComposition({\n  compositionID: 'my-metadata-compo',\n  composition: {\n    objectID: 'my-metadata-compo',\n    name: 'my composition',\n    behavior: {\n      injection: {\n        main: { source: { search: { index: 'foo', params: { filters: 'brand:adidas' } } } },\n        injectedItems: [\n          {\n            key: 'injectedItem1',\n            source: { search: { index: 'foo', params: { filters: 'brand:adidas' } } },\n            position: 2,\n            length: 1,\n            metadata: {\n              hits: {\n                addItemKey: true,\n                extra: {\n                  'my-string': 'string',\n                  'my-bool': true,\n                  'my-number': 42,\n                  'my-object': { 'sub-key': 'sub-value' },\n                  'my-array': [1, 2, 3],\n                  'my-empty-object': {},\n                },\n              },\n            },\n          },\n          {\n            key: 'externalItem',\n            source: { search: { index: 'foo', params: { filters: 'brand:puma' } } },\n            position: 5,\n            length: 5,\n            metadata: {\n              hits: {\n                addItemKey: true,\n                extra: {\n                  'my-string': 'string',\n                  'my-bool': true,\n                  'my-number': 42,\n                  'my-object': { 'sub-key': 'sub-value' },\n                  'my-array': [1, 2, 3],\n                  'my-empty-object': {},\n                },\n              },\n            },\n          },\n        ],\n      },\n    },\n  },\n});"
    },
    "putCompositionRule": {
      "putCompositionRule": "const response = await client.putCompositionRule({\n  compositionID: 'compositionID',\n  objectID: 'rule-with-exernal-source',\n  compositionRule: {\n    objectID: 'rule-with-exernal-source',\n    description: 'my description',\n    tags: ['tag1', 'tag2'],\n    enabled: true,\n    validity: [{ from: 1704063600, until: 1704083600 }],\n    conditions: [\n      { anchoring: 'contains', pattern: 'harry' },\n      { anchoring: 'contains', pattern: 'potter' },\n    ],\n    consequence: {\n      behavior: {\n        injection: {\n          main: { source: { search: { index: 'my-index', params: { filters: 'brand:adidas' } } } },\n          injectedItems: [\n            {\n              key: 'injectedItem',\n              source: {\n                external: { index: 'my-index', params: { filters: 'brand:adidas' }, ordering: 'userDefined' },\n              },\n              position: 0,\n              length: 3,\n            },\n          ],\n        },\n      },\n    },\n  },\n});"
    },
    "saveRules": {
      "saveRules": "const response = await client.saveRules({\n  compositionID: 'rule-with-exernal-source',\n  rules: {\n    requests: [\n      {\n        action: 'upsert',\n        body: {\n          objectID: 'rule-with-exernal-source',\n          description: 'my description',\n          tags: ['tag1', 'tag2'],\n          enabled: true,\n          validity: [{ from: 1704063600, until: 1704083600 }],\n          conditions: [\n            { anchoring: 'contains', pattern: 'harry' },\n            { anchoring: 'contains', pattern: 'potter' },\n          ],\n          consequence: {\n            behavior: {\n              injection: {\n                main: { source: { search: { index: 'my-index', params: { filters: 'brand:adidas' } } } },\n                injectedItems: [\n                  {\n                    key: 'injectedItem',\n                    source: {\n                      external: { index: 'my-index', params: { filters: 'brand:adidas' }, ordering: 'userDefined' },\n                    },\n                    position: 0,\n                    length: 3,\n                  },\n                ],\n              },\n            },\n          },\n        },\n      },\n    ],\n  },\n});"
    },
    "search": {
      "search": "const response = await client.search({\n  compositionID: 'foo',\n  requestBody: {\n    params: {\n      query: 'batman',\n      injectedItems: {\n        injectedItem1: {\n          items: [\n            { objectID: 'my-object-1' },\n            {\n              objectID: 'my-object-2',\n              metadata: {\n                'my-string': 'string',\n                'my-bool': true,\n                'my-number': 42,\n                'my-object': { 'sub-key': 'sub-value' },\n                'my-array': [1, 2, 3],\n                'my-empty-object': {},\n              },\n            },\n          ],\n        },\n      },\n    },\n  },\n});"
    },
    "searchCompositionRules": {
      "default": "const response = await client.searchCompositionRules({\n  compositionID: 'foo',\n  searchCompositionRulesParams: { query: 'batman' },\n});"
    },
    "searchForFacetValues": {
      "default": "const response = await client.searchForFacetValues({\n  compositionID: 'foo',\n  facetName: 'brand',\n  searchForFacetValuesRequest: { params: { maxFacetHits: 10 } },\n});"
    },
    "setClientApiKey": {
      "default": "client.setClientApiKey({ apiKey: 'updated-api-key' });"
    },
    "init": {
      "default": "const client = compositionClient('ALGOLIA_APPLICATION_ID', 'ALGOLIA_API_KEY');"
    }
  },
  "kotlin": {},
  "php": {},
  "python": {},
  "ruby": {},
  "scala": {},
  "swift": {}
}